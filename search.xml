<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>remove-element</title>
      <link href="/2023/05/11/remove-element/"/>
      <url>/2023/05/11/remove-element/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h1><h2 id="C-solution"><a href="#C-solution" class="headerlink" title="C++ solution"></a>C++ solution</h2><pre><code class="c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int len=nums.size();        auto iter =std::remove(nums.begin(),nums.end(),val);        nums.erase(iter, nums.end());                 return nums.size();    &#125;&#125;;</code></pre><h2 id="Java-solution"><a href="#Java-solution" class="headerlink" title="Java solution"></a>Java solution</h2><pre><code class="java">    </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search</title>
      <link href="/2023/05/10/binary-search/"/>
      <url>/2023/05/10/binary-search/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#head1"> <strong><a href="https://leetcode.cn/problems/binary-search/">Ⅰ 704 二分查找</a></strong> </a><ul><li><a href="#head2"> note</a><ul><li><a href="#head3">1. 二分法的两种区间划分</a></li><li><a href="#head4">2. 二分法取中间值防溢出</a></li></ul></li><li><a href="#head5">C++ solution</a></li><li><a href="#head6">Java solution</a></li></ul></li><li><a href="#head7"><strong><a href="https://leetcode.cn/problems/search-insert-position/">Ⅱ  35. 搜索插入位置</a></strong></a><ul><li><a href="#head8">C++ solution</a></li><li><a href="#head9">Java solution</a></li></ul></li><li><a href="#head10"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/"> Ⅲ 34. 在排序数组中查找元素的第一个和最后一个位置</a></a><ul><li><a href="#head11">C++ solution</a></li><li><a href="#head12">Java solution</a></li></ul></li></ul><h1 id="Ⅰ-704-二分查找"><a href="#Ⅰ-704-二分查找" class="headerlink" title=" Ⅰ 704 二分查找 "></a><span id="head1"> <strong><a href="https://leetcode.cn/problems/binary-search/">Ⅰ 704 二分查找</a></strong> </span></h1><p><img src="/2023/05/10/binary-search/1.png" alt="704"></p><h2 id="note"><a href="#note" class="headerlink" title=" note"></a><span id="head2"> note</span></h2><h3 id="1-二分法的两种区间划分"><a href="#1-二分法的两种区间划分" class="headerlink" title="1. 二分法的两种区间划分"></a><span id="head3">1. 二分法的两种区间划分</span></h3><p>每次写二分最容易纠结的part就是下面C++代码里面的A,B,C,D行:</p><ul><li>A 处是用nums.size()-1还是nums.size()?</li><li>B 处是 &lt;&#x3D; 还是 &lt; ?</li><li>C 处是 mid 还是 mid - 1 ?</li><li>D 处是 mid 还是 mid + 1 ?</li></ul><p>实际上这些不同的本质实际上是对于数组区间的划分法不同：</p><table><thead><tr><th></th><th>左闭右闭区间</th><th>左闭右开区间</th></tr></thead><tbody><tr><td>A</td><td><code>high=nums.size()-1</code></td><td><code>high=nums.size()</code></td></tr><tr><td>B</td><td><code> while(low&lt;=high)</code></td><td><code> while(low&lt;high)</code></td></tr><tr><td>C</td><td><code> high=mid-1;</code></td><td><code> high=mid;</code></td></tr><tr><td>D</td><td><code>low=mid+1;</code></td><td><code>low=mid+1;</code></td></tr></tbody></table><h3 id="2-二分法取中间值防溢出"><a href="#2-二分法取中间值防溢出" class="headerlink" title="2. 二分法取中间值防溢出"></a><span id="head4">2. 二分法取中间值防溢出</span></h3><pre><code class="c++"> mid = (low+high) / 2</code></pre><p>E 处的写法在两大数相加的时候容易发生溢出，可以改成下面的写法：</p><pre><code class="c++"> mid = low + (( high - low ) / 2)</code></pre><h2 id="C-solution"><a href="#C-solution" class="headerlink" title="C++ solution"></a><span id="head5">C++ solution</span></h2><pre><code class="c++">class Solution &#123;public     int search(vector&lt;int&gt;&amp; nums, int target) &#123;/*A*/   int low=0,high=nums.size()-1;/*B*/   while(low&lt;=high)&#123;/*E*/        int mid=(low+high)/2;            if(target==nums[mid])&#123;                return mid;            &#125;else if(target&lt;nums[mid])&#123;/*C*/           high=mid-1;            &#125;else&#123;/*D*/           low=mid+1;            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre><h2 id="Java-solution"><a href="#Java-solution" class="headerlink" title="Java solution"></a><span id="head6">Java solution</span></h2><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;        int low=0,high=nums.length-1;        while(low&lt;=high)&#123;            int mid=(low+high)/2;            if(nums[mid]==target)&#123;                return mid;            &#125;else if(nums[mid]&gt;=target)&#123;                high=mid-1;            &#125;else&#123;                low=mid+1;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><h1 id="Ⅱ-35-搜索插入位置"><a href="#Ⅱ-35-搜索插入位置" class="headerlink" title="Ⅱ  35. 搜索插入位置"></a><span id="head7"><strong><a href="https://leetcode.cn/problems/search-insert-position/">Ⅱ  35. 搜索插入位置</a></strong></span></h1><p><img src="/2023/05/10/binary-search/2.png" alt="35"></p><h2 id="C-solution-1"><a href="#C-solution-1" class="headerlink" title="C++ solution"></a><span id="head8">C++ solution</span></h2><pre><code class="c++">class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        int low =0,high=nums.size()-1,mid,ans=nums.size();        while(low&lt;=high)&#123;            mid =(low+high)&gt;&gt;1;                        if(target&lt;=nums[mid])&#123;//在左边                 ans=mid;                high=mid-1;            &#125;else&#123;                low=mid+1;            &#125;        &#125;        return ans;    &#125;&#125;;</code></pre><h2 id="Java-solution-1"><a href="#Java-solution-1" class="headerlink" title="Java solution"></a><span id="head9">Java solution</span></h2><pre><code class="java">class Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int low = 0, high = nums.length-1, ans = nums.length;        while(low&lt;=high)&#123;            int mid = ( low + high ) &gt;&gt; 1;            if(target &lt;= nums[mid])&#123;// 在左边                ans = mid;                high = mid-1;            &#125; else&#123;                low = mid +1;            &#125;        &#125;         return ans;       &#125;&#125;</code></pre><h1 id="Ⅲ-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#Ⅲ-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title=" Ⅲ 34. 在排序数组中查找元素的第一个和最后一个位置"></a><span id="head10"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/"> Ⅲ 34. 在排序数组中查找元素的第一个和最后一个位置</a></span></h1><p><img src="/2023/05/10/binary-search/3.png" alt="34"></p><h2 id="C-solution-2"><a href="#C-solution-2" class="headerlink" title="C++ solution"></a><span id="head11">C++ solution</span></h2><pre><code class="c++">class Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;                int left = binarySearch(nums,target,true);        int right =  binarySearch(nums,target,false)-1;                if(left &lt;= right &amp;&amp; right &lt; nums.size() &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target)&#123;                        return vector&lt;int&gt;&#123;left,right&#125;;        &#125;else&#123;            return vector&lt;int&gt;&#123;-1,-1&#125;;        &#125;            &#125;        int binarySearch(vector&lt;int&gt;nums,int target,bool isLeft)&#123;        int low =0,high=nums.size()-1,mid,ans=nums.size();                while(low&lt;=high)&#123;                        mid=(low+high)&gt;&gt;1;                        if(target&lt;nums[mid]||isLeft&amp;&amp;target&lt;=nums[mid])&#123;                ans = mid;                high = mid - 1;                &#125;else&#123;                low = mid + 1;            &#125;        &#125;        return ans;    &#125;    &#125;;</code></pre><h2 id="Java-solution-2"><a href="#Java-solution-2" class="headerlink" title="Java solution"></a><span id="head12">Java solution</span></h2><pre><code class="java">class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;      int [] arr=&#123;-1,-1&#125;;            int left = binarySearch(nums, target, true);            int right = binarySearch(nums, target, false)-1;            if(left&lt;=right &amp;&amp; right&lt;nums.length &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target)&#123;                arr[0]=left;                arr[1]=right;            &#125;             return arr;    &#125;        public int binarySearch(int[] nums, int target, boolean isLeft)&#123;            int low = 0, high = nums.length-1, mid, ans = nums.length;            while(low&lt;=high)&#123;                mid=(low+high)&gt;&gt;1;                if(target &lt; nums[mid]|| isLeft &amp;&amp; target &lt;= nums[mid])&#123;                    ans = mid;                    high = mid - 1;                &#125;else&#123;                    low = mid + 1;                &#125;                            &#125;            return ans;        &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
