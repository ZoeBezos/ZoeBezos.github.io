<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="zoe">


    <meta name="subtitle" content="liberté">




<title>Stack &amp; Queue | ZOE&#39;s site</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/jquery-3.7.0.min.js"></script>
    
    <script src="/js/mathjax2.7.5.js"></script>
    



    
    
        
    


<!-- 搜索的部分 -->



    <script>
    // function searchToggle() {
    //     const width = $(document.body).width()
    //     if(width > 479) {
    //         return;
    //     }
    //     const search = $('.search');
    //     const searchForm = $('.form-search')

    //     if(!search.hasClass("mobile-search")) {
    //         search.addClass("mobile-search");
    //     } else {
    //         search.removeClass("mobile-search");
    //     } 
    // }

    function searchToggle() {
        const width = $(document.body).width()
        if(width > 479) {
            return;
        }
        const search = $('.search');
        const searchForm = $('.form-search');
        const menuToggle = $('.menu-toggle');
        const title = $('.navbar-header-title ');

        if(!search.hasClass("mobile-search")) {
            search.addClass("mobile-search");
            menuToggle.addClass("open-search")
            title.addClass("mobile-title-hidden")
        } else {
            search.removeClass("mobile-search");
            menuToggle.removeClass("open-search")
            // title.css({visibility: 'visible'})
            title.removeClass("mobile-title-hidden")
        } 
    }



    function search(searchInputEl, formEl, flag) {
        const path = "/" + "search.json"; // 可以在public 下查看这个search.json
        $(formEl).submit(function(e){
            e.preventDefault();
            let target = null
            if(searchInputEl == null) {
                const screenWidth = $(document.body).width();
                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');
                console.log(target);
            } else {
                target = $(searchInputEl)
            }

            if(!flag && target.val() === '') {
                return ;
            }

            $("#u-search").fadeIn(500, function() {
                $("body > .wrapper").addClass("modal-active");

                $.ajax({
                    url: path,
                    dataType: "json",
                    beforeSend: function (xhr) {
                        $input = target.val();
                        $(".form-input").val($input);
                        const loadingBar = $('.search-loading-bar') 
                        loadingBar.css({
                            width:'100%',
                            display: 'block'
                        });
                    },
                    success: function( datas ) {
                        console.log(datas);
                        const $resultPanel = $(".modal-body")[0];
                        let str = `<ul class="modal-results">`;
                        var keywords = $(".form-input").val().trim().toLowerCase().split(/[\s\-]+/);
                        $resultPanel.innerHTML = "";
                        let hasResult = false
                        let text = `<div class="no-result">找不到与关键词相关的内容....</div>`;

                        if ($(".form-input").val().trim().length <= 0) {
                            // 没有结果
                            $resultPanel.innerHTML = text;
                            return;
                        }
                        datas.forEach(function (data, index) {
                            var isMatch = true;
                            if (!data.title || data.title.trim() === '') {
                                data.title = "Untitled";
                            }
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content && data.content.trim().replace(/<[^>]+>/g, "").toLowerCase() || '';
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty contents
                            if (data_content !== '') {
                                keywords.forEach(function (keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);

                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        hasResult = true
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            } else {
                                isMatch = false;
                            }
                            // show search results
                            if (isMatch) {
                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class="title">${data_title}</span>`;
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 200 characters
                                    var start = first_occur - 40;
                                    var end = first_occur + 160;

                                    if (start < 0) {
                                        start = 0;
                                    }

                                    if (start == 0) {
                                        end = 200;
                                    }

                                    if (end > content.length) {
                                        end = content.length;
                                    }

                                    var match_content = content.substring(start, end);

                                    // highlight all keywords
                                    keywords.forEach(function (keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, `<em class="search-keyword">${keyword}</em>`);
                                    });

                                    str += `<span class="content"> ${match_content} ...</span></a>`;
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        if(hasResult) {
                            $resultPanel.innerHTML = str;
                        } else {
                            $resultPanel.innerHTML = text;
                        }

                    },
                    complete: function() {
                        setTimeout(() => {
                                const loadingBar = $('.search-loading-bar') 
                                loadingBar.css({
                                    width:'0%',
                                    display: 'none'
                                });
                        }, 300)
                    }
                });
            })

        });
    }

    $(document).ready(function() {
        $('.modal-close').click(function () { 
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })

        $('.modal-overlay').click(function() {
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })
        search(null, ".form-search", false)
        search("#u-search-modal-form .form-input", ".u-search-modal-form", true)
    })
</script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                // pagebody.classList.add('dark-theme');
                // mobile
                // document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <!-- <div class="navbar-header header-logo"><a href="/">ZOE&#39;s site</a></div> -->
            <div class="navbar-header header-logo"><a href="/"><i class="iconfont icon-zhuye" style="font-size: 1em;"></i>ZOE&#39;s site</a></div>
            <div class="menu navbar-right">
                <!-- 这里表示的是pc端搜索框 -->
                
                
    <div class="search ">
        <!-- <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div> -->
        <form class="form-search">
            <input class="input" placeholder="search" autocomplete="on" id="pc-search-input"/>
        </form>
    </div>

                
                <a class="menu-item" target="_blank" rel="noopener" href="https://github.com/ZoeBezos">Github</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://www.linkedin.com/in/zoe-bezos/">Linkedin</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <!-- <label for="switch_default" class="toggleBtn"></label> -->
            </div>
        </div>
    </nav>
    
    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ZOE&#39;s site</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="navbar-mobile-right">
                    
                    
    <div class="search ">
        <!-- <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div> -->
        <form class="form-search">
            <input class="input" placeholder="search" autocomplete="on" id="mobile-search-input"/>
        </form>
    </div>

                    <!-- <div class="menu-toggle" onclick="mobileBtn()">&#9776; menu</div> -->
                </div>
    
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://github.com/ZoeBezos">Github</a>
                
                <a class="menu-item" target="_blank" rel="noopener" href="https://www.linkedin.com/in/zoe-bezos/">Linkedin</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>

    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Stack &amp; Queue</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">zoe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 6, 2023&nbsp;&nbsp;20:17:06</a>
                        </span>
                    
                    

                        <span class="post-category">                        
                            Category:                        
                                                    
                            <a href="/categories/algorithm-learning/">algorithm learning</a>
                            
                        </span>

                    

                    
                        
                        <span class="post-count">                        
                            Words:                        
                            <a href="">9.6k</a>                         
                        </span>
                        
                    
                                                                        
                    
                        
                        <span class="post-count">                        
                            Time:                        
                            <a href="">42min</a>                         
                        </span>
                        
                    
                        
                </div>
            
        </header>

        <div class="post-content">
            <table>
<thead>
<tr>
<th>类型</th>
<th>题号</th>
<th>完成</th>
</tr>
</thead>
<tbody><tr>
<td>栈的实现</td>
<td>🟢232. 用栈实现队列</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟢225. 用队列实现栈</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟢面试题 03.01. 三合一</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟡1441. 用栈操作构建数组</td>
<td>✅</td>
</tr>
<tr>
<td>单调栈</td>
<td>🟢496. 下一个更大元素 I</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🔴84. 柱状图中最大的矩形</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🟡739. 每日温度</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🟡901. 股票价格跨度</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🔴42. 接雨水</td>
<td></td>
</tr>
<tr>
<td>最小栈</td>
<td>🟢面试题 03.02. 栈的最小值</td>
<td>✅</td>
</tr>
<tr>
<td>字符串去重问题</td>
<td>🟡316.去除重复字母</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🟢1047. 删除字符串中的所有相邻重复项</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟡1209. 删除字符串中的所有相邻重复项 II</td>
<td></td>
</tr>
<tr>
<td>栈与括号匹配</td>
<td>🟢20. 有效的括号</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟡636. 函数的独占时间</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🔴591. 标签验证器</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🔴32. 最长有效括号</td>
<td></td>
</tr>
<tr>
<td>表达式求值</td>
<td>🟡150. 逆波兰表达式求值</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🔴224. 基本计算器</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🟡227. 基本计算器 II</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🔴770. 基本计算器 IV</td>
<td></td>
</tr>
<tr>
<td>用栈访问最后若干元素</td>
<td>🟢682. 棒球比赛</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟡71. 简化路径</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟡388. 文件的最长绝对路径</td>
<td>✅</td>
</tr>
<tr>
<td>递归</td>
<td>🟡385. 迷你语法分析器</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🟡341. 扁平化嵌套列表迭代器</td>
<td></td>
</tr>
<tr>
<td></td>
<td>🟡394. 字符串解码</td>
<td>✅</td>
</tr>
<tr>
<td>滑动窗口最大值问题</td>
<td>🔴239. 滑动窗口最大值</td>
<td></td>
</tr>
<tr>
<td>求前 K 个高频元素</td>
<td>🟡347. 前K个高频元素</td>
<td>✅</td>
</tr>
<tr>
<td></td>
<td>🟡692. 前K个高频单词</td>
<td>✅</td>
</tr>
</tbody></table>
<h1><span id="zhan-de-shi-xian">栈的实现</span></h1><h2><span id="232-yong-zhan-shi-xian-dui-lie">🟢232. 用栈实现队列</span></h2><blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MyQueue", "push", "push", "peek", "pop", "empty"]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></tbody></table></figure>





<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>设计</p>
<p>队列</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line">    Stack&lt;Integer&gt;in;</span><br><span class="line">    Stack&lt;Integer&gt;out;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.in=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.out=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="built_in">this</span>.in.push(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">this</span>.out.pop();</span><br><span class="line">        out2in();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">this</span>.out.peek();</span><br><span class="line">        out2in();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.in.isEmpty();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.in.isEmpty()){</span><br><span class="line">            <span class="built_in">this</span>.out.push(<span class="built_in">this</span>.in.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out2in</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.out.isEmpty()){</span><br><span class="line">            <span class="built_in">this</span>.in.push(<span class="built_in">this</span>.out.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(1)</em></li>
</ul>
<h2><span id="225-yong-dui-lie-shi-xian-zhan">🟢225. 用队列实现栈</span></h2><blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MyStack", "push", "push", "top", "pop", "empty"]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></tbody></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>
<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>
</ul>
<p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p>
<p>Related Topics</p>
<p>栈</p>
<p>设计</p>
<p>队列</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; in;</span><br><span class="line">    Queue&lt;Integer&gt;out;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.in=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.out=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="built_in">this</span>.in.offer(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">this</span>.in.peek();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.in.isEmpty()){</span><br><span class="line">            temp=<span class="built_in">this</span>.in.peek();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.in.size()==<span class="number">1</span>){</span><br><span class="line">                <span class="built_in">this</span>.in.poll();</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">this</span>.out.offer(<span class="built_in">this</span>.in.poll());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.out.isEmpty()){</span><br><span class="line">            <span class="built_in">this</span>.in.offer(<span class="built_in">this</span>.out.poll());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> temp=<span class="built_in">this</span>.in.peek();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.in.isEmpty()){</span><br><span class="line">            temp=<span class="built_in">this</span>.in.peek();</span><br><span class="line">            <span class="built_in">this</span>.out.offer(<span class="built_in">this</span>.in.poll());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.out.isEmpty()){</span><br><span class="line">            <span class="built_in">this</span>.in.offer(<span class="built_in">this</span>.out.poll());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.in.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(1)</em></li>
</ul>
<h2><span id="mian-shi-ti-03-01-san-he-yi">🟢面试题 03.01. 三合一</span></h2><blockquote>
<p>三合一。描述如何只用一个数组来实现三个栈。</p>
<p>你应该实现<code>push(stackNum, value)</code>、<code>pop(stackNum)</code>、<code>isEmpty(stackNum)</code>、<code>peek(stackNum)</code>方法。<code>stackNum</code>表示栈下标，<code>value</code>表示压入的值。</p>
<p>构造函数会传入一个<code>stackSize</code>参数，代表每个栈的大小。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 输入：</span><br><span class="line">["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]</span><br><span class="line">[[1], [0, 1], [0, 2], [0], [0], [0], [0]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, 1, -1, -1, true]</span><br><span class="line">说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入：</span><br><span class="line">["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"]</span><br><span class="line">[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, null, 2, 1, -1, -1]</span><br></pre></td></tr></tbody></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= stackNum &lt;= 2</code></li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>设计</p>
<p>数组</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TripleInOne</span> {</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt;[] three2one;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TripleInOne</span><span class="params">(<span class="type">int</span> stackSize)</span> {</span><br><span class="line">        size = stackSize;</span><br><span class="line">        three2one = <span class="keyword">new</span> <span class="title class_">Stack</span>[<span class="number">3</span>];</span><br><span class="line">        three2one[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        three2one[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        three2one[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> stackNum, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (three2one[stackNum].size() &lt; size) {</span><br><span class="line">            three2one[stackNum].push(value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> stackNum)</span> {</span><br><span class="line">        <span class="keyword">if</span> (three2one[stackNum].isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> three2one[stackNum].pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">(<span class="type">int</span> stackNum)</span> {</span><br><span class="line">        <span class="keyword">if</span> (three2one[stackNum].isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> three2one[stackNum].peek();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> stackNum)</span> {</span><br><span class="line">        <span class="keyword">return</span> three2one[stackNum].isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(1)</em></li>
</ul>
<h2><span id="1441-yong-zhan-cao-zuo-gou-jian-shu-zu">🟡1441. 用栈操作构建数组</span></h2><blockquote>
<p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = { 1 , 2 , 3 ..., n }</code> 中依次读取一个数字。</p>
<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>
<ul>
<li><code>"Push"</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>
<li><code>"Pop"</code>：删除数组中的最后一个元素。</li>
<li>如果目标数组构建完成，就停止读取更多元素。</li>
</ul>
<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [1,3], n = 3</span><br><span class="line">输出：["Push","Push","Pop","Push"]</span><br><span class="line">解释： </span><br><span class="line">读取 1 并自动推入数组 -&gt; [1]</span><br><span class="line">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class="line">读取 3 并自动推入数组 -&gt; [1,3]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [1,2,3], n = 3</span><br><span class="line">输出：["Push","Push","Push"]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [1,2], n = 4</span><br><span class="line">输出：["Push","Push"]</span><br><span class="line">解释：只需要读取前 2 个数字就可以停止。</span><br></pre></td></tr></tbody></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target.length &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= target[i] &lt;= n</code></li>
<li><code>target</code> 严格递增</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>数组</p>
<p>模拟</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">buildArray</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length; i++) {</span><br><span class="line">            res.add(<span class="string">"Push"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> last; j &lt; target[i]-<span class="number">1</span>; j++) {</span><br><span class="line">                res.add(<span class="string">"Pop"</span>);</span><br><span class="line">                res.add(<span class="string">"Push"</span>);</span><br><span class="line">            }</span><br><span class="line">            last = target[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(1)</em></li>
</ul>
<h1><span id="dan-diao-zhan">单调栈</span></h1><h2><span id="496-xia-yi-ge-geng-da-yuan-su-i">🟢496. 下一个更大元素 I</span></h2><blockquote>
<p> <code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>
<p> 给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p> 对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p> 返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出：[3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<p> <strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>
<p> Related Topics</p>
<p> 栈</p>
<p> 数组</p>
<p> 哈希表</p>
<p> 单调栈</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            res[i]=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums2[j] == nums1[i]) {</span><br><span class="line">                    pos = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (; pos &lt; nums2.length; pos++) {</span><br><span class="line">                <span class="keyword">if</span>(nums2[pos]&gt;nums1[i]){</span><br><span class="line">                    res[i]=nums2[pos];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(1)</em></li>
</ul>
<h2><span id="84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing">🔴84. 柱状图中最大的矩形</span></h2><h2><span id="739-mei-ri-wen-du">🟡739. 每日温度</span></h2><h2><span id="901-gu-piao-jie-ge-kua-du">🟡901. 股票价格跨度</span></h2><h2><span id="42-jie-yu-shui">🔴42. 接雨水</span></h2><h1><span id="zui-xiao-zhan">最小栈</span></h1><h2><span id="mian-shi-ti-03-02-zhan-de-zui-xiao-zhi">🟢面试题 03.02. 栈的最小值</span></h2><blockquote>
<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top(); --&gt; 返回 0.</span><br><span class="line">minStack.getMin(); --&gt; 返回 -2.</span><br></pre></td></tr></tbody></table></figure>





<p>Related Topics</p>
<p>栈</p>
<p>设计</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> {</span><br><span class="line">    Stack&lt;Integer&gt;stack;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> {</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min=Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="built_in">this</span>.min=Math.min(<span class="built_in">this</span>.min,x);</span><br><span class="line">        <span class="built_in">this</span>.stack.push(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.stack.peek()==<span class="built_in">this</span>.min){</span><br><span class="line">            <span class="type">int</span> new_min=Integer.MAX_VALUE;</span><br><span class="line">            <span class="built_in">this</span>.stack.pop();</span><br><span class="line">            Stack&lt;Integer&gt;temp=(Stack&lt;Integer&gt;)<span class="built_in">this</span>.stack.clone();</span><br><span class="line">            <span class="keyword">while</span> (!temp.isEmpty()){</span><br><span class="line">                new_min=Math.min(new_min,temp.pop());</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">this</span>.min=new_min;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.stack.pop();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:O(n)</li>
<li>space:O(1)</li>
</ul>
<h1><span id="zi-fu-chuan-qu-chong-wen-ti">字符串去重问题</span></h1><h2><span id="316-qu-chu-chong-fu-zi-mu">🟡316.去除重复字母</span></h2><blockquote>
<p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bcabc"</span><br><span class="line">输出："abc"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "cbacdcbc"</span><br><span class="line">输出："acdb"</span><br></pre></td></tr></tbody></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p><strong>注意：</strong>该题与 1081 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同</p>
<p>Related Topics</p>
<p>栈</p>
<p>贪心</p>
<p>字符串</p>
<p>单调栈</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 🟢<span class="number">1047.</span> 删除字符串中的所有相邻重复项</span><br><span class="line"></span><br><span class="line">&gt; 给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在 S 上反复执行重复项删除操作，直到无法继续删除。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; **示例：**</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**提示：**</span><br><span class="line"></span><br><span class="line">1. `1 &lt;= S.length &lt;= 20000`</span><br><span class="line">2. `S` 仅由小写英文字母组成。</span><br><span class="line"></span><br><span class="line">Related Topics</span><br><span class="line"></span><br><span class="line">栈</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Solution {</span><br><span class="line">   public String removeDuplicates(String s) {</span><br><span class="line">       Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">       for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">           if (stack.isEmpty() || s.charAt(i) != stack.peek()) {</span><br><span class="line">               stack.push(s.charAt(i));</span><br><span class="line">           } else {</span><br><span class="line">               stack.pop();</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       StringBuilder res=new StringBuilder();</span><br><span class="line">       for (int i = 0; i &lt; stack.size(); i++) {</span><br><span class="line">           res.append(stack.get(i));</span><br><span class="line">       }</span><br><span class="line">       return res.toString();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="1209-shan-chu-zi-fu-chuan-zhong-de-suo-you-xiang-lin-chong-fu-xiang-ii">🟡1209. 删除字符串中的所有相邻重复项 II</span></h2><blockquote>
<p>给你一个字符串 <code>s</code>，「<code>k</code> 倍重复项删除操作」将会从 <code>s</code> 中选择 <code>k</code> 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>
<p>你需要对 <code>s</code> 重复进行无限次这样的删除操作，直到无法继续为止。</p>
<p>在执行完所有删除操作后，返回最终得到的字符串。</p>
<p>本题答案保证唯一。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abcd", k = 2</span><br><span class="line">输出："abcd"</span><br><span class="line">解释：没有要删除的内容。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "deeedbbcccbdaa", k = 3</span><br><span class="line">输出："aa"</span><br><span class="line">解释： </span><br><span class="line">先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"</span><br><span class="line">再删除 "bbb"，得到 "dddaa"</span><br><span class="line">最后删除 "ddd"，得到 "aa"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "pbbcggttciiippooaais", k = 2</span><br><span class="line">输出："ps"</span><br></pre></td></tr></tbody></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>2 &lt;= k &lt;= 10^4</code></li>
<li><code>s</code> 中只含有小写英文字母。</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>字符串</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  栈与括号匹配</span><br><span class="line"></span><br><span class="line">## 🟢<span class="number">20.</span> 有效的括号 </span><br><span class="line"></span><br><span class="line">&gt; 给定一个只包括 `<span class="string">'('</span>`，`<span class="string">')'</span>`，`<span class="string">'{'</span>`，`<span class="string">'}'</span>`，`<span class="string">'['</span>`，`<span class="string">']'</span>` 的字符串 `s` ，判断字符串是否有效。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 有效字符串需满足：</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="number">1.</span> 左括号必须用相同类型的右括号闭合。</span><br><span class="line">&gt; <span class="number">2.</span> 左括号必须以正确的顺序闭合。</span><br><span class="line">&gt; <span class="number">3.</span> 每个右括号都有一个对应的相同类型的左括号。</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; **示例 <span class="number">1</span>：**</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>输入：s = “()”<br>输出：true</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**示例 2：**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>输入：s = “()[]{}”<br>输出：true</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**示例 3：**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>输入：s = “(]”<br>输出：false</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**提示：**</span><br><span class="line"></span><br><span class="line">- `1 &lt;= s.length &lt;= 104`</span><br><span class="line">- `s` 仅由括号 `'()[]{}'` 组成</span><br><span class="line"></span><br><span class="line">Related Topics</span><br><span class="line"></span><br><span class="line">栈</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">class Solution {</span><br><span class="line">   public boolean isValid(String s) {</span><br><span class="line">       Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">       for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">           if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[') {</span><br><span class="line">               stack.push(s.charAt(i));</span><br><span class="line">           } else if (stack.isEmpty() || s.charAt(i) == ')' &amp;&amp; stack.peek() != '(' ||</span><br><span class="line">                   s.charAt(i) == '}' &amp;&amp; stack.peek() != '{' ||</span><br><span class="line">                   s.charAt(i) == ']' &amp;&amp; stack.peek() != '[') {</span><br><span class="line">               return false;</span><br><span class="line">           } else {</span><br><span class="line">               stack.pop();</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       return stack.isEmpty();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="636-han-shu-de-du-zhan-shi-jian">🟡636. 函数的独占时间</span></h2><blockquote>
<p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于 <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p>
<p>函数调用 <strong>存储在一个 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p>
<p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>"{function_id}:{"start" | "end"}:{timestamp}"</code> 进行格式化的字符串。例如，<code>"0:start:3"</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>"1:end:2"</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用</strong> 。</p>
<p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p>
<p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/04/05/diag1b.png" alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]</span><br><span class="line">输出：[3,4]</span><br><span class="line">解释：</span><br><span class="line">函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 </span><br><span class="line">函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 </span><br><span class="line">函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 </span><br><span class="line">所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 </span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]</span><br><span class="line">输出：[8]</span><br><span class="line">解释：</span><br><span class="line">函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。</span><br><span class="line">函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。</span><br><span class="line">函数 0（初始调用）恢复执行，并立刻再次调用它自身。</span><br><span class="line">函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。</span><br><span class="line">函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。</span><br><span class="line">所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]</span><br><span class="line">输出：[7,1]</span><br><span class="line">解释：</span><br><span class="line">函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。</span><br><span class="line">函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。</span><br><span class="line">函数 0（初始调用）恢复执行，并立刻调用函数 1 。</span><br><span class="line">函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。</span><br><span class="line">函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。</span><br><span class="line">所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 </span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]</span><br><span class="line">输出：[8,1]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, logs = ["0:start:0","0:end:0"]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></tbody></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= logs.length &lt;= 500</code></li>
<li><code>0 &lt;= function_id &lt; n</code></li>
<li><code>0 &lt;= timestamp &lt;= 109</code></li>
<li>两个开始事件不会在同一时间戳发生</li>
<li>两个结束事件不会在同一时间戳发生</li>
<li>每道函数都有一个对应 <code>"start"</code> 日志的 <code>"end"</code> 日志</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>数组</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exclusiveTime(<span class="type">int</span> n, List&lt;String&gt; logs) {</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> logs.size();</span><br><span class="line">        <span class="type">int</span>[] ids = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] times = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        String[] actions = <span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            String[] splited = logs.get(i).split(<span class="string">":"</span>);</span><br><span class="line">            ids[i] = Integer.parseInt(splited[<span class="number">0</span>]);</span><br><span class="line">            times[i] = Integer.parseInt(splited[<span class="number">2</span>]);</span><br><span class="line">            actions[i] = splited[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (actions[<span class="number">0</span>].equals(<span class="string">"start"</span>)) {</span><br><span class="line">                    stack.push(ids[<span class="number">0</span>]);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (actions[i].equals(<span class="string">"start"</span>)) {</span><br><span class="line">                <span class="keyword">if</span> (actions[i - <span class="number">1</span>].equals(<span class="string">"start"</span>)) {</span><br><span class="line">                    res[stack.peek()] += times[i] - times[i - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty()){</span><br><span class="line">                        res[stack.peek()] += times[i] - times[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                stack.push(ids[i]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (actions[i - <span class="number">1</span>].equals(<span class="string">"start"</span>)) {</span><br><span class="line">                    res[stack.peek()] += times[i] - times[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    res[stack.peek()] += times[i] - times[i - <span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="591-biao-qian-yan-zheng-qi">🔴591. 标签验证器</span></h2><h2><span id="32-zui-chang-you-xiao-gua-hao">🔴32. 最长有效括号</span></h2><blockquote>
</blockquote>
<h1><span id="biao-da-shi-qiu-zhi">表达式求值</span></h1><h2><span id="150-ni-bo-lan-biao-da-shi-qiu-zhi">🟡150. 逆波兰表达式求值</span></h2><blockquote>
<p> 给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p> 请你计算该表达式。返回一个表示表达式值的整数。</p>
<p> <strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = ["2","1","+","3","*"]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = ["4","13","5","/","+"]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 3：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p> <strong>逆波兰表达式：</strong></p>
<p> 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p> 逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<p> Related Topics</p>
<p> 栈</p>
<p> 数组</p>
<p> 数学</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tokens.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (tokens[i].equals(<span class="string">"+"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(n1 + n2);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"*"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(n1 * n2);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"-"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(n2 - n1);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].equals(<span class="string">"/"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(n2 / n1);</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> num=Integer.parseInt(tokens[i]);</span><br><span class="line">                stack.push(num);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="224-ji-ben-ji-suan-qi">🔴224. 基本计算器</span></h2><h2><span id="227-ji-ben-ji-suan-qi-ii">🟡227. 基本计算器 II</span></h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> {</span><br><span class="line">        s = s.replaceAll(<span class="string">" "</span>, <span class="string">""</span>);</span><br><span class="line">        String[] nums = s.split(<span class="string">"[^0-9]"</span>, <span class="number">0</span>);</span><br><span class="line">        String[] ops = Arrays.stream(s.split(<span class="string">"[0-9]"</span>, <span class="number">0</span>))</span><br><span class="line">                .filter(part -&gt; !part.isEmpty())</span><br><span class="line">                .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        Stack&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; ops_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx_num</span> <span class="operator">=</span> <span class="number">0</span>, idx_ops = <span class="number">0</span>;</span><br><span class="line">        res.push(Integer.parseInt(nums[idx_num++]));</span><br><span class="line">        <span class="keyword">while</span> (idx_num &lt; nums.length &amp;&amp; idx_ops &lt; ops.length) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">op</span> <span class="operator">=</span> ops[idx_ops];</span><br><span class="line">            <span class="keyword">if</span> (op.equals(<span class="string">"*"</span>) || op.equals(<span class="string">"/"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> res.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(nums[idx_num++]);</span><br><span class="line">                <span class="keyword">if</span> (op.equals(<span class="string">"*"</span>)) {</span><br><span class="line">                    res.push(a * b);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    res.push(a / b);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (!ops_stack.isEmpty()) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> res.pop();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> res.pop();</span><br><span class="line">                    <span class="keyword">if</span> (ops_stack.pop().equals(<span class="string">"+"</span>)) {</span><br><span class="line">                        res.push(b + a);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        res.push(b - a);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (idx_ops + <span class="number">1</span> &lt; ops.length &amp;&amp; (ops[idx_ops + <span class="number">1</span>].equals(<span class="string">"*"</span>) || ops[idx_ops + <span class="number">1</span>].equals(<span class="string">"/"</span>))) {</span><br><span class="line">                    ops_stack.push(op);</span><br><span class="line">                    res.push(Integer.parseInt(nums[idx_num++]));</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> res.pop();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(nums[idx_num++]);</span><br><span class="line">                    <span class="keyword">if</span> (op.equals(<span class="string">"+"</span>)) {</span><br><span class="line">                        res.push(a + b);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        res.push(a - b);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            idx_ops++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!ops_stack.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> res.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> res.pop();</span><br><span class="line">            <span class="keyword">if</span> (ops_stack.pop().equals(<span class="string">"+"</span>)) {</span><br><span class="line">                res.push(b + a);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                res.push(b - a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:O()</li>
<li>space:O()</li>
</ul>
<h2><span id="770-ji-ben-ji-suan-qi-iv">🔴770. 基本计算器 IV</span></h2><h1><span id="yong-zhan-fang-wen-zui-hou-ruo-gan-yuan-su">用栈访问最后若干元素</span></h1><h2><span id="682-bang-qiu-bi-sai">🟢682. 棒球比赛</span></h2><blockquote>
<p> 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p> 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>
<ol>
<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>
<li><code>"+"</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>
<li><code>"D"</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
<li><code>"C"</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
</ol>
<p> 请你返回记录中所有得分的总和。</p>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：ops = ["5","2","C","D","+"]</span><br><span class="line">输出：30</span><br><span class="line">解释：</span><br><span class="line">"5" - 记录加 5 ，记录现在是 [5]</span><br><span class="line">"2" - 记录加 2 ，记录现在是 [5, 2]</span><br><span class="line">"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].</span><br><span class="line">"D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].</span><br><span class="line">"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].</span><br><span class="line">所有得分的总和 5 + 10 + 15 = 30</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：ops = ["5","-2","4","C","D","9","+","+"]</span><br><span class="line">输出：27</span><br><span class="line">解释：</span><br><span class="line">"5" - 记录加 5 ，记录现在是 [5]</span><br><span class="line">"-2" - 记录加 -2 ，记录现在是 [5, -2]</span><br><span class="line">"4" - 记录加 4 ，记录现在是 [5, -2, 4]</span><br><span class="line">"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]</span><br><span class="line">"D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]</span><br><span class="line">"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]</span><br><span class="line">"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]</span><br><span class="line">"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]</span><br><span class="line">所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 3：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ops = ["1"]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= ops.length &lt;= 1000</code></li>
<li><code>ops[i]</code> 为 <code>"C"</code>、<code>"D"</code>、<code>"+"</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 104, 3 * 104]</code></li>
<li>对于 <code>"+"</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li>
<li>对于 <code>"C"</code> 和 <code>"D"</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li>
</ul>
<p> Related Topics</p>
<p> 栈</p>
<p> 数组</p>
<p> 模拟</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calPoints</span><span class="params">(String[] operations)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; operations.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (operations[i].equals(<span class="string">"C"</span>)) {</span><br><span class="line">                stack.pop();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (operations[i].equals(<span class="string">"D"</span>)) {</span><br><span class="line">                stack.push(stack.peek() * <span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (operations[i].equals(<span class="string">"+"</span>)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> temp + stack.peek();</span><br><span class="line">                stack.push(temp);</span><br><span class="line">                stack.push(sum);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(operations[i]);</span><br><span class="line">                stack.push(num);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="71-jian-hua-lu-jing">🟡71. 简化路径</span></h2><blockquote>
<p> 给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>
<p> 在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>
<p> 请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 <code>'/'</code> 开头。</li>
<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>
<li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>'/'</code> 结尾。</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>
</ul>
<p> 返回简化后得到的 <strong>规范路径</strong> 。</p>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = "/home/"</span><br><span class="line">输出："/home"</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = "/../"</span><br><span class="line">输出："/"</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 3：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = "/home//foo/"</span><br><span class="line">输出："/home/foo"</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 4：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：path = "/a/./b/../../c/"</span><br><span class="line">输出："/c"</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= path.length &lt;= 3000</code></li>
<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>
<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>
</ul>
<p> Related Topics</p>
<p> 栈</p>
<p> 字符串</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> {</span><br><span class="line">        String[] splited = path.split(<span class="string">"[/*]"</span>);</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; splited.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (splited[i].equals(<span class="string">"."</span>) || splited[i].equals(<span class="string">""</span>)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (splited[i].equals(<span class="string">".."</span>)) {</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                stack.push(splited[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stack.size(); i++) {</span><br><span class="line">            res.append(<span class="string">"/"</span>);</span><br><span class="line">            res.append(stack.get(i));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="388-wen-jian-de-zui-chang-jue-dui-lu-jing">🟡388. 文件的最长绝对路径</span></h2><blockquote>
<p> 假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p>
<p> <img src="https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg" alt="img"></p>
<p> 这里将 <code>dir</code> 作为根目录中的唯一目录。<code>dir</code> 包含两个子目录 <code>subdir1</code> 和 <code>subdir2</code> 。<code>subdir1</code> 包含文件 <code>file1.ext</code> 和子目录 <code>subsubdir1</code>；<code>subdir2</code> 包含子目录 <code>subsubdir2</code>，该子目录下包含文件 <code>file2.ext</code> 。</p>
<p> 在文本格式中，如下所示(⟶表示制表符)：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">⟶ subdir1</span><br><span class="line">⟶ ⟶ file1.ext</span><br><span class="line">⟶ ⟶ subsubdir1</span><br><span class="line">⟶ subdir2</span><br><span class="line">⟶ ⟶ subsubdir2</span><br><span class="line">⟶ ⟶ ⟶ file2.ext</span><br></pre></td></tr></tbody></table></figure>

<p> 如果是代码表示，上面的文件系统可以写为 <code>"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</code> 。<code>'\n'</code> 和 <code>'\t'</code> 分别是换行符和制表符。</p>
<p> 文件系统中的每个文件和文件夹都有一个唯一的 <strong>绝对路径</strong> ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 <code>'/'</code> 连接。上面例子中，指向 <code>file2.ext</code> 的 <strong>绝对路径</strong> 是 <code>"dir/subdir2/subsubdir2/file2.ext"</code> 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 <code>name.extension</code> 的格式，其中 <code>name</code> 和 <code>extension</code>由字母、数字和/或空格组成。</p>
<p> 给定一个以上述格式表示文件系统的字符串 <code>input</code> ，返回文件系统中 <em>指向 <strong>文件</strong> 的 <strong>最长绝对路径</strong> 的长度</em> 。 如果系统中没有文件，返回 <code>0</code>。</p>
<p> <strong>示例 1：</strong></p>
<p> <img src="https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg" alt="img"></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"</span><br><span class="line">输出：20</span><br><span class="line">解释：只有一个文件，绝对路径为 "dir/subdir2/file.ext" ，路径长度 20</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
<p> <img src="https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg" alt="img"></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</span><br><span class="line">输出：32</span><br><span class="line">解释：存在两个文件：</span><br><span class="line">"dir/subdir1/file1.ext" ，路径长度 21</span><br><span class="line">"dir/subdir2/subsubdir2/file2.ext" ，路径长度 32</span><br><span class="line">返回 32 ，因为这是最长的路径</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 3：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：input = "a"</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在任何文件</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 4：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：input = "file1.txt\nfile2.txt\nlongfile.txt"</span><br><span class="line">输出：12</span><br><span class="line">解释：根目录下有 3 个文件。</span><br><span class="line">因为根目录中任何东西的绝对路径只是名称本身，所以答案是 "longfile.txt" ，路径长度为 12</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= input.length &lt;= 104</code></li>
<li><code>input</code> 可能包含小写或大写的英文字母，一个换行符 <code>'\n'</code>，一个制表符 <code>'\t'</code>，一个点 <code>'.'</code>，一个空格 <code>' '</code>，和数字。</li>
</ul>
<p> Related Topics</p>
<p> 栈</p>
<p> 深度优先搜索</p>
<p> 字符串</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthLongestPath</span><span class="params">(String input)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        String[] splited = input.split(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; splited.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; splited[i].length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (splited[i].charAt(j) == <span class="string">'\t'</span>) {</span><br><span class="line">                    cnt++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//数cnt</span></span><br><span class="line">            <span class="keyword">if</span> (cnt != stack.size()) {</span><br><span class="line">                <span class="type">int</span> size=stack.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size - cnt; j++) {</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//排出多余的元素</span></span><br><span class="line">            stack.push(splited[i].length() - cnt);</span><br><span class="line">            <span class="comment">//插入当前元素</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">is_file</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; splited[i].length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (splited[i].charAt(j) == <span class="string">'.'</span>) {</span><br><span class="line">                    is_file = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (is_file) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; stack.size(); j++) {</span><br><span class="line">                    sum += stack.get(j) + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                max = Math.max(max, sum - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//如果是文件，考虑更新最大值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(n^2^)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h1><span id="di-gui">递归</span></h1><h2><span id="385-mi-ni-yu-fa-fen-xi-qi">🟡385. 迷你语法分析器</span></h2><blockquote>
<p> 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 <code>NestedInteger</code> 。</p>
<p> 列表中的每个元素只可能是整数或整数嵌套列表</p>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "324",</span><br><span class="line">输出：324</span><br><span class="line">解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "[123,[456,[789]]]",</span><br><span class="line">输出：[123,[456,[789]]]</span><br><span class="line">解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：</span><br><span class="line">1. 一个 integer 包含值 123</span><br><span class="line">2. 一个包含两个元素的嵌套列表：</span><br><span class="line">    i.  一个 integer 包含值 456</span><br><span class="line">    ii. 一个包含一个元素的嵌套列表</span><br><span class="line">         a. 一个 integer 包含值 789</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由数字、方括号 <code>"[]"</code>、负号 <code>'-'</code> 、逗号 <code>','</code>组成</li>
<li>用例保证 <code>s</code> 是可解析的 <code>NestedInteger</code></li>
<li>输入中的所有值的范围是 <code>[-106, 106]</code></li>
</ul>
<p> Related Topics</p>
<p> 栈</p>
<p> 深度优先搜索</p>
<p> 字符串</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  🟡<span class="number">341.</span> 扁平化嵌套列表迭代器</span><br><span class="line"></span><br><span class="line">&gt;  给你一个嵌套的整数列表 `nestedList` 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</span><br><span class="line">&gt;</span><br><span class="line">&gt;  实现扁平迭代器类 `NestedIterator` ：</span><br><span class="line">&gt;</span><br><span class="line">&gt;  -  `NestedIterator(List nestedList)` 用嵌套列表 `nestedList` 初始化迭代器。</span><br><span class="line">&gt;  -  `<span class="type">int</span> <span class="title function_">next</span><span class="params">()</span>` 返回嵌套列表的下一个整数。</span><br><span class="line">&gt;  -  `<span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>` 如果仍然存在待迭代的整数，返回 `<span class="literal">true</span>` ；否则，返回 `<span class="literal">false</span>` 。</span><br><span class="line">&gt;</span><br><span class="line">&gt;  你的代码将会用下述伪代码检测：</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p> initialize iterator with nestedList<br> res = []<br> while iterator.hasNext()<br>     append iterator.next() to the end of res<br> return res<br> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果 `res` 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**示例 1：**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br> 输入：nestedList = [[1,1],2,[1,1]]<br> 输出：[1,1,2,1,1]<br> 解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。<br> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**示例 2：**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br> 输入：nestedList = [1,[4,[6]]]<br> 输出：[1,4,6]<br> 解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。<br> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> **提示：**</span><br><span class="line"></span><br><span class="line"> -  `1 &lt;= nestedList.length &lt;= 500`</span><br><span class="line"> -  嵌套列表中的整数值在范围 `[-106, 106]` 内</span><br><span class="line"></span><br><span class="line"> Related Topics</span><br><span class="line"></span><br><span class="line"> 栈</span><br><span class="line"></span><br><span class="line"> 树</span><br><span class="line"></span><br><span class="line"> 深度优先搜索</span><br><span class="line"></span><br><span class="line"> 设计</span><br><span class="line"></span><br><span class="line"> 队列</span><br><span class="line"></span><br><span class="line"> 迭代器</span><br><span class="line"></span><br><span class="line">```java</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<h2><span id="394-zi-fu-chuan-jie-ma">🟡394. 字符串解码</span></h2><blockquote>
<p> 给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p> 编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "3[a]2[bc]"</span><br><span class="line">输出："aaabcbc"</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "3[a2[c]]"</span><br><span class="line">输出："accaccacc"</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 3：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "2[abc]3[cd]ef"</span><br><span class="line">输出："abcabccdcdcdef"</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 4：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abc3[cd]xyz"</span><br><span class="line">输出："abccdcdcdxyz"</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 30</code></li>
<li><code>s</code> 由小写英文字母、数字和方括号 <code>'[]'</code> 组成</li>
<li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li>
<li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li>
</ul>
<p> Related Topics</p>
<p> 栈</p>
<p> 递归</p>
<p> 字符串</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  滑动窗口最大值问题</span><br><span class="line"></span><br><span class="line">## 🔴<span class="number">239.</span> 滑动窗口最大值</span><br><span class="line"></span><br><span class="line"># 求前 K 个高频元素</span><br><span class="line"></span><br><span class="line">## 🟡<span class="number">347.</span> 前K个高频元素 </span><br><span class="line"></span><br><span class="line">&gt;  给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。</span><br><span class="line">&gt;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;</span><br><span class="line">&gt;  **示例 <span class="number">1</span>:**</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p> 输入: nums = [1,1,1,2,2,3], k = 2<br> 输出: [1,2]<br> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**示例 2:**</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><br> 输入: nums = [1], k = 1<br> 输出: [1]<br> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> **提示：**</span><br><span class="line"></span><br><span class="line"> -  `1 &lt;= nums.length &lt;= 105`</span><br><span class="line"> -  `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`</span><br><span class="line"> -  题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> **进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。</span><br><span class="line"></span><br><span class="line"> Related Topics</span><br><span class="line"></span><br><span class="line"> 数组</span><br><span class="line"></span><br><span class="line"> 哈希表</span><br><span class="line"></span><br><span class="line"> 分治</span><br><span class="line"></span><br><span class="line"> 桶排序</span><br><span class="line"></span><br><span class="line"> 计数</span><br><span class="line"></span><br><span class="line"> 快速选择</span><br><span class="line"></span><br><span class="line"> 排序</span><br><span class="line"></span><br><span class="line"> 堆（优先队列）</span><br><span class="line"></span><br><span class="line">方法一：HashMap + Comparator</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Solution {</span><br><span class="line">   public int[] topKFrequent(int[] nums, int k) {</span><br><span class="line">       int[] res = new int[k];</span><br><span class="line">       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">       for (int i = 0; i &lt; nums.length; i++) {</span><br><span class="line">           int key = nums[i];</span><br><span class="line">           map.put(key, map.getOrDefault(key, 0) + 1);</span><br><span class="line">       }</span><br><span class="line">       List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());</span><br><span class="line">       list.sort(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {</span><br><span class="line">           @Override</span><br><span class="line">           public int compare(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2) {</span><br><span class="line">               return o2.getValue().compareTo(o1.getValue());</span><br><span class="line">           }</span><br><span class="line">       });</span><br><span class="line">       for (int i = 0; i &lt; k; i++) {</span><br><span class="line">           res[i] = list.get(i).getKey();</span><br><span class="line">       }</span><br><span class="line">       return res;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<ul>
<li>time:<em>O(nlogk)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<p>方法二：HashMap + PriorityQueue</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> {</span><br><span class="line">                <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entity : map.entrySet()) {</span><br><span class="line">            heap.offer(entity);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">            res[i] = heap.poll().getKey();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(nlogk)</em></li>
<li>space:<em>O(n)</em></li>
</ul>
<h2><span id="692-qian-k-ge-gao-pin-dan-ci">🟡692. 前K个高频单词</span></h2><blockquote>
<p> 给定一个单词列表 <code>words</code> 和一个整数 <code>k</code> ，返回前 <code>k</code> 个出现次数最多的单词。</p>
<p> 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p>
<p> <strong>示例 1：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: words = ["i", "love", "leetcode", "i", "love", "coding"], k = 2</span><br><span class="line">输出: ["i", "love"]</span><br><span class="line">解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。</span><br><span class="line">    注意，按字母顺序 "i" 在 "love" 之前。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2：</strong></p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4</span><br><span class="line">输出: ["the", "is", "sunny", "day"]</span><br><span class="line">解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>注意：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 500</code></li>
<li><code>1 &lt;= words[i] &lt;= 10</code></li>
<li><code>words[i]</code> 由小写英文字母组成。</li>
<li><code>k</code> 的取值范围是 <code>[1, **不同** words[i] 的数量]</code></li>
</ul>
<p> <strong>进阶：</strong>尝试以 <code>O(n log k)</code> 时间复杂度和 <code>O(n)</code> 空间复杂度解决。</p>
<p> Related Topics</p>
<p> 字典树</p>
<p> 哈希表</p>
<p> 字符串</p>
<p> 桶排序</p>
<p> 计数</p>
<p> 排序</p>
<p> 堆（优先队列）</p>
</blockquote>
<p>方法一：HashMap + Comparator</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> {</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> words[i];</span><br><span class="line">            map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.entrySet());</span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (o2.getValue() != o1.getValue()) {</span><br><span class="line">                    <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> o1.getKey().compareTo(o2.getKey());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">            res.add(list.get(i).getKey());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(nlogk)</em></li>
<li>space*:O(n)*</li>
</ul>
<p>方法二：HashMap + PriorityQueue</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> {</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> words[i];</span><br><span class="line">            map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> {</span><br><span class="line">                <span class="keyword">if</span> (o2.getValue() != o1.getValue()) {</span><br><span class="line">                    <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">return</span> o1.getKey().compareTo(o2.getKey());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entity : map.entrySet()) {</span><br><span class="line">            heap.offer(entity);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">            res.add(heap.poll().getKey());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>time:<em>O(nlogk)</em></li>
<li>space*:O(n)*</li>
</ul>

        </div>



    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        
            <script src='https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js'></script>
            <script>
                if (window.mermaid) {
                    mermaid.initialize({
                        startOnLoad: true,
                        theme: 'neural',
                    });
                }
            </script>
        
        <span>© zoe | <a href="https://hexo.io" target="_blank"></a>  <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank"></a>
              
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<span class="site-uv">

👤

 <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>

</span>&nbsp;





<span class="site-pv">

 | 👁️

 <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>

</span>


  
               
        </span>
    </div>
</footer>

    </div>

    <!-- 搜索功能 -->
    <!-- Chic/layout.ejs -->
    <div id="u-search">
        <div class="modal">
            <div class="modal-header">
                <div class="container">
                    <form id="u-search-modal-form" class="u-search-modal-form">
                        <button type="submit" class="form-submit-btn">
                            <img src="/image/search.png" class="search-btn-img" />
                        </button>
                        <input placeholder="搜索文章。。。" class="form-input" onchange="inputChange(event)" id="modal-form-input">
                    </form>
                    <a class="modal-close">x</a>
                </div>
                <div class="search-loading">
                    <div class="search-loading-bar"></div>
                </div>
            </div>
            <div class="modal-body">
                <!-- <ul class="modal-results">
                    <li class="result-item">
                        <a class="result-item-detail">
                            <span class="title">页面配置</span>
                            <span class="content">
                                网址，例如： front-matter---layout: postdate: <b mark></b>
                                7-07-05title: [转]如何搭建基于Hexo的独立博客categories: [Dev, Hexo]tags: - Hexoauthor: name: xaoxuu avatar: https://cdn.jsdelivr.......
                            </span>
                        </a>
                    </li>
                </ul> -->
            </div>
        </div>
        <div class="modal-overlay"></div>
    </div>


</body>



</html>


