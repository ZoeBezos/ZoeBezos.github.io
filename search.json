[{"title":"coding-2244-minimum-time-to-complete-all-tasks","url":"/2024/05/15/coding-2244-minimum-time-to-complete-all-tasks/","content":"\n"},{"title":"🟡2391.minimum amount of time to collect garbage","url":"/2024/05/11/coding-2391-minimum-amount-of-time-to-collect-garbage/","content":"\n# Description\n\n> 给你一个下标从 **0** 开始的字符串数组 `garbage` ，其中 `garbage[i]` 表示第 `i` 个房子的垃圾集合。`garbage[i]` 只包含字符 `'M'` ，`'P'` 和 `'G'` ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 **一** 单位的任何一种垃圾都需要花费 `1` 分钟。\n>\n> 同时给你一个下标从 **0** 开始的整数数组 `travel` ，其中 `travel[i]` 是垃圾车从房子 `i` 行驶到房子 `i + 1` 需要的分钟数。\n>\n> 城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 `0` 出发，**按顺序** 到达每一栋房子。但它们 **不是必须** 到达所有的房子。\n>\n> 任何时刻只有 **一辆** 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 **不能** 做任何事情。\n>\n> 请你返回收拾完所有垃圾需要花费的 **最少** 总分钟数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\n> 输出：21\n> 解释：\n> 收拾纸的垃圾车：\n> 1. 从房子 0 行驶到房子 1\n> 2. 收拾房子 1 的纸垃圾\n> 3. 从房子 1 行驶到房子 2\n> 4. 收拾房子 2 的纸垃圾\n> 收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。\n> 收拾玻璃的垃圾车：\n> 1. 收拾房子 0 的玻璃垃圾\n> 2. 从房子 0 行驶到房子 1\n> 3. 从房子 1 行驶到房子 2\n> 4. 收拾房子 2 的玻璃垃圾\n> 5. 从房子 2 行驶到房子 3\n> 6. 收拾房子 3 的玻璃垃圾\n> 收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。\n> 由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。\n> 所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\n> 输出：37\n> 解释：\n> 收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。\n> 收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。\n> 收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。\n> 总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= garbage.length <= 105`\n> - `garbage[i]` 只包含字母 `'M'` ，`'P'` 和 `'G'` 。\n> - `1 <= garbage[i].length <= 10`\n> - `travel.length == garbage.length - 1`\n> - `1 <= travel[i] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 字符串\n>\n> 前缀和\n\n# Solution\n\n```java\nclass Solution {\n    public int garbageCollection(String[] garbage, int[] travel) {\n        int sum = 0;\n        int[] last = new int[3];\n        for (int i = 0; i < garbage.length; i++) {\n            sum += garbage[i].length();\n            if (garbage[i].contains(\"M\")) {\n                last[0] = i;\n            }\n            if (garbage[i].contains(\"P\")) {\n                last[1] = i;\n            }\n            if (garbage[i].contains(\"G\")) {\n                last[2] = i;\n            }\n        }\n        for (int i = 0; i < last.length; i++) {\n            for (int j = 0; j < last[i]; j++) {\n                sum += travel[j];\n            }\n        }\n        return sum;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Array","algorithm-DP"]},{"title":"🟢2960.count tested devices after test operations","url":"/2024/05/10/coding-2960-count-tested-devices-after-test-operations/","content":"\n# Description\n\n> 给你一个长度为 `n` 、下标从 **0** 开始的整数数组 `batteryPercentages` ，表示 `n` 个设备的电池百分比。\n>\n> 你的任务是按照顺序测试每个设备 `i`，执行以下测试操作：\n>\n> - 如果\n>\n>    \n>\n>   ```\n>   batteryPercentages[i]\n>   ```\n>\n>    \n>\n>   大于\n>\n>    \n>\n>   ```\n>   0\n>   ```\n>\n>   ：\n>\n>   - **增加** 已测试设备的计数。\n>   - 将下标在 `[i + 1, n - 1]` 的所有设备的电池百分比减少 `1`，确保它们的电池百分比 **不会低于** `0` ，即 `batteryPercentages[j] = max(0, batteryPercentages[j] - 1)`。\n>   - 移动到下一个设备。\n>\n> - 否则，移动到下一个设备而不执行任何测试。\n>\n> 返回一个整数，表示按顺序执行测试操作后 **已测试设备** 的数量。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：batteryPercentages = [1,1,2,1,3]\n> 输出：3\n> 解释：按顺序从设备 0 开始执行测试操作：\n> 在设备 0 上，batteryPercentages[0] > 0 ，现在有 1 个已测试设备，batteryPercentages 变为 [1,0,1,0,2] 。\n> 在设备 1 上，batteryPercentages[1] == 0 ，移动到下一个设备而不进行测试。\n> 在设备 2 上，batteryPercentages[2] > 0 ，现在有 2 个已测试设备，batteryPercentages 变为 [1,0,1,0,1] 。\n> 在设备 3 上，batteryPercentages[3] == 0 ，移动到下一个设备而不进行测试。\n> 在设备 4 上，batteryPercentages[4] > 0 ，现在有 3 个已测试设备，batteryPercentages 保持不变。\n> 因此，答案是 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：batteryPercentages = [0,1,2]\n> 输出：2\n> 解释：按顺序从设备 0 开始执行测试操作：\n> 在设备 0 上，batteryPercentages[0] == 0 ，移动到下一个设备而不进行测试。\n> 在设备 1 上，batteryPercentages[1] > 0 ，现在有 1 个已测试设备，batteryPercentages 变为 [0,1,1] 。\n> 在设备 2 上，batteryPercentages[2] > 0 ，现在有 2 个已测试设备，batteryPercentages 保持不变。\n> 因此，答案是 2 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= n == batteryPercentages.length <= 100 `\n> - `0 <= batteryPercentages[i] <= 100`\n\n# Solution\n\n```java\nclass Solution {\n    public int countTestedDevices(int[] batteryPercentages) {\n        int cnt=0,len= batteryPercentages.length;\n        for (int i = 0; i < len; i++) {\n            if(batteryPercentages[i]>0){\n                cnt++;\n                for (int j = i+1; j < len; j++) {\n                    batteryPercentages[j]=Math.max(0,batteryPercentages[j]-1);\n                }\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(1)*\n","tags":["algorithm-Array","algorithm-Simulation"]},{"title":"🟡2105.watering plants ii","url":"/2024/05/09/coding-2105-watering-plants-ii/","content":"\n# Description\n\n> Alice 和 Bob 打算给花园里的 `n` 株植物浇水。植物排成一行，从左到右进行标记，编号从 `0` 到 `n - 1` 。其中，第 `i` 株植物的位置是 `x = i` 。\n>\n> 每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，**最初是满的** 。他们按下面描述的方式完成浇水：\n>\n> - Alice 按 **从左到右** 的顺序给植物浇水，从植物 `0` 开始。Bob 按 **从右到左** 的顺序给植物浇水，从植物 `n - 1` 开始。他们 **同时** 给植物浇水。\n> - 无论需要多少水，为每株植物浇水所需的时间都是相同的。\n> - 如果 Alice/Bob 水罐中的水足以 **完全** 灌溉植物，他们 **必须** 给植物浇水。否则，他们 **首先**（立即）重新装满罐子，然后给植物浇水。\n> - 如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水 **更多** 的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。\n>\n> 给你一个下标从 **0** 开始的整数数组 `plants` ，数组由 `n` 个整数组成。其中，`plants[i]` 为第 `i` 株植物需要的水量。另有两个整数 `capacityA` 和 `capacityB` 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 **次数** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：plants = [2,2,3,3], capacityA = 5, capacityB = 5\n> 输出：1\n> 解释：\n> - 最初，Alice 和 Bob 的水罐中各有 5 单元水。\n> - Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n> - Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。\n> - Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。\n> 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：plants = [2,2,3,3], capacityA = 3, capacityB = 4\n> 输出：2\n> 解释：\n> - 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。\n> - Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n> - Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。\n> - 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。\n> 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：plants = [5], capacityA = 10, capacityB = 8\n> 输出：0\n> 解释：\n> - 只有一株植物\n> - Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。\n> 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == plants.length`\n> - `1 <= n <= 105`\n> - `1 <= plants[i] <= 106`\n> - `max(plants[i]) <= capacityA, capacityB <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 模拟\n\n# Solution\n\n```java\nclass Solution {\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\n        int cur_A = capacityA, cur_B = capacityB;\n        int len = plants.length;\n        int cnt = 0;\n        for (int i = 0; i < (len + 1) / 2; i++) {\n            if (i == len - 1 - i && cur_A < plants[i] && cur_B >= plants[len - 1 - i]) {\n                cur_B -= plants[len - 1 - i];\n                break;\n            }\n\n            if (cur_A < plants[i]) {\n                cnt++;\n                cur_A = capacityA - plants[i];\n            } else {\n                cur_A -= plants[i];\n            }\n            if (i == len - 1 - i){\n                break;\n            }\n            if (cur_B < plants[len - 1 - i]) {\n                cnt++;\n                cur_B = capacityB - plants[len - 1 - i];\n            } else {\n                cur_B -= plants[len - 1 - i];\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Array","algorithm-Simulation","algorithm-Two Pointers"]},{"title":"🟡2079.watering plants","url":"/2024/05/08/coding-2079-watering-plants/","content":"\n# Description\n\n> 你打算用一个水罐给花园里的 `n` 株植物浇水。植物排成一行，从左到右进行标记，编号从 `0` 到 `n - 1` 。其中，第 `i` 株植物的位置是 `x = i` 。`x = -1` 处有一条河，你可以在那里重新灌满你的水罐。\n>\n> 每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：\n>\n> - 按从左到右的顺序给植物浇水。\n> - 在给当前植物浇完水之后，如果你没有足够的水 **完全** 浇灌下一株植物，那么你就需要返回河边重新装满水罐。\n> - 你 **不能** 提前重新灌满水罐。\n>\n> 最初，你在河边（也就是，`x = -1`），在 x 轴上每移动 **一个单位** 都需要 **一步** 。\n>\n> 给你一个下标从 **0** 开始的整数数组 `plants` ，数组由 `n` 个整数组成。其中，`plants[i]` 为第 `i` 株植物需要的水量。另有一个整数 `capacity` 表示水罐的容量，返回浇灌所有植物需要的 **步数** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：plants = [2,2,3,3], capacity = 5\n> 输出：14\n> 解释：从河边开始，此时水罐是装满的：\n> - 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。\n> - 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。\n> - 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。\n> - 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。\n> - 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。\n> - 走到植物 3 (4 步) ，浇水。\n> 需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：plants = [1,1,1,4,2,3], capacity = 4\n> 输出：30\n> 解释：从河边开始，此时水罐是装满的：\n> - 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。\n> - 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。\n> - 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。\n> - 走到植物 5 (6 步) ，浇水。\n> 需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：plants = [7,7,7,7,7,7,7], capacity = 8\n> 输出：49\n> 解释：每次浇水都需要重新灌满水罐。\n> 需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == plants.length`\n> - `1 <= n <= 1000`\n> - `1 <= plants[i] <= 106`\n> - `max(plants[i]) <= capacity <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 模拟\n\n# Solution\n\n```java\nclass Solution {\n    public int wateringPlants(int[] plants, int capacity) {\n        int sum = 0;\n        int cur = capacity;\n        for (int i = 0; i < plants.length; i++) {\n            if (cur < plants[i]) {\n                sum += i + i + 1;\n                cur = capacity - plants[i];\n            } else {\n                sum++;\n                cur -= plants[i];\n            }\n        }\n        return sum;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Array","algorithm-Simulation"]},{"title":"🟡1026.maximum difference between node and ancestor","url":"/2024/04/05/coding-1026-maximum-difference-between-node-and-ancestor/","content":"\n# Description\n\n> 给定二叉树的根节点 `root`，找出存在于 **不同** 节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。\n>\n> （如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg)\n>\n> ```\n> 输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]\n> 输出：7\n> 解释： \n> 我们有大量的节点与其祖先的差值，其中一些如下：\n> |8 - 3| = 5\n> |3 - 7| = 4\n> |8 - 1| = 7\n> |10 - 13| = 3\n> 在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,null,0,3]\n> 输出：3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中的节点数在 `2` 到 `5000` 之间。\n> - `0 <= Node.val <= 105`\n\n# Solution\n\n```java\nclass Solution {\n    public int maxAncestorDiff(TreeNode root) {\n        return dfs(root, root.val, root.val);\n    }\n\n    public int dfs(TreeNode root, int min, int max) {\n        if (root == null) {\n            return 0;\n        }\n        int diff = Math.max(Math.abs(root.val - min), Math.abs(root.val - max));\n        min = Math.min(min, root.val);\n        max = Math.max(max, root.val);\n        diff = Math.max(diff, dfs(root.left, min, max));\n        diff = Math.max(diff, dfs(root.right, min, max));\n        return diff;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS"]},{"title":"🟢1379.find a corresponding node of a  binary-tree in a clone of that tree","url":"/2024/04/03/coding-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/","content":"\n# Description\n\n> 给你两棵二叉树，原始树 `original` 和克隆树 `cloned`，以及一个位于原始树 `original` 中的目标节点 `target`。\n>\n> 其中，克隆树 `cloned` 是原始树 `original` 的一个 **副本** 。\n>\n> 请找出在树 `cloned` 中，与 `target` **相同** 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。\n>\n>  \n>\n> **注意：**你 **不能** 对两棵二叉树，以及 `target` 节点进行更改。**只能** 返回对克隆树 `cloned` 中已有的节点的引用。\n>\n> \n>\n>  \n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/02/21/e1.png)\n>\n> ```\n> 输入: tree = [7,4,3,null,null,6,19], target = 3\n> 输出: 3\n> 解释: 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/02/21/e2.png)\n>\n> ```\n> 输入: tree = [7], target =  7\n> 输出: 7\n> ```\n>\n> **示例 3:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/02/21/e3.png)\n>\n> ```\n> 输入: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n> 输出: 4\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树中节点的数量范围为 `[1, 104]` 。\n> - 同一棵树中，没有值相同的节点。\n> - `target` 节点是树 `original` 中的一个节点，并且不会是 `null` 。\n>\n>  \n>\n> **进阶：**如果树中允许出现值相同的节点，将如何解答？\n\n# Solution\n\n```java\nclass Solution {\n\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n        return preOrder(cloned, target.val);\n    }\n\n    TreeNode preOrder(TreeNode root, int targetVal) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val == targetVal) {\n            return root;\n        }\n        TreeNode left = preOrder(root.left, targetVal);\n        if (left != null) {\n            return left;\n        }\n        TreeNode right = preOrder(root.right, targetVal);\n        return right;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS","algorithm-DFS"]},{"title":"🟢2810.faulty keyboard","url":"/2024/04/01/coding-2810-faulty-keyboard/","content":"\n# Description\n\n> 你的笔记本键盘存在故障，每当你在上面输入字符 `'i'` 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。\n>\n> 给你一个下标从 **0** 开始的字符串 `s` ，请你用故障键盘依次输入每个字符。\n>\n> 返回最终笔记本屏幕上输出的字符串。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"string\"\n> 输出：\"rtsng\"\n> 解释：\n> 输入第 1 个字符后，屏幕上的文本是：\"s\" 。\n> 输入第 2 个字符后，屏幕上的文本是：\"st\" 。\n> 输入第 3 个字符后，屏幕上的文本是：\"str\" 。\n> 因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 \"rts\" 。\n> 输入第 5 个字符后，屏幕上的文本是：\"rtsn\" 。\n> 输入第 6 个字符后，屏幕上的文本是： \"rtsng\" 。\n> 因此，返回 \"rtsng\" 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"poiinter\"\n> 输出：\"ponter\"\n> 解释：\n> 输入第 1 个字符后，屏幕上的文本是：\"p\" 。\n> 输入第 2 个字符后，屏幕上的文本是：\"po\" 。\n> 因为第 3 个字符是 'i' ，屏幕上的文本被反转，变成 \"op\" 。\n> 因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 \"po\" 。\n> 输入第 5 个字符后，屏幕上的文本是：\"pon\" 。\n> 输入第 6 个字符后，屏幕上的文本是：\"pont\" 。\n> 输入第 7 个字符后，屏幕上的文本是：\"ponte\" 。\n> 输入第 8 个字符后，屏幕上的文本是：\"ponter\" 。\n> 因此，返回 \"ponter\" 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= s.length <= 100`\n> - `s` 由小写英文字母组成\n> - `s[0] != 'i'`\n\n# Solution\n\n```java\nclass Solution {\n    public String finalString(String s) {\n        StringBuilder res=new StringBuilder();\n        for (char ch:s.toCharArray()){\n            if(ch=='i'){\n                res=res.reverse();\n            }else {\n                res.append(ch+\"\");\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n","tags":["algorithm-Simulation","algorithm-String"]},{"title":"🟢2129.capitalize the title","url":"/2024/03/11/coding-2129-capitalize-the-title/","content":"\n# Description\n\n> 给你一个字符串 `title` ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 **大写** ：\n>\n> - 如果单词的长度为 `1` 或者 `2` ，所有字母变成小写。\n> - 否则，将单词首字母大写，剩余字母变成小写。\n>\n> 请你返回 **大写后** 的 `title` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：title = \"capiTalIze tHe titLe\"\n> 输出：\"Capitalize The Title\"\n> 解释：\n> 由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：title = \"First leTTeR of EACH Word\"\n> 输出：\"First Letter of Each Word\"\n> 解释：\n> 单词 \"of\" 长度为 2 ，所以它保持完全小写。\n> 其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：title = \"i lOve leetcode\"\n> 输出：\"i Love Leetcode\"\n> 解释：\n> 单词 \"i\" 长度为 1 ，所以它保留小写。\n> 其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= title.length <= 100`\n> - `title` 由单个空格隔开的单词组成，且不含有任何前导或后缀空格。\n> - 每个单词由大写和小写英文字母组成，且都是 **非空** 的。\n>\n> Related Topics\n>\n> 字符串\n\n# Solution\n\n```java\nclass Solution {\n    public String capitalizeTitle(String title) {\n        title = title.toLowerCase();\n        char[] chars = title.toCharArray();\n        int cnt=0;\n        for (int i = title.length()-1; i >= 0; i--) {\n            if (!Character.isLetterOrDigit(title.charAt(i))){\n                cnt = 0;\n            }else{\n                cnt++;\n            }\n            if (cnt > 2 && Character.isLowerCase(chars[i]) && (i == 0 || !Character.isLetterOrDigit(title.charAt(i - 1)))) {\n                chars[i] += 'A' - 'a';\n            }\n        }\n        return String.copyValueOf(chars);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-String"]},{"title":"🟢232.implement queue using stacks","url":"/2024/03/04/coding-232-implement-queue-using-stacks/","content":"\n# Description\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n>\n> 实现 `MyQueue` 类：\n>\n> - `void push(int x)` 将元素 x 推到队列的末尾\n> - `int pop()` 从队列的开头移除并返回元素\n> - `int peek()` 返回队列开头的元素\n> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n>\n> **说明：**\n>\n> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> \n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\n>\n> \n>\n> **进阶：**\n>\n> - 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n# Solution\n\n```java\nclass MyQueue {\n    Stack<Integer>in;\n    Stack<Integer>out;\n    public MyQueue() {\n        this.in=new Stack<>();\n        this.out=new Stack<>();\n    }\n    \n    public void push(int x) {\n        this.in.push(x);\n    }\n    \n    public int pop() {\n        while (!this.in.isEmpty()){\n            this.out.push(this.in.pop());\n        }\n        int res=this.out.pop();\n        while (!this.out.isEmpty()){\n            this.in.push(this.out.pop());\n        }\n        return res;\n    }\n    \n    public int peek() {\n        while (!this.in.isEmpty()){\n            this.out.push(this.in.pop());\n        }\n        int res=this.out.peek();\n        while (!this.out.isEmpty()){\n            this.in.push(this.out.pop());\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return this.in.isEmpty();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Stack","algorithm-Queue","algorithm-Design"]},{"title":"🟢225.implement stack using queues","url":"/2024/03/03/coding-225-implement-stack-using-queues/","content":"\n# Description\n\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n>\n> 实现 `MyStack` 类：\n>\n> - `void push(int x)` 将元素 x 压入栈顶。\n> - `int pop()` 移除并返回栈顶元素。\n> - `int top()` 返回栈顶元素。\n> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **注意：**\n>\n> - 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。\n> - 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 2, 2, false]\n> \n> 解释：\n> MyStack myStack = new MyStack();\n> myStack.push(1);\n> myStack.push(2);\n> myStack.top(); // 返回 2\n> myStack.pop(); // 返回 2\n> myStack.empty(); // 返回 False\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`\n> - 每次调用 `pop` 和 `top` 都保证栈不为空\n>\n> \n>\n> **进阶：**你能否仅用一个队列来实现栈。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n# Solution\n\n```java\nclass MyStack {\n    Queue<Integer>in;\n    Queue<Integer>out;\n    public MyStack() {\n        this.in=new LinkedList<>();\n        this.out=new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        this.in.offer(x);\n    }\n    \n    public int pop() {\n        int size=this.in.size();\n        for (int i = 0; i < size-1; i++) {\n            this.out.offer(this.in.poll());\n        }\n        int res=this.in.poll();\n        for (int i = 0; i < size-1; i++) {\n            this.in.offer(this.out.poll());\n        }\n        return res;\n    }\n    \n    public int top() {\n        int size=this.in.size();\n        int res=this.in.peek();\n        for (int i = 0; i < size; i++) {\n            res=this.in.peek();\n            this.out.offer(this.in.poll());\n        }\n        for (int i = 0; i < size; i++) {\n            this.in.offer(this.out.poll());\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return this.in.isEmpty();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Stack","algorithm-Queue","algorithm-Design"]},{"title":"🟡2369.check if there is a valid partition for the array","url":"/2024/03/01/coding-2369-check-if-there-is-a-valid-partition-for-the-array/","content":"\n# Description\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` ，你必须将数组划分为一个或多个 **连续** 子数组。\n>\n> 如果获得的这些子数组中每个都能满足下述条件 **之一** ，则可以称其为数组的一种 **有效** 划分：\n>\n> 1. 子数组 **恰** 由 `2` 个相等元素组成，例如，子数组 `[2,2]` 。\n> 2. 子数组 **恰** 由 `3` 个相等元素组成，例如，子数组 `[4,4,4]` 。\n> 3. 子数组 **恰** 由 `3` 个连续递增元素组成，并且相邻元素之间的差值为 `1` 。例如，子数组 `[3,4,5]` ，但是子数组 `[1,3,5]` 不符合要求。\n>\n> 如果数组 **至少** 存在一种有效划分，返回 `true` ，否则，返回 `false` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,4,4,5,6]\n> 输出：true\n> 解释：数组可以划分成子数组 [4,4] 和 [4,5,6] 。\n> 这是一种有效划分，所以返回 true 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,1,1,2]\n> 输出：false\n> 解释：该数组不存在有效划分。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 105`\n> - `1 <= nums[i] <= 106`\n\n# Solution\n\n```java\nclass Solution {\n    public boolean validPartition(int[] nums) {\n        int len= nums.length;\n        boolean[]dp=new boolean[len+1];\n        dp[0]=true;\n        if(nums[0]==nums[1]){\n            dp[2]=true;\n        }\n        if(len>=3&&(nums[0]==nums[1]&&nums[1]==nums[2]||nums[2]-nums[1]==1&&nums[1]-nums[0]==1)){\n            dp[3]=true;\n        }\n        for (int i = 4; i <= len; i++) {\n            if((dp[i-2]&&nums[i-1]==nums[i-2])||(dp[i-3]&&(nums[i-1]==nums[i-2]&&nums[i-2]==nums[i-3]||nums[i-1]-nums[i-2]==1&&nums[i-2]-nums[i-3]==1))){\n                dp[i]=true;\n            }\n        }\n        return dp[len];\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Array","algorithm-DP"]},{"title":"Math","url":"/2024/02/27/java-class-math/","content":"\narrays\n\nmath\n\nbigdecimal\n\nbiginteger\n\nrangdom\n\ndate\n\n","categories":["important classes"]},{"title":"🟢938.range sum of bst","url":"/2024/02/26/coding-938-range-sum-of-bst/","content":"\n# Description\n\n> 给定二叉搜索树的根结点 `root`，返回值位于范围 *`[low, high]`* 之间的所有结点的值的和。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)\n>\n> ```\n> 输入：root = [10,5,15,3,7,null,18], low = 7, high = 15\n> 输出：32\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg)\n>\n> ```\n> 输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[1, 2 * 104]` 内\n> - `1 <= Node.val <= 105`\n> - `1 <= low <= high <= 105`\n> - 所有 `Node.val` **互不相同**\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n# Solution(Recurs)\n\n```java\nclass Solution {\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root==null){\n            return 0;\n        }else if(root.val<low){\n            return rangeSumBST(root.right, low, high);\n        }else if(root.val>high){\n            return rangeSumBST(root.left, low, high);\n        }else {\n            return root.val+rangeSumBST(root.left, low, high)+rangeSumBST(root.right, low, high);\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS","algorithm-BST"]},{"title":"🟡235.lowest common ancestor of a binary-search-tree","url":"/2024/02/25/coding-235-lowest-common-ancestor-of-a-binary-search-tree/","content":"\n# Description\n\n> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n>\n> 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)\n>\n>  \n>\n> **示例 1:**\n>\n> ```\n> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n> 输出: 6 \n> 解释: 节点 2 和节点 8 的最近公共祖先是 6。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n> 输出: 2\n> 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n> ```\n>\n>  \n>\n> **说明:**\n>\n> - 所有节点的值都是唯一的。\n> - p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        int sub1=root.val-p.val>0?1:root.val-p.val<0?-1:0;\n        int sub2=root.val-q.val>0?1:root.val-q.val<0?-1:0;\n        if(sub1*sub2<=0){\n            return root;\n        }else {\n            if(sub1<0){\n                return lowestCommonAncestor(root.right,p,q);\n            }else {\n                return lowestCommonAncestor(root.left,p,q);\n            }\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS","algorithm-BST"]},{"title":"🟡2583 kth largest sum in a binary-tree","url":"/2024/02/23/coding-2583-kth-largest-sum-in-a-binary-tree/","content":"\n# Description\n\n> 给你一棵二叉树的根节点 `root` 和一个正整数 `k` 。\n>\n> 树中的 **层和** 是指 **同一层** 上节点值的总和。\n>\n> 返回树中第 `k` 大的层和（不一定不同）。如果树少于 `k` 层，则返回 `-1` 。\n>\n> **注意**，如果两个节点与根节点的距离相同，则认为它们在同一层。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png)\n>\n> ```\n> 输入：root = [5,8,9,2,1,3,7,4,6], k = 2\n> 输出：13\n> 解释：树中每一层的层和分别是：\n> - Level 1: 5\n> - Level 2: 8 + 9 = 17\n> - Level 3: 2 + 1 + 3 + 7 = 13\n> - Level 4: 4 + 6 = 10\n> 第 2 大的层和等于 13 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png)\n>\n> ```\n> 输入：root = [1,2,null,3], k = 1\n> 输出：3\n> 解释：最大的层和是 3 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树中的节点数为 `n`\n> - `2 <= n <= 105`\n> - `1 <= Node.val <= 106`\n> - `1 <= k <= n`\n\n# Solution\n\n```java\nclass Solution {\n    public long kthLargestLevelSum(TreeNode root, int k) {\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        Queue<Long>heap=new PriorityQueue<>(new Comparator<Long>() {\n            @Override\n            public int compare(Long o1, Long o2) {\n                return o2.compareTo(o1);\n            }\n        });\n        int cnt=0;\n        while (!queue.isEmpty()){\n            cnt++;\n            int size=queue.size();\n            long sum=0;\n            while (size-->0){\n                TreeNode node=queue.poll();\n                sum+=node.val;\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            heap.offer(sum);\n        }\n        if(k>cnt){\n            return -1;\n        }\n        for (int i = 0; i < k-1; i++) {\n            heap.poll();\n        }\n        return heap.poll();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS","algorithm-Sorting"]},{"title":"🟡106.construct binary-tree from inorder and postorder traversal","url":"/2024/02/21/coding-106-construct-binary-tree-from-inorder-and-postorder-traversal/","content":"\n# Description\n\n> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。\n>\n>  \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n>\n> ```\n> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n> 输出：[3,9,20,null,null,15,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：inorder = [-1], postorder = [-1]\n> 输出：[-1]\n> ```\n>\n>  \n>\n> **提示:**\n>\n> - `1 <= inorder.length <= 3000`\n> - `postorder.length == inorder.length`\n> - `-3000 <= inorder[i], postorder[i] <= 3000`\n> - `inorder` 和 `postorder` 都由 **不同** 的值组成\n> - `postorder` 中每一个值都在 `inorder` 中\n> - `inorder` **保证**是树的中序遍历\n> - `postorder` **保证**是树的后序遍历\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    int[]inOrder;\n    int[]postOrder;\n    int len;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        inOrder=inorder;\n        postOrder=postorder;\n        len= inorder.length;\n        TreeNode res=new TreeNode(postOrder[len-1]);\n        recursion(res,len-1,0,len-1);\n        return res;\n    }\n    void recursion(TreeNode root,int base,int left,int right){\n        if(root==null||left>=right){\n            return;\n        }\n        int i=left;\n        while (i<right&&inOrder[i]!=postOrder[base]){\n            i++;\n        }\n        int left_cnt=i-left;\n        int right_cnt=right-i;\n        if(left_cnt>0){\n            root.left=new TreeNode(postOrder[base-right_cnt-1]);\n            recursion(root.left,base-right_cnt-1,left,i-1);\n        }\n        if(right_cnt>0){\n            root.right=new TreeNode(postOrder[base-1]);\n            recursion(root.right,base-1,i+1,right);\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-Array","algorithm-HashTable","algorithm-Divide & Conquer"]},{"title":"🟡105.construct binary-tree from preorder and inorder traversal","url":"/2024/02/20/coding-105-construct-binary-tree-from-preorder-and-inorder-traversal/","content":"\n# Description\n\n> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。\n>\n>  \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n>\n> ```\n> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n> 输出: [3,9,20,null,null,15,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: preorder = [-1], inorder = [-1]\n> 输出: [-1]\n> ```\n>\n>  \n>\n> **提示:**\n>\n> - `1 <= preorder.length <= 3000`\n> - `inorder.length == preorder.length`\n> - `-3000 <= preorder[i], inorder[i] <= 3000`\n> - `preorder` 和 `inorder` 均 **无重复** 元素\n> - `inorder` 均出现在 `preorder`\n> - `preorder` **保证** 为二叉树的前序遍历序列\n> - `inorder` **保证** 为二叉树的中序遍历序列\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    int[]preOrder;\n    int[]inOrder;\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        this.preOrder=preorder;\n        this.inOrder=inorder;\n        int len= this.preOrder.length;\n        TreeNode head=new TreeNode(this.preOrder[0]);\n        recursion(head,0,0,len-1);\n        return head;\n    }\n    void recursion(TreeNode root,int base,int left,int right){\n        if(left>=right){\n            return;\n        }\n        int i=left;\n        while (i<right&&this.inOrder[i]!=this.preOrder[base]){\n            i++;\n        }\n        int left_cnt=i-left;\n        int right_cnt=right-i;\n        if(left_cnt>0){\n            root.left=new TreeNode(this.preOrder[base+1]);\n        }\n        if(right_cnt>0){\n            root.right=new TreeNode(this.preOrder[base+1+left_cnt]);\n        }\n        recursion(root.left,base+1,left,i-1);\n        recursion(root.right,base+1+left_cnt,i+1,right);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-Array","algorithm-HashTable","algorithm-Divide & Conquer"]},{"title":"🔸124th LeetCode Biweekly Contest","url":"/2024/02/18/contest-biweekly-124/","content":"\n|      | score | problem                               | tag  |\n| ---- | ----- | ------------------------------------- | ---- |\n| ✅    | 3     | 🟢相同分数的最大操作数目 I             |      |\n| ✅    | 4     | 🟡进行操作使字符串为空                 |      |\n|      | 5     | 🟡相同分数的最大操作数目 II            |      |\n|      | 6     | 🔴修改数组后最大化数组中的连续元素数目 |      |\n\n# 🟢相同分数的最大操作数目 I\n\n> 给你一个整数数组 `nums` ，如果 `nums` **至少** 包含 `2` 个元素，你可以执行以下操作：\n>\n> - 选择 `nums` 中的前两个元素并将它们删除。\n>\n> 一次操作的 **分数** 是被删除元素的和。\n>\n> 在确保 **所有操作分数相同** 的前提下，请你求出 **最多** 能进行多少次操作。\n>\n> 请你返回按照上述要求 **最多** 可以进行的操作次数。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,2,1,4,5]\n> 输出：2\n> 解释：我们执行以下操作：\n> - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [1,4,5] 。\n> - 删除前两个元素，分数为 1 + 4 = 5 ，nums = [5] 。\n> 由于只剩下 1 个元素，我们无法继续进行任何操作。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,6,1,4]\n> 输出：1\n> 解释：我们执行以下操作：\n> - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [6,1,4] 。\n> 由于下一次操作的分数与前一次不相等，我们无法继续进行任何操作。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 100`\n> - `1 <= nums[i] <= 1000`\n\n```java\nclass Solution {\n    public int maxOperations(int[] nums) {\n        int index=0,len=nums.length;\n        int sum=nums[index]+nums[index+1];\n        index+=2;\n        int cnt=1;\n        while(index<len&&index+1<len){\n            int sum_=nums[index]+nums[index+1];\n            if(sum_==sum){\n                cnt++;\n            }else{\n                break;\n            }\n            index+=2;\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n# 🟡进行操作使字符串为空\n\n> 给你一个字符串 `s` 。\n>\n> 请你进行以下操作直到 `s` 为 **空** ：\n>\n> - 每次操作 **依次** 遍历 `'a'` 到 `'z'`，如果当前字符出现在 `s` 中，那么删除出现位置 **最早** 的该字符。\n>\n> 请你返回进行 **最后** 一次操作 **之前** 的字符串 `s` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"aabcbbca\"\n> 输出：\"ba\"\n> 解释：我们进行以下操作：\n> - 删除 s = \"aabcbbca\" 中加粗加斜字符，得到字符串 s = \"abbca\" 。\n> - 删除 s = \"abbca\" 中加粗加斜字符，得到字符串 s = \"ba\" 。\n> - 删除 s = \"ba\" 中加粗加斜字符，得到字符串 s = \"\" 。\n> 进行最后一次操作之前的字符串为 \"ba\" 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\"\n> 输出：\"abcd\"\n> 解释：我们进行以下操作：\n> - 删除 s = \"abcd\" 中加粗加斜字符，得到字符串 s = \"\" 。\n> 进行最后一次操作之前的字符串为 \"abcd\" 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= s.length <= 5 * 105`\n> - `s` 只包含小写英文字母。\n\n```java\nclass Solution {\n    public String lastNonEmptyString(String s) {\n        int max=0;\n        int[]cnt=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            int key=s.charAt(i)-'a';\n            cnt[key]++;\n            max=Math.max(max,cnt[key]);\n        }\n        StringBuilder res=new StringBuilder();\n        for (int i = s.length()-1; i >=0.; i--) {\n             int key=s.charAt(i)-'a';\n            if(cnt[key]==max){\n                res.append(s.charAt(i));\n                cnt[key]=0;\n            }\n        }\n        return res.reverse().toString();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n# 🟡相同分数的最大操作数目 II\n\n> 给你一个整数数组 `nums` ，如果 `nums` **至少** 包含 `2` 个元素，你可以执行以下操作中的 **任意** 一个：\n>\n> - 选择 `nums` 中最前面两个元素并且删除它们。\n> - 选择 `nums` 中最后两个元素并且删除它们。\n> - 选择 `nums` 中第一个和最后一个元素并且删除它们。\n>\n> 一次操作的 **分数** 是被删除元素的和。\n>\n> 在确保 **所有操作分数相同** 的前提下，请你求出 **最多** 能进行多少次操作。\n>\n> 请你返回按照上述要求 **最多** 可以进行的操作次数。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,2,1,2,3,4]\n> 输出：3\n> 解释：我们执行以下操作：\n> - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [1,2,3,4] 。\n> - 删除第一个元素和最后一个元素，分数为 1 + 4 = 5 ，nums = [2,3] 。\n> - 删除第一个元素和最后一个元素，分数为 2 + 3 = 5 ，nums = [] 。\n> 由于 nums 为空，我们无法继续进行任何操作。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,6,1,4]\n> 输出：2\n> 解释：我们执行以下操作：\n> - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [6,1,4] 。\n> - 删除最后两个元素，分数为 1 + 4 = 5 ，nums = [6] 。\n> 至多进行 2 次操作。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 2000`\n> - `1 <= nums[i] <= 1000`\n\n```java\n```\n\n\n\n# 🔴修改数组后最大化数组中的连续元素数目\n\n> 给你一个下标从 **0** 开始只包含 **正** 整数的数组 `nums` 。\n>\n> 一开始，你可以将数组中 **任意数量** 元素增加 **至多** `1` 。\n>\n> 修改后，你可以从最终数组中选择 **一个或者更多** 元素，并确保这些元素升序排序后是 **连续** 的。比方说，`[3, 4, 5]` 是连续的，但是 `[3, 4, 6]` 和 `[1, 1, 2, 3]` 不是连续的。\n>\n> 请你返回 **最多** 可以选出的元素数目。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,1,5,1,1]\n> 输出：3\n> 解释：我们将下标 0 和 3 处的元素增加 1 ，得到结果数组 nums = [3,1,5,2,1] 。\n> 我们选择元素 [3,1,5,2,1] 并将它们排序得到 [1,2,3] ，是连续元素。\n> 最多可以得到 3 个连续元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,4,7,10]\n> 输出：1\n> 解释：我们可以选择的最多元素数目是 1 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `1 <= nums[i] <= 106`\n\n```java\n```\n\n","tags":["contest"]},{"title":"🟢589.n-ary-tree preorder traversal","url":"/2024/02/18/coding-589-n-ary-tree-preorder-traversal/","content":"\n# Description\n\n> 给定一个 n 叉树的根节点 `root` ，返回 *其节点值的 **前序遍历*** 。\n>\n> n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。\n>\n> \n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n>\n> ```\n> 输入：root = [1,null,3,2,4,null,5,6]\n> 输出：[1,3,5,6,2,4]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n>\n> ```\n> 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> 输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 节点总数在范围 `[0, 104]`内\n> - `0 <= Node.val <= 104`\n> - n 叉树的高度小于或等于 `1000`\n>\n>  \n>\n> **进阶：**递归法很简单，你可以使用迭代法完成此题吗?\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer>res=new ArrayList<>();\n        preOder(res,root);\n        return res;\n    }\n    void preOder(List<Integer> res,Node root){\n        if(root==null){\n            return;\n        }\n        res.add(root.val);\n        for (int i = 0; i < root.children.size(); i++) {\n            preOder(res, root.children.get(i));\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n# Solution(Iteration)\n\n```java\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<Node> s = new Stack<>();\n        if(root!=null)s.push(root);\n        while(!s.isEmpty()){\n            Node node=s.peek();\n            if(node!=null){\n                s.pop();\n                s.push(node);\n                s.push(null);\n                for (int i = node.children.size()-1; i >= 0; i--) {\n                    s.push(node.children.get(i));\n                }    \n            }else{\n                s.pop();\n                node=s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-DFS","algorithm-Stack"]},{"title":"🟡429.n ary tree level order traversal","url":"/2024/02/17/coding-429-n-ary-tree-level-order-traversal/","content":"\n# Description\n\n> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。\n>\n> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n>\n> ```\n> 输入：root = [1,null,3,2,4,null,5,6]\n> 输出：[[1],[3,2,4],[5,6]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n>\n> ```\n> 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树的高度不会超过 `1000`\n> - 树的节点总数在 `[0, 10^4]` 之间\n\n# Solution\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<Node>queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            List<Integer>list=new ArrayList<>();\n            while (size-->0){\n                Node node=queue.poll();\n                list.add(node.val);\n                for (int i = 0; i < node.children.size(); i++) {\n                    queue.offer(node.children.get(i));\n                }\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BFS"]},{"title":"class Arrays","url":"/2024/02/16/java-arrays-class/","content":"\n![image-20240216130257400](C:\\blog\\source\\_posts\\java-class-arrays\\image-20240216130257400.png)\n\n# 概览\n\n| categories     | name                                                         | return      |\n| -------------- | ------------------------------------------------------------ | ----------- |\n| innner classes | NaturalOrder implements Comparator<Object>                   | -           |\n|                | LegacyMergeSort                                              | -           |\n|                | ArrayList<E> extends AbstractList<E>     implements RandomAccess, java.io.Serializable | -           |\n|                | ArrayItr<E> implements Iterator<E>                           | -           |\n| fields         | 🔒MIN_ARRAY_SORT_GRAN                                         | int         |\n|                | 🔒INSERTIONSORT_THRESHOLD                                     | int         |\n| conductors     | Arrays()                                                     | Object      |\n| methods        | sort                                                         | void        |\n|                | parallelSort                                                 | void        |\n|                | rangeCheck                                                   | void        |\n|                | legacyMergeSort                                              | void        |\n|                | mergeSort                                                    | void        |\n|                | swap                                                         | void        |\n|                | parallelPrefix                                               | void        |\n|                | binarySearch                                                 | int         |\n|                | binarySearch0                                                | int         |\n|                | equals                                                       | boolean     |\n|                | fill                                                         | void        |\n|                | copyOf                                                       | T[]         |\n|                | copyOfRange                                                  | T[]         |\n|                | asList                                                       | List<T>     |\n|                | hashCode                                                     | int         |\n|                | deepHashCode                                                 | int         |\n|                | primitiveArrayHashCode                                       | int         |\n|                | deepEquals                                                   | boolean     |\n|                | deepEquals0                                                  | boolean     |\n|                | toString                                                     | String      |\n|                | deepToString                                                 | String/void |\n|                | setAll                                                       | void        |\n|                | parallelSetAll                                               | void        |\n|                | Spliterator                                                  | <T>         |\n|                | Stream                                                       | Stream<T>   |\n|                | compare                                                      | int         |\n|                | compareUnsigned                                              | int         |\n|                | mismatch                                                     | int         |\n\n# 内部类\n","categories":["Java"]},{"title":"Arrays","url":"/2024/02/16/java-class-array/","content":"\n![image-20240216130257400](java-class-arrays/image-20240216130257400.png)\n\n# 概览\n\n| categories     | name                                                         | return      |\n| -------------- | ------------------------------------------------------------ | ----------- |\n| innner classes | NaturalOrder implements Comparator<Object>                   | -           |\n|                | LegacyMergeSort                                              | -           |\n|                | ArrayList<E> extends AbstractList<E>     implements RandomAccess, java.io.Serializable | -           |\n|                | ArrayItr<E> implements Iterator<E>                           | -           |\n| fields         | 🔒MIN_ARRAY_SORT_GRAN                                         | int         |\n|                | 🔒INSERTIONSORT_THRESHOLD                                     | int         |\n| conductors     | Arrays()                                                     | Object      |\n| methods        | sort                                                         | void        |\n|                | parallelSort                                                 | void        |\n|                | rangeCheck                                                   | void        |\n|                | legacyMergeSort                                              | void        |\n|                | mergeSort                                                    | void        |\n|                | swap                                                         | void        |\n|                | parallelPrefix                                               | void        |\n|                | binarySearch                                                 | int         |\n|                | binarySearch0                                                | int         |\n|                | equals                                                       | boolean     |\n|                | fill                                                         | void        |\n|                | copyOf                                                       | T[]         |\n|                | copyOfRange                                                  | T[]         |\n|                | asList                                                       | List<T>     |\n|                | hashCode                                                     | int         |\n|                | deepHashCode                                                 | int         |\n|                | primitiveArrayHashCode                                       | int         |\n|                | deepEquals                                                   | boolean     |\n|                | deepEquals0                                                  | boolean     |\n|                | toString                                                     | String      |\n|                | deepToString                                                 | String/void |\n|                | setAll                                                       | void        |\n|                | parallelSetAll                                               | void        |\n|                | Spliterator                                                  | <T>         |\n|                | Stream                                                       | Stream<T>   |\n|                | compare                                                      | int         |\n|                | compareUnsigned                                              | int         |\n|                | mismatch                                                     | int         |\n\n# 内部类\n","categories":["important classes"]},{"title":"🟡103.binary tree zigzag level order traversal","url":"/2024/02/16/coding-103-binary-tree-zigzag-level-order-traversal/","content":"\n# Description\n\n> 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[3],[20,9],[15,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n# Solution\n\n```java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            List<Integer>list=new ArrayList<>();\n            while (size-->0){\n                TreeNode node=queue.poll();\n                list.add(node.val);\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            if(res.size()%2==1){\n                Collections.reverse(list);\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS"]},{"title":"🟡107.binary tree level order traversalii","url":"/2024/02/15/coding-107-binary-tree-level-order-traversal-ii/","content":"\n# Description\n\n> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[15,7],[9,20],[3]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-1000 <= Node.val <= 1000`\n\n# Solution\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }        \n        Queue<TreeNode>queue=new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int size=queue.size();\n            List<Integer>list=new ArrayList<>();\n            while(size-->0){\n                TreeNode node=queue.poll();\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n                list.add(node.val);\n            }\n            res.add(list);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS"]},{"title":"🟡102.binary tree level order traversal","url":"/2024/02/14/coding-102-binary-tree-level-order-traversal/","content":"\n# Description\n\n> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[3],[9,20],[15,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-1000 <= Node.val <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n# Solution\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            List<Integer>list=new ArrayList<>();\n            while (size-->0){\n                TreeNode node=queue.poll();\n                list.add(node.val);\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS"]},{"title":"🔹384th LeetCode Weekly Contest","url":"/2024/02/12/contest-weekly-384/","content":"\n|      | score | problem                      | tag                                              |\n| ---- | ----- | ---------------------------- | ------------------------------------------------ |\n| ✅    | 2     | 🟢修改矩阵                    | arrary matrix                                    |\n| ✅    | 4     | 🟡匹配模式数组的子数组数目 I  | arrary string-matching hash-fuction rolling-hash |\n|      | 5     | 🟡回文字符串的最大数量        | arrary string sorting counting hashtable greedy  |\n|      | 6     | 🔴匹配模式数组的子数组数目 II | arrary string-matching hash-fuction rolling-hash |\n\n# 🟢修改矩阵\n\n> 给你一个下标从 **0** 开始、大小为 `m x n` 的整数矩阵 `matrix` ，新建一个下标从 **0** 开始、名为 `answer` 的矩阵。使 `answer` 与 `matrix` 相等，接着将其中每个值为 `-1` 的元素替换为所在列的 **最大** 元素。\n>\n> 返回矩阵 `answer` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/24/matrix1.png)\n>\n> ```\n> 输入：matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n> 输出：[[1,2,9],[4,8,6],[7,8,9]]\n> 解释：上图显示了发生替换的元素（蓝色区域）。\n> - 将单元格 [1][1] 中的值替换为列 1 中的最大值 8 。\n> - 将单元格 [0][2] 中的值替换为列 2 中的最大值 9 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/24/matrix2.png)\n>\n> ```\n> 输入：matrix = [[3,-1],[5,2]]\n> 输出：[[3,2],[5,2]]\n> 解释：上图显示了发生替换的元素（蓝色区域）。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `2 <= m, n <= 50`\n> - `-1 <= matrix[i][j] <= 100`\n> - 测试用例中生成的输入满足每列至少包含一个非负整数。\n\n```java\nclass Solution {\n    public int[][] modifiedMatrix(int[][] matrix) {\n        int n=matrix.length;\n        int m=matrix[0].length;\n        int[]max=new int[m];\n        for(int j=0;j<m;j++){\n            for(int i=0;i<n;i++){\n                max[j]=Math.max(max[j],matrix[i][j]);\n            }\n        }\n        for(int j=0;j<m;j++){\n            for(int i=0;i<n;i++){\n                if(matrix[i][j]==-1){\n                    matrix[i][j]=max[j];\n                }\n            }\n        }\n        return matrix;\n    }\n}\n```\n\n- time：*O(m·n)*\n- space：*O(m)*\n\n# 🟡匹配模式数组的子数组数目 I\n\n> 给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` ，和一个下标从 `0` 开始长度为 `m` 的整数数组 `pattern` ，`pattern` 数组只包含整数 `-1` ，`0` 和 `1` 。\n>\n> 大小为 `m + 1` 的\n>\n> 子数组\n>\n> `nums[i..j]` 如果对于每个元素 `pattern[k]` 都满足以下条件，那么我们说这个子数组匹配模式数组 `pattern` ：\n>\n> \n>\n> - 如果 `pattern[k] == 1` ，那么 `nums[i + k + 1] > nums[i + k]`\n> - 如果 `pattern[k] == 0` ，那么 `nums[i + k + 1] == nums[i + k]`\n> - 如果 `pattern[k] == -1` ，那么 `nums[i + k + 1] < nums[i + k]`\n>\n> 请你返回匹配 `pattern` 的 `nums` 子数组的 **数目** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5,6], pattern = [1,1]\n> 输出：4\n> 解释：模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。\n> 所以 nums 中总共有 4 个子数组匹配这个模式。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n> 输出：2\n> 解释：这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。\n> 所以 nums 中总共有 2 个子数组匹配这个模式。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n == nums.length <= 100`\n> - `1 <= nums[i] <= 109`\n> - `1 <= m == pattern.length < n`\n> - `-1 <= pattern[i] <= 1`\n\n```java\nclass Solution {\n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n        int n=nums.length,m=pattern.length;\n        int cnt=0;\n        for(int i=0;i<n-m;i++){\n            int temp=0;\n            for(int j=0;j<m;j++){\n                if(Integer.compare(nums[i+j+1],nums[i+j])==pattern[j]){\n                    temp++;\n                }else {\n                    break;\n                }\n            }\n            if(temp==m){\n                cnt++;\n            }            \n        }\n        return cnt;\n    }\n}\n```\n\n- time：*O(m·n)*\n- space：*O(1)*\n\n# 🟡回文字符串的最大数量\n\n> 给你一个下标从 **0** 开始的字符串数组 `words` ，数组的长度为 `n` ，且包含下标从 **0** 开始的若干字符串。\n>\n> 你可以执行以下操作 **任意** 次数（**包括零次**）：\n>\n> - 选择整数`i`、`j`、`x`和`y`，满足`0 <= i, j < n`，`0 <= x < words[i].length`，`0 <= y < words[j].length`，**交换** 字符 `words[i][x]` 和 `words[j][y]` 。\n>\n> 返回一个整数，表示在执行一些操作后，`words` 中可以包含的回文字符串的 **最大** 数量。\n>\n> **注意：**在操作过程中，`i` 和 `j` 可以相等。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：words = [\"abbb\",\"ba\",\"aa\"]\n> 输出：3\n> 解释：在这个例子中，获得最多回文字符串的一种方式是：\n> 选择 i = 0, j = 1, x = 0, y = 0，交换 words[0][0] 和 words[1][0] 。words 变成了 [\"bbbb\",\"aa\",\"aa\"] 。\n> words 中的所有字符串都是回文。\n> 因此，可实现的回文字符串的最大数量是 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words = [\"abc\",\"ab\"]\n> 输出：2\n> 解释：在这个例子中，获得最多回文字符串的一种方式是： \n> 选择 i = 0, j = 1, x = 1, y = 0，交换 words[0][1] 和 words[1][0] 。words 变成了 [\"aac\",\"bb\"] 。\n> 选择 i = 0, j = 0, x = 1, y = 2，交换 words[0][1] 和 words[0][2] 。words 变成了 [\"aca\",\"bb\"] 。\n> 两个字符串都是回文 。\n> 因此，可实现的回文字符串的最大数量是 2。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words = [\"cd\",\"ef\",\"a\"]\n> 输出：1\n> 解释：在这个例子中，没有必要执行任何操作。\n> words 中有一个回文 \"a\" 。\n> 可以证明，在执行任何次数操作后，无法得到更多回文。\n> 因此，答案是 1 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= words.length <= 1000`\n> - `1 <= words[i].length <= 100`\n> - `words[i]` 仅由小写英文字母组成。\n\n```java\n\n```\n\n# 🔴匹配模式数组的子数组数目 II\n\n> 给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` ，和一个下标从 `0` 开始长度为 `m` 的整数数组 `pattern` ，`pattern` 数组只包含整数 `-1` ，`0` 和 `1` 。\n>\n> 大小为 `m + 1` 的\n>\n> 子数组\n>\n> `nums[i..j]` 如果对于每个元素 `pattern[k]` 都满足以下条件，那么我们说这个子数组匹配模式数组 `pattern` ：\n>\n> \n>\n> - 如果 `pattern[k] == 1` ，那么 `nums[i + k + 1] > nums[i + k]`\n> - 如果 `pattern[k] == 0` ，那么 `nums[i + k + 1] == nums[i + k]`\n> - 如果 `pattern[k] == -1` ，那么 `nums[i + k + 1] < nums[i + k]`\n>\n> 请你返回匹配 `pattern` 的 `nums` 子数组的 **数目** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5,6], pattern = [1,1]\n> 输出：4\n> 解释：模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。\n> 所以 nums 中总共有 4 个子数组匹配这个模式。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n> 输出：2\n> 解释：这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。\n> 所以 nums 中总共有 2 个子数组匹配这个模式。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n == nums.length <= 106`\n> - `1 <= nums[i] <= 109`\n> - `1 <= m == pattern.length < n`\n> - `-1 <= pattern[i] <= 1`\n\n```java\n\n```\n\n","tags":["contest"]},{"title":"🟢145.binary tree postorder traversal","url":"/2024/02/12/coding-145-binary-tree-postorder-traversal/","content":"\n# Description\n\n> 给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        postOrder(res,root);\n        return res;\n    }\n    void postOrder(List<Integer> res,TreeNode root){\n        if(root==null){\n            return;\n        }\n        postOrder(res,root.left);\n        postOrder(res,root.right);\n        res.add(root.val);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n# Solution(Iteration)\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null){\n            s.push(root);\n        }\n        while(!s.empty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();                \n                s.push(node);\n                s.push(null);\n                if(node.right!=null){\n                    s.push(node.right);\n                }                \n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.peek();\n                s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS","algorithm-Stack"]},{"title":"🟢144.binary tree preorder traversal","url":"/2024/02/11/coding-144-binary-tree-preorder-traversal/","content":"\n# Description\n\n> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[1,2,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> **示例 4：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)\n>\n> ```\n> 输入：root = [1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 5：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)\n>\n> ```\n> 输入：root = [1,null,2]\n> 输出：[1,2]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n>  \n>\n> **进阶：**递归算法很简单，你可以通过迭代算法完成吗？\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        preOrder(res,root);\n        return res;        \n    }\n    void preOrder(List<Integer> list,TreeNode root){\n        if(root==null){\n            return;\n        }\n        list.add(root.val);\n        preOrder(list,root.left);\n        preOrder(list,root.right);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n# Solution(Iteration)\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null)s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n                s.push(node);\n                s.push(null);\n            }else{\n                s.pop();\n                node=s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS","algorithm-Stack"]},{"title":"🟢94.binary tree inorder traversal","url":"/2024/02/10/coding-94-binary-tree-inorder-traversal/","content":"\n# Description\n\n> 给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[1,3,2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶:** 递归算法很简单，你可以通过迭代算法完成吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n# Solution\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        inOrder(res,root);\n        return res;\n    }\n    void inOrder(List<Integer>list,TreeNode root){\n        if(root==null){\n            return;\n        }\n        inOrder(list,root.left);\n        list.add(root.val);\n        inOrder(list,root.right);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null){\n            s.push(root);\n        }\n        while(!s.empty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                s.push(node);\n                s.push(null);\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.peek();\n                s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS","algorithm-Stack"]},{"title":"🟡236.lowest common ancestor of a binary tree","url":"/2024/02/09/coding-236-lowest-common-ancestor-of-a-binary-tree/","content":"\n# Description\n\n> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n> 输出：3\n> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n> 输出：5\n> 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1,2], p = 1, q = 2\n> 输出：1\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[2, 105]` 内。\n> - `-109 <= Node.val <= 109`\n> - 所有 `Node.val` `互不相同` 。\n> - `p != q`\n> - `p` 和 `q` 均存在于给定的二叉树中。\n\n# Solution(Back Traking)\n\n```java\nclass Solution {\n\n    static LinkedList<TreeNode> l=new LinkedList<>();\n    static LinkedList<TreeNode> l1,l2;\n    static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        l.add(root);\n        backTracking(root,p,0);\n        backTracking(root,q,1);\n        int index=0;\n        while(index< l1.size()\n                &&index<l2.size()\n                &&l1.get(index)==l2.get(index)){\n            index++;\n        }\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            if(node==l1.get(index-1)){\n                return node;\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n        }\n        return root;\n    }\n    static void backTracking(TreeNode root, TreeNode node,int num){\n        if(root==node){\n            if(num==0){\n                l1= (LinkedList) l.clone();\n            }else{\n                l2= (LinkedList) l.clone();\n            }\n            return;\n        }\n        if(root.left!=null){\n            l.add(root.left);\n            backTracking(root.left,node,num);\n            l.removeLast();\n        }\n        if(root.right!=null){\n            l.add(root.right);\n            backTracking(root.right,node,num);\n            l.removeLast();\n        }\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(n)*\n\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q){\n\t\t\treturn root;\n        }            \n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left != null && right != null){\n        \treturn root;\n        }else{\n\t\t\treturn left != null ? left : right;\n        }        \n   \n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-DFS"]},{"title":"🟢993.cousins in binary tree","url":"/2024/02/08/coding-993-cousins-in-binary-tree/","content":"\n# Description\n\n> 在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。\n>\n> 如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。\n>\n> 我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。\n>\n> 只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。\n>\n> \n>\n> **示例 1：\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png)**\n>\n> ```\n> 输入：root = [1,2,3,4], x = 4, y = 3\n> 输出：false\n> ```\n>\n> **示例 2：\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png)**\n>\n> ```\n> 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png)**\n>\n> ```\n> 输入：root = [1,2,3,null,4], x = 2, y = 3\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 二叉树的节点数介于 `2` 到 `100` 之间。\n> - 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n# Solution\n\n```java\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\nclass Solution {\n    public boolean isCousins(TreeNode root, int x, int y) {\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size= queue.size();\n            Set<Integer> hashSet=new HashSet<>();\n            while (size-->0){\n                TreeNode node=queue.poll();\n                hashSet.add(node.val);\n                Set<Integer>set=new HashSet<>();\n                if(node.left!=null){\n                    set.add(node.left.val);\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    set.add(node.right.val);\n                    queue.offer(node.right);\n                }\n                if(set.contains(x)&&set.contains(y)){\n                    return false;\n                }\n            }\n            if(hashSet.contains(x)&&hashSet.contains(y)){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS","algorithm-DFS"]},{"title":"🟡2641. cousins in binary tree ii","url":"/2024/02/07/coding-2641-cousins-in-binary-tree-ii/","content":"\n# Description\n\n> 给你一棵二叉树的根 `root` ，请你将每个节点的值替换成该节点的所有 **堂兄弟节点值的和** 。\n>\n> 如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 **堂兄弟** 。\n>\n> 请你返回修改值之后，树的根 `root` 。\n>\n> **注意**，一个节点的深度指的是从树根节点到这个节点经过的边数。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/01/11/example11.png)\n>\n> ```\n> 输入：root = [5,4,9,1,10,null,7]\n> 输出：[0,0,0,7,7,null,11]\n> 解释：上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n> - 值为 5 的节点没有堂兄弟，所以值修改为 0 。\n> - 值为 4 的节点没有堂兄弟，所以值修改为 0 。\n> - 值为 9 的节点没有堂兄弟，所以值修改为 0 。\n> - 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n> - 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n> - 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/01/11/diagram33.png)\n>\n> ```\n> 输入：root = [3,1,2]\n> 输出：[0,0,0]\n> 解释：上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n> - 值为 3 的节点没有堂兄弟，所以值修改为 0 。\n> - 值为 1 的节点没有堂兄弟，所以值修改为 0 。\n> - 值为 2 的节点没有堂兄弟，所以值修改为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目的范围是 `[1, 105]` 。\n> - `1 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 哈希表\n>\n> 二叉树\n\n# Solution\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public TreeNode replaceValueInTree(TreeNode root) {\n        root.val=0;\n        List<TreeNode> queue=List.of(root);\n        while (!queue.isEmpty()){\n            List<TreeNode>temp=queue;\n            queue=new ArrayList<>();\n            int sum=0;\n            for (TreeNode node:temp) {\n                if(node.left!=null){\n                    sum+=node.left.val;\n                    queue.add(node.left);\n                }\n                if(node.right!=null){\n                    sum+=node.right.val;\n                    queue.add(node.right);\n                }\n            }\n            for (TreeNode node:temp){\n                int childsum=(node.left==null?0:node.left.val)+(node.right==null?0:node.right.val);\n                if(node.left!=null){\n                    node.left.val=sum-childsum;\n                }\n                if(node.right!=null){\n                    node.right.val=sum-childsum;\n                }\n            }\n        }\n        return root;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Tree","algorithm-BiTree","algorithm-BFS","algorithm-DFS","algorithm-HashTable"]},{"title":"🟡lcp 30.magic tower game","url":"/2024/02/06/coding-lcp-30-magic-tower-game/","content":"\n# Description\n\n> 小扣当前位于魔塔游戏第一层，共有 `N` 个房间，编号为 `0 ~ N-1`。每个房间的补血道具/怪物对于血量影响记于数组 `nums`，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；`0` 表示房间对血量无影响。\n>\n> **小扣初始血量为 1，且无上限**。假定小扣原计划按房间编号升序访问所有房间补血/打怪，**为保证血量始终为正值**，小扣需对房间访问顺序进行调整，**每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾**。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。\n>\n> **示例 1：**\n>\n> > 输入：`nums = [100,100,100,-250,-60,-140,-50,-50,100,150]`\n> >\n> > 输出：`1`\n> >\n> > 解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。\n>\n> **示例 2：**\n>\n> > 输入：`nums = [-200,-300,400,0]`\n> >\n> > 输出：`-1`\n> >\n> > 解释：调整访问顺序也无法完成全部房间的访问。\n>\n> **提示：**\n>\n> - `1 <= nums.length <= 10^5`\n> - `-10^5 <= nums[i] <= 10^5`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 堆（优先队列）\n\n# Solution\n\n```java\nclass Solution {\n    public int magicTower(int[] nums) {\n        int cnt=0;\n        long sum=1,delay=0;\n        Queue<Integer> heap=new PriorityQueue<>() ;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<0){\n                heap.offer(nums[i]);\n            }\n            sum+=nums[i];\n            if(sum<=0){\n                cnt++;\n                int cur=heap.poll();\n                delay+=cur;\n                sum-=cur;// sum减掉此前加过的最小负数\n            }\n        }\n        sum+=delay; // 最后一个数别无选择\n        return sum>0?cnt:-1;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Array","algorithm-Greedy","algorithm-Heap(Priority Queue)"]},{"title":"🔹383th LeetCode Weekly Contest","url":"/2024/02/04/contest-weekly-383/","content":"\n|      | score | problem                              | tag                                               |\n| ---- | ----- | ------------------------------------ | ------------------------------------------------- |\n| ✅    | 3     | 🟢边界上的蚂蚁                        | array prefix-sum simulation                       |\n|      | 4     | 🟡将单词恢复初始状态所需的最短时间 I  | string rolling-hash hash-function string-matching |\n|      | 5     | 🟡找出网格的区域平均强度              | array matrix                                      |\n|      | 6     | 🔴将单词恢复初始状态所需的最短时间 II | string rolling-hash hash-function string-matching |\n\n# 🟢边界上的蚂蚁\n\n> 边界上有一只蚂蚁，它有时向 **左** 走，有时向 **右** 走。\n>\n> 给你一个 **非零** 整数数组 `nums` 。蚂蚁会按顺序读取 `nums` 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n>\n> - 如果 `nums[i] < 0` ，向 **左** 移动 `-nums[i]`单位。\n> - 如果 `nums[i] > 0` ，向 **右** 移动 `nums[i]`单位。\n>\n> 返回蚂蚁 **返回** 到边界上的次数。\n>\n> **注意：**\n>\n> - 边界两侧有无限的空间。\n> - 只有在蚂蚁移动了 `|nums[i]|` 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,3,-5]\n> 输出：1\n> 解释：第 1 步后，蚂蚁距边界右侧 2 单位远。\n> 第 2 步后，蚂蚁距边界右侧 5 单位远。\n> 第 3 步后，蚂蚁位于边界上。\n> 所以答案是 1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,-3,-4]\n> 输出：0\n> 解释：第 1 步后，蚂蚁距边界右侧 3 单位远。\n> 第 2 步后，蚂蚁距边界右侧 5 单位远。\n> 第 3 步后，蚂蚁距边界右侧 2 单位远。\n> 第 4 步后，蚂蚁距边界左侧 2 单位远。\n> 蚂蚁从未返回到边界上，所以答案是 0 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `-10 <= nums[i] <= 10`\n> - `nums[i] != 0`\n\n```java\nclass Solution {\n    public int returnToBoundaryCount(int[] nums) {\n        int cnt=0,sum=0;\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n            if(sum==0){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time：*O(n)*\n- space：*O(1)*\n\n# 🟡将单词恢复初始状态所需的最短时间 I\n\n> 给你一个下标从 **0** 开始的字符串 `word` 和一个整数 `k` 。\n>\n> 在每一秒，你必须执行以下操作：\n>\n> - 移除 `word` 的前 `k` 个字符。\n> - 在 `word` 的末尾添加 `k` 个任意字符。\n>\n> **注意** 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 **两种** 操作。\n>\n> 返回将 `word` 恢复到其 **初始** 状态所需的 **最短** 时间（该时间必须大于零）。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：word = \"abacaba\", k = 3\n> 输出：2\n> 解释：\n> 第 1 秒，移除 word 的前缀 \"aba\"，并在末尾添加 \"bac\" 。因此，word 变为 \"cababac\"。\n> 第 2 秒，移除 word 的前缀 \"cab\"，并在末尾添加 \"aba\" 。因此，word 变为 \"abacaba\" 并恢复到始状态。\n> 可以证明，2 秒是 word 恢复到其初始状态所需的最短时间。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：word = \"abacaba\", k = 4\n> 输出：1\n> 解释：\n> 第 1 秒，移除 word 的前缀 \"abac\"，并在末尾添加 \"caba\" 。因此，word 变为 \"abacaba\" 并恢复到初始状态。\n> 可以证明，1 秒是 word 恢复到其初始状态所需的最短时间。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：word = \"abcbabcd\", k = 2\n> 输出：4\n> 解释：\n> 每一秒，我们都移除 word 的前 2 个字符，并在 word 末尾添加相同的字符。\n> 4 秒后，word 变为 \"abcbabcd\" 并恢复到初始状态。\n> 可以证明，4 秒是 word 恢复到其初始状态所需的最短时间。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= word.length <= 50`\n> - `1 <= k <= word.length`\n> - `word`仅由小写英文字母组成。\n\n```java\n```\n\n\n\n# 🟡找出网格的区域平均强度\n\n> 给你一个下标从 **0** 开始、大小为 `m x n` 的网格 `image` ，表示一个灰度图像，其中 `image[i][j]` 表示在范围 `[0..255]` 内的某个像素强度。另给你一个 **非负** 整数 `threshold` 。\n>\n> 如果 `image[a][b]` 和 `image[c][d]` 满足 `|a - c| + |b - d| == 1` ，则称这两个像素是 **相邻像素** 。\n>\n> **区域** 是一个 `3 x 3` 的子网格，且满足区域中任意两个 **相邻** 像素之间，像素强度的 **绝对差** **小于或等于** `threshold` 。\n>\n> **区域** 内的所有像素都认为属于该区域，而一个像素 **可以** 属于 **多个** 区域。\n>\n> 你需要计算一个下标从 **0** 开始、大小为 `m x n` 的网格 `result` ，其中 `result[i][j]` 是 `image[i][j]` 所属区域的 **平均** 强度，**向下取整** 到最接近的整数。如果 `image[i][j]` 属于多个区域，`result[i][j]` 是这些区域的 **“取整后的平均强度”** 的 **平均值**，也 **向下取整** 到最接近的整数。如果 `image[i][j]` 不属于任何区域，则 `result[i][j]` **等于** `image[i][j]` 。\n>\n> 返回网格 `result` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/21/example0corrected.png)\n>\n> ```\n> 输入：image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n> 输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]\n> 解释：图像中存在两个区域，如图片中的阴影区域所示。第一个区域的平均强度为 9 ，而第二个区域的平均强度为 9.67 ，向下取整为 9 。两个区域的平均强度为 (9 + 9) / 2 = 9 。由于所有像素都属于区域 1 、区域 2 或两者，因此 result 中每个像素的强度都为 9 。\n> 注意，在计算多个区域的平均值时使用了向下取整的值，因此使用区域 2 的平均强度 9 来进行计算，而不是 9.67 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/21/example1corrected.png)\n>\n> ```\n> 输入：image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n> 输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n> 解释：图像中存在两个区域，如图片中的阴影区域所示。第一个区域的平均强度为 25 ，而第二个区域的平均强度为 30 。两个区域的平均强度为 (25 + 30) / 2 = 27.5 ，向下取整为 27 。图像中第 0 行的所有像素属于区域 1 ，因此 result 中第 0 行的所有像素为 25 。同理，result 中第 3 行的所有像素为 30 。图像中第 1 行和第 2 行的像素属于区域 1 和区域 2 ，因此它们在 result 中的值为 27 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1\n> 输出：[[5,6,7],[8,9,10],[11,12,13]]\n> 解释：图像中不存在任何区域，因此对于所有像素，result[i][j] == image[i][j] 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `3 <= n, m <= 500`\n> - `0 <= image[i][j] <= 255`\n> - `0 <= threshold <= 255`\n\n```java\n```\n\n# 🔴将单词恢复初始状态所需的最短时间 II\n\n> 给你一个下标从 **0** 开始的字符串 `word` 和一个整数 `k` 。\n>\n> 在每一秒，你必须执行以下操作：\n>\n> - 移除 `word` 的前 `k` 个字符。\n> - 在 `word` 的末尾添加 `k` 个任意字符。\n>\n> **注意** 添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 **两种** 操作。\n>\n> 返回将 `word` 恢复到其 **初始** 状态所需的 **最短** 时间（该时间必须大于零）。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：word = \"abacaba\", k = 3\n> 输出：2\n> 解释：\n> 第 1 秒，移除 word 的前缀 \"aba\"，并在末尾添加 \"bac\" 。因此，word 变为 \"cababac\"。\n> 第 2 秒，移除 word 的前缀 \"cab\"，并在末尾添加 \"aba\" 。因此，word 变为 \"abacaba\" 并恢复到始状态。\n> 可以证明，2 秒是 word 恢复到其初始状态所需的最短时间。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：word = \"abacaba\", k = 4\n> 输出：1\n> 解释：\n> 第 1 秒，移除 word 的前缀 \"abac\"，并在末尾添加 \"caba\" 。因此，word 变为 \"abacaba\" 并恢复到初始状态。\n> 可以证明，1 秒是 word 恢复到其初始状态所需的最短时间。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：word = \"abcbabcd\", k = 2\n> 输出：4\n> 解释：\n> 每一秒，我们都移除 word 的前 2 个字符，并在 word 末尾添加相同的字符。\n> 4 秒后，word 变为 \"abcbabcd\" 并恢复到初始状态。\n> 可以证明，4 秒是 word 恢复到其初始状态所需的最短时间。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= word.length <= 105 `\n> - `1 <= k <= word.length`\n> - `word`仅由小写英文字母组成。\n\n```java\n```\n\n","tags":["contest"]},{"title":"🟢292. nim game","url":"/2024/02/04/coding-292-nim-game/","content":"\n# Description\n\n> 你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim游戏/6737105)：\n>\n> - 桌子上有一堆石头。\n> - 你们轮流进行自己的回合， **你作为先手** 。\n> - 每一回合，轮到的人拿掉 1 - 3 块石头。\n> - 拿掉最后一块石头的人就是获胜者。\n>\n> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 4\n> 输出：false \n> 解释：以下是可能的结果:\n> 1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。\n> 2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。\n> 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。\n> 在所有结果中，你的朋友是赢家。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：n = 2\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 231 - 1`\n>\n> Related Topics\n>\n> 脑筋急转弯\n>\n> 数学\n>\n> 博弈\n\n# Solution\n\n```java\nclass Solution {\n    public boolean canWinNim(int n) {\n        return n%4!=0;\n    }\n}\n```\n\n- time:*O(1)*\n- space:*O(1)*\n","tags":["algorithm-Math","algorithm-Brain Teaser","algorithm-Game Theory"]},{"title":"🔸123th LeetCode Biweekly Contest","url":"/2024/02/03/contest-biweekly-123/","content":"\n|      | score | problem              | tag                              |\n| ---- | ----- | -------------------- | -------------------------------- |\n| ✅    | 3     | 🟢三角形类型 II       | math array sorting               |\n|      | 4     | 🟡人员站位的方案数 I  | geometry array math enum sorting |\n|      | 5     | 🟡最大好子数组和      | array math prefix-sum            |\n|      | 7     | 🔴人员站位的方案数 II | geometry array math enum sorting |\n\n# 🟢三角形类型 II\n\n> 给你一个下标从 **0** 开始长度为 `3` 的整数数组 `nums` ，需要用它们来构造三角形。\n>\n> - 如果一个三角形的所有边长度相等，那么这个三角形称为 **equilateral** 。\n> - 如果一个三角形恰好有两条边长度相等，那么这个三角形称为 **isosceles** 。\n> - 如果一个三角形三条边的长度互不相同，那么这个三角形称为 **scalene** 。\n>\n> 如果这个数组无法构成一个三角形，请你返回字符串 `\"none\"` ，否则返回一个字符串表示这个三角形的类型。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,3,3]\n> 输出：\"equilateral\"\n> 解释：由于三条边长度相等，所以可以构成一个等边三角形，返回 \"equilateral\" 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,4,5]\n> 输出：\"scalene\"\n> 解释：\n> nums[0] + nums[1] = 3 + 4 = 7 ，大于 nums[2] = 5 。\n> nums[0] + nums[2] = 3 + 5 = 8 ，大于 nums[1] = 4 。\n> nums[1] + nums[2] = 4 + 5 = 9 ，大于 nums[0] = 3 。\n> 由于任意两边纸盒都大于第三边，所以可以构成一个三角形。\n> 因为三条边的长度互不相等，所以返回 \"scalene\" 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `nums.length == 3`\n> - `1 <= nums[i] <= 100`\n\n```java\nclass Solution {\n    public String triangleType(int[] nums) {\n        Arrays.sort(nums);\n        if(nums[0]+nums[1]<=nums[2]){\n            return \"none\";\n        }else if(nums[0]==nums[1]&&nums[1]==nums[2]){\n            return \"equilateral\";\n        }else if(nums[0]==nums[1]||nums[1]==nums[2]){\n            return \"isosceles\";\n        }else{\n            return \"scalene\";\n        }\n    }\n}\n```\n\n- time：*O(1)*\n- space：*O(1)*\n\n# 🟡人员站位的方案数 I\n\n> 给你一个 `n x 2` 的二维数组 `points` ，它表示二维平面上的一些点坐标，其中 `points[i] = [xi, yi]` 。\n>\n> 我们定义 x 轴的正方向为 **右** （**x 轴递增的方向**），x 轴的负方向为 **左** （**x 轴递减的方向**）。类似的，我们定义 y 轴的正方向为 **上** （**y 轴递增的方向**），y 轴的负方向为 **下** （**y 轴递减的方向**）。\n>\n> 你需要安排这 `n` 个人的站位，这 `n` 个人中包括 liupengsay 和小羊肖恩 。你需要确保每个点处 **恰好** 有 **一个** 人。同时，liupengsay 想跟小羊肖恩单独玩耍，所以 liupengsay 会以 liupengsay 的坐标为 **左上角** ，小羊肖恩的坐标为 **右下角** 建立一个矩形的围栏（**注意**，围栏可能 **不** 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 **内部** 或者 **边缘** 上有任何其他人，liupengsay 都会难过。\n>\n> 请你在确保 liupengsay **不会** 难过的前提下，返回 liupengsay 和小羊肖恩可以选择的 **点对** 数目。\n>\n> **注意**，liupengsay 建立的围栏必须确保 liupengsay 的位置是矩形的左上角，小羊肖恩的位置是矩形的右下角。比方说，以 `(1, 1)` ，`(1, 3)` ，`(3, 1)` 和 `(3, 3)` 为矩形的四个角，给定下图的两个输入，liupengsay 都不能建立围栏，原因如下：\n>\n> - 图一中，liupengsay 在 `(3, 3)` 且小羊肖恩在 `(1, 1)` ，liupengsay 的位置不是左上角且小羊肖恩的位置不是右下角。\n> - 图二中，liupengsay 在 `(1, 3)` 且小羊肖恩在 `(1, 1)` ，小羊肖恩的位置不是在围栏的右下角。\n>\n> ![img](https://assets.leetcode.com/uploads/2024/01/04/example0alicebob-1.png)\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png)\n>\n> ```\n> 输入：points = [[1,1],[2,2],[3,3]]\n> 输出：0\n> 解释：没有办法可以让 liupengsay 的围栏以 liupengsay 的位置为左上角且小羊肖恩的位置为右下角。所以我们返回 0 。\n> ```\n>\n> **示例 2：**\n>\n> **[![img](https://pic.leetcode.cn/1706880313-YelabI-example2.jpeg)](https://pic.leetcode.cn/1706880313-YelabI-example2.jpeg)**\n>\n> ```\n> 输入：points = [[6,2],[4,4],[2,6]]\n> 输出：2\n> 解释：总共有 2 种方案安排 liupengsay 和小羊肖恩的位置，使得 liupengsay 不会难过：\n> - liupengsay 站在 (4, 4) ，小羊肖恩站在 (6, 2) 。\n> - liupengsay 站在 (2, 6) ，小羊肖恩站在 (4, 4) 。\n> 不能安排 liupengsay 站在 (2, 6) 且小羊肖恩站在 (6, 2) ，因为站在 (4, 4) 的人处于围栏内。\n> ```\n>\n> **示例 3：**\n>\n> **[![img](https://pic.leetcode.cn/1706880311-mtPGYC-example3.jpeg)](https://pic.leetcode.cn/1706880311-mtPGYC-example3.jpeg)**\n>\n> ```\n> 输入：points = [[3,1],[1,3],[1,1]]\n> 输出：2\n> 解释：总共有 2 种方案安排 liupengsay 和小羊肖恩的位置，使得 liupengsay 不会难过：\n> - liupengsay 站在 (1, 1) ，小羊肖恩站在 (3, 1) 。\n> - liupengsay 站在 (1, 3) ，小羊肖恩站在 (1, 1) 。\n> 不能安排 liupengsay 站在 (1, 3) 且小羊肖恩站在 (3, 1) ，因为站在 (1, 1) 的人处于围栏内。\n> 注意围栏是可以不包含任何面积的，上图中第一和第二个围栏都是合法的。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n <= 50`\n> - `points[i].length == 2`\n> - `0 <= points[i][0], points[i][1] <= 50`\n> - `points[i]` 点对两两不同。\n\n```java\n```\n\n\n\n# 🟡最大好子数组和\n\n> 给你一个长度为 `n` 的数组 `nums` 和一个 **正** 整数 `k` 。\n>\n> 如果 `nums` 的一个子数组中，第一个元素和最后一个元素 **差的绝对值恰好** 为 `k` ，我们称这个子数组为 **好** 的。换句话说，如果子数组 `nums[i..j]` 满足 `|nums[i] - nums[j]| == k` ，那么它是一个好子数组。\n>\n> 请你返回 `nums` 中 **好** 子数组的 **最大** 和，如果没有好子数组，返回 `0` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5,6], k = 1\n> 输出：11\n> 解释：好子数组中第一个元素和最后一个元素的差的绝对值必须为 1 。好子数组有 [1,2] ，[2,3] ，[3,4] ，[4,5] 和 [5,6] 。最大子数组和为 11 ，对应的子数组为 [5,6] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [-1,3,2,4,5], k = 3\n> 输出：11\n> 解释：好子数组中第一个元素和最后一个元素的差的绝对值必须为 3 。好子数组有 [-1,3,2] 和 [2,4,5] 。最大子数组和为 11 ，对应的子数组为 [2,4,5] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [-1,-2,-3,-4], k = 2\n> 输出：-6\n> 解释：好子数组中第一个元素和最后一个元素的差的绝对值必须为 2 。好子数组有 [-1,-2,-3] 和 [-2,-3,-4] 。最大子数组和为 -6 ，对应的子数组为 [-1,-2,-3] 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n> - `1 <= k <= 109`\n\n# 🔴 人员站位的方案数 II\n\n> 给你一个 `n x 2` 的二维数组 `points` ，它表示二维平面上的一些点坐标，其中 `points[i] = [xi, yi]` 。\n>\n> 我们定义 x 轴的正方向为 **右** （**x 轴递增的方向**），x 轴的负方向为 **左** （**x 轴递减的方向**）。类似的，我们定义 y 轴的正方向为 **上** （**y 轴递增的方向**），y 轴的负方向为 **下** （**y 轴递减的方向**）。\n>\n> 你需要安排这 `n` 个人的站位，这 `n` 个人中包括 liupengsay 和小羊肖恩 。你需要确保每个点处 **恰好** 有 **一个** 人。同时，liupengsay 想跟小羊肖恩单独玩耍，所以 liupengsay 会以 liupengsay 的坐标为 **左上角** ，小羊肖恩的坐标为 **右下角** 建立一个矩形的围栏（**注意**，围栏可能 **不** 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 **内部** 或者 **边缘** 上有任何其他人，liupengsay 都会难过。\n>\n> 请你在确保 liupengsay **不会** 难过的前提下，返回 liupengsay 和小羊肖恩可以选择的 **点对** 数目。\n>\n> **注意**，liupengsay 建立的围栏必须确保 liupengsay 的位置是矩形的左上角，小羊肖恩的位置是矩形的右下角。比方说，以 `(1, 1)` ，`(1, 3)` ，`(3, 1)` 和 `(3, 3)` 为矩形的四个角，给定下图的两个输入，liupengsay 都不能建立围栏，原因如下：\n>\n> - 图一中，liupengsay 在 `(3, 3)` 且小羊肖恩在 `(1, 1)` ，liupengsay 的位置不是左上角且小羊肖恩的位置不是右下角。\n> - 图二中，liupengsay 在 `(1, 3)` 且小羊肖恩在 `(1, 1)` ，小羊肖恩的位置不是在围栏的右下角。\n>\n> ![img](https://assets.leetcode.com/uploads/2024/01/04/example0alicebob-1.png)\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png)\n>\n> ```\n> 输入：points = [[1,1],[2,2],[3,3]]\n> 输出：0\n> 解释：没有办法可以让 liupengsay 的围栏以 liupengsay 的位置为左上角且小羊肖恩的位置为右下角。所以我们返回 0 。\n> ```\n>\n> **示例 2：**\n>\n> **[![img](https://pic.leetcode.cn/1706880313-YelabI-example2.jpeg)](https://pic.leetcode.cn/1706880313-YelabI-example2.jpeg)**\n>\n> ```\n> 输入：points = [[6,2],[4,4],[2,6]]\n> 输出：2\n> 解释：总共有 2 种方案安排 liupengsay 和小羊肖恩的位置，使得 liupengsay 不会难过：\n> - liupengsay 站在 (4, 4) ，小羊肖恩站在 (6, 2) 。\n> - liupengsay 站在 (2, 6) ，小羊肖恩站在 (4, 4) 。\n> 不能安排 liupengsay 站在 (2, 6) 且小羊肖恩站在 (6, 2) ，因为站在 (4, 4) 的人处于围栏内。\n> ```\n>\n> **示例 3：**\n>\n> **[![img](https://pic.leetcode.cn/1706880311-mtPGYC-example3.jpeg)](https://pic.leetcode.cn/1706880311-mtPGYC-example3.jpeg)**\n>\n> ```\n> 输入：points = [[3,1],[1,3],[1,1]]\n> 输出：2\n> 解释：总共有 2 种方案安排 liupengsay 和小羊肖恩的位置，使得 liupengsay 不会难过：\n> - liupengsay 站在 (1, 1) ，小羊肖恩站在 (3, 1) 。\n> - liupengsay 站在 (1, 3) ，小羊肖恩站在 (1, 1) 。\n> 不能安排 liupengsay 站在 (1, 3) 且小羊肖恩站在 (3, 1) ，因为站在 (1, 1) 的人处于围栏内。\n> 注意围栏是可以不包含任何面积的，上图中第一和第二个围栏都是合法的。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n <= 1000`\n> - `points[i].length == 2`\n> - `-109 <= points[i][0], points[i][1] <= 109`\n> - `points[i]` 点对两两不同。\n\n```java\n```\n\n","tags":["contest"]},{"title":"🟢590.n-ary-tree postorder traversal","url":"/2024/02/01/coding-590-n-ary-tree-postorder-traversal/","content":"\n# Description\n\n\n\n> 给定一个 n 叉树的根节点 `root` ，返回 *其节点值的 **后序遍历*** 。\n>\n> n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n>\n> ```\n> 输入：root = [1,null,3,2,4,null,5,6]\n> 输出：[5,6,3,2,4,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n>\n> ```\n> 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> 输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 节点总数在范围 `[0, 104]` 内\n> - `0 <= Node.val <= 104`\n> - n 叉树的高度小于或等于 `1000`\n>\n>  \n>\n> **进阶：**递归法很简单，你可以使用迭代法完成此题吗?\n\n# Solution(Recursion)\n\n```java\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }        \n        postOrder(res,root);\n        return res;\n\n    }\n    void postOrder(List<Integer> res,Node root) {\n        for(int i=0;i<root.children.size();i++){\n            postOrder(res,root.children.get(i));\n        }\n        res.add(root.val);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n","tags":["algorithm-Tree","algorithm-DFS","algorithm-Stack"]},{"title":"Divide & Conquer","url":"/2024/01/31/algorithm-divide&conquer/","content":"\n| 类型       | 题号                                            | 完成 |\n| ---------- | ----------------------------------------------- | ---- |\n| 分解问题   | 🟢169. 多数元素                                  | ✅    |\n|            | 🔴4. 寻找两个正序数组的中位数                    |      |\n|            | 🟢543. 二叉树的直径                              |      |\n| 解决子问题 | 🟢69. x 的平方根                                 |      |\n|            | 🟡53. 最大子数组和                               |      |\n|            | 🟡34. 在排序数组中查找元素的第一个和最后一个位置 |      |\n| 合并结果   | 🔴23. 合并 K 个升序链表                          |      |\n|            | 🟡1277. 统计全为 1 的正方形子矩阵                |      |\n\n#  分解问题\n\n## 🟢169. 多数元素\n\n> 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。\n>\n> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,2,3]\n> 输出：3\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,2,1,1,1,2,2]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 5 * 104`\n> - `-109 <= nums[i] <= 109`\n>\n> \n>\n> **进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 计数\n>\n> 排序\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        return majorityElementRec(nums, 0, nums.length - 1);\n    }\n    int majorityElementRec(int[] nums, int lo, int hi) {\n        if (lo == hi) {\n            return nums[lo];\n        }\n        int mid = (hi - lo) / 2 + lo;\n        int left = majorityElementRec(nums, lo, mid);\n        int right = majorityElementRec(nums, mid + 1, hi);\n\n        if (left == right) {\n            return left;\n        }\n        int leftCount = countInRange(nums, left, lo, hi);\n        int rightCount = countInRange(nums, right, lo, hi);\n        return leftCount > rightCount ? left : right;\n    }\n    int countInRange(int[] nums, int num, int lo, int hi) {\n        int count = 0;\n        for (int i = lo; i <= hi; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(log n)*\n\n## 🔴4. 寻找两个正序数组的中位数\n\n> 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。\n>\n> 算法的时间复杂度应该为 `O(log (m+n))` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,3], nums2 = [2]\n> 输出：2.00000\n> 解释：合并数组 = [1,2,3] ，中位数 2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [1,2], nums2 = [3,4]\n> 输出：2.50000\n> 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `nums1.length == m`\n> - `nums2.length == n`\n> - `0 <= m <= 1000`\n> - `0 <= n <= 1000`\n> - `1 <= m + n <= 2000`\n> - `-106 <= nums1[i], nums2[i] <= 106`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 分治\n\n```java\n```\n\n\n\n\n\n## 🟢543. 二叉树的直径\n\n#  解决子问题\n\n##  🟢69. x 的平方根\n\n## 🟡53. 最大子数组和\n\n## 🟡34. 在排序数组中查找元素的第一个和最后一个位置\n\n#  合并结果\n\n## 🔴23. 合并 K 个升序链表\n\n## 🟡1277. 统计全为 1 的正方形子矩阵\n\n","categories":["algorithm learning"]},{"title":"Sorting","url":"/2024/01/31/algorithm-sorting/","content":"\n# 十大内部排序算法\n\n| 排序算法                     | 适用的数据结构 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 排序方式  | 稳定性 |\n| ---------------------------- | -------------- | -------------- | -------------- | -------------- | ---------- | --------- | ------ |\n| [ 冒泡排序(Bubble sort)2)    | 数组           | O(n)           | O(n^2^)        | O(n^2^)        | O(1)       | In-place  | 稳定   |\n| [ 插入排序(Insertion sort)4) | 数组、链表     | O(n)           | O(n^2^)        | O(n^2^)        | O(1)       | In-place  | 稳定   |\n| [ 选择排序(Selection sort)6) | 数组、链表     | O(n^2^)        | O(n^2^)        | O(n^2^)        | O(1)       | In-place  | 不稳定 |\n| [ 快速排序(Quick sort)8)     | 数组           | O(n log n)     | O(n log n)     | O(n log n)     | O(n log n) | In-place  | 不稳定 |\n| [ 堆排序(Heap sort)10)       | 数组           | O(n log n)     | O(n log n)     | O(n log n)     | O(1)       | In-place  | 不稳定 |\n| [ 希尔排序(Shell sort)17)    | 数组           | O(n log n)     | O(n^2^)        | O(n log n)     | O(1)       | In-place  | 不稳定 |\n| [ 归并排序(Merge sort)19)    | 数组、链表     | O(n log n)     | O(n log n)     | O(n log n)     | O(n)       | Out-place | 稳定   |\n| [ 计数排序(Counting sort)23) | 数组、链表     | O(n+k)         | O(n+k)         | O(n+k)         | O(k)       | Out-place | 稳定   |\n| [ 桶排序(Bucket sort)26)     | 数组、链表     | O(n+k)         | O(n+k)         | O(n^2^)        | O(n+k)     | Out-place | 稳定   |\n| [ 基数排序(Radix sort)29)    | 数组、链表     | O(n×k)         | O(n×k)         | O(n×k)         | O(n+k)     | Out-place | 稳定   |\n\n*注：\n\n①n为数组长度或链表节点数，k为等待排序元素的最大位数\n\n②归并排序中内部使用到插入排序\n\n③基数排序中内部使用到计数排序或者桶排序\n\n④基数排序需要经过处理才可以对负数元素排序\n\n| 平均时间复杂度 | 排序算法                 | 题目                        |\n| -------------- | ------------------------ | --------------------------- |\n| O(n^2^)        | 冒泡排序(Bubble sort)    | 🟢283. 移动零                |\n|                | 插入排序(Insertion sort) | 🟡147. 对链表进行插入排序    |\n|                | 选择排序(Selection sort) | 🟡LCR 159. 库存管理 III      |\n| O(nlog n)      | 快速排序(Quick sort)     | 🟡912. 排序数组              |\n|                | 堆排序(Heap sort)        | 🟡912. 排序数组              |\n|                |                          | 🟡215. 数组中的第K个最大元素 |\n|                |                          | 🟡面试题 17.14. 最小K个数    |\n|                |                          | 🟡347. 前 K 个高频元素       |\n|                |                          | 🟡692. 前K个高频单词         |\n|                |                          | 🔴23. 合并 K 个升序链表      |\n|                | 希尔排序(Shell sort)     | 🟡912. 排序数组              |\n|                | 归并排序(Merge sort)     | 🟡912. 排序数组              |\n|                |                          | 🟡148. 排序链表              |\n|                |                          | 🔴23. 合并 K 个升序链表      |\n| O(n)           | 计数排序(Counting sort)  | 🟡912. 排序数组              |\n|                |                          | 🟡75. 颜色分类               |\n|                | 桶排序(Bucket sort)      | 🟡912. 排序数组              |\n|                |                          | 🟡148. 排序链表              |\n|                | 基数排序(Radix sort)     | 🟡912. 排序数组              |\n|                | 特别排序                 | 🟡179. 最大数                |\n\n#  冒泡排序\n\n## 🟢283. 移动零\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len= nums.length;\n        for (int i = 0; i < len-1; i++) {\n            for (int j = 1; j < len-i; j++) {\n                if(nums[j-1]==0){\n                    int temp=nums[j];\n                    nums[j]=nums[j-1];\n                    nums[j-1]=temp;\n                }\n            }\n        }\n    }\n}\n```\n\n- time:*O(n^2^)*\n\n- space:*O(1)*\n\n# 插入排序\n\n## 🟡147. 对链表进行插入排序\n\n> 给定单个链表的头 `head` ，使用 **插入排序** 对链表进行排序，并返回 *排序后链表的头* 。\n>\n> **插入排序** 算法的步骤:\n>\n> 1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n> 2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n> 3. 重复直到所有输入数据插入完为止。\n>\n> 下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。\n>\n> 对链表进行插入排序。\n>\n> ![img](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg)\n>\n> ```\n> 输入: head = [4,2,1,3]\n> 输出: [1,2,3,4]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg)\n>\n> ```\n> 输入: head = [-1,5,3,4,0]\n> 输出: [-1,0,3,4,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - 列表中的节点数在 `[1, 5000]`范围内\n> - `-5000 <= Node.val <= 5000`\n>\n> Related Topics\n>\n> 链表\n>\n> 排序\n\n```java\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        ListNode res=new ListNode(-6000);\n        ListNode ptr1=head;\n        ListNode ptr2=res,ptr3=ptr2;\n        while (ptr1!=null){\n            ptr2=res;\n            while (ptr2!=null&&ptr2.val<ptr1.val){\n                ptr3=ptr2;\n                ptr2=ptr2.next;\n            }\n            if(ptr3.next==null){\n                ptr3.next=new ListNode(ptr1.val);\n            }else{\n                ListNode temp=new ListNode(ptr1.val);\n                temp.next=ptr3.next;\n                ptr3.next=temp;\n            }\n            ptr1=ptr1.next;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n^2^)*\n\n- space:*O(1)*\n\n#  选择排序\n\n## 🟡LCR 159. 库存管理 III\n\n> 仓库管理员以数组 `stock` 形式记录商品库存表，其中 `stock[i]` 表示对应商品库存余量。请返回库存余量最少的 `cnt` 个商品余量，返回 **顺序不限**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：stock = [2,5,7,4], cnt = 1\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：stock = [0,2,3,6], cnt = 2\n> 输出：[0,2] 或 [2,0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= cnt <= stock.length <= 10000 0 <= stock[i] <= 10000`\n>\n> \n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 快速选择\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public int[] inventoryManagement(int[] stock, int cnt) {\n        int len=stock.length;\n        for (int i = 0; i < len; i++) {\n            for (int j = i+1; j < len; j++) {\n                if(stock[j]<stock[i]){\n                    int temp=stock[i];\n                    stock[i]=stock[j];\n                    stock[j]=temp;\n                }\n            }\n        }\n        int[]res=new int[cnt];\n        for (int i = 0; i < cnt; i++) {\n            res[i]=stock[i];\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^2^)*\n\n- space:*O(cnt)*\n\n#  快速排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution{\n    public int[]sortArray(int[]nums){\n        int len=nums.length;\n        quickSort(nums,0,len-1);\n        return nums;\n    }\n    public void quickSort(int[]nums,int left,int right){\n        if(left<right){\n            int i=left;\n            int j=right;\n            int base=nums[i];\n            while(i<j){\n                while(i<j&&nums[j]>base){\n                    j--;\n                }\n                if(i<j){\n                    nums[i++]=nums[j];\n                }\n                while(i<j&&nums[i]<base){\n                    i++;\n                }\n                if(i<j){\n                    nums[j--]=nums[i];\n                }\n            }\n            nums[i]=base;\n            quickSort(nums,left,i-1);\n            quickSort(nums,i+1,right);\n        }\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(1)*\n\n#  堆排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) { \n        int len= nums.length;\n        Queue<Integer>heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o1-o2;\n            }\n        });\n        for (int i = 0; i < len; i++) {\n            heap.offer(nums[i]);\n        }\n        for (int i = 0; i < len; i++) {\n            nums[i]=heap.poll();//推出堆顶元素算法复杂度为O(nlogn)\n        }\n        return nums;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n## 🟡215. 数组中的第K个最大元素\n\n> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n>\n> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n>\n> 你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: [3,2,1,5,6,4], k = 2\n> 输出: 5\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: [3,2,3,1,2,4,5,5,6], k = 4\n> 输出: 4\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= nums.length <= 105`\n> - `-104 <= nums[i] <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 快速选择\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int len= nums.length;\n        Queue<Integer>heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2-o1;\n            }\n        });\n        for (int i = 0; i < len; i++) {\n            heap.offer(nums[i]);\n        }\n        for (int i = 0; i < k-1; i++) {\n            heap.poll();\n        }\n        return heap.poll();\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n## 🟡面试题 17.14. 最小K个数\n\n> 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。\n>\n> **示例：**\n>\n> ```\n> 输入： arr = [1,3,5,7,2,4,6,8], k = 4\n> 输出： [1,2,3,4]\n> ```\n>\n> **提示：**\n>\n> - `0 <= len(arr) <= 100000`\n> - `0 <= k <= min(100000, len(arr))`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 快速选择\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public int[] smallestK(int[] arr, int k) {\n        int[]res=new int[k];\n        int len=arr.length;\n        if(k==0){\n            return res;\n        }\n        Queue<Integer> heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2-o1;//大的先排出去\n            }\n        });\n        for (int i = 0; i < len; i++) {\n            heap.offer(arr[i]);\n            if(heap.size()>k){\n                heap.poll();\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            res[i]=heap.poll();\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n## 🟡347. 前 K 个高频元素\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [1,1,1,2,2,3], k = 2\n> 输出: [1,2]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [1], k = 1\n> 输出: [1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`\n> - 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的\n>\n> \n>\n> **进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 桶排序\n>\n> 计数\n>\n> 快速选择\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        int len= nums.length;\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < len; i++) {\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\n        }\n        Queue<Integer>heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return map.get(o1)-map.get(o2);//队列先排出最小的\n            }\n        });\n        for (int key:map.keySet() ) {\n            heap.offer(key);\n            if(heap.size()>k){\n                heap.poll();\n            }\n        }\n        int[]res=new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i]=heap.poll();\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n## 🟡692. 前K个高频单词\n\n> 给定一个单词列表 `words` 和一个整数 `k` ，返回前 `k` 个出现次数最多的单词。\n>\n> 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， **按字典顺序** 排序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: words = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\n> 输出: [\"i\", \"love\"]\n> 解析: \"i\" 和 \"love\" 为出现次数最多的两个单词，均为2次。\n>     注意，按字母顺序 \"i\" 在 \"love\" 之前。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\n> 输出: [\"the\", \"is\", \"sunny\", \"day\"]\n> 解析: \"the\", \"is\", \"sunny\" 和 \"day\" 是出现次数最多的四个单词，\n>     出现次数依次为 4, 3, 2 和 1 次。\n> ```\n>\n> \n>\n> **注意：**\n>\n> - `1 <= words.length <= 500`\n> - `1 <= words[i] <= 10`\n> - `words[i]` 由小写英文字母组成。\n> - `k` 的取值范围是 `[1, **不同** words[i] 的数量]`\n>\n> \n>\n> **进阶：**尝试以 `O(n log k)` 时间复杂度和 `O(n)` 空间复杂度解决。\n>\n> Related Topics\n>\n> 字典树\n>\n> 哈希表\n>\n> 字符串\n>\n> 桶排序\n>\n> 计数\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        int len= words.length;\n        Map<String,Integer>map=new HashMap<>();\n        for (int i = 0; i < len; i++) {\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\n        }\n        System.out.println(map);\n        List<String>res=new ArrayList<>();\n        Queue<String>heap=new PriorityQueue<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                if(map.get(o1)==map.get(o2)){\n                    return o2.compareTo(o1);//字典序 大的先排出去\n                }else{\n                    return map.get(o1)-map.get(o2);//大小 小的先排出去\n                }\n            }\n        });\n        for (String key:map.keySet() ) {\n            heap.offer(key);\n            if(heap.size()>k){\n                heap.poll();\n            }\n        }\n        while (!heap.isEmpty()){\n            res.add(heap.poll());\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n## 🔴23. 合并 K 个升序链表\n\n> 给你一个链表数组，每个链表都已经按升序排列。\n>\n> 请你将所有链表合并到一个升序链表中，返回合并后的链表。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：lists = [[1,4,5],[1,3,4],[2,6]]\n> 输出：[1,1,2,3,4,4,5,6]\n> 解释：链表数组如下：\n> [\n>   1->4->5,\n>   1->3->4,\n>   2->6\n> ]\n> 将它们合并到一个有序链表中得到。\n> 1->1->2->3->4->4->5->6\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：lists = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：lists = [[]]\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `k == lists.length`\n> - `0 <= k <= 10^4`\n> - `0 <= lists[i].length <= 500`\n> - `-10^4 <= lists[i][j] <= 10^4`\n> - `lists[i]` 按 **升序** 排列\n> - `lists[i].length` 的总和不超过 `10^4`\n>\n> Related Topics\n>\n> 链表\n>\n> 分治\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        int len=lists.length;\n        if(len==0){\n            return null;\n        }\n        Queue<Integer>heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o1-o2;\n            }\n        });\n        for (int i = 0; i < len; i++) {\n            if(lists[i]==null){\n                continue;\n            }\n            ListNode ptr=lists[i];\n            while(ptr!=null){\n                heap.offer(ptr.val);\n                ptr=ptr.next;\n            }\n        }\n        if(!heap.isEmpty()){\n            ListNode res=new ListNode(heap.poll());\n            ListNode ptr=res;\n            while (!heap.isEmpty()){\n                ListNode node=new ListNode(heap.poll());\n                ptr.next=node;\n                ptr=ptr.next;\n            }\n            return res;\n        }else{\n            return null;\n        }\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n#  希尔排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution{\n    public int[] sortArray(int[] nums){\n        int len= nums.length;\n        for (int gap = len / 2; gap > 0; gap /= 2) {\n            // 共gap个组，对每一组都执行直接插入排序\n            for (int i = 0 ;i < gap; i++) {\n                for (int j = i + gap; j < len; j += gap) {\n                    // 如果nums[j] < nums[j-gap]，则寻找nums[j]位置，并将后面数据的位置都后移。\n                    if (nums[j] < nums[j - gap]) {\n                        int tmp = nums[j];\n                        int k = j - gap;\n                        while (k >= 0 && nums[k] > tmp) {\n                            nums[k + gap] = nums[k];\n                            k -= gap;\n                        }\n                        nums[k + gap] = tmp;\n                    }\n                }\n            }\n        }\n        return nums;\n    }\n}\n```\n\n- time:*O(nlogn~O(n^2^))*\n\n- space:*O(n)*\n\n#  归并排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution{\n    public int[] sortArray(int[] nums){\n        int len = nums.length;\n        mergeSort(nums,0,len-1);\n        return nums;\n    }\n    void mergeSort(int[] arr, int start, int end) {\n        //分治的结束条件\n        if (start >= end) {\n            return;\n        }\n        //保证不溢出取start和end的中位数\n        int mid = start + ((end - start) >> 1);\n        //递归排序并且合并\n        mergeSort(arr, start, mid);\n        mergeSort(arr, mid + 1, end);\n        merge(arr, start, mid, end);\n    }\n    void merge(int[] arr, int start, int mid, int end) {\n        int[] temp = new int[end - start + 1];\n        int p1 = start;\n        int p2 = mid + 1;\n        int p = 0;\n        while (p1 <= mid && p2 <= end) {\n            if (arr[p1] > arr[p2]) {\n                temp[p++] = arr[p2++];\n            } else {\n                temp[p++] = arr[p1++];\n            }\n        }\n        while (p1 <= mid) {\n            temp[p++] = arr[p1++];\n        }\n        while (p2 <= end) {\n            temp[p++] = arr[p2++];\n        }\n        for (int i = 0; i < temp.length; i++) {\n            arr[i + start] = temp[i];\n        }\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n## 🟡148. 排序链表\n\n> 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)\n>\n> ```\n> 输入：head = [4,2,1,3]\n> 输出：[1,2,3,4]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)\n>\n> ```\n> 输入：head = [-1,5,3,4,0]\n> 输出：[-1,0,3,4,5]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目在范围 `[0, 5 * 104]` 内\n> - `-105 <= Node.val <= 105`\n>\n> \n>\n> **进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n>\n> 分治\n>\n> 排序\n>\n> 归并排序\n\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode mid = getMiddle(head);\n        ListNode left = sortList(head);\n        ListNode right = sortList(mid);\n        return merge(left, right);\n    }\n    ListNode getMiddle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode mid = slow.next;\n        slow.next = null;\n        return mid;\n    }\n    ListNode merge(ListNode l1, ListNode l2) {\n        ListNode res = new ListNode(0);\n        ListNode p = res;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                p.next = l1;\n                l1 = l1.next;\n            } else {\n                p.next = l2;\n                l2 = l2.next;\n            }\n            p = p.next;\n        }\n        if (l1 != null) {\n            p.next = l1;\n        }\n        if (l2 != null) {\n            p.next = l2;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(n)*\n\n\n\n## 🔴23. 合并 K 个升序链表\n\n> 给你一个链表数组，每个链表都已经按升序排列。\n>\n> 请你将所有链表合并到一个升序链表中，返回合并后的链表。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：lists = [[1,4,5],[1,3,4],[2,6]]\n> 输出：[1,1,2,3,4,4,5,6]\n> 解释：链表数组如下：\n> [\n>   1->4->5,\n>   1->3->4,\n>   2->6\n> ]\n> 将它们合并到一个有序链表中得到。\n> 1->1->2->3->4->4->5->6\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：lists = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：lists = [[]]\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `k == lists.length`\n> - `0 <= k <= 10^4`\n> - `0 <= lists[i].length <= 500`\n> - `-10^4 <= lists[i][j] <= 10^4`\n> - `lists[i]` 按 **升序** 排列\n> - `lists[i].length` 的总和不超过 `10^4`\n>\n> Related Topics\n>\n> 链表\n>\n> 分治\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        int len= lists.length;\n        if(len==0){\n            return null;\n        }\n        return biaryMerge(lists,0,len-1);\n    }\n    ListNode biaryMerge(ListNode[] lists,int i,int j){\n        if(i>j){\n            return null;\n        } else if (i==j) {\n            return lists[i];\n        }\n        int mid=(i+j)/2;\n        return merge(biaryMerge(lists,i,mid),biaryMerge(lists,mid+1,j));\n    }\n    ListNode merge(ListNode l1, ListNode l2) {\n        ListNode res = new ListNode(0);\n        ListNode p = res;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                p.next = l1;\n                l1 = l1.next;\n            } else {\n                p.next = l2;\n                l2 = l2.next;\n            }\n            p = p.next;\n        }\n        if (l1 != null) {\n            p.next = l1;\n        }\n        if (l2 != null) {\n            p.next = l2;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(nlogk)*\n\n- space:*O(n + log(k))*\n\n#  计数排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        // 找到数组中的最大值和最小值\n        int min = Arrays.stream(nums).min().getAsInt();\n        int max = Arrays.stream(nums).max().getAsInt();\n        // 计算计数数组的长度\n        int length = max - min + 1;\n        int[] count = new int[length];\n        // 统计每个元素的出现次数\n        for (int num : nums) {\n            count[num - min]++;\n        }\n        // 将计数数组转换为前缀和数组\n        for (int i = 1; i < length; i++) {\n            count[i] += count[i - 1];\n        }\n        // 创建临时数组存储排序后的结果\n        int[] res = new int[nums.length];\n        // 将元素按照计数数组的前缀和分配到临时数组\n        for (int i = nums.length - 1; i >= 0; i--) {\n            int index = count[nums[i] - min] - 1;\n            res[index] = nums[i];\n            count[nums[i] - min]--;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(n)*\n\n## 🟡75. 颜色分类\n\n> 给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n>\n> 我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。\n>\n> \n>\n> 必须在不使用库内置的 sort 函数的情况下解决这个问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,0,2,1,1,0]\n> 输出：[0,0,1,1,2,2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,0,1]\n> 输出：[0,1,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 300`\n> - `nums[i]` 为 `0`、`1` 或 `2`\n>\n> \n>\n> **进阶：**\n>\n> - 你能想出一个仅使用常数空间的一趟扫描算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int len= nums.length;\n        int num0=0,num1=0;\n        for (int i = 0; i < len; i++) {\n            int num=nums[i];\n            nums[i]=2;\n            if(num<2){\n                nums[num1++]=1;\n            }\n            if(num<1){\n                nums[num0++]=0;\n            }\n        }\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n# 桶排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution{\n    public int[]sortArray(int[]nums){\n        int len=nums.length;\n        int MAX=200000;\n        int HALF=50001;\n        int min=nums[0]+HALF;\n        int max=nums[0]+HALF;\n        int[]bucket=new int[MAX];\n        for (int i = 0; i < len; i++) {\n            bucket[nums[i]+HALF]++;\n            min=Math.min(min,nums[i]+HALF);\n            max=Math.max(max,nums[i]+HALF);\n        }\n        int index=0;\n        for (int i = min; i <= max; i++) {\n            for (int j = 0; j < bucket[i]; j++) {\n                nums[index++]=i-HALF;\n            }\n        }\n        return nums;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n小小改良版\n\n```java\nclass Solution{\n    public int[] sortArray(int[] nums){\n        int len = nums.length;\n        int min = nums[0];\n        int max = nums[0];\n        for (int i = 0; i < len; i++) {\n            min = Math.min(min, nums[i]);\n            max = Math.max(max, nums[i]);\n        }\n        int range = max - min + 1;\n        int[] bucket = new int[range];\n        for (int i = 0; i < len; i++) {\n            bucket[nums[i] - min]++;\n        }\n        int index = 0;\n        for (int i = 0; i < range; i++) {\n            for (int j = 0; j < bucket[i]; j++) {\n                nums[index++] = i + min;\n            }\n        }\n        return nums;\n    }\n}\n```\n\n- time:*O(n+range)*\n\n- space:*O(range)*\n\n## 🟡148. 排序链表\n\n> 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)\n>\n> ```\n> 输入：head = [4,2,1,3]\n> 输出：[1,2,3,4]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)\n>\n> ```\n> 输入：head = [-1,5,3,4,0]\n> 输出：[-1,0,3,4,5]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目在范围 `[0, 5 * 104]` 内\n> - `-105 <= Node.val <= 105`\n>\n> \n>\n> **进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n>\n> 分治\n>\n> 排序\n>\n> 归并排序\n\n```java\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ptr=head;\n        int max=head.val;\n        int min=head.val;\n        while (ptr!=null){\n            max=Math.max(max,ptr.val);\n            min=Math.min(min,ptr.val);\n            ptr=ptr.next;\n        }\n        int range = max - min + 1;\n        int[] bucket = new int[range];\n        ptr=head;\n        while (ptr!=null){\n            bucket[ptr.val - min]++;\n            ptr=ptr.next;\n        }\n        ptr=head;\n        for (int i = 0; i < range; i++) {\n            for (int j = 0; j < bucket[i]; j++) {\n                ptr.val=i+min;\n                ptr=ptr.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n+range)*\n- space:*O(range)*\n\n#  基数排序\n\n## 🟡912. 排序数组\n\n> 给你一个整数数组 `nums`，请你将该数组升序排列。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,1,1,2,0,0]\n> 输出：[0,0,1,1,2,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 104`\n> - `-5 * 104 <= nums[i] <= 5 * 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 桶排序\n>\n> 计数排序\n>\n> 基数排序\n>\n> 排序\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution{\n    public int[] sortArray(int[] nums){\n        // 找到数组中的最小值\n        int min = Arrays.stream(nums).min().getAsInt();\n        if(min<0){\n            for (int i = 0; i < nums.length; i++) {\n                nums[i]-=min;\n            }\n        }\n        // 找到数组中的最大值\n        int max = Arrays.stream(nums).max().getAsInt();\n        // 计算最大值的位数\n        int digits = String.valueOf(max).length();\n        // 进行 digits 轮计数排序\n        for (int i = 0; i < digits; i++) {\n            nums = countingSort(nums, i);\n        }\n        if(min<0){\n            for (int i = 0; i < nums.length; i++) {\n                nums[i]+=min;\n            }\n        }\n        return nums;\n    }\n    private int[] countingSort(int[] nums, int digit) {\n        // 创建计数数组\n        int[] count = new int[10];\n        // 统计每个数字的出现次数\n        for (int num : nums) {\n            int d = (int)(num / Math.pow(10, digit)) % 10;\n            count[d]++;\n        }\n        // 将计数数组转换为前缀和数组\n        for (int i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        // 创建临时数组存储排序后的结果\n        int[] res = new int[nums.length];\n        // 将元素按照计数数组的前缀和分配到临时数组\n        for (int i = nums.length - 1; i >= 0; i--) {\n            int d = (int)(nums[i] / Math.pow(10, digit)) % 10;\n            int index = count[d] - 1;\n            res[index] = nums[i];\n            count[d]--;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n+digits)*\n- space:*O(1)*\n\n#  特别排序\n\n## 🟡179. 最大数\n\n> 给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。\n>\n> **注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [10,2]\n> 输出：\"210\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,30,34,5,9]\n> 输出：\"9534330\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `0 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public String largestNumber(int[] nums) {\n        Comparator<Integer> comparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                String sa = String.valueOf(o1);\n                String sb = String.valueOf(o2);\n                return (sb + sa).compareTo(sa + sb);\n            }\n        };\n        Integer[] numbers = new Integer[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            numbers[i] = nums[i];\n        }\n        Arrays.sort(numbers, comparator);\n        StringBuilder sb=new StringBuilder();\n        int flag=0;\n        for (int i = 0; i < numbers.length; i++) {\n            if(numbers[i]!=0||flag==1){\n                flag=1;\n                sb.append(numbers[i]);\n            }\n        }\n        if(sb.isEmpty()){\n            return \"0\";\n        }else{\n            return sb.toString();\n        }\n    }\n}\n```\n\n- time:*O(n·m·logn)*m为两个数字的位数之和\n- space:*O(n)*\n","categories":["algorithm learning"]},{"title":"Number & Bits","url":"/2024/01/31/algorithm-number&bits/","content":"\n| 类型     | 题号                      | 完成 |\n| -------- | ------------------------- | ---- |\n| 进制转换 | 🟢67.二进制求和            | ✅    |\n|          | 🟢504.七进制数             | ✅    |\n|          | 🟢405.数字转换为十六进制数 | ✅    |\n|          | 🟢476.数字的补数           | ✅    |\n|          | 🟢66.加一                  | ✅    |\n|          | 🔴479.最大回文数乘积       |      |\n|          | 🔴564.寻找最近的回文数     |      |\n|          | 🟡7.整数反转               | ✅    |\n|          | 🟢693. 交替位二进制数      | ✅    |\n| 数值计算 | 🟢415. 字符串相加          | ✅    |\n|          | 🟡43. 字符串相乘           |      |\n|          | 556. 下一个更大元素 III   |      |\n|          | 🟢9. 回文数                | ✅    |\n|          | 🟢258. 各位相加            | ✅    |\n|          | 🟢461. 汉明距离            | ✅    |\n|          | 🟡477. 汉明距离总和        | ✅    |\n| 数学问题 | 🟡204. 计数质数            |      |\n|          | 🟢263. 丑数                |      |\n|          | 🟢367. 有效的完全平方数    |      |\n|          | 🟢1071. 字符串的最大公因子 |      |\n\n# 进制转换\n\n## 🟢67.二进制求和 \n\n> 给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入:a = \"11\", b = \"1\"\n> 输出：\"100\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：a = \"1010\", b = \"1011\"\n> 输出：\"10101\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= a.length, b.length <= 104`\n> - `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成\n> - 字符串如果不是 `\"0\"` ，就不含前导零\n>\n> Related Topics\n>\n> 位运算\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public String addBinary(String a, String b) {\n        int la=a.length(),lb=b.length();\n        int cout=0;\n        StringBuilder sb=new StringBuilder();\n        for (int i = 0; i < Math.max(la,lb); i++) {\n            int cur_a=la-1-i>=0?a.charAt(la-1-i)-'0':0;\n            int cur_b=lb-1-i>=0?b.charAt(lb-1-i)-'0':0;\n            int sum=cur_a+cur_b+cout;\n            if(sum<=1){\n                sb.append(sum);\n                cout=0;\n            }else {\n                sb.append(sum-2);\n                cout=1;\n            }\n        }\n        if(cout==1){\n            sb.append(1);\n        }\n        return sb.reverse().toString();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n\n\n## 🟢504.七进制数 \n\n> 给定一个整数 `num`，将其转化为 **7 进制**，并以字符串形式输出。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: num = 100\n> 输出: \"202\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: num = -7\n> 输出: \"-10\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-107 <= num <= 107`\n>\n> Related Topics\n>\n> 数学\n\n```java\nclass Solution {\n    public String convertToBase7(int num) {\n        StringBuilder sb=new StringBuilder();\n        boolean nav=false;\n        if(num<0){\n            nav=true;\n            num*=-1;\n        }\n        if(num==0){\n            return \"0\";\n        }\n        while (num>0){\n            sb.append(num%7);\n            num/=7;\n        }\n        return nav?\"-\"+sb.reverse().toString():sb.reverse().toString();\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢405.数字转换为十六进制数 \n\n> 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 [补码运算](https://baike.baidu.com/item/补码/6854613?fr=aladdin) 方法。\n>\n> **注意:**\n>\n> 1. 十六进制中所有字母(`a-f`)都必须是小写。\n> 2. 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符`'0'`来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。\n> 3. 给定的数确保在32位有符号整数范围内。\n> 4. **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。**\n>\n> **示例 1：**\n>\n> ```\n> 输入:\n> 26\n> \n> 输出:\n> \"1a\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入:\n> -1\n> \n> 输出:\n> \"ffffffff\"\n> ```\n>\n> Related Topics\n>\n> 位运算\n>\n> 数学\n\n```java\nclass Solution {\n    public String toHex(long num) {\n        StringBuilder sb = new StringBuilder();\n        if (num == 0) {\n            return \"0\";\n        }\n        if(num<0){\n            num+=2L*(Integer.MAX_VALUE+1L);\n        }\n        while (num > 0) {\n            if (num % 16 < 10) {\n                sb.append(num % 16);\n            } else {\n                sb.append((char) (num % 16 - 10 + 'a'));\n            }\n            num/=16;\n        }\n        return sb.reverse().toString();\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(log n)*\n\n## 🟢476.数字的补数 \n\n> 对整数的二进制表示取反（`0` 变 `1` ，`1` 变 `0`）后，再转换为十进制表示，可以得到这个整数的补数。\n>\n> - 例如，整数 `5` 的二进制表示是 `\"101\"` ，取反后得到 `\"010\"` ，再转回十进制表示得到补数 `2` 。\n>\n> 给你一个整数 `num` ，输出它的补数。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 5\n> 输出：2\n> 解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 1\n> 输出：0\n> 解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num < 231`\n>\n> \n>\n> **注意：**本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同\n>\n> Related Topics\n>\n> 位运算\n\n```java\nclass Solution {\n    public int findComplement(int num) {\n        String binary=Integer.toBinaryString(num);\n        StringBuilder sb=new StringBuilder();\n        for (int i = 0; i < binary.length(); i++) {\n            sb.append(binary.charAt(i)=='0'?'1':'0');\n        }\n        return Integer.parseInt(sb.toString(),2);\n    }\n}\n```\n\n- time:*O(digit)*\n- space:*O(1)*\n\n## 🟢66.加一 \n\n> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。\n>\n> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n>\n> 你可以假设除了整数 0 之外，这个整数不会以零开头。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：digits = [1,2,3]\n> 输出：[1,2,4]\n> 解释：输入数组表示数字 123。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：digits = [4,3,2,1]\n> 输出：[4,3,2,2]\n> 解释：输入数组表示数字 4321。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：digits = [0]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= digits.length <= 100`\n> - `0 <= digits[i] <= 9`\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int len=digits.length;\n        if(digits[len-1]!=9){\n            digits[len-1]++;\n            return digits;\n        }else {\n            int index=len-1;\n            while (index>=0&&digits[index]==9){\n                index--;\n            }\n            if(index==-1){\n                int[] res=new int[len+1];\n                res[0]=1;\n                for (int i = 1; i <= len; i++) {\n                    res[i]=0;\n                }\n                return res;\n            }else {\n                for (int i = index+1; i < len; i++) {\n                    digits[i]=0;\n                }\n                digits[index]++;\n                return digits;\n            }\n        }\n    }\n}\n```\n\n- time:*O(digit)*\n- space:*O(1)*\n\n## 🔴479.最大回文数乘积 \n\n## 🔴564.寻找最近的回文数 \n\n## 🟡7.整数反转 \n\n> 给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。\n>\n> 如果反转后整数超过 32 位的有符号整数的范围 `[−231,  231 − 1]` ，就返回 0。\n>\n> **假设环境不允许存储 64 位整数（有符号或无符号）。**\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 123\n> 输出：321\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = -123\n> 输出：-321\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：x = 120\n> 输出：21\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：x = 0\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-231 <= x <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        String str=String.valueOf(x);\n        boolean nav=false;\n        if(x<0){\n            nav=true;\n            str=str.substring(1);\n        }\n        str=new StringBuilder(str).reverse().toString();\n        long res=Long.parseLong(str);\n        if(res>Integer.MAX_VALUE){\n            return 0;\n        }\n        return nav?-(int)res:(int)res;\n    }\n}\n```\n\n- time:*O(1)*\n- space:*O(digit)*\n\n## 🟢693. 交替位二进制数\n\n> 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 5\n> 输出：true\n> 解释：5 的二进制表示是：101\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 7\n> 输出：false\n> 解释：7 的二进制表示是：111.\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：n = 11\n> 输出：false\n> 解释：11 的二进制表示是：1011.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 231 - 1`\n>\n> Related Topics\n>\n> 位运算\n\n```java\nclass Solution {\n    public boolean hasAlternatingBits(int n) {\n        String binary=Integer.toBinaryString(n);\n        for (int i = 1; i < binary.length(); i++) {\n            if(binary.charAt(i)==binary.charAt(i-1)){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(digit)*\n- space:*O(digit)*\n\n# 数值计算\n\n## 🟢415. 字符串相加 \n\n> 给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。\n>\n> 你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num1 = \"11\", num2 = \"123\"\n> 输出：\"134\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num1 = \"456\", num2 = \"77\"\n> 输出：\"533\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：num1 = \"0\", num2 = \"0\"\n> 输出：\"0\"\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= num1.length, num2.length <= 104`\n> - `num1` 和`num2` 都只包含数字 `0-9`\n> - `num1` 和`num2` 都不包含任何前导零\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        String  res=\"\";\n        num1=new StringBuilder(num1).reverse().toString();\n        num2=new StringBuilder(num2).reverse().toString();\n        String longer=num1.length()>=num2.length()?num1:num2;\n        String shorter=num1.length()<num2.length()?num1:num2;\n        int cout=0;\n        for (int i = 0; i < shorter.length(); i++) {\n            int sum=Integer.parseInt(longer.charAt(i)+\"\")+Integer.parseInt(shorter.charAt(i)+\"\")+cout;\n            if(sum>=10){\n                res+=String.valueOf(sum-10);\n                cout=1;\n            }else {\n                res+=String.valueOf(sum);\n                cout=0;\n            }\n        }\n        for (int i = shorter.length(); i < longer.length(); i++) {\n            int sum=Integer.parseInt(longer.charAt(i)+\"\")+cout;\n            if(sum>=10){\n                res+=String.valueOf(sum-10);\n                cout=1;\n            }else {\n                res+=String.valueOf(sum);\n                cout=0;\n            }\n        }\n        if(cout>0){\n            res+=String.valueOf(cout);\n        }\n        return new StringBuilder(res).reverse().toString();\n    }\n}\n```\n\n- time:*O(digit)*\n- space:*O(digit)*\n\n## 🟡43. 字符串相乘 \n\n## 🟡556. 下一个更大元素 III \n\n> 给你一个正整数 `n` ，请你找出符合条件的最小整数，其由重新排列 `n` 中存在的每位数字组成，并且其值大于 `n` 。如果不存在这样的正整数，则返回 `-1` 。\n>\n> **注意** ，返回的整数应当是一个 **32 位整数** ，如果存在满足题意的答案，但不是 **32 位整数** ，同样返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 12\n> 输出：21\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 21\n> 输出：-1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 双指针\n>\n> 字符串\n\n```java\n```\n\n\n\n## 🟢9. 回文数 \n\n> 给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n>\n> 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n>\n> - 例如，`121` 是回文，而 `123` 不是。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 121\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = -121\n> 输出：false\n> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：x = 10\n> 输出：false\n> 解释：从右向左读, 为 01 。因此它不是一个回文数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-231 <= x <= 231 - 1`\n>\n> \n>\n> **进阶：**你能不将整数转为字符串来解决这个问题吗？\n>\n> Related Topics\n>\n> 数学\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String string=String.valueOf(x);\n        int i=0,j=string.length()-1;\n        while (i<j){\n            if(string.charAt(i)!=string.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(digit)*\n- space:*O(digit)*\n\n## 🟢258. 各位相加 \n\n> 给定一个非负整数 `num`，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: num = 38\n> 输出: 2 \n> 解释: 各位相加的过程为：\n> 38 --> 3 + 8 --> 11\n> 11 --> 1 + 1 --> 2\n> 由于 2 是一位数，所以返回 2。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: num = 0\n> 输出: 0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= num <= 231 - 1`\n>\n> \n>\n> **进阶：**你可以不使用循环或者递归，在 `O(1)` 时间复杂度内解决这个问题吗？\n>\n> Related Topics\n>\n> 数学\n>\n> 数论\n>\n> 模拟\n\n```java\nclass Solution {\n    public int addDigits(int num) {\n        int res=num;\n        while (num>=10){\n            res=0;\n            while (num>0){\n                res+=num%10;\n                num/=10;\n            }\n            num=res;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟢461. 汉明距离 \n\n> 两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。\n>\n> 给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 1, y = 4\n> 输出：2\n> 解释：\n> 1   (0 0 0 1)\n> 4   (0 1 0 0)\n>        ↑   ↑\n> 上面的箭头指出了对应二进制位不同的位置。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = 3, y = 1\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= x, y <= 231 - 1`      //  2^8^-1\n>\n> Related Topics\n>\n> 位运算\n\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        return Integer.bitCount(x^y);\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟡477. 汉明距离总和\n\n> 两个整数的 [汉明距离](https://baike.baidu.com/item/汉明距离/475174?fr=aladdin) 指的是这两个数字的二进制数对应位不同的数量。\n>\n> 给你一个整数数组 `nums`，请你计算并返回 `nums` 中任意两个数之间 **汉明距离的总和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,14,2]\n> 输出：6\n> 解释：在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）\n> 所以答案为：\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,14,4]\n> 输出：4\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `0 <= nums[i] <= 109`\n> - 给定输入的对应答案符合 **32-bit** 整数范围\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int totalHammingDistance(int[] nums) {\n        int res=0;\n        for (int i = 0; i < nums.length-1; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                res+=Integer.bitCount(nums[i]^nums[j]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(1)*\n\n```java\nclass Solution {\n    public int totalHammingDistance(int[] nums) {\n        int ans = 0, n = nums.length;\n        for (int i = 0; i < 30; ++i) {\n            int c = 0;\n            for (int val : nums) {\n                c += (val >> i) & 1;\n            }\n            ans += c * (n - c);\n        }\n        return ans;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n# 数学问题\t\n\n## 🟡204. 计数质数\n\n## 🟢263. 丑数 \n\n## 🟢367. 有效的完全平方数 \n\n> 给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。\n>\n> **完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n>\n> 不能使用任何内置的库函数，如 `sqrt` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 16\n> 输出：true\n> 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 14\n> 输出：false\n> 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n```java\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        long left = 1, right = num ;\n        while (left <= right) {\n            long mid = (right + left) / 2;\n            if (mid * mid == num) {\n                return true;\n            } else if (mid * mid > num) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return num == 1;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟢1071. 字符串的最大公因子\n\n> 对于字符串 `s` 和 `t`，只有在 `s = t + t + t + ... + t + t`（`t` 自身连接 1 次或多次）时，我们才认定 “`t` 能除尽 `s`”。\n>\n> 给定两个字符串 `str1` 和 `str2` 。返回 *最长字符串 `x`，要求满足 `x` 能除尽 `str1` 且 `x` 能除尽 `str2`* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：str1 = \"ABCABC\", str2 = \"ABC\"\n> 输出：\"ABC\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：str1 = \"ABABAB\", str2 = \"ABAB\"\n> 输出：\"AB\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：str1 = \"LEET\", str2 = \"CODE\"\n> 输出：\"\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= str1.length, str2.length <= 1000`\n> - `str1` 和 `str2` 由大写英文字母组成\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n\n```java\n```\n\n","categories":["algorithm learning"]},{"title":"Bit Manipulation","url":"/2024/01/31/algorithm-bit-manipulation/","content":"\n| 类型             | 题号                                | 完成 |\n| ---------------- | ----------------------------------- | ---- |\n| 位运算的基本运算 | 🟢136. 只出现一次的数字              |      |\n|                  | 🟢190. 颠倒二进制位                  |      |\n|                  | 🟢191. 位1的个数                     |      |\n|                  | 🟡201. 数字范围按位与                |      |\n|                  | 🟢338. 比特位计数                    |      |\n| 位运算的技巧     | 🟡260. 只出现一次的数字 III          |      |\n|                  | 🟢342. 4的幂                         |      |\n|                  | 🟡371. 两整数之和                    |      |\n| 布隆过滤器       | 🟢705. 设计哈希集合                  |      |\n|                  | 🟢706. 设计哈希映射                  |      |\n|                  | 🔴1044. 最长重复子串                 |      |\n|                  | 🟡211. 添加与搜索单词 - 数据结构设计 |      |\n\n#  位运算的基本运算\n\n## 🟢136. 只出现一次的数字\n\n> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n>\n> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n>\n> **示例 1 ：**\n>\n> ```\n> 输入：nums = [2,2,1]\n> 输出：1\n> ```\n>\n> **示例 2 ：**\n>\n> ```\n> 输入：nums = [4,1,2,1,2]\n> 输出：4\n> ```\n>\n> **示例 3 ：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-3 * 104 <= nums[i] <= 3 * 104`\n> - 除了某个元素只出现一次以外，其余每个元素均出现两次。\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n\n```java\n```\n\n\n\n## 🟢190. 颠倒二进制位 \n\n##  🟢191. 位1的个数 \n\n## 🟡201. 数字范围按位与 \n\n## 🟢338. 比特位计数\n\n#  位运算的技巧\n\n## 🟡260. 只出现一次的数字 III\n\n## 🟢342. 4的幂 \n\n## 🟡371. 两整数之和\n\n#  布隆过滤器\n\n## 🟢705. 设计哈希集合 \n\n## 🟢706. 设计哈希映射\n\n## 🔴1044. 最长重复子串 \n\n## 🟡211. 添加与搜索单词 - 数据结构设计\n\n","categories":["algorithm learning"]},{"title":"Prefix Sum","url":"/2024/01/31/algorithm-prefix-sum/","content":"\n| 类型             | 题号                                | 完成 |\n| ---------------- | ----------------------------------- | ---- |\n| 一维数组的前缀和 | 🟢724. 寻找数组的中心下标            | ✅    |\n|                  | 🟡560. 和为 K 的子数组               | ✅    |\n|                  | 🟡930. 和相同的二元子数组            | ✅    |\n|                  | 🟡525. 连续数组                      |      |\n|                  | 🟡974. 和可被 K 整除的子数组         | ✅    |\n|                  | 🟡523. 连续的子数组和                | ✅    |\n|                  | 🟡1248. 统计「优美子数组」           |      |\n| 二维数组的前缀和 | 🟢304. 二维区域和检索 - 矩阵不可变   | ✅    |\n|                  | 🟡1314. 矩阵区域和                   | ✅    |\n|                  | 🔴1074. 元素和为目标值的子矩阵数量   |      |\n|                  | 🔴363. 矩形区域不超过 K 的最大数值和 |      |\n| 前缀和与二叉树   | 🟡437. 路径总和 III                  |      |\n|                  | 🟢1022. 从根到叶的二进制数之和       |      |\n|                  | 🟡129. 求根节点到叶节点数字之和      |      |\n\n# 一维数组的前缀和\n\n## 🟢724. 寻找数组的中心下标\n\n> 给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。\n>\n> 数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。\n>\n> 如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。\n>\n> 如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1, 7, 3, 6, 5, 6]\n> 输出：3\n> 解释：\n> 中心下标是 3 。\n> 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n> 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1, 2, 3]\n> 输出：-1\n> 解释：\n> 数组中不存在满足此条件的中心下标。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [2, 1, -1]\n> 输出：0\n> 解释：\n> 中心下标是 0 。\n> 左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n> 右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-1000 <= nums[i] <= 1000`\n>\n> \n>\n> **注意：**本题与主站 1991 题相同：https://leetcode-cn.com/problems/find-the-middle-index-in-array/\n>\n> Related Topics\n>\n> 数组\n>\n> 前缀和\n\n```java\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        int presum = 0;\n        for (int x : nums) {\n           presum += x;\n        }\n        int leftsum = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftsum == presum - nums[i] - leftsum) {\n                return i;\n            }\n            leftsum += nums[i];\n        }\n        return -1;\n    }\n}\n\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡560. 和为 K 的子数组\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。\n>\n> 子数组是数组中元素的连续非空序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,1], k = 2\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3], k = 3\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 2 * 104`\n> - `-1000 <= nums[i] <= 1000`\n> - `-107 <= k <= 107`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 前缀和\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        map.put(0, 1);\n        int count = 0;\n        int preSum = 0;\n        for (int x : nums) {\n            preSum += x;\n            if (map.containsKey(preSum - k)) {\n                count += map.get(preSum - k);\n            }\n            map.put(preSum,map.getOrDefault(preSum,0) + 1);\n        }\n        return count;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡930. 和相同的二元子数组\n\n> 给你一个二元数组 `nums` ，和一个整数 `goal` ，请你统计并返回有多少个和为 `goal` 的 **非空** 子数组。\n>\n> **子数组** 是数组的一段连续部分。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,0,1,0,1], goal = 2\n> 输出：4\n> 解释：\n> 有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,0,0,0], goal = 0\n> 输出：15\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `nums[i]` 不是 `0` 就是 `1`\n> - `0 <= goal <= nums.length`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 前缀和\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        int len = nums.length;\n        int[] preSum = new int[len + 1];\n        preSum[0] = 0;\n        for (int i = 0; i < len; i++) {\n            preSum[i + 1] = preSum[i] + nums[i];\n        }\n        int count = 0;\n        for (int left = 0; left < len; left++) {\n            for (int right = left; right < len; right++) {\n                if (preSum[right + 1] - preSum[left] == goal) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        Map<Integer,Integer>map=new HashMap<>();\n        map.put(0,1);\n        int preSum=0;\n        int cnt=0;\n        for (int x:nums) {\n            preSum+=x;\n            if(map.containsKey(preSum-goal)){\n                cnt+=map.get(preSum-goal);\n            }\n            map.put(preSum,map.getOrDefault(preSum,0)+1);\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡525. 连续数组\n\n> 给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1]\n> 输出: 2\n> 说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0,1,0]\n> 输出: 2\n> 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `nums[i]` 不是 `0` 就是 `1`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 前缀和\n\n```java\n\n```\n\n\n\n## 🟡974. 和可被 K 整除的子数组\n\n> 给定一个整数数组 `nums` 和一个整数 `k` ，返回其中元素之和可被 `k` 整除的（连续、非空） **子数组** 的数目。\n>\n> **子数组** 是数组的 **连续** 部分。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,5,0,-2,-3,1], k = 5\n> 输出：7\n> 解释：\n> 有 7 个子数组满足其元素之和可被 k = 5 整除：\n> [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [5], k = 9\n> 输出: 0\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `2 <= k <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 前缀和\n\n```java\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int[] hashtable=new int[k];\n        hashtable[0]=1;\n        int preSum = 0;\n        int cnt=0;\n        for (int i = 0; i < nums.length; i++) {\n            preSum += nums[i];\n            int key = (preSum%k+k) % k;\n            cnt+=hashtable[key];\n            hashtable[key]++;\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡523. 连续的子数组和\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n>\n> - 子数组大小 **至少为 2** ，且\n> - 子数组元素总和为 `k` 的倍数。\n>\n> 如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> 如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` 始终视为 `k` 的一个倍数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [23,2,4,6,7], k = 6\n> 输出：true\n> 解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [23,2,6,4,7], k = 6\n> 输出：true\n> 解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n> 42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [23,2,6,4,7], k = 13\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `0 <= nums[i] <= 109`\n> - `0 <= sum(nums[i]) <= 231 - 1`\n> - `1 <= k <= 231 - 1`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 数学\n>\n> 前缀和\n\n```java\nclass Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        map.put(0,-1);\n        int preSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            preSum += nums[i];\n            int key = preSum % k;\n            if (map.containsKey(key)) {\n                if (i - map.get(key) >= 2) {\n                    return true;\n                }\n                continue;\n            }\n            map.put(key,i);\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡1248. 统计「优美子数组」\n\n> 给你一个整数数组 `nums` 和一个整数 `k`。如果某个连续子数组中恰好有 `k` 个奇数数字，我们就认为这个子数组是「**优美子数组**」。\n>\n> 请返回这个数组中 **「优美子数组」** 的数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2,1,1], k = 3\n> 输出：2\n> 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,4,6], k = 1\n> 输出：0\n> 解释：数列中不包含任何奇数，所以不存在优美子数组。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n> 输出：16\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 50000`\n> - `1 <= nums[i] <= 10^5`\n> - `1 <= k <= nums.length`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 数学\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int numberOfSubarrays(int[] nums, int k) {\n        Map<Integer,Integer>map=new HashMap<>();\n        map.put(0,1);\n        int oddCnt=0;\n        int cnt=0;\n        for (int x:nums) {\n            if(x%2==1){\n                oddCnt++;\n            }\n            if(map.containsKey(oddCnt-k)){\n                cnt+=map.get(oddCnt-k);\n            }\n            map.put(oddCnt,map.getOrDefault(oddCnt,0)+1);\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n# 二维数组的前缀和\n\n## 🟢304. 二维区域和检索 - 矩阵不可变 \n\n> 给定一个二维矩阵 `matrix`，以下类型的多个请求：\n>\n> - 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 `(row1, col1)` ，**右下角** 为 `(row2, col2)` 。\n>\n> 实现 `NumMatrix` 类：\n>\n> - `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化\n> - `int sumRegion(int row1, int col1, int row2, int col2)` 返回 **左上角** `(row1, col1)` 、**右下角** `(row2, col2)` 所描述的子矩阵的元素 **总和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png)\n>\n> ```\n> 输入: \n> [\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n> [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n> 输出: \n> [null, 8, 11, 12]\n> \n> 解释:\n> NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);\n> numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\n> numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\n> numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= m, n <= 200`\n> - `-105 <= matrix[i][j] <= 105`\n> - `0 <= row1 <= row2 < m`\n> - `0 <= col1 <= col2 < n`\n> - 最多调用 `104` 次 `sumRegion` 方法\n>\n> Related Topics\n>\n> 设计\n>\n> 数组\n>\n> 矩阵\n>\n> 前缀和\n\n```java\nclass NumMatrix {\n    int[][]preSum;\n    public NumMatrix(int[][] matrix) {\n        int n=matrix.length,m=matrix[0].length;\n        this.preSum=new int[n+1][m+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                this.preSum[i+1][j+1]=this.preSum[i + 1][j] + this.preSum[i][j + 1] - this.preSum[i][j] + matrix[i][j];\n            }\n        }\n    }    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return this.preSum[row2+1][col2+1]+this.preSum[row1][col1]-\n                this.preSum[row1][col2+1]-this.preSum[row2+1][col1];\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n## 🟡1314. 矩阵区域和\n\n> 给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k` ，请你返回一个矩阵 `answer` ，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和：\n>\n> - `i - k <= r <= i + k, `\n> - `j - k <= c <= j + k` 且\n> - `(r, c)` 在矩阵内。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n> 输出：[[12,21,16],[27,45,33],[24,39,28]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n> 输出：[[45,45,45],[45,45,45],[45,45,45]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == mat.length`\n> - `n == mat[i].length`\n> - `1 <= m, n, k <= 100`\n> - `1 <= mat[i][j] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 前缀和\n\n```java\nclass Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int n=mat.length,m=mat[0].length;\n        int[][]preSum=new int[n+1][m+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                preSum[i+1][j+1]=preSum[i + 1][j] + preSum[i][j + 1] - preSum[i][j] + mat[i][j];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int row1=i-k<0?0:i-k;\n                int col1=j-k<0?0:j-k;\n                int row2=i+k>=n?n-1:i+k;\n                int col2=j+k>=m?m-1:j+k;\n                mat[i][j]=preSum[row2+1][col2+1]+preSum[row1][col1]-preSum[row2+1][col1]-preSum[row1][col2+1];\n            }\n        }\n        return mat;\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n## 🔴1074. 元素和为目标值的子矩阵数量\n\n## 🔴363. 矩形区域不超过 K 的最大数值和\n\n# 前缀和与二叉树\n\n## 🟡437. 路径总和 III\n\n## 🟢1022. 从根到叶的二进制数之和\n\n## 🟡129. 求根节点到叶节点数字之和\n\n","categories":["algorithm learning"]},{"title":"Binary Search","url":"/2024/01/31/algorithm-binary-search/","content":"\n| 类型                                 | 题号                                                 | 完成 |\n| ------------------------------------ | ---------------------------------------------------- | ---- |\n| 普通二分查找                         | 🟢704.二分查找                                        | ✅    |\n|                                      | 🟢69.x 的平方根                                       | ✅    |\n|                                      | 🟢35.搜索插入位置                                     | ✅    |\n|                                      | 🟡153.寻找旋转排序数组中的最小值                      | ✅    |\n|                                      | 🟢367.有效的完全平方数                                | ✅    |\n|                                      | 🟡50.Pow(x, n)                                        | ✅    |\n|                                      | 🟢278.第一个错误的版本                                | ✅    |\n|                                      | 🔴4.寻找两个正序数组的中位数                          | ✅    |\n|                                      | 🟡 167.两数之和 II - 输入有序数组                     | ✅    |\n|                                      | 🟢744.寻找比目标字母大的最小字母                      | ✅    |\n|                                      | 🟡162.寻找峰值                                        | ✅    |\n| 查找区间                             | 🟡34.在排序数组中查找元素的第一个和最后一个位置       | ✅    |\n|                                      | 🟡658.找到 K 个最接近的元素                           | ✅    |\n|                                      | 🟢278.第一个错误的版本                                | ✅    |\n|                                      | 🟡74.搜索二维矩阵                                     | ✅    |\n| 旋转排列数组                         | 🟡33.搜索旋转排序数组                                 | ✅    |\n|                                      | 🟡81.搜索旋转排序数组 II                              | ✅    |\n|                                      | 🟡240.搜索二维矩阵 II                                 | ✅    |\n|                                      | 🟡48.旋转图像                                         | ✅    |\n|                                      | 🟢448.找到所有数组中消失的数字                        | ✅    |\n|                                      | 🔴154.寻找旋转排序数组中的最小值 II                   |      |\n| 二分答案                             | 🟡275.H 指数 Ⅱ                                        | ✅    |\n|                                      | 🟡1283.使结果不超过阈值的最小除数 1542                | ✅    |\n|                                      | 🟡2187.完成旅途的最少时间 1641                        | ✅    |\n|                                      | 🟡2226.每个小孩最多能分到多少糖果 1646                | ✅    |\n|                                      | 🟡1870.准时到达的列车最小时速 1676                    |      |\n|                                      | 1011.在 D 天内送达包裹的能力 1725                    |      |\n|                                      | 🟡875.爱吃香蕉的珂珂 1766                             | ✅    |\n|                                      | 1898.可移除字符的最大数目 1913                       |      |\n|                                      | 1482.制作 m 束花所需的最少天数 1946                  |      |\n|                                      | 1642.可以到达的最远建筑 1962                         |      |\n|                                      | 2861.最大合金数 1981                                 |      |\n|                                      | 2258.逃离火灾 2347                                   |      |\n| 最小化最大值                         | 2064.分配给商店的最多商品的最小值 1886               |      |\n|                                      | 1760.袋子里最少数目的球 1940                         |      |\n|                                      | 2439.最小化数组中的最大值 1965                       |      |\n|                                      | 2560.打家劫舍 IV 2081                                |      |\n|                                      | 778.水位上升的泳池中游泳 2097 相当于最小化路径最大值 |      |\n|                                      | 2616.最小化数对的最大差值 2155                       |      |\n|                                      | 2513.最小化两个数组中的最大值 2302                   |      |\n| 最大化最小值                         | 1552.两球之间的磁力 1922                             |      |\n|                                      | 2861.最大合金数 1981                                 |      |\n|                                      | 2517.礼盒的最大甜蜜度 2021                           |      |\n|                                      | 02812.找出最安全路径 2154                            |      |\n|                                      | 528.最大化城市的最小供电站数目 2236                  |      |\n| 第 K 小/大（部分题目也可以用堆解决） | 🟡786.第 K 个最小的素数分数 2169                      | ✅    |\n|                                      | 373.查找和最小的 K 对数字                            |      |\n|                                      | 719.找出第 K 小的数对距离                            |      |\n|                                      | 1439.有序矩阵中的第 k 个最小数组和 2134              |      |\n|                                      | 378.有序矩阵中第 K 小的元素                          |      |\n|                                      | 2040.两个有序数组的第 K 小乘积 2518                  |      |\n|                                      | 2386.找出数组的第 K 大和 2648                        |      |\n\n\n\n# 普通二分查找\n\n## 🟢704.二分查找 \n\n> 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n>\n> \n> **示例 1:**\n>\n> ```\n> 输入: nums = [-1,0,3,5,9,12], target = 9\n> 输出: 4\n> 解释: 9 出现在 nums 中并且下标为 4\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [-1,0,3,5,9,12], target = 2\n> 输出: -1\n> 解释: 2 不存在 nums 中因此返回 -1\n> ```\n>\n> \n>\n> **提示：**\n>\n> 1. 你可以假设 `nums` 中的所有元素是不重复的。\n> 2. `n` 将在 `[1, 10000]`之间。\n> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int res=-1;\n        int len= nums.length;\n        int i=0,j=len-1;\n        while (i<=j){\n            int mid=(i+j)/2;\n            if(nums[mid]==target){\n                res=mid;\n                break;\n            } else if (nums[mid]>target) {\n                j=mid-1;\n            }else{\n                i=mid+1;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟢69.x 的平方根 \n\n> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。\n>\n> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**\n>\n> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 4\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = 8\n> 输出：2\n> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= x <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==0||x==1){\n            return x;\n        }\n        int l=1,r=x-1;\n        while(l<r){\n            int mid=l+(r-l+1)/2;\n            if(mid<=x/mid){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟢35.搜索插入位置 \n\n> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n>\n> 请必须使用时间复杂度为 `O(log n)` 的算法。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [1,3,5,6], target = 5\n> 输出: 2\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [1,3,5,6], target = 2\n> 输出: 1\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: nums = [1,3,5,6], target = 7\n> 输出: 4\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= nums.length <= 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 为 **无重复元素** 的 **升序** 排列数组\n> - `-104 <= target <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int len= nums.length;\n        int res=-1;\n        int i=0,j=len-1;\n        while (i<=j){\n            int mid=(i+j)/2;\n            if(nums[mid]>target){\n                j=mid-1;\n            } else if (nums[mid]<target) {\n                i=mid+1;\n            }else{\n                res=mid;\n                break;\n            }\n        }\n        return res==-1?i:res;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟡153.寻找旋转排序数组中的最小值 \n\n> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：\n>\n> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`\n> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`\n>\n> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。\n>\n> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。\n>\n> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,4,5,1,2]\n> 输出：1\n> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,5,6,7,0,1,2]\n> 输出：0\n> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [11,13,15,17]\n> 输出：11\n> 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 5000`\n> - `-5000 <= nums[i] <= 5000`\n> - `nums` 中的所有整数 **互不相同**\n> - `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        int left=0,right=nums.length-1;\n        while ( left<right){\n            int mid= left+ (right- left)/2;\n            if(nums[mid] < nums[right]){\n               right= mid;\n            } else {\n                left= mid+1;\n            }\n        }\n        return nums[ left];\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟢367.有效的完全平方数 \n\n> 给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。\n>\n> **完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n>\n> 不能使用任何内置的库函数，如 `sqrt` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 16\n> 输出：true\n> 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 14\n> 输出：false\n> 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n```java\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        if(num==1){\n            return true;\n        }\n        int l=1,r=num-1;\n        while (l<r){\n            int mid=l+(r-l+1)/2;\n            if(mid<=num/mid){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r*r==num;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟡50.Pow(x, n) \n\n> 实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 2.00000, n = 10\n> 输出：1024.00000\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = 2.10000, n = 3\n> 输出：9.26100\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：x = 2.00000, n = -2\n> 输出：0.25000\n> 解释：2-2 = 1/22 = 1/4 = 0.25\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-100.0 < x < 100.0`\n> - `-231 <= n <= 231-1`\n> - `n` 是一个整数\n> - 要么 `x` 不为零，要么 `n > 0` 。\n> - `-104 <= xn <= 104`\n>\n> Related Topics\n>\n> 递归\n>\n> 数学\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        long N = n;\n        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n    double quickMul(double x, long N) {\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n##  🟢278.第一个错误的版本\n\n> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n>\n> 假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。\n>\n> 你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 5, bad = 4\n> 输出：4\n> 解释：\n> 调用 isBadVersion(3) -> false \n> 调用 isBadVersion(5) -> true \n> 调用 isBadVersion(4) -> true\n> 所以，4 是第一个错误的版本。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1, bad = 1\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= bad <= n <= 231 - 1`\n>\n> Related Topics\n>\n> 二分查找\n>\n> 交互\n\n```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left=1,right=n;\n        while (left<right){\n            int mid=left+(right-left)/2;//注意取mid的算法\n            if(isBadVersion(mid)){\n                right=mid;\n            }else {\n                left=mid+1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n##  🔴4.寻找两个正序数组的中位数\n\n> 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。\n>\n> 算法的时间复杂度应该为 `O(log (m+n))` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,3], nums2 = [2]\n> 输出：2.00000\n> 解释：合并数组 = [1,2,3] ，中位数 2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [1,2], nums2 = [3,4]\n> 输出：2.50000\n> 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `nums1.length == m`\n> - `nums2.length == n`\n> - `0 <= m <= 1000`\n> - `0 <= n <= 1000`\n> - `1 <= m + n <= 2000`\n> - `-106 <= nums1[i], nums2[i] <= 106`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 分治\n\n```java\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int len1=nums1.length,len2=nums2.length;\n        int mid_index=(len1+len2)/2;\n        int index1=0,index2=0;\n        double res=0,last=0;\n        for (int i = 0; i <= mid_index; i++) {\n            if(index1>=len1){\n                res=nums2[index2++];\n            } else if (index2>=len2) {\n                res=nums1[index1++];\n            }else {\n                if(nums1[index1]<=nums2[index2]){\n                    res=nums1[index1++];\n                }else {\n                    res=nums2[index2++];\n                }\n            }\n            if(i==mid_index){\n                break;\n            }\n            last=res;\n        }\n        return (len1+len2)%2==1?res:(res+last)/2;\n    }\n}\n```\n\n- time:*O(n/2)*\n- space:*O(1)*\n\n## 🟡 167.两数之和 II - 输入有序数组 \n\n> 给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。\n>\n> 以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。\n>\n> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。\n>\n> 你所设计的解决方案必须只使用常量级的额外空间。\n>\n> **示例 1：**\n>\n> ```\n> 输入：numbers = [2,7,11,15], target = 9\n> 输出：[1,2]\n> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：numbers = [2,3,4], target = 6\n> 输出：[1,3]\n> 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：numbers = [-1,0], target = -1\n> 输出：[1,2]\n> 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= numbers.length <= 3 * 104`\n> - `-1000 <= numbers[i] <= 1000`\n> - `numbers` 按 **非递减顺序** 排列\n> - `-1000 <= target <= 1000`\n> - **仅存在一个有效答案**\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 二分查找\n\n双指针\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left=0,right= numbers.length-1;\n        while (left<right){\n            int sum=numbers[left]+numbers[right];\n            if(sum==target){\n                return new int[]{left + 1, right + 1};\n            } else if (sum<target) {\n                left++;\n            }else {\n                right--;\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n二分法\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        for (int i = 0; i < numbers.length; i++) {\n            int new_target = target - numbers[i];\n            int left = i + 1;\n            int right = numbers.length - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (numbers[mid] == new_target) {\n                    return new int[]{i + 1, mid + 1};\n                } else if (numbers[mid] > new_target) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟢744.寻找比目标字母大的最小字母 \n\n> 给你一个字符数组 `letters`，该数组按**非递减顺序**排序，以及一个字符 `target`。`letters` 里**至少有两个不同**的字符。\n>\n> 返回 `letters` 中大于 `target` 的最小的字符。如果不存在这样的字符，则返回 `letters` 的第一个字符。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: letters = [\"c\", \"f\", \"j\"]，target = \"a\"\n> 输出: \"c\"\n> 解释：letters 中字典上比 'a' 大的最小字符是 'c'。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: letters = [\"c\",\"f\",\"j\"], target = \"c\"\n> 输出: \"f\"\n> 解释：letters 中字典顺序上大于 'c' 的最小字符是 'f'。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\n> 输出: \"x\"\n> 解释：letters 中没有一个字符在字典上大于 'z'，所以我们返回 letters[0]。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= letters.length <= 104`\n> - `letters[i]` 是一个小写字母\n> - `letters` 按**非递减顺序**排序\n> - `letters` 最少包含两个不同的字母\n> - `target` 是一个小写字母\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        int left=0,right=letters.length-1;\n        while (left<right){\n            int mid=(left+right)/2;\n            if(letters[mid]>target){\n                right=mid;\n            } else if (letters[mid]<=target) {\n                left=mid+1;\n            }\n        }\n        return letters[left]<=target?letters[0]:letters[left];\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟡162.寻找峰值\n\n> 峰值元素是指其值严格大于左右相邻值的元素。\n>\n> 给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。\n>\n> 你可以假设 `nums[-1] = nums[n] = -∞` 。\n>\n> 你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1]\n> 输出：2\n> 解释：3 是峰值元素，你的函数应该返回其索引 2。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,1,3,5,6,4]\n> 输出：1 或 5 \n> 解释：你的函数可以返回索引 1，其峰值元素为 2；\n>      或者返回索引 5， 其峰值元素为 6。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `-231 <= nums[i] <= 231 - 1`\n> - 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        int max=Integer.MIN_VALUE,res=0;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]>max){\n                max=nums[i];\n                res=i;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n```java\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left<right){\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[mid + 1]) {//峰值在左侧\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n#  查找区间\n\n## 🟡34.在排序数组中查找元素的第一个和最后一个位置 \n\n> 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n>\n> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n>\n> 你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,7,7,8,8,10], target = 8\n> 输出：[3,4]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,7,7,8,8,10], target = 6\n> 输出：[-1,-1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [], target = 0\n> 输出：[-1,-1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n> - `nums` 是一个非递减数组\n> - `-109 <= target <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        if(nums.length==0){\n            return new int[]{-1,-1};\n        }\n        return new int[]{biarySearchFirst(nums,target),biarySearchLast(nums,target)};\n    }\n    int biarySearchFirst(int[] nums, int target){\n        int left=0,right=nums.length-1;\n        while (left<right){\n            int mid=(left+right)/2;\n            if(nums[mid]<target){\n                left=mid+1;\n            }else {\n                right=mid;\n            }\n        }\n        return nums[left]==target?left:-1;\n    }\n    int biarySearchLast(int[] nums, int target){\n        int left=0,right=nums.length-1;\n        while (left<right){\n            int mid=(left+right+1)/2;\n            if(nums[mid]>target){\n                right=mid-1;\n\n            }else {\n                left=mid;\n            }\n        }\n        return nums[left]==target?left:-1;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟡658.找到 K 个最接近的元素 \n\n> 给定一个 **排序好** 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。\n>\n> 整数 `a` 比整数 `b` 更接近 `x` 需要满足：\n>\n> - `|a - x| < |b - x|` 或者\n> - `|a - x| == |b - x|` 且 `a < b`\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：arr = [1,2,3,4,5], k = 4, x = 3\n> 输出：[1,2,3,4]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：arr = [1,2,3,4,5], k = 4, x = -1\n> 输出：[1,2,3,4]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= arr.length`\n> - `1 <= arr.length <= 104`\n> - `arr` 按 **升序** 排列\n> - `-104 <= arr[i], x <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n>\n> 滑动窗口\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        PriorityQueue<Integer> heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                if(Math.abs(o1-x)!=Math.abs(o2-x)){\n                    return Math.abs(o1-x)-Math.abs(o2-x);\n                }else{\n                    return o1-o2;\n                }\n            }\n        });\n        for (int i = 0; i < arr.length; i++) {\n            heap.offer(arr[i]);\n        }\n        List<Integer>res=new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            res.add(heap.poll());\n        }\n        Collections.sort(res);\n        return res;\n    }\n}\n```\n\n- time:*O(n log k)*\n- space:*O(k)*\n\n```java\nclass Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        int right = binarySearch(arr, x);\n        int left = right - 1;\n        while (k-- > 0) {\n            if (left < 0) {\n                right++;\n            } else if (right >= arr.length) {\n                left--;\n            } else if (x - arr[left] <= arr[right] - x) {\n                left--;\n            } else {\n                right++;\n            }\n        }\n        List<Integer> ans = new ArrayList<Integer>();\n        for (int i = left + 1; i < right; i++) {\n            ans.add(arr[i]);\n        }\n        return ans;\n    }\n\n    public int binarySearch(int[] arr, int x) {\n        int low = 0, high = arr.length - 1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] >= x) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(k)*\n\n## 🟡74.搜索二维矩阵\n\n> 给你一个满足下述两条属性的 `m x n` 整数矩阵：\n>\n> - 每行中的整数从左到右按非严格递增顺序排列。\n> - 每行的第一个整数大于前一行的最后一个整数。\n>\n> 给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\n>\n> ```\n> 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)\n>\n> ```\n> 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= m, n <= 100`\n> - `-104 <= matrix[i][j], target <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 矩阵\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int i=0,j= matrix.length-1;\n        while (i<j){\n            int mid=i+(j-i)/2;\n            if(mid==i){\n                break;\n            }\n            if(matrix[mid][0]>target){\n                j=mid-1;\n            }else{\n                i=mid;\n            }\n        }\n        if(matrix[j][0]<=target){\n            i=j;\n        }\n        int l=0,r=matrix[i].length-1;\n        while (l<r){\n            int mid=l+(r-l)/2;\n            if(matrix[i][mid]==target){\n                return true;\n            }else if(matrix[i][mid]>target){\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        return matrix[i][l]==target;\n    }\n}\n```\n\n- time:*O(log n + log m)*\n- space:*O(1)*\n\n#  旋转排列数组\n\n## 🟡33.搜索旋转排序数组 \n\n> 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。\n>\n> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。\n>\n> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。\n>\n> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,5,6,7,0,1,2], target = 0\n> 输出：4\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,5,6,7,0,1,2], target = 3\n> 输出：-1\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1], target = 0\n> 输出：-1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5000`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 中的每个值都 **独一无二**\n> - 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转\n> - `-104 <= target <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        if (n == 0) {\n            return -1;\n        }\n        if (n == 1) {\n            return nums[0] == target ? 0 : -1;\n        }\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n- time:*O(log n )*\n- space:*O(1)*\n\n## 🟡81.搜索旋转排序数组 II \n\n> 已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。\n>\n> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。\n>\n> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。\n>\n> 你必须尽可能减少整个操作步骤。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,5,6,0,0,1,2], target = 0\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,5,6,0,0,1,2], target = 3\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5000`\n> - `-104 <= nums[i] <= 104`\n> - 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转\n> - `-104 <= target <= 104`\n>\n> \n>\n> **进阶：**\n>\n> - 这是 [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/) 的延伸题目，本题中的 `nums` 可能包含重复元素。\n> - 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n>\n> \n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public boolean search(int[] nums, int target) {\n        int n = nums.length;\n        if (n == 0) {\n            return false;\n        }\n        if (n == 1) {\n            return nums[0] == target;\n        }\n        int l = 0, r = n - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] == target) {\n                return true;\n            }\n            if(nums[l]==nums[mid]&&nums[mid]==nums[r]){\n                l++;\n                r--;\n            } else if (nums[l] <= nums[mid]) {\n                if (nums[l] <= target && target < nums[mid]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(log n )*\n- space:*O(1)*\n\n## 🟡240.搜索二维矩阵 II \n\n> 编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n>\n> - 每行的元素从左到右升序排列。\n> - 每列的元素从上到下升序排列。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)\n>\n> ```\n> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)\n>\n> ```\n> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= n, m <= 300`\n> - `-109 <= matrix[i][j] <= 109`\n> - 每行的所有元素从左到右升序排列\n> - 每列的所有元素从上到下升序排列\n> - `-109 <= target <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 分治\n>\n> 矩阵\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int i = 0; i < matrix.length; i++) {\n            if(matrix[i][0]>target||matrix[i][matrix[i].length-1]<target){\n                continue;\n            }\n            if(binarySearch(matrix[i],target)!=-1){\n                return true;\n            }\n        }\n        return false;\n    }\n    int binarySearch(int[]arr,int target){\n        int i=0,j=arr.length-1;\n        while (i<=j){\n            int mid=(i+j)/2;\n            if(arr[mid]==target){\n                return mid;\n            } else if (arr[mid]>target) {\n                j=mid-1;\n            }else {\n                i=mid+1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n- time:*O(n log m )*\n- space:*O(1)*\n\n## 🟡48.旋转图像\n\n> 给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n>\n> 你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[[7,4,1],[8,5,2],[9,6,3]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n>\n> ```\n> 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n> 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == matrix.length == matrix[i].length`\n> - `1 <= n <= 20`\n> - `-1000 <= matrix[i][j] <= 1000`\n>\n> \n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n>\n> 矩阵\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i < n / 2; i++) {\n            for (int j = 0; j < (n + 1) / 2; j++) {\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[n - 1 - j][i];\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\n                matrix[j][n - 1 - i] = tmp;\n            }\n        }\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(1)*\n\n## 🟢448.找到所有数组中消失的数字 \n\n> 给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[5,6]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,1]\n> 输出：[2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 105`\n> - `1 <= nums[i] <= n`\n>\n> **进阶：**你能在不使用额外空间且时间复杂度为 `O(n)` 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        int n= nums.length;\n        List<Integer>list=new ArrayList<>();\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < n; i++) {\n            set.add(nums[i]);\n        }\n        for (int i = 1; i <= n; i++) {\n            if(!set.contains(i)){\n                list.add(i);\n            }\n        }\n        return list;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🔴154.寻找旋转排序数组中的最小值 II\n\n# 二分答案\n\n## 🟡275.H 指数 II\n\n> 给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数，`citations` 已经按照 **升序排列** 。计算并返回该研究者的 h 指数。\n>\n> [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：h 代表“高引用次数”（high citations），一名科研人员的 `h` 指数是指他（她）的 （`n` 篇论文中）**至少** 有 `h` 篇论文分别被引用了**至少** `h` 次。\n>\n> 请你设计并实现对数时间复杂度的算法解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：citations = [0,1,3,5,6]\n> 输出：3\n> 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。\n>      由于研究者有3篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：citations = [1,2,100]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == citations.length`\n> - `1 <= n <= 105`\n> - `0 <= citations[i] <= 1000`\n> - `citations` 按 **升序排列**\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int hIndex(int[] citations) {\n        int h= citations.length;\n        for (int i = 0; i < citations.length; i++) {\n            if(citations[i]>=h){\n                return h;\n            }\n            h--;\n        }\n        return 0;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n```java\nclass Solution{\n    public int hIndex(int[] citations) {\n        int len= citations.length;\n        int left = 0, right = len- 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (citations[mid] >= len- mid) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return len- left;\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(1)*\n\n## 🟡1283.使结果不超过阈值的最小除数 1542\n\n> 给你一个整数数组 `nums` 和一个正整数 `threshold` ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。\n>\n> 请你找出能够使上述结果小于等于阈值 `threshold` 的除数中 **最小** 的那个。\n>\n> 每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。\n>\n> 题目保证一定有解。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,5,9], threshold = 6\n> 输出：5\n> 解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。\n> 如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,3,5,7,11], threshold = 11\n> 输出：3\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [19], threshold = 5\n> 输出：4\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 10^4`\n> - `1 <= nums[i] <= 10^6`\n> - `nums.length <= threshold <= 10^6`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int smallestDivisor(int[] nums, int threshold) {\n        int left=1,right= Arrays.stream(nums).max().getAsInt();\n        int res=-1;\n        while (left<=right){\n            int mid=(left+right)/2;\n            int temp=0;\n            for (int i = 0; i < nums.length; i++) {\n                temp+=(nums[i]-1)/mid+1;\n            }\n            if(temp<=threshold){//符合条件中的最小值\n                res=mid;\n                right=mid-1;\n            }else {\n                left=mid+1;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(1)*\n\n## 🟡2187.完成旅途的最少时间 1641\n\n> 给你一个数组 `time` ，其中 `time[i]` 表示第 `i` 辆公交车完成 **一趟****旅途** 所需要花费的时间。\n>\n> 每辆公交车可以 **连续** 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 **立马开始** 下一趟旅途。每辆公交车 **独立** 运行，也就是说可以同时有多辆公交车在运行且互不影响。\n>\n> 给你一个整数 `totalTrips` ，表示所有公交车 **总共** 需要完成的旅途数目。请你返回完成 **至少** `totalTrips` 趟旅途需要花费的 **最少** 时间。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：time = [1,2,3], totalTrips = 5\n> 输出：3\n> 解释：\n> - 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。\n>   已完成的总旅途数为 1 + 0 + 0 = 1 。\n> - 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。\n>   已完成的总旅途数为 2 + 1 + 0 = 3 。\n> - 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。\n>   已完成的总旅途数为 3 + 1 + 1 = 5 。\n> 所以总共完成至少 5 趟旅途的最少时间为 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：time = [2], totalTrips = 1\n> 输出：2\n> 解释：\n> 只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。\n> 所以完成 1 趟旅途的最少时间为 2 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= time.length <= 105`\n> - `1 <= time[i], totalTrips <= 107`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public long minimumTime(int[] time, int totalTrips) {\n        Arrays.sort(time);\n        long left=0,right=1L*totalTrips* time[0];//1L很重要，而且要放在前面\n        while (left<right){\n            long mid=(left+right)/2;\n            long trips=0;\n            for (int t:time) {\n                if(mid<t){\n                    break;\n                }\n                trips+=mid/t;\n            }\n            if(trips>=totalTrips){//符合条件\n                right=mid;//中的最小值\n            }else {\n                left=mid+1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(1)*\n\n## 🟡2226.每个小孩最多能分到多少糖果 1646\n\n> 给你一个 **下标从 0 开始** 的整数数组 `candies` 。数组中的每个元素表示大小为 `candies[i]` 的一堆糖果。你可以将每堆糖果分成任意数量的 **子堆** ，但 **无法** 再将两堆合并到一起。\n>\n> 另给你一个整数 `k` 。你需要将这些糖果分配给 `k` 个小孩，使每个小孩分到 **相同** 数量的糖果。每个小孩可以拿走 **至多一堆** 糖果，有些糖果可能会不被分配。\n>\n> 返回每个小孩可以拿走的 **最大糖果数目** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：candies = [5,8,6], k = 3\n> 输出：5\n> 解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：candies = [2,5], k = 11\n> 输出：0\n> 解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= candies.length <= 105`\n> - `1 <= candies[i] <= 107`\n> - `1 <= k <= 1012`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int maximumCandies(int[] candies, long k) {\n        Arrays.sort(candies);\n        int len=candies.length;\n        long left=1L,right=1L*candies[len-1],res=0L;\n        while (left<=right){\n            long mid=left+(right-left)/2;\n            long children=0L;\n            for (int i = 0; i < len; i++) {\n                children+=1L*candies[i]/mid;\n            }\n            if(children>=k){\n                res=mid;\n                left=mid+1;\n            }else {\n                right=mid-1;\n            }\n        }\n        return (int)res;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(1)*\n\n## 🟡2226.每个小孩最多能分到多少糖果 16461870.准时到达的列车最小时速 1676\n\n> 给你一个浮点数 `hour` ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 `n` 趟列车。另给你一个长度为 `n` 的整数数组 `dist` ，其中 `dist[i]` 表示第 `i` 趟列车的行驶距离（单位是千米）。\n>\n> 每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。\n>\n> - 例如，第 `1` 趟列车需要 `1.5` 小时，那你必须再等待 `0.5` 小时，搭乘在第 2 小时发车的第 `2` 趟列车。\n>\n> 返回能满足你准时到达办公室所要求全部列车的 **最小正整数** 时速（单位：千米每小时），如果无法准时到达，则返回 `-1` 。\n>\n> 生成的测试用例保证答案不超过 `107` ，且 `hour` 的 **小数点后最多存在两位数字** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：dist = [1,3,2], hour = 6\n> 输出：1\n> 解释：速度为 1 时：\n> - 第 1 趟列车运行需要 1/1 = 1 小时。\n> - 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。\n> - 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。\n> - 你将会恰好在第 6 小时到达。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：dist = [1,3,2], hour = 2.7\n> 输出：3\n> 解释：速度为 3 时：\n> - 第 1 趟列车运行需要 1/3 = 0.33333 小时。\n> - 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。\n> - 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。\n> - 你将会在第 2.66667 小时到达。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：dist = [1,3,2], hour = 1.9\n> 输出：-1\n> 解释：不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == dist.length`\n> - `1 <= n <= 105`\n> - `1 <= dist[i] <= 105`\n> - `1 <= hour <= 109`\n> - `hours` 中，小数点后最多存在两位数字\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n## 1011.在 D 天内送达包裹的能力 1725\n\n## 🟡875.爱吃香蕉的珂珂 1766\n\n> 珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。\n>\n> 珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。\n>\n> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n>\n> 返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：piles = [3,6,7,11], h = 8\n> 输出：4\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：piles = [30,11,23,4,20], h = 5\n> 输出：30\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：piles = [30,11,23,4,20], h = 6\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= piles.length <= 104`\n> - `piles.length <= h <= 109`\n> - `1 <= piles[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        Arrays.sort(piles);\n        int len=piles.length;\n        long left=1,right=1L* piles[len-1]*len;//1L很重要，而且要放在前面\n        while (left<right){\n            long mid=(left+right)/2;\n            long hour=0;\n            for (int p:piles) {\n                hour+=(p-1)/mid+1;\n            }\n            if(hour<=h){//符合条件\n                right=mid;//中的最小值\n            }else {\n                left=mid+1;\n            }\n        }\n        return (int)left;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(1)*\n\n## 1898.可移除字符的最大数目 1913\n\n## 1482.制作 m 束花所需的最少天数 1946\n\n## 1642.可以到达的最远建筑 1962\n\n## 2861.最大合金数 1981\n\n## 2258.逃离火灾 2347\n\n# 最小化最大值\n\n## 2064.分配给商店的最多商品的最小值 1886\n\n## 1760.袋子里最少数目的球 1940\n\n## 2439.最小化数组中的最大值 1965\n\n## 2560.打家劫舍 IV 2081\n\n## 778.水位上升的泳池中游泳 2097 相当于最小化路径最大值\n\n## 2616.最小化数对的最大差值 2155\n\n## 2513.最小化两个数组中的最大值 2302\n\n# 最大化最小值\n\n## 1552.两球之间的磁力 1920\n\n## 2861.最大合金数 1981\n\n## 2517.礼盒的最大甜蜜度 2021\n\n## 2812.找出最安全路径 2154\n\n## 2528.最大化城市的最小供电站数目 2236\n\n# 第 K 小/大（部分题目也可以用堆解决）\n\n## 378.有序矩阵中第 K 小的元素\n\n> 给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。\n> 请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。\n>\n> 你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n> 输出：13\n> 解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：matrix = [[-5]], k = 1\n> 输出：-5\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= n <= 300`\n> - `-109 <= matrix[i][j] <= 109`\n> - 题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列\n> - `1 <= k <= n2`\n>\n> \n>\n> **进阶：**\n>\n> - 你能否用一个恒定的内存(即 `O(1)` 内存复杂度)来解决这个问题?\n> - 你能在 `O(n)` 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) ）很有趣。\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 矩阵\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\n```\n\n\n\n## 373.查找和最小的 K 对数字\n\n## 719.找出第 K 小的数对距离\n\n## 1439.有序矩阵中的第 k 个最小数组和 2134\n\n## 786.第 K 个最小的素数分数 2169\n\n## 2040.两个有序数组的第 K 小乘积 2518\n\n## 2386.找出数组的第 K 大和 2648\n\n","categories":["algorithm learning"]},{"title":"Sliding Windows","url":"/2024/01/31/algorithm-sliding-windows/","content":"\n| 类型                           | 题号                                                  | 完成 |\n| ------------------------------ | ----------------------------------------------------- | ---- |\n| 定长滑动窗口                   | 🟡1456.定长子串中元音的最大数目 1263                   | ✅    |\n|                                | 🟢2269. 找到一个数字的 K 美丽值 1280                   | ✅    |\n|                                | 🟢1984. 学生分数的最小差值 1306                        | ✅    |\n|                                | 🟢643. 子数组最大平均数 I                              | ✅    |\n|                                | 🟡1343. 大小为 K 且平均值大于等于阈值的子数组数目 1317 | ✅    |\n|                                | 🟡2090. 半径为 k 的子数组平均值 1358                   | ✅    |\n|                                | 🟢2379. 得到 K 个黑块的最少涂色次数 1360               | ✅    |\n|                                | 🟡1052. 爱生气的书店老板 1418                          | ✅    |\n|                                | 🟡2841. 几乎唯一子数组的最大和 1546                    | ✅    |\n|                                | 🟡2461. 长度为 K 子数组中的最大和 1553                 | ✅    |\n|                                | 🟡1423.可获得的最大点数 1574                           | ✅    |\n|                                | 🟡2134. 最少交换次数来组合所有的 1 II 1748             | ✅    |\n|                                | 🟡2653.滑动子数组的美丽值 1786                         |      |\n|                                | 🟡567. 字符串的排列                                    | ✅    |\n|                                | 🟡438. 找到字符串中所有字母异位词                      | ✅    |\n|                                | 🔴2156.查找给定哈希值的子串 2063                       |      |\n|                                | 🔴2953.统计完全子字符串 2449                           |      |\n|                                | 🟢346. 数据流中的移动平均值（会员题）                  | 💰    |\n|                                | 🟡1100. 长度为 K 的无重复字符子串（会员题）            | 💰    |\n|                                | 🟡1852. 每个子数组的数字种类数（会员题）               | 💰    |\n|                                | 🟡2067. 等计数子串的数量（会员题）                     | 💰    |\n|                                | 🔴2107. 分享 K 个糖果后独特口味的数量（会员题）        | 💰    |\n|                                | 🔴446. 等差数列划分 II - 子序列                        |      |\n|                                | 🟡718. 最长重复子数组                                  | ✅    |\n|                                | 🔴239. 滑动窗口最大值                                  |      |\n|                                | 🔴480. 滑动窗口中位数                                  |      |\n| 不定长滑动窗口（求最长/最大）  | 🟡3. 无重复字符的最长子串                              | ✅    |\n|                                | 🟡1493. 删掉一个元素以后全为 1 的最长子数组 1423       | ✅    |\n|                                | 🟡2730. 找到最长的半重复子字符串 1502                  |      |\n|                                | 🟡904. 水果成篮 1516                                   |      |\n|                                | 1695. 删除子数组的最大得分 1529                       |      |\n|                                | 2958. 最多 K 个重复元素的最长子数组 1535              |      |\n|                                | 2024. 考试的最大困扰度 1643                           |      |\n|                                | 1004. 最大连续1的个数 III 1656                        |      |\n|                                | 1438. 绝对差不超过限制的最长连续子数组 1672           |      |\n|                                | 2401. 最长优雅子数组 1750                             |      |\n|                                | 1658. 将 x 减到 0 的最小操作数 1817                   |      |\n|                                | 1838. 最高频元素的频数 1876                           |      |\n|                                | 2516. 每种字符至少取 K 个 1948                        |      |\n|                                | 2831. 找出最长等值子数组 1976                         |      |\n|                                | 2106. 摘水果 2062                                     |      |\n|                                | 1610. 可见点的最大数目 2147                           |      |\n|                                | 2781. 最长合法子字符串的长度 2204                     |      |\n|                                | 2968. 执行操作使频率分数最大 2444                     |      |\n|                                | 395. 至少有 K 个重复字符的最长子串                    |      |\n|                                | 1763. 最长的美好子字符串                              |      |\n|                                | 159. 至多包含两个不同字符的最长子串（会员题）         | 💰    |\n|                                | 340. 至多包含 K 个不同字符的最长子串（会员题）        | 💰    |\n| 不定长滑动窗口（求最短/最小）  | 209. 长度最小的子数组                                 |      |\n|                                | 1234. 替换子串得到平衡字符串 1878                     |      |\n|                                | 1574. 删除最短的子数组使剩余数组有序 1932             |      |\n|                                | 76. 最小覆盖子串                                      |      |\n|                                | 面试题 17.18. 最短超串                                |      |\n| 不定长滑动窗口（求子数组个数） | 2799. 统计完全子数组的数目 1398                       |      |\n|                                | 713.乘积小于 K 的子数组                               |      |\n|                                | 1358.包含所有三种字符的子字符串数目 1646              |      |\n|                                | 2962. 统计最大元素出现至少 K 次的子数组 1701          |      |\n|                                | 2302. 统计得分小于 K 的子数组数目 1808                |      |\n|                                | 2537. 统计好子数组的数目 1892                         |      |\n|                                | 2762.不间断子数组 1940                                |      |\n|                                | 2972.统计移除递增子数组的数目 II 2153                 |      |\n|                                | 2743. 计算没有重复字符的子字符串数量（会员题）        | 💰    |\n| 多指针滑动窗口                 | 930. 和相同的二元子数组 1592                          |      |\n|                                | 1248.统计「优美子数组」 1624                          |      |\n|                                | 2563. 统计公平数对的数目 1721                         |      |\n|                                | 1712. 将数组分成三个子数组的方案数 2079               |      |\n|                                | 2444. 统计定界子数组的数目 2093                       |      |\n|                                | 992. K 个不同整数的子数组 2210                        |      |\n|                                | 1989. 捉迷藏中可捕获的最大人数（会员题）              | 💰    |\n| 待定                           | 🟢674. 最长连续递增序列                                |      |\n|                                | 🔴632. 最小区间                                        |      |\n|                                | 🟡560. 和为 K 的子数组                                 |      |\n|                                | 🔴862. 和至少为 K 的最短子数组                         |      |\n\n# 定长滑动窗口\n\n## 🟡1456.定长子串中元音的最大数目 1263\n\n> 给你字符串 `s` 和整数 `k` 。\n>\n> 请返回字符串 `s` 中长度为 `k` 的单个子字符串中可能包含的最大元音字母数。\n>\n> 英文中的 **元音字母** 为（`a`, `e`, `i`, `o`, `u`）。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abciiidef\", k = 3\n> 输出：3\n> 解释：子字符串 \"iii\" 包含 3 个元音字母。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"aeiou\", k = 2\n> 输出：2\n> 解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"leetcode\", k = 3\n> 输出：2\n> 解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：s = \"rhythms\", k = 4\n> 输出：0\n> 解释：字符串 s 中不含任何元音字母。\n> ```\n>\n> **示例 5：**\n>\n> ```\n> 输入：s = \"tryhard\", k = 4\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 10^5`\n> - `s` 由小写英文字母组成\n> - `1 <= k <= s.length`\n>\n> Related Topics\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int cnt=0;\n        for (int i = 0; i < k&&i<s.length(); i++) {\n            cnt+=check(s.charAt(i));\n        }\n        int res=cnt;\n        for (int fast = k; fast < s.length(); fast++) {\n            cnt+=check(s.charAt(fast))-check(s.charAt(fast-k));\n            res=Math.max(res,cnt);\n            if(res==k){\n                return k;\n            }\n        }\n        return res;\n    }\n    int check(char ch){\n        return ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'?1:0;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢2269. 找到一个数字的 K 美丽值 1280\n\n> 一个整数 `num` 的 **k** 美丽值定义为 `num` 中符合以下条件的 **子字符串** 数目：\n>\n> - 子字符串长度为 `k` 。\n> - 子字符串能整除 `num` 。\n>\n> 给你整数 `num` 和 `k` ，请你返回 `num` 的 k 美丽值。\n>\n> 注意：\n>\n> - 允许有 **前缀** **0** 。\n> - `0` 不能整除任何值。\n>\n> 一个 **子字符串** 是一个字符串里的连续一段字符序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 240, k = 2\n> 输出：2\n> 解释：以下是 num 里长度为 k 的子字符串：\n> - \"240\" 中的 \"24\" ：24 能整除 240 。\n> - \"240\" 中的 \"40\" ：40 能整除 240 。\n> 所以，k 美丽值为 2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 430043, k = 2\n> 输出：2\n> 解释：以下是 num 里长度为 k 的子字符串：\n> - \"430043\" 中的 \"43\" ：43 能整除 430043 。\n> - \"430043\" 中的 \"30\" ：30 不能整除 430043 。\n> - \"430043\" 中的 \"00\" ：0 不能整除 430043 。\n> - \"430043\" 中的 \"04\" ：4 不能整除 430043 。\n> - \"430043\" 中的 \"43\" ：43 能整除 430043 。\n> 所以，k 美丽值为 2 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 109`\n> - `1 <= k <= num.length` （将 `num` 视为字符串）\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int divisorSubstrings(int num, int k) {\n        int cnt=0;\n        String string=String.valueOf(num);\n        String cur=\"\";\n        for (int i = k; i <= string.length(); i++) {\n            cur=string.substring(i-k,i);\n            if(Integer.parseInt(cur)!=0&&num%Integer.parseInt(cur)==0){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n-k)*\n- space:*O(1)*\n\n## 🟢1984. 学生分数的最小差值 1306\n\n> 给你一个 **下标从 0 开始** 的整数数组 `nums` ，其中 `nums[i]` 表示第 `i` 名学生的分数。另给你一个整数 `k` 。\n>\n> 从数组中选出任意 `k` 名学生的分数，使这 `k` 个分数间 **最高分** 和 **最低分** 的 **差值** 达到 **最小化** 。\n>\n> 返回可能的 **最小差值** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [90], k = 1\n> 输出：0\n> 解释：选出 1 名学生的分数，仅有 1 种方法：\n> - [90] 最高分和最低分之间的差值是 90 - 90 = 0\n> 可能的最小差值是 0\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [9,4,1,7], k = 2\n> 输出：2\n> 解释：选出 2 名学生的分数，有 6 种方法：\n> - [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5\n> - [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8\n> - [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2\n> - [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3\n> - [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3\n> - [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6\n> 可能的最小差值是 2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= nums.length <= 1000`\n> - `0 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 排序\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {\n        Arrays.sort(nums);\n        int min=nums[nums.length-1]-nums[0];\n        for (int i = k-1; i < nums.length; i++) {\n            min=Math.min(min,nums[i]-nums[i-k+1]);\n        }\n        return min;\n    }\n}\n```\n\n- time:*O(n-k)*\n- space:*O(1)*\n\n## 🟢643. 子数组最大平均数 I\n\n> 给你一个由 `n` 个元素组成的整数数组 `nums` 和一个整数 `k` 。\n>\n> 请你找出平均数最大且 **长度为 `k`** 的连续子数组，并输出该最大平均数。\n>\n> 任何误差小于 `10-5` 的答案都将被视为正确答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,12,-5,-6,50,3], k = 4\n> 输出：12.75\n> 解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5], k = 1\n> 输出：5.00000\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= k <= n <= 105`\n> - `-104 <= nums[i] <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int max=Integer.MIN_VALUE;\n        int sum=0;\n        for (int i = 0; i < k; i++) {\n            sum+=nums[i];\n        }\n        max=sum;\n        for (int i = k; i < nums.length; i++) {\n            sum+=nums[i]-nums[i-k];\n            max=Math.max(max,sum);\n        }\n        return (1.0)*max/k;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡1343. 大小为 K 且平均值大于等于阈值的子数组数目 1317\n\n> 给你一个整数数组 `arr` 和两个整数 `k` 和 `threshold` 。\n>\n> 请你返回长度为 `k` 且平均值大于等于 `threshold` 的子数组数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n> 输出：3\n> 解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n> 输出：6\n> 解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= arr.length <= 105`\n> - `1 <= arr[i] <= 104`\n> - `1 <= k <= arr.length`\n> - `0 <= threshold <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\n        int cnt=0;\n        int sum=0;\n        threshold*=k;\n        for (int i = 0; i < k; i++) {\n            sum+=arr[i];\n        }\n        if(sum>=threshold){\n            cnt++;\n        }\n        for (int i = k; i < arr.length; i++) {\n            sum+=arr[i]-arr[i-k];\n            if(sum>=threshold){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡2090. 半径为 k 的子数组平均值 1358\n\n> 给你一个下标从 **0** 开始的数组 `nums` ，数组中有 `n` 个整数，另给你一个整数 `k` 。\n>\n> **半径为 k 的子数组平均值** 是指：`nums` 中一个以下标 `i` 为 **中心** 且 **半径** 为 `k` 的子数组中所有元素的平均值，即下标在 `i - k` 和 `i + k` 范围（**含** `i - k` 和 `i + k`）内所有元素的平均值。如果在下标 `i` 前或后不足 `k` 个元素，那么 **半径为 k 的子数组平均值** 是 `-1` 。\n>\n> 构建并返回一个长度为 `n` 的数组 `avgs` ，其中 `avgs[i]` 是以下标 `i` 为中心的子数组的 **半径为 k 的子数组平均值** 。\n>\n> `x` 个元素的 **平均值** 是 `x` 个元素相加之和除以 `x` ，此时使用截断式 **整数除法** ，即需要去掉结果的小数部分。\n>\n> - 例如，四个元素 `2`、`3`、`1` 和 `5` 的平均值是 `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75`，截断后得到 `2` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/11/07/eg1.png)\n>\n> ```\n> 输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n> 输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n> 解释：\n> - avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n> - 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n>   使用截断式 整数除法，avg[3] = 37 / 7 = 5 。\n> - 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n> - 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n> - avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [100000], k = 0\n> 输出：[100000]\n> 解释：\n> - 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n>   avg[0] = 100000 / 1 = 100000 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [8], k = 100000\n> 输出：[-1]\n> 解释：\n> - avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 105`\n> - `0 <= nums[i], k <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int[] getAverages(int[] nums, int k) {\n        int len= nums.length;\n        int[]res=new int[len];\n        for (int i = 0; i < k&&i<len; i++) {\n            res[i]=-1;\n            res[len-1-i]=-1;\n        }\n        long sum=0;\n        long div=2*k+1;\n        for (int i = 0; i < div&&i<len; i++) {\n            sum+=nums[i];\n        }\n        if(div<=len){\n            res[k]=(int)(sum/div);\n            for (int i = k+1; i < len-k&&i<len; i++) {\n                sum+=nums[i+k]-nums[i-k-1];\n                res[i]=(int)(sum/div);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢2379. 得到 K 个黑块的最少涂色次数 1360\n\n> 给你一个长度为 `n` 下标从 **0** 开始的字符串 `blocks` ，`blocks[i]` 要么是 `'W'` 要么是 `'B'` ，表示第 `i` 块的颜色。字符 `'W'` 和 `'B'` 分别表示白色和黑色。\n>\n> 给你一个整数 `k` ，表示想要 **连续** 黑色块的数目。\n>\n> 每一次操作中，你可以选择一个白色块将它 **涂成** 黑色块。\n>\n> 请你返回至少出现 **一次** 连续 `k` 个黑色块的 **最少** 操作次数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：blocks = \"WBBWWBBWBW\", k = 7\n> 输出：3\n> 解释：\n> 一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n> 得到 blocks = \"BBBBBBBWBW\" 。\n> 可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n> 所以我们返回 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：blocks = \"WBWBBBW\", k = 2\n> 输出：0\n> 解释：\n> 不需要任何操作，因为已经有 2 个连续的黑块。\n> 所以我们返回 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == blocks.length`\n> - `1 <= n <= 100`\n> - `blocks[i]` 要么是 `'W'` ，要么是 `'B'` 。\n> - `1 <= k <= n`\n>\n> Related Topics\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int minimumRecolors(String blocks, int k) {\n        int cnt=0;\n        for (int i = 0; i <k ; i++) {\n            if(blocks.charAt(i)=='B'){\n                cnt++;\n            }\n        }\n        if(cnt==k){\n            return 0;\n        }\n        int max=cnt;\n        for (int i = k; i < blocks.length(); i++) {\n            if(blocks.charAt(i)=='B'){\n                cnt++;\n            }\n            if(blocks.charAt(i-k)=='B'){\n                cnt--;\n            }\n            if(cnt==k){\n                return 0;\n            }\n            max=Math.max(max,cnt);\n        }\n        return k-max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡1052. 爱生气的书店老板 1418\n\n> 有一个书店老板，他的书店开了 `n` 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 `n` 的整数数组 `customers` ，其中 `customers[i]` 是在第 `i` 分钟开始时进入商店的顾客数量，所有这些顾客在第 `i` 分钟结束后离开。\n>\n> 在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。\n>\n> 当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。\n>\n> 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `minutes` 分钟不生气，但却只能使用一次。\n>\n> 请你返回 *这一天营业下来，最多有多少客户能够感到满意* 。\n>\n> **示例 1：**\n>\n> ```\n> 输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\n> 输出：16\n> 解释：书店老板在最后 3 分钟保持冷静。\n> 感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：customers = [1], grumpy = [0], minutes = 1\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == customers.length == grumpy.length`\n> - `1 <= minutes <= n <= 2 * 104`\n> - `0 <= customers[i] <= 1000`\n> - `grumpy[i] == 0 or 1`\n>\n> Related Topics\n>\n> 数组\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\n        int total=0;\n        int len= grumpy.length;\n        for (int i = 0; i < len; i++) {\n            total+=customers[i]*(1-grumpy[i]);\n        }\n        for (int i = 0; i < minutes; i++) {\n            if(grumpy[i]==1){\n                total+=customers[i];\n            }\n        }\n        int max=total;\n        for (int i = minutes; i < len; i++) {\n            if(grumpy[i]==1){\n                total+=customers[i];\n            }\n            if(grumpy[i-minutes]==1){\n                total-=customers[i-minutes];\n            }\n            max=Math.max(max,total);\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡2841. 几乎唯一子数组的最大和 1546\n\n> 给你一个整数数组 `nums` 和两个正整数 `m` 和 `k` 。\n>\n> 请你返回 `nums` 中长度为 `k` 的 **几乎唯一** 子数组的 **最大和** ，如果不存在几乎唯一子数组，请你返回 `0` 。\n>\n> 如果 `nums` 的一个子数组有至少 `m` 个互不相同的元素，我们称它是 **几乎唯一** 子数组。\n>\n> 子数组指的是一个数组中一段连续 **非空** 的元素序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,6,7,3,1,7], m = 3, k = 4\n> 输出：18\n> 解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3\n> 输出：23\n> 解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3\n> 输出：0\n> 解释：输入数组中不存在长度为 k = 3 的子数组含有至少  m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 2 * 104`\n> - `1 <= m <= k <= nums.length`\n> - `1 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public long maxSum(List<Integer> nums, int m, int k) {\n        Map<Integer,Integer> map=new HashMap<>();\n        long sum=0;\n        for (int i = 0; i < k; i++) {\n            sum+=nums.get(i);\n            int key=nums.get(i);\n            map.put(key,map.getOrDefault(key,0)+1);\n        }\n        long max=0;\n        if(map.size()>=m){\n            max=sum;\n        }\n        for (int i = k; i < nums.size(); i++) {\n            sum+=nums.get(i)-nums.get(i-k);\n            int key=nums.get(i);\n            map.put(key,map.getOrDefault(key,0)+1);\n            key=nums.get(i-k);\n            map.put(key,map.get(key)-1);\n            if(map.get(key)==0){\n                map.remove(key);\n            }\n            if(map.size()>=m){\n                max=Math.max(max,sum);\n            }\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡2461. 长度为 K 子数组中的最大和 1553\n\n> 给你一个整数数组 `nums` 和一个整数 `k` 。请你从 `nums` 中满足下述条件的全部子数组中找出最大子数组和：\n>\n> - 子数组的长度是 `k`，且\n> - 子数组中的所有元素 **各不相同 。**\n>\n> 返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 `0` 。\n>\n> **子数组** 是数组中一段连续非空的元素序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,5,4,2,9,9,9], k = 3\n> 输出：15\n> 解释：nums 中长度为 3 的子数组是：\n> - [1,5,4] 满足全部条件，和为 10 。\n> - [5,4,2] 满足全部条件，和为 11 。\n> - [4,2,9] 满足全部条件，和为 15 。\n> - [2,9,9] 不满足全部条件，因为元素 9 出现重复。\n> - [9,9,9] 不满足全部条件，因为元素 9 出现重复。\n> 因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,4,4], k = 3\n> 输出：0\n> 解释：nums 中长度为 3 的子数组是：\n> - [4,4,4] 不满足全部条件，因为元素 4 出现重复。\n> 因为不存在满足全部条件的子数组，所以返回 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= nums.length <= 105`\n> - `1 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public long maximumSubarraySum(int[] nums, int k) {\n        Map<Integer,Integer> map=new HashMap<>();\n        long sum=0;\n        for (int i = 0; i < k; i++) {\n            sum+=nums[i];\n            int key=nums[i];\n            map.put(key,map.getOrDefault(key,0)+1);\n        }\n        long max=0;\n        if(map.size()==k){\n            max=sum;\n        }\n        for (int i = k; i < nums.length; i++) {\n            sum+=nums[i]-nums[i-k];\n            int key=nums[i];\n            map.put(key,map.getOrDefault(key,0)+1);\n            key=nums[i-k];\n            map.put(key,map.get(key)-1);\n            if(map.get(key)==0){\n                map.remove(key);\n            }\n            if(map.size()==k){\n                max=Math.max(max,sum);\n            }\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡1423.可获得的最大点数 1574\n\n> 几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。\n>\n> 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。\n>\n> 你的点数就是你拿到手中的所有卡牌的点数之和。\n>\n> 给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：cardPoints = [1,2,3,4,5,6,1], k = 3\n> 输出：12\n> 解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：cardPoints = [2,2,2], k = 2\n> 输出：4\n> 解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：cardPoints = [9,7,7,9,7,7,9], k = 7\n> 输出：55\n> 解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：cardPoints = [1,1000,1], k = 1\n> 输出：1\n> 解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 \n> ```\n>\n> **示例 5：**\n>\n> ```\n> 输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3\n> 输出：202\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= cardPoints.length <= 10^5`\n> - `1 <= cardPoints[i] <= 10^4`\n> - `1 <= k <= cardPoints.length`\n>\n> Related Topics\n>\n> 数组\n>\n> 前缀和\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int sum=0;\n        int len=cardPoints.length;\n        for (int i = 0; i < k; i++) {\n            sum+=cardPoints[len-1-i];\n        }\n        int max=sum;\n        for (int i = 0; i < k; i++) {\n            sum+=cardPoints[i]-cardPoints[len-k+i];\n            max=Math.max(max,sum);\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(k)*\n- space:*O(1)*\n\n## 🟡2134. 最少交换次数来组合所有的 1 II 1748\n\n> **交换** 定义为选中一个数组中的两个 **互不相同** 的位置并交换二者的值。\n>\n> **环形** 数组是一个数组，可以认为 **第一个** 元素和 **最后一个** 元素 **相邻** 。\n>\n> 给你一个 **二进制环形** 数组 `nums` ，返回在 **任意位置** 将数组中的所有 `1` 聚集在一起需要的最少交换次数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [0,1,0,1,1,0,0]\n> 输出：1\n> 解释：这里列出一些能够将所有 1 聚集在一起的方案：\n> [0,0,1,1,1,0,0] 交换 1 次。\n> [0,1,1,1,0,0,0] 交换 1 次。\n> [1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。\n> 无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。\n> 因此，需要的最少交换次数为 1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,1,1,0,0,1,1,0]\n> 输出：2\n> 解释：这里列出一些能够将所有 1 聚集在一起的方案：\n> [1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。\n> [1,1,1,1,1,0,0,0,0] 交换 2 次。\n> 无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。\n> 因此，需要的最少交换次数为 2 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,1,0,0,1]\n> 输出：0\n> 解释：得益于数组的环形特性，所有的 1 已经聚集在一起。\n> 因此，需要的最少交换次数为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `nums[i]` 为 `0` 或者 `1`\n>\n> Related Topics\n>\n> 数组\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int minSwaps(int[] nums) {\n        int len= nums.length;\n        int k= Arrays.stream(nums).sum();\n        int sum=0;\n        for (int i = 0; i < k; i++) {\n            sum+=nums[i];\n        }\n        int max=sum;\n        for (int i = k; i < len; i++) {\n            sum+=nums[i]-nums[i-k];\n            max=Math.max(max,sum);\n        }\n        for (int i = 0; i < k; i++) {\n            sum+=nums[i]-nums[len-k+i];\n            max=Math.max(max,sum);\n        }\n        return k-max;\n    }\n}\n```\n\n- time:*O(n+k)*\n- space:*O(1)*\n\n## 🟡2653.滑动子数组的美丽值 1786\n\n> 给你一个长度为 `n` 的整数数组 `nums` ，请你求出每个长度为 `k` 的子数组的 **美丽值** 。\n>\n> 一个子数组的 **美丽值** 定义为：如果子数组中第 `x` **小整数** 是 **负数** ，那么美丽值为第 `x` 小的数，否则美丽值为 `0` 。\n>\n> 请你返回一个包含 `n - k + 1` 个整数的数组，**依次** 表示数组中从第一个下标开始，每个长度为 `k` 的子数组的 **美丽值** 。\n>\n> - 子数组指的是数组中一段连续 **非空** 的元素序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,-1,-3,-2,3], k = 3, x = 2\n> 输出：[-1,-2,-2]\n> 解释：总共有 3 个 k = 3 的子数组。\n> 第一个子数组是 [1, -1, -3] ，第二小的数是负数 -1 。\n> 第二个子数组是 [-1, -3, -2] ，第二小的数是负数 -2 。\n> 第三个子数组是 [-3, -2, 3] ，第二小的数是负数 -2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [-1,-2,-3,-4,-5], k = 2, x = 2\n> 输出：[-1,-2,-3,-4]\n> 解释：总共有 4 个 k = 2 的子数组。\n> [-1, -2] 中第二小的数是负数 -1 。\n> [-2, -3] 中第二小的数是负数 -2 。\n> [-3, -4] 中第二小的数是负数 -3 。\n> [-4, -5] 中第二小的数是负数 -4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [-3,1,2,-3,0,-3], k = 2, x = 1\n> 输出：[-3,0,-3,-3,-3]\n> 解释：总共有 5 个 k = 2 的子数组。\n> [-3, 1] 中最小的数是负数 -3 。\n> [1, 2] 中最小的数不是负数，所以美丽值为 0 。\n> [2, -3] 中最小的数是负数 -3 。\n> [-3, 0] 中最小的数是负数 -3 。\n> [0, -3] 中最小的数是负数 -3 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length `\n> - `1 <= n <= 105`\n> - `1 <= k <= n`\n> - `1 <= x <= k `\n> - `-50 <= nums[i] <= 50 `\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\n```\n\n\n\n## 🟡567. 字符串的排列\n\n> 给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。\n>\n> 换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s1 = \"ab\" s2 = \"eidbaooo\"\n> 输出：true\n> 解释：s2 包含 s1 的排列之一 (\"ba\").\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s1= \"ab\" s2 = \"eidboaoo\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s1.length, s2.length <= 104`\n> - `s1` 和 `s2` 仅包含小写字母\n>\n> Related Topics\n>\n> 哈希表\n>\n> 双指针\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        int k=s1.length();\n        if(s2.length()<k){\n            return false;\n        }\n        int[]starded=new int[26];\n        int[]cnt=new int[26];\n        for (int i = 0; i < k; i++) {\n            starded[s1.charAt(i)-'a']++;\n            cnt[s2.charAt(i)-'a']++;\n        }\n        if(check(cnt,starded)){\n            return true;\n        }\n        for (int i = k; i < s2.length(); i++) {\n            cnt[s2.charAt(i)-'a']++;\n            cnt[s2.charAt(i-k)-'a']--;\n            if(check(cnt,starded)){\n                return true;\n            }\n        }\n        return false;\n    }\n    boolean check(int[] arr1,int[]arr2){\n        for (int i = 0; i < arr1.length; i++) {\n            if(arr1[i]!=arr2[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡438. 找到字符串中所有字母异位词\n\n> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n>\n> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"cbaebabacd\", p = \"abc\"\n> 输出: [0,6]\n> 解释:\n> 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n> 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"abab\", p = \"ab\"\n> 输出: [0,1,2]\n> 解释:\n> 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n> 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n> 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, p.length <= 3 * 104`\n> - `s` 和 `p` 仅包含小写字母\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int k=p.length();\n        List<Integer>res=new ArrayList<>();\n        if(s.length()<p.length()){\n            return res;\n        }\n        int[]standard=new int[26];\n        int[]cur=new int[26];\n        for (int i = 0; i < k; i++) {\n            standard[p.charAt(i)-'a']++;\n            cur[s.charAt(i)-'a']++;\n        }\n        if(check(cur,standard)){\n            res.add(0);\n        }\n        for (int i = k; i < s.length(); i++) {\n            cur[s.charAt(i)-'a']++;\n            cur[s.charAt(i-k)-'a']--;\n            if(check(cur,standard)){\n                res.add(i-k+1);\n            }\n        }\n        return res;\n    }\n    boolean check(int[] arr1,int[]arr2){\n        for (int i = 0; i < arr1.length; i++) {\n            if(arr1[i]!=arr2[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🔴2156.查找给定哈希值的子串 2063\n\n> 给定整数 `p` 和 `m` ，一个长度为 `k` 且下标从 **0** 开始的字符串 `s` 的哈希值按照如下函数计算：\n>\n> - `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`.\n>\n> 其中 `val(s[i])` 表示 `s[i]` 在字母表中的下标，从 `val('a') = 1` 到 `val('z') = 26` 。\n>\n> 给你一个字符串 `s` 和整数 `power`，`modulo`，`k` 和 `hashValue` 。请你返回 `s` 中 **第一个** 长度为 `k` 的 **子串** `sub` ，满足 `hash(sub, power, modulo) == hashValue` 。\n>\n> 测试数据保证一定 **存在** 至少一个这样的子串。\n>\n> **子串** 定义为一个字符串中连续非空字符组成的序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\n> 输出：\"ee\"\n> 解释：\"ee\" 的哈希值为 hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。\n> \"ee\" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 \"ee\" 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\n> 输出：\"fbx\"\n> 解释：\"fbx\" 的哈希值为 hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 。\n> \"bxz\" 的哈希值为 hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 。\n> \"fbx\" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 \"fbx\" 。\n> 注意，\"bxz\" 的哈希值也为 32 ，但是它在字符串中比 \"fbx\" 更晚出现。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= s.length <= 2 * 104`\n> - `1 <= power, modulo <= 109`\n> - `0 <= hashValue < modulo`\n> - `s` 只包含小写英文字母。\n> - 测试数据保证一定 **存在** 满足条件的子串。\n>\n> Related Topics\n>\n> 字符串\n>\n> 滑动窗口\n>\n> 哈希函数\n>\n> 滚动哈希\n\n```java\n```\n\n\n\n## 🔴2953.统计完全子字符串 2449\n\n> 给你一个字符串 `word` 和一个整数 `k` 。\n>\n> 如果 `word` 的一个子字符串 `s` 满足以下条件，我们称它是 **完全字符串：**\n>\n> - `s` 中每个字符 **恰好** 出现 `k` 次。\n> - 相邻字符在字母表中的顺序 **至多** 相差 `2` 。也就是说，`s` 中两个相邻字符 `c1` 和 `c2` ，它们在字母表中的位置相差 **至多** 为 `2` 。\n>\n> 请你返回 `word` 中 **完全** 子字符串的数目。\n>\n> **子字符串** 指的是一个字符串中一段连续 **非空** 的字符序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：word = \"igigee\", k = 2\n> 输出：3\n> 解释：完全子字符串需要满足每个字符恰好出现 2 次，且相邻字符相差至多为 2 ：igigee, igigee, igigee 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：word = \"aaabbbccc\", k = 3\n> 输出：6\n> 解释：完全子字符串需要满足每个字符恰好出现 3 次，且相邻字符相差至多为 2 ：aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc, aaabbbccc 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= word.length <= 105`\n> - `word` 只包含小写英文字母。\n> - `1 <= k <= word.length`\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\n```\n\n\n\n## 🟢346. 数据流中的移动平均值（会员题）\n\n## 🟡1100. 长度为 K 的无重复字符子串（会员题）\n\n## 🟡1852. 每个子数组的数字种类数（会员题）\n\n## 🟡2067. 等计数子串的数量（会员题）\n\n## 🔴2107. 分享 K 个糖果后独特口味的数量（会员题）\n\n## 🔴446. 等差数列划分 II - 子序列\n\n> 给你一个整数数组 `nums` ，返回 `nums` 中所有 **等差子序列** 的数目。\n>\n> 如果一个序列中 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该序列为等差序列。\n>\n> - 例如，`[1, 3, 5, 7, 9]`、`[7, 7, 7, 7]` 和 `[3, -1, -5, -9]` 都是等差序列。\n> - 再例如，`[1, 1, 2, 5, 7]` 不是等差序列。\n>\n> 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。\n>\n> - 例如，`[2,5,10]` 是 `[1,2,1,***2***,4,1,***5\\***,***10***]` 的一个子序列。\n>\n> 题目数据保证答案是一个 **32-bit** 整数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,4,6,8,10]\n> 输出：7\n> 解释：所有的等差子序列为：\n> [2,4,6]\n> [4,6,8]\n> [6,8,10]\n> [2,4,6,8]\n> [4,6,8,10]\n> [2,4,6,8,10]\n> [2,6,10]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [7,7,7,7,7]\n> 输出：16\n> 解释：数组中的任意子序列都是等差子序列。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1  <= nums.length <= 1000`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\n```\n\n\n\n## 🟡718. 最长重复子数组\n\n> 给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n> 输出：3\n> 解释：长度最长的公共子数组是 [3,2,1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n> 输出：5\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 动态规划\n>\n> 滑动窗口\n>\n> 哈希函数\n>\n> 滚动哈希\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int max = 0;\n        for (int i = -(nums2.length - 1); i <= nums1.length - 1; i++) {\n            int len = commonLen(nums1, nums2, i);\n            max = Math.max(max, len);\n        }\n        return max;\n    }\n    int commonLen(int[] nums1, int[] nums2, int offset) {\n        int cnt = 0, max = cnt;\n        int index1 = 0, index2 = 0;\n        if (offset < 0) {\n            index2 = -offset;\n        } else if (offset > 0) {\n            index1 = offset;\n        }\n        while (index1 < nums1.length && index2 < nums2.length) {\n            if (nums1[index1] == nums2[index2]) {\n                cnt++;\n            } else {\n                max = Math.max(max, cnt);\n                cnt = 0;\n            }\n            index1++;\n            index2++;\n        }\n        max = Math.max(max, cnt);\n        return max;\n    }\n}\n```\n\n- time:*O((n+m)·min(n,m))*\n- space:*O(1)*\n\n## 🔴239. 滑动窗口最大值 \n\n> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n>\n> 返回 *滑动窗口中的最大值* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n> 输出：[3,3,5,5,6,7]\n> 解释：\n> 滑动窗口的位置                最大值\n> ---------------               -----\n> [1  3  -1] -3  5  3  6  7       3\n>  1 [3  -1  -3] 5  3  6  7       3\n>  1  3 [-1  -3  5] 3  6  7       5\n>  1  3  -1 [-3  5  3] 6  7       5\n>  1  3  -1  -3 [5  3  6] 7       6\n>  1  3  -1  -3  5 [3  6  7]      7\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1], k = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-104 <= nums[i] <= 104`\n> - `1 <= k <= nums.length`\n>\n> Related Topics\n>\n> 队列\n>\n> 数组\n>\n> 滑动窗口\n>\n> 单调队列\n>\n> 堆（优先队列）\n\n```java\n```\n\n\n\n## 🔴480. 滑动窗口中位数 \n\n\n\n\n\n# 不定长滑动窗口（求最长/最大）\n\n## 🟡3. 无重复字符的最长子串\n\n> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"abcabcbb\"\n> 输出: 3 \n> 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"bbbbb\"\n> 输出: 1\n> 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"pwwkew\"\n> 输出: 3\n> 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n>      请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= s.length <= 5 * 104`\n> - `s` 由英文字母、数字、符号和空格组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int max = 0;\n        Set<Character> set = new HashSet<>();\n        int left = 0, right = 0;\n        while (left < s.length() && right < s.length()) {\n            if (!set.contains(s.charAt(right))) {\n                set.add(s.charAt(right));\n                right++;\n            } else {\n                while (left < s.length() && s.charAt(left) != s.charAt(right)) {\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n                left++;\n                right++;\n            }\n            max = Math.max(max, right - left );\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(26)*\n\n## 🟡1493. 删掉一个元素以后全为 1 的最长子数组 1423\n\n> 给你一个二进制数组 `nums` ，你需要从中删掉一个元素。\n>\n> 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。\n>\n> 如果不存在这样的子数组，请返回 0 。\n>\n> \n>\n> **提示 1：**\n>\n> ```\n> 输入：nums = [1,1,0,1]\n> 输出：3\n> 解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,1,1,0,1,1,0,1]\n> 输出：5\n> 解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,1,1]\n> 输出：2\n> 解释：你必须要删除一个元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `nums[i]` 要么是 `0` 要么是 `1` 。\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int longestSubarray(int[] nums) {\n        int max = 0;\n        int len = nums.length;\n        int left = 0, right = 0;\n        boolean flag = true;\n        while (left < len && right < len) {\n            if (nums[right] == 0 && flag) {// having 0\n                flag = false;\n            } else if (nums[right] == 0) {// move left\n                while (left < nums.length && nums[left] == 1) {\n                    left++;\n                }\n                left++;\n            }\n            max = Math.max(max, right - left);\n            right++;\n        }\n        if(max==len){\n            return max-1;\n        }else {\n            return max;\n        }\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(26)*\n\n## 🟡2730. 找到最长的半重复子字符串 1502\n\n> 给你一个下标从 **0** 开始的字符串 `s` ，这个字符串只包含 `0` 到 `9` 的数字字符。\n>\n> 如果一个字符串 `t` 中至多有一对相邻字符是相等的，那么称这个字符串 `t` 是 **半重复的** 。例如，`0010` 、`002020` 、`0123` 、`2002` 和 `54944` 是半重复字符串，而 `00101022` 和 `1101234883` 不是。\n>\n> 请你返回 `s` 中最长 **半重复** 子字符串的长度。\n>\n> 一个 **子字符串** 是一个字符串中一段连续 **非空** 的字符。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"52233\"\n> 输出：4\n> 解释：最长半重复子字符串是 \"5223\" ，子字符串从 i = 0 开始，在 j = 3 处结束。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"5494\"\n> 输出：4\n> 解释：s 就是一个半重复字符串，所以答案为 4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"1111111\"\n> 输出：2\n> 解释：最长半重复子字符串是 \"11\" ，子字符串从 i = 0 开始，在 j = 1 处结束。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 50`\n> - `'0' <= s[i] <= '9'`\n>\n> Related Topics\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\n```\n\n\n\n## 904. 水果成篮 1516\n\n## 1695. 删除子数组的最大得分 1529\n\n## 2958. 最多 K 个重复元素的最长子数组 1535\n\n## 2024. 考试的最大困扰度 1643\n\n## 1004. 最大连续1的个数 III 1656\n\n## 1438. 绝对差不超过限制的最长连续子数组 1672\n\n## 2401. 最长优雅子数组 1750\n\n## 1658. 将 x 减到 0 的最小操作数 1817\n\n## 1838. 最高频元素的频数 1876\n\n## 2516. 每种字符至少取 K 个 1948\n\n## 2831. 找出最长等值子数组 1976\n\n## 2106. 摘水果 2062\n\n## 1610. 可见点的最大数目 2147\n\n## 2781. 最长合法子字符串的长度 2204\n\n## 2968. 执行操作使频率分数最大 2444\n\n## 395. 至少有 K 个重复字符的最长子串\n\n## 1763. 最长的美好子字符串\n\n## 159. 至多包含两个不同字符的最长子串（会员题）\n\n## 340. 至多包含 K 个不同字符的最长子串（会员题）\n\n# 不定长滑动窗口（求最短/最小）\n\n## 209. 长度最小的子数组\n\n## 1234. 替换子串得到平衡字符串 1878\n\n## 1574. 删除最短的子数组使剩余数组有序 1932\n\n## 76. 最小覆盖子串\n\n## 面试题 17.18. 最短超串\n\n# 不定长滑动窗口（求子数组个数）\n\n## 2799. 统计完全子数组的数目 1398\n\n## 713.乘积小于 K 的子数组\n\n## 1358.包含所有三种字符的子字符串数目 1646\n\n## 2962. 统计最大元素出现至少 K 次的子数组 1701\n\n## 2302. 统计得分小于 K 的子数组数目 1808\n\n## 2537. 统计好子数组的数目 1892\n\n## 2762.不间断子数组 1940\n\n## 2972.统计移除递增子数组的数目 II 2153\n\n## 2743. 计算没有重复字符的子字符串数量（会员题）\n\n# 多指针滑动窗口\n\n## 930. 和相同的二元子数组 1592\n\n## 1248.统计「优美子数组」 1624\n\n## 2563. 统计公平数对的数目 1721\n\n## 1712. 将数组分成三个子数组的方案数 2079\n\n## 2444. 统计定界子数组的数目 2093\n\n## 992. K 个不同整数的子数组 2210\n\n## 1989. 捉迷藏中可捕获的最大人数（会员题）\n\n\n\n#  待定\n\n## 🟢674. 最长连续递增序列\n\n## 🔴943. 最短超级串 \n\n## 🔴632. 最小区间 \n\n## 🟡560. 和为 K 的子数组\n\n## 🔴862. 和至少为 K 的最短子数组\n\n","categories":["algorithm learning"]},{"title":"Recursion","url":"/2024/01/31/algorithm-recursion/","content":"\n| 类型             | 题号                   | 完成 |\n| ---------------- | ---------------------- | ---- |\n| 二叉树相关问题   | 🟢100. 相同的树         | ✅    |\n|                  | 🟢226. 翻转二叉树       | ✅    |\n|                  | 🟢104. 二叉树的最大深度 | ✅    |\n|                  | 🟢543. 二叉树的直径     |      |\n|                  | 🟢617. 合并二叉树       | ✅    |\n|                  | 🟢 572. 另一棵树的子树  |      |\n|                  | 🟢965. 单值二叉树       | ✅    |\n|                  | 🟢101. 对称二叉树       | ✅    |\n| 回溯相关问题     | 🟡39. 组合总和          |      |\n|                  | 🟡46. 全排列            |      |\n|                  | 🟡 79. 单词搜索         |      |\n|                  | 🔴51. N 皇后            |      |\n|                  | 🔴37. 解数独            |      |\n| 动态规划相关问题 | 🟢509. 斐波那契数       | ✅    |\n|                  | 🟢70. 爬楼梯            | ✅    |\n|                  | 🟡53. 最大子数组和      |      |\n|                  | 🟡198. 打家劫舍         |      |\n|                  | 🟡300. 最长递增子序列   |      |\n\n# 二叉树相关问题\t\n\n## 🟢100. 相同的树 \n\n> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。\n>\n> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\n>\n> ```\n> 输入：p = [1,2,3], q = [1,2,3]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\n>\n> ```\n> 输入：p = [1,2], q = [1,null,2]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\n>\n> ```\n> 输入：p = [1,2,1], q = [1,1,2]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 两棵树上的节点数目都在范围 `[0, 100]` 内\n> - `-104 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        } else if (p==null||q==null) {\n            return false;\n        } else if (p.val!=q.val) {\n            return false;\n        }\n        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n    }\n}\n```\n\n\n\n## 🟢226. 翻转二叉树 \n\n> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3,6,9]\n> 输出：[4,7,2,9,6,3,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n>\n> ```\n> 输入：root = [2,1,3]\n> 输出：[2,3,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目范围在 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null){\n            return null;\n        }\n        if(root.left==null&&root.right==null){\n\n        } else if (root.left==null) {\n            root.left=invertTree(root.right);\n            root.right=null;\n        } else if (root.right==null) {\n            root.right=invertTree(root.left);\n            root.left=null;\n        }else {\n            TreeNode temp=root.left;\n            root.left=invertTree(root.right);\n            root.right=invertTree(temp);\n        }\n        return root;\n    }\n}\n```\n\n\n\n## 🟢104. 二叉树的最大深度 \n\n> 给定一个二叉树 `root` ，返回其最大深度。\n>\n> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\n>\n> \n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：3\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1,null,2]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数量在 `[0, 104]` 区间内。\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n}\n```\n\n\n\n## 🟢543. 二叉树的直径 \n\n> 给你一棵二叉树的根节点，返回该树的 **直径** 。\n>\n> 二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。\n>\n> 两节点之间路径的 **长度** 由它们之间边数表示。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\n>\n> ```\n> 输入：root = [1,2,3,4,5]\n> 输出：3\n> 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1,2]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[1, 104]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n```java\n```\n\n\n\n##  🟢617. 合并二叉树\n\n> 给你两棵二叉树： `root1` 和 `root2` 。\n>\n> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。\n>\n> 返回合并后的二叉树。\n>\n> **注意:** 合并过程必须从两个树的根节点开始。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)\n>\n> ```\n> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n> 输出：[3,4,5,5,4,null,7]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root1 = [1], root2 = [1,2]\n> 输出：[2,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 两棵树中的节点数目在范围 `[0, 2000]` 内\n> - `-104 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        if(root1==null&&root2==null){\n            return null;\n        } else if (root1==null) {\n            return root2;\n        } else if (root2==null) {\n            return root1;\n        }else {\n            root1.val+=root2.val;\n            root1.left=mergeTrees(root1.left,root2.left);\n            root1.right=mergeTrees(root1.right,root2.right);\n            return root1;\n        }\n    }\n}\n```\n\n\n\n## 🟢 572. 另一棵树的子树 \n\n> 给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> 二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)\n>\n> ```\n> 输入：root = [3,4,5,1,2], subRoot = [4,1,2]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)\n>\n> ```\n> 输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `root` 树上的节点数量范围是 `[1, 2000]`\n> - `subRoot` 树上的节点数量范围是 `[1, 1000]`\n> - `-104 <= root.val <= 104`\n> - `-104 <= subRoot.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n>\n> 字符串匹配\n>\n> 哈希函数\n\n```java\n```\n\n\n\n## 🟢965. 单值二叉树\n\n> 如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。\n>\n> 只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png)\n>\n> ```\n> 输入：[1,1,1,1,1,null,1]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png)\n>\n> ```\n> 输入：[2,2,2,5,2]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> 1. 给定树的节点数范围是 `[1, 100]`。\n> 2. 每个节点的值都是整数，范围为 `[0, 99]` 。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        if(root.left!=null&&root.left.val!=root.val){\n            return false;\n        }\n        if(root.right!=null&&root.right.val!=root.val){\n            return false;\n        }\n        if(root.left==null&&root.right==null){\n            return true;\n        } else if (root.left==null) {\n            return isUnivalTree(root.right);\n        } else if (root.right==null) {\n            return isUnivalTree(root.left);\n        }else {\n            return isUnivalTree(root.left)&&isUnivalTree(root.right);\n        }\n    }\n}\n```\n\n\n\n## 🟢101. 对称二叉树\n\n> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)\n>\n> ```\n> 输入：root = [1,2,2,3,4,4,3]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)\n>\n> ```\n> 输入：root = [1,2,2,null,3,null,3]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[1, 1000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶：**你可以运用递归和迭代两种方法解决这个问题吗？\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isSame(root.left,root.right);\n    }\n    boolean isSame(TreeNode root1,TreeNode root2){\n        if(root1==null&&root2==null){\n            return true;\n        } else if (root1==null||root2==null) {\n            return false;\n        }else {\n            return root1.val==root2.val&&isSame(root1.left,root2.right)&&isSame(root1.right,root2.left);\n        }\n    }\n}\n```\n\n#  回溯相关问题\n\n##  🟡39. 组合总和 \n\n> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。\n>\n> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n>\n> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：candidates = [2,3,6,7], target = 7\n> 输出：[[2,2,3],[7]]\n> 解释：\n> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n> 7 也是一个候选， 7 = 7 。\n> 仅有这两种组合。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: candidates = [2,3,5], target = 8\n> 输出: [[2,2,2,2],[2,3,3],[3,5]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入: candidates = [2], target = 1\n> 输出: []\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= candidates.length <= 30`\n> - `2 <= candidates[i] <= 40`\n> - `candidates` 的所有元素 **互不相同**\n> - `1 <= target <= 40`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\n```\n\n\n\n## 🟡46. 全排列 \n\n## 🟡 79. 单词搜索\n\n## 🔴51. N 皇后 \n\n## 🔴37. 解数独\n\n#  动态规划相关问题\t\n\n## 🟢509. 斐波那契数\n\n> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n>\n> ```\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n> ```\n>\n> 给定 `n` ，请计算 `F(n)` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 2\n> 输出：1\n> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 3\n> 输出：2\n> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：n = 4\n> 输出：3\n> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= n <= 30`\n>\n> Related Topics\n>\n> 递归\n>\n> 记忆化搜索\n>\n> 数学\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n==0){\n            return 0;\n        }else if(n==1||n==2){\n            return 1;\n        } else  {\n            return fib(n-1)+fib(n-2);\n        }\n    }\n}\n```\n\n\n\n## 🟢70. 爬楼梯\n\n> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n>\n> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 2\n> 输出：2\n> 解释：有两种方法可以爬到楼顶。\n> 1. 1 阶 + 1 阶\n> 2. 2 阶\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 3\n> 输出：3\n> 解释：有三种方法可以爬到楼顶。\n> 1. 1 阶 + 1 阶 + 1 阶\n> 2. 1 阶 + 2 阶\n> 3. 2 阶 + 1 阶\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 45`\n>\n> Related Topics\n>\n> 记忆化搜索\n>\n> 数学\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        int[]dp=new int[n+2];\n        dp[1]=1;\n        dp[2]=2;\n        for (int i = 3; i <= n; i++) {\n            dp[i]=dp[i-1]+dp[i-2];\n        }\n        return dp[n];\n    }\n}\n```\n\n\n\n## 🟡53. 最大子数组和\n\n> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n> **子数组** 是数组中的一个连续部分。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：1\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [5,4,-1,7,8]\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-104 <= nums[i] <= 104`\n>\n> \n>\n> **进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 动态规划\n\n```java\n```\n\n\n\n## 🟡198. 打家劫舍 \n\n## 🟡300. 最长递增子序列\n\n\n\n","categories":["algorithm learning"]},{"title":"🟢2670.find the distinct difference-array","url":"/2024/01/31/coding-2670-find-the-distinct-difference-array/","content":"\n# Description\n\n> 给你一个下标从 **0** 开始的数组 `nums` ，数组长度为 `n` 。\n>\n> `nums` 的 **不同元素数目差** 数组可以用一个长度为 `n` 的数组 `diff` 表示，其中 `diff[i]` 等于前缀 `nums[0, ..., i]` 中不同元素的数目 **减去** 后缀 `nums[i + 1, ..., n - 1]` 中不同元素的数目。\n>\n> 返回 `nums` 的 **不同元素数目差** 数组。\n>\n> 注意 `nums[i, ..., j]` 表示 `nums` 的一个从下标 `i` 开始到下标 `j` 结束的子数组（包含下标 `i` 和 `j` 对应元素）。特别需要说明的是，如果 `i > j` ，则 `nums[i, ..., j]` 表示一个空子数组。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5]\n> 输出：[-3,-1,1,3,5]\n> 解释：\n> 对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 4 个不同的元素。因此，diff[0] = 1 - 4 = -3 。\n> 对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n> 对于 i = 2，前缀中有 3 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 3 - 2 = 1 。\n> 对于 i = 3，前缀中有 4 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 4 - 1 = 3 。\n> 对于 i = 4，前缀中有 5 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 5 - 0 = 5 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,3,4,2]\n> 输出：[-2,-1,0,2,3]\n> 解释：\n> 对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[0] = 1 - 3 = -2 。\n> 对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n> 对于 i = 2，前缀中有 2 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 2 - 2 = 0 。\n> 对于 i = 3，前缀中有 3 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 3 - 1 = 2 。\n> 对于 i = 4，前缀中有 3 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 3 - 0 = 3 。 \n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n == nums.length <= 50`\n> - `1 <= nums[i] <= 50`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n# Solution\n\n```java\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int len= nums.length;\n        int[]res=new int[len];\n        for (int i = 0; i < len; i++) {\n            Set<Integer> set1=new HashSet<>();\n            for (int j = 0; j <= i; j++) {\n                set1.add(nums[j]);\n            }\n            Set<Integer>set2=new HashSet<>();\n            for (int j = i+1; j < len; j++) {\n                set2.add(nums[j]);\n            }\n            res[i]=set1.size()-set2.size();\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n)*：\n\n# Better Solution\n\n```java\nclass Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        int n = nums.length;\n        int[] sum = new int[n];\n        for (int i = 0; i < n; i++) {\n            set.add(nums[i]); \n            sum[i] = set.size();\n        } \n        set.clear(); \n        for (int i = n - 1; i >= 0; i--) { \n            sum[i] = sum[i] - set.size(); \n            set.add(nums[i]);\n        }\n        return sum;\n    } \n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Array","algorithm-HashTable"]},{"title":"🟡402.remove k digits","url":"/2024/01/28/coding-402-remove-k-digits/","content":"\n# Description\n\n> 给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。\n>\n>  \n>\n> **示例 1 ：**\n>\n> ```\n> 输入：num = \"1432219\", k = 3\n> 输出：\"1219\"\n> 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。\n> ```\n>\n> **示例 2 ：**\n>\n> ```\n> 输入：num = \"10200\", k = 1\n> 输出：\"200\"\n> 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n> ```\n>\n> **示例 3 ：**\n>\n> ```\n> 输入：num = \"10\", k = 2\n> 输出：\"0\"\n> 解释：从原数字移除所有的数字，剩余为空就是 0 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= k <= num.length <= 105`\n> - `num` 仅由若干位数字（0 - 9）组成\n> - 除了 **0** 本身之外，`num` 不含任何前导零\n\n# Solution\n\n```java\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        int len=num.length();\n        Stack<Character>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            char ch=num.charAt(i);\n            while (!stack.isEmpty()&&k>0&&stack.peek()>ch){\n                stack.pop();\n                k--;\n            }\n            stack.push(num.charAt(i));\n        }\n        for (int i = 0; i < k; i++) {\n            stack.pop();\n        }\n        StringBuilder res=new StringBuilder();\n        int size=stack.size();\n        boolean flag=true;\n        for (Character character : stack) {\n            if(character=='0'&&flag){\n                continue;\n            }\n            if(character!='0'){\n                flag=false;\n            }\n            res.append(character);\n        }\n        return res.isEmpty()?\"0\":res.toString();\n    }\n}\n```\n\n- time: *O(n)*\n- space:*O(n)*\n","tags":["algorithm-Stack","algorithm-String","algorithm-Greedy","algorithm-Monotone Stack"]},{"title":"🟡316. remove duplicate letters","url":"/2024/01/28/coding-316-remove-duplicate-letters/","content":"\n# Description\n\n> 给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"bcabc\"\n> 输出：\"abc\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"cbacdcbc\"\n> 输出：\"acdb\"\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 由小写英文字母组成\n\n# Solution\n\n```java\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        Stack<Character>stack=new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch=s.charAt(i);\n            if(stack.contains(ch)){\n                continue;\n            }\n            while(!stack.isEmpty()&&stack.peek()>ch&&s.indexOf(stack.peek(),i)!=-1){\n                stack.pop();\n            }\n            stack.push(ch);\n        }\n        int size= stack.size();\n        char[]res=new char[size];\n        for (int i = 0; i < size; i++) {\n            res[i]=stack.get(i);\n        }\n        return String.copyValueOf(res);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n","tags":["algorithm-Stack","algorithm-String","algorithm-Greedy","algorithm-Monotone Stack"]},{"title":"🔹382th LeetCode Weekly Contest","url":"/2024/01/28/contest-weekly-382/","content":"\n|      | score | problem                             | tag                           |\n| ---- | ----- | ----------------------------------- | ----------------------------- |\n| ✅    | 2     | 🟢按键变更的次数                     | string                        |\n|      | 4     | 🟡子集中元素的最大数量               | string array enum             |\n|      | 5     | 🟡Alice 和 Bob 玩鲜花游戏            | math                          |\n|      | 8     | 🔴给定操作次数内使剩余元素的或值最小 | array greedy bit-manipulation |\n\n# 🟢按键变更的次数\n\n> 给你一个下标从 **0** 开始的字符串 `s` ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 `s = \"ab\"` 表示按键变更一次，而 `s = \"bBBb\"` 不存在按键变更。\n>\n> 返回用户输入过程中按键变更的次数。\n>\n> **注意：**`shift` 或 `caps lock` 等修饰键不计入按键变更，也就是说，如果用户先输入字母 `'a'` 然后输入字母 `'A'` ，不算作按键变更。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"aAbBcC\"\n> 输出：2\n> 解释： \n> 从 s[0] = 'a' 到 s[1] = 'A'，不存在按键变更，因为不计入 caps lock 或 shift 。\n> 从 s[1] = 'A' 到 s[2] = 'b'，按键变更。\n> 从 s[2] = 'b' 到 s[3] = 'B'，不存在按键变更，因为不计入 caps lock 或 shift 。\n> 从 s[3] = 'B' 到 s[4] = 'c'，按键变更。\n> 从 s[4] = 'c' 到 s[5] = 'C'，不存在按键变更，因为不计入 caps lock 或 shift 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"AaAaAaaA\"\n> 输出：0\n> 解释： 不存在按键变更，因为这个过程中只按下字母 'a' 和 'A' ，不需要进行按键变更。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= s.length <= 100`\n> - `s` 仅由英文大写字母和小写字母组成。\n\n```java\nclass Solution {\n    public int countKeyChanges(String s) {\n        int res=0;\n        s=s.toLowerCase();\n        for (int i = 1; i < s.length(); i++) {\n            if(s.charAt(i)!=s.charAt(i-1)){\n                res++;\n            }\n        }\n        return  res;\n    }\n}\n```\n\n\n\n# 🟡子集中元素的最大数量\n\n> 给你一个 **正整数** 数组 `nums` 。\n>\n> 你需要从数组中选出一个满足下述条件的\n>\n> 子集\n>\n> ：\n>\n> \n>\n> - 你可以将选中的元素放置在一个下标从 **0** 开始的数组中，并使其遵循以下模式：`[x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x]`（**注意**，`k` 可以是任何 **非负** 的 2 的幂）。例如，`[2, 4, 16, 4, 2]` 和 `[3, 9, 3]` 都符合这一模式，而 `[2, 4, 8, 4, 2]` 则不符合。\n>\n> 返回满足这些条件的子集中，元素数量的 **最大值** *。*\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,4,1,2,2]\n> 输出：3\n> 解释：选择子集 {4,2,2} ，将其放在数组 [2,4,2] 中，它遵循该模式，且 22 == 4 。因此答案是 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,3,2,4]\n> 输出：1\n> 解释：选择子集 {1}，将其放在数组 [1] 中，它遵循该模式。因此答案是 1 。注意我们也可以选择子集 {2} 、{4} 或 {3} ，可能存在多个子集都能得到相同的答案。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 105`\n> - `1 <= nums[i] <= 109`\n\n```java\n```\n\n\n\n# 🟡Alice 和 Bob 玩鲜花游戏\n\n> Alice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 `x` 朵鲜花，逆时针有 `y` 朵鲜花。\n>\n> 游戏过程如下：\n>\n> 1. Alice 先行动。\n> 2. 每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。\n> 3. 一次行动结束后，如果所有鲜花都被摘完了，那么 **当前** 玩家抓住对手并赢得游戏的胜利。\n>\n> 给你两个整数 `n` 和 `m` ，你的任务是求出满足以下条件的所有 `(x, y)` 对：\n>\n> - 按照上述规则，Alice 必须赢得游戏。\n> - Alice 顺时针方向上的鲜花数目 `x` 必须在区间 `[1,n]` 之间。\n> - Alice 逆时针方向上的鲜花数目 `y` 必须在区间 `[1,m]` 之间。\n>\n> 请你返回满足题目描述的数对 `(x, y)` 的数目。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 3, m = 2\n> 输出：3\n> 解释：以下数对满足题目要求：(1,2) ，(3,2) ，(2,1) 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1, m = 1\n> 输出：0\n> 解释：没有数对满足题目要求。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= n, m <= 105`\n\n```java\n```\n\n\n\n# 🔴给定操作次数内使剩余元素的或值最小\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。\n>\n> 一次操作中，你可以选择 `nums` 中满足 `0 <= i < nums.length - 1` 的一个下标 `i` ，并将 `nums[i]` 和 `nums[i + 1]` 替换为数字 `nums[i] & nums[i + 1]` ，其中 `&` 表示按位 `AND` 操作。\n>\n> 请你返回 **至多** `k` 次操作以内，使 `nums` 中所有剩余元素按位 `OR` 结果的 **最小值** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,5,3,2,7], k = 2\n> 输出：3\n> 解释：执行以下操作：\n> 1. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [1,3,2,7] 。\n> 2. 将 nums[2] 和 nums[3] 替换为 (nums[2] & nums[3]) ，得到 nums 为 [1,3,2] 。\n> 最终数组的按位或值为 3 。\n> 3 是 k 次操作以内，可以得到的剩余元素的最小按位或值。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [7,3,15,14,2,8], k = 4\n> 输出：2\n> 解释：执行以下操作：\n> 1. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [3,15,14,2,8] 。\n> 2. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [3,14,2,8] 。\n> 3. 将 nums[0] 和 nums[1] 替换为 (nums[0] & nums[1]) ，得到 nums 为 [2,2,8] 。\n> 4. 将 nums[1] 和 nums[2] 替换为 (nums[1] & nums[2]) ，得到 nums 为 [2,0] 。\n> 最终数组的按位或值为 2 。\n> 2 是 k 次操作以内，可以得到的剩余元素的最小按位或值。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [10,7,10,3,9,14,9,4], k = 1\n> 输出：15\n> 解释：不执行任何操作，nums 的按位或值为 15 。\n> 15 是 k 次操作以内，可以得到的剩余元素的最小按位或值。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `0 <= nums[i] < 230`\n> - `0 <= k < nums.length`\n\n```java\n```\n\n","tags":["contest"]},{"title":"Hashtable","url":"/2024/01/27/java-collection-hashtable/","content":"\n![image-20240127193003913](java-collection-hashtable/image-20240127193003913.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"Treeap","url":"/2024/01/27/java-collection-treemap/","content":"\n![image-20240127192344010](java-collection-treemap/image-20240127192344010.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"LinkedHashMap⭐","url":"/2024/01/27/java-collection-linkedhashmap/","content":"\n![image-20240127192740571](java-collection-linkedhashmap/image-20240127192740571.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"ConcurrentHashMap⭐","url":"/2024/01/27/java-collection-concurrenthashmap/","content":"\n![image-20240127193505579](java-collection-concurrenthashmap/image-20240127193505579.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"HashMap⭐","url":"/2024/01/27/java-collection-hashmap/","content":"\n![image-20240127192535019](java-collection-hashmap/image-20240127192535019.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"LinkedHashSet","url":"/2024/01/27/java-collection-linkedhashset/","content":"\n![image-20240127192803822](java-collection-linkedhashset/image-20240127192803822.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"TreeSet","url":"/2024/01/27/java-collection-treeset/","content":"\n![image-20240127192240839](java-collection-treeset/image-20240127192240839.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"HashSet","url":"/2024/01/27/java-collection-hashset/","content":"\n![image-20240127192942908](java-collection-hashset/image-20240127192942908.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"DelayQueue⭐","url":"/2024/01/27/java-collection-delayqueue/","content":"\n![image-20240127193617441](java-collection-delayqueue/image-20240127193617441.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"ArrayBlockingQueue⭐","url":"/2024/01/27/java-collection-arrayblockingqueue/","content":"\n![image-20240127193426405](java-collection-arrayblockingqueue/image-20240127193426405.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"PriorityQueue⭐","url":"/2024/01/27/java-collection-priorityqueue/","content":"\n![image-20240127191059542](java-collection-priorityqueue/image-20240127191059542.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"ArrayDeque","url":"/2024/01/27/java-collection-arraydeque/","content":"\n![image-20240127190929640](java-collection-arraydeque/image-20240127190929640.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"Stack","url":"/2024/01/27/java-collection-stack/","content":"\n![image-20240127190822755](java-collection-stack/image-20240127190822755.png)\n\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"Vector","url":"/2024/01/27/java-collection-vector/","content":"\n![image-20240127190637841](java-collection-vector/image-20240127190637841.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"LinkedList⭐","url":"/2024/01/27/java-collection-linkedlist/","content":"\n\n\n![image-20240127190349455](java-collection-linkedlist/image-20240127190349455.png)\n\n# 实现的接口\n\n| 接口名               | 意义                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| List<E>              | 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问 |\n| Deque<E>             | 继承自 `Queue` 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构 |\n| Cloneable            | 表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作               |\n| java.io.Serializable | 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便 |\n\n# 成员变量\n\n| 是否可变(final) | 成员变量名                        | 变量类型 | 含义                                                         | 值                   |\n| --------------- | --------------------------------- | -------- | ------------------------------------------------------------ | -------------------- |\n| 🔒               | serialVersionUID                  | long     | 用于序列化版本管理                                           | 8683452581122892189L |\n| 🔒               | DEAFAULT_CAPACITY                 | int      | 默认初始容量大小                                             | 10                   |\n| 🔒               | EMPTY_ELEMENTDATA                 | Object[] | 空数组（用于空实例）                                         | {}                   |\n| 🔒               | DEFAULTCAPACITY_EMPTY_ELEMENTDATA | Object[] | 用于默认大小空实例的共享空数组实例。    把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少 | {}                   |\n| 🔓               | elementData                       | Object[] | 保存ArrayList数据的数组                                      |                      |\n| 🔓               | size                              | int      | Array                                                        |                      |\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"CopyOnWriteArrayList⭐","url":"/2024/01/27/java-collection-copyonwritearraylist/","content":"\n![image-20240127193324341](java-collection-copyonwritearraylist/image-20240127193324341.png)\n","tags":["reading notes"],"categories":["Java Collection"]},{"title":"ArrayList ⭐","url":"/2024/01/27/java-collection-arraylist/","content":"\n\n\n![image-20240126232307898](java-collection-arraylist/image-20240126232307898.png)\n\n# 实现的接口\n\n| 接口名               | 意义                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| List<E>              | 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问 |\n| RandomAccess         | 表明可以通过元素的序号快速获取元素对象，就是快速随机访问     |\n| Cloneable            | 表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作               |\n| java.io.Serializable | 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便 |\n\n# 成员变量\n\n| 是否可变(final) | 成员变量名                        | 变量类型 | 含义                                                         | 值                   |\n| --------------- | --------------------------------- | -------- | ------------------------------------------------------------ | -------------------- |\n| 🔒               | serialVersionUID                  | long     | 用于序列化版本管理                                           | 8683452581122892189L |\n| 🔒               | DEAFAULT_CAPACITY                 | int      | 默认初始容量大小                                             | 10                   |\n| 🔒               | EMPTY_ELEMENTDATA                 | Object[] | 空数组（用于空实例）                                         | {}                   |\n| 🔒               | DEFAULTCAPACITY_EMPTY_ELEMENTDATA | Object[] | 用于默认大小空实例的共享空数组实例。    把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少 | {}                   |\n| 🔓               | elementData                       | Object[] | 保存ArrayList数据的数组                                      |                      |\n| 🔓               | size                              | int      | ArrayList 所包含的元素个数                                   |                      |\n\n# 构造函数\n\n| name                                 | return | time | space              |\n| ------------------------------------ | ------ | ---- | ------------------ |\n| ArrayList(int initialCapacity)       | Object | O(1) | O(initialCapacity) |\n| ArrayList()                          | Object | O(1) | O(1)               |\n| ArrayList(Collection<? extends E> c) | Object |      |                    |\n\n\n\n## ArrayList(int initialCapacity)\n\n带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n\n```java\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        //如果传入的参数大于0，创建initialCapacity大小的数组\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        //如果传入的参数等于0，创建空数组\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        //其他情况，抛出异常\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+initialCapacity);\n    }\n}\n```\n\n## ArrayList()\n\n默认无参构造函数 \n\nDEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n\n```java\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n## ArrayList(Collection<? extends E> c)\n\n构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    //将指定集合转换为数组\n    Object[] a = c.toArray();\n    //如果elementData数组的长度不为0\n    if ((size = a.length) != 0) {\n        // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）\n        if (c.getClass() == ArrayList.class) { \n            //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组\n            elementData = a;\n        } else {\n            // 其他情况，用空数组代替\n            elementData = Arrays.copyOf(a, size, Object[].class);\n        }\n    } else {\n        elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n# 成员函数\n\n## 私有方法部分⭐\n\n### trimToSize函数\n\n用于将列表的容量调整为当前元素数量的大小，它的主要意义在于优化内存使用。\n\n```java\npublic void trimToSize() {\n    //modCount 是 ArrayList 类中的一个字段，用于表示对该列表进行结构性修改的次数。它是用于支持 fail-fast 机制的一部分。\n\n\t//modCount 的含义是，在对 ArrayList 进行结构性修改（如添加、删除元素）时，每次修改都会使 modCount 的值递增。这样，在进行迭代操作时，可以检查 modCount 是否与迭代器期望的值相等。如果不相等，就意味着在迭代过程中列表的结构发生了修改，可能会导致迭代器的操作不正确，因此会抛出 ConcurrentModificationException 异常。\n\n\t//通过比较 modCount 的值和迭代器的期望值，可以帮助识别潜在的并发修改问题，进而提供代码的稳定性和可靠性。\n\n\t//需要注意的是，对列表进行的某些非结构性修改操作（如修改元素的值）不会增加 modCount 的计数，因为这些操作并不会影响列表的结构。\n    modCount++;\n    if (size < elementData.length) {\n        elementData = (size == 0)\n            ? EMPTY_ELEMENTDATA\n            : Arrays.copyOf(elementData, size);\n    }\n}\n```\n\n### ensureCapacity函数\n\n用于确保 ArrayList 的容量至少达到指定值。如果当前容量小于指定值，则会进行扩容操作。\n\n```java\npublic void ensureCapacity(int minCapacity) {\n    if (minCapacity > elementData.length\n        && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n        && minCapacity <= DEFAULT_CAPACITY)) {\n        modCount++;\n        grow(minCapacity);\n    }\n}\n```\n\n### grow函数\n\n用于实现 ArrayList 的动态扩容\n\n```java\nprivate Object[] grow(int minCapacity) {\n    //获取当前数组的容量 oldCapacity\n    int oldCapacity = elementData.length;\n    //如果当前数组容量大于 0 或者当前数组不是使用默认容量的空数组，则计算新的容量大小 newCapacity\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        //新的容量大小由 ArraysSupport.newLength() 方法决定，它根据最小增长需求 minCapacity - oldCapacity 和合适的增长率 oldCapacity >> 1（当前容量的一半）来确定新的容量大小\n        int newCapacity = ArraysSupport.newLength(oldCapacity,\n                         minCapacity - oldCapacity, /* 最小增长需求 */ \n                         oldCapacity >> 1 /* 合适的增长率*/);\n        //将旧数组的元素复制到新数组，并将新数组赋值给 elementData。最后，返回新的数组。\n        return elementData = Arrays.copyOf(elementData, newCapacity);\n    } else {\n        //\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n    }\n}\nprivate Object[] grow() {\n    //是 grow(int minCapacity) 方法的简化版本，它调用 grow(size + 1) 来根据 ArrayList 的当前元素数量进行扩容。这样可以确保有足够的空间来添加一个新元素\n    return grow(size + 1);\n}\n```\n\nArraysSupport类部分代码：\n\n```java\npublic static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n\npublic static int newLength(int oldLength, int minGrowth, int prefGrowth) {\n    // 由于内联，未检查前提条件\n    // 假定 oldLength >= 0\n    // 假定 minGrowth > 0\n\n    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // 可能会溢出\n    if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {\n        return prefLength;\n    } else {\n        // 将代码放入单独的方法中\n        return hugeLength(oldLength, minGrowth);\n    }\n}\n\nprivate static int hugeLength(int oldLength, int minGrowth) {\n    int minLength = oldLength + minGrowth;\n    if (minLength < 0) { // 溢出\n        throw new OutOfMemoryError(\n            \"Required array length \" + oldLength + \" + \" + minGrowth + \" is too large\");\n    } else if (minLength <= SOFT_MAX_ARRAY_LENGTH) {\n        return SOFT_MAX_ARRAY_LENGTH;\n    } else {\n        return minLength;\n    }\n}\n```\n\n## 实现 List 接口的方法\n\n```java\npublic int size() {\n    return size;\n}\n    \npublic boolean isEmpty() {\n    return size == 0;\n}\n\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n\npublic int indexOf(Object o) {\n    return indexOfRange(o, 0, size);\n}\n\nint indexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    if (o == null) {\n        for (int i = start; i < end; i++) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = start; i < end; i++) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\npublic int lastIndexOf(Object o) {\n    return lastIndexOfRange(o, 0, size);\n}\n\nint lastIndexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    if (o == null) {\n        for (int i = end - 1; i >= start; i--) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    } else {\n        for (int i = end - 1; i >= start; i--) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\npublic Object clone() {\n    try {\n        ArrayList<?> v = (ArrayList<?>) super.clone();\n        v.elementData = Arrays.copyOf(elementData, size);\n        v.modCount = 0;\n        return v;\n    } catch (CloneNotSupportedException e) {\n        // 这不应该发生，因为我们是可克隆的\n        throw new InternalError(e);\n    }\n}\n\n   \npublic Object[] toArray() {\n    return Arrays.copyOf(elementData, size);\n}\n\n    \n@SuppressWarnings(\"unchecked\")\npublic <T> T[] toArray(T[] a) {\n    if (a.length < size)\n        // 为a的运行时类型创建一个新数组，但我的内容：\n        return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n    System.arraycopy(elementData, 0, a, 0, size);\n    if (a.length > size)\n        a[size] = null;\n    return a;\n}\n\n@SuppressWarnings(\"unchecked\")\nE elementData(int index) {\n    return (E) elementData[index];\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <E> E elementAt(Object[] es, int index) {\n    return (E) es[index];\n}\n\npublic E get(int index) {\n    Objects.checkIndex(index, size);\n    return elementData(index);\n}\n\npublic E set(int index, E element) {\n    Objects.checkIndex(index, size);\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n\n\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\n    \npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    modCount++;\n    final int s;\n    Object[] elementData;\n    if ((s = size) == (elementData = this.elementData).length)\n        elementData = grow();\n    System.arraycopy(elementData, index,\n                     elementData, index + 1,\n                     s - index);\n    elementData[index] = element;\n    size = s + 1;\n}\n\npublic E remove(int index) {\n    Objects.checkIndex(index, size);\n    final Object[] es = elementData;\n\n    @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];\n    fastRemove(es, index);\n\n    return oldValue;\n}\n\n/**\n     * {@inheritDoc}\n     */\npublic boolean equals(Object o) {\n    if (o == this) {\n        return true;\n    }\n\n    if (!(o instanceof List)) {\n        return false;\n    }\n\n    final int expectedModCount = modCount;\n    // ArrayList可以被子类化并被赋予任意行为，但我们仍然可以处理o是ArrayList的常见情况\n    boolean equal = (o.getClass() == ArrayList.class)\n        ? equalsArrayList((ArrayList<?>) o)\n        : equalsRange((List<?>) o, 0, size);\n\n    checkForComodification(expectedModCount);\n    return equal;\n}\n\nboolean equalsRange(List<?> other, int from, int to) {\n    final Object[] es = elementData;\n    if (to > es.length) {\n        throw new ConcurrentModificationException();\n    }\n    var oit = other.iterator();\n    for (; from < to; from++) {\n        if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {\n            return false;\n        }\n    }\n    return !oit.hasNext();\n}\n\nprivate boolean equalsArrayList(ArrayList<?> other) {\n    final int otherModCount = other.modCount;\n    final int s = size;\n    boolean equal;\n    if (equal = (s == other.size)) {\n        final Object[] otherEs = other.elementData;\n        final Object[] es = elementData;\n        if (s > es.length || s > otherEs.length) {\n            throw new ConcurrentModificationException();\n        }\n        for (int i = 0; i < s; i++) {\n            if (!Objects.equals(es[i], otherEs[i])) {\n                equal = false;\n                break;\n            }\n        }\n    }\n    other.checkForComodification(otherModCount);\n    return equal;\n    }\n\nprivate void checkForComodification(final int expectedModCount) {\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n/**\n     * {@inheritDoc}\n     */\npublic int hashCode() {\n    int expectedModCount = modCount;\n    int hash = hashCodeRange(0, size);\n    checkForComodification(expectedModCount);\n    return hash;\n}\n\nint hashCodeRange(int from, int to) {\n    final Object[] es = elementData;\n    if (to > es.length) {\n        throw new ConcurrentModificationException();\n    }\n    int hashCode = 1;\n    for (int i = from; i < to; i++) {\n        Object e = es[i];\n        hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n    }\n    return hashCode;\n}\n\npublic boolean remove(Object o) {\n    final Object[] es = elementData;\n    final int size = this.size;\n    int i = 0;\n    found: {\n        if (o == null) {\n            for (; i < size; i++)\n                if (es[i] == null)\n                    break found;\n        } else {\n            for (; i < size; i++)\n                if (o.equals(es[i]))\n                    break found;\n        }\n        return false;\n    }\n    fastRemove(es, i);\n    return true;\n}\n\n\nprivate void fastRemove(Object[] es, int i) {\n    modCount++;\n    final int newSize;\n    if ((newSize = size - 1) > i)\n        System.arraycopy(es, i + 1, es, i, newSize - i);\n    es[size = newSize] = null;\n}\n\n\npublic void clear() {\n    modCount++;\n    final Object[] es = elementData;\n    for (int to = size, i = size = 0; i < to; i++)\n        es[i] = null;\n}\n\n\npublic boolean addAll(Collection<? extends E> c) {\n    Object[] a = c.toArray();\n    modCount++;\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n    Object[] elementData;\n    final int s;\n    if (numNew > (elementData = this.elementData).length - (s = size))\n        elementData = grow(s + numNew);\n    System.arraycopy(a, 0, elementData, s, numNew);\n    size = s + numNew;\n    return true;\n}\n\nhrows NullPointerException if the specified collection is null\n    */\n    public boolean addAll(int index, Collection<? extends E> c) {\n    rangeCheckForAdd(index);\n\n    Object[] a = c.toArray();\n    modCount++;\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n    Object[] elementData;\n    final int s;\n    if (numNew > (elementData = this.elementData).length - (s = size))\n        elementData = grow(s + numNew);\n\n    int numMoved = s - index;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index,\n                         elementData, index + numNew,\n                         numMoved);\n    System.arraycopy(a, 0, elementData, index, numNew);\n    size = s + numNew;\n    return true;\n}\n\nprotected void removeRange(int fromIndex, int toIndex) {\n    if (fromIndex > toIndex) {\n        throw new IndexOutOfBoundsException(\n            outOfBoundsMsg(fromIndex, toIndex));\n    }\n    modCount++;\n    shiftTailOverGap(elementData, fromIndex, toIndex);\n}\n\n\nprivate void shiftTailOverGap(Object[] es, int lo, int hi) {\n    System.arraycopy(es, hi, es, lo, size - hi);\n    for (int to = size, i = (size -= hi - lo); i < to; i++)\n        es[i] = null;\n}\n\nprivate void rangeCheckForAdd(int index) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n\nprivate String outOfBoundsMsg(int index) {\n    return \"Index: \"+index+\", Size: \"+size;\n}\n\nprivate static String outOfBoundsMsg(int fromIndex, int toIndex) {\n    return \"From Index: \" + fromIndex + \" > To Index: \" + toIndex;\n}\n\npublic boolean removeAll(Collection<?> c) {\n    return batchRemove(c, false, 0, size);\n}\n\npublic boolean retainAll(Collection<?> c) {\n    return batchRemove(c, true, 0, size);\n}\n\nboolean batchRemove(Collection<?> c, boolean complement,\n                    final int from, final int end) {\n    Objects.requireNonNull(c);\n    final Object[] es = elementData;\n    int r;\n    // 针对最初的幸存者进行优化\n    for (r = from;; r++) {\n        if (r == end)\n            return false;\n        if (c.contains(es[r]) != complement)\n            break;\n    }\n    int w = r++;\n    try {\n        for (Object e; r < end; r++)\n            if (c.contains(e = es[r]) == complement)\n                es[w++] = e;\n    } catch (Throwable ex) {\n        // 保持与AbstractCollection的行为兼容性，即使c.包含()抛出。\n        System.arraycopy(es, r, es, w, end - r);\n        w += end - r;\n        throw ex;\n    } finally {\n        modCount += end - w;\n        shiftTailOverGap(es, w, end);\n    }\n    return true;\n}\n@java.io.Serial\n    private void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n    // 写出元素计数和所有隐藏内容\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // 写出大小作为与clone()行为兼容性的容量\n    s.writeInt(size);\n\n    // 按正确的顺序写出所有元素\n    for (int i=0; i<size; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n@java.io.Serial\n    private void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n\n    // 读入大小，以及任何隐藏的东西\n    s.defaultReadObject();\n\n    // 读入容量\n    s.readInt(); // 忽略\n\n    if (size > 0) {\n        // 与Clone()一样，根据大小而不是容量分配阵列\n        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);\n        Object[] elements = new Object[size];\n\n        // 以适当的顺序读入所有元素。\n        for (int i = 0; i < size; i++) {\n            elements[i] = s.readObject();\n        }\n\n        elementData = elements;\n    } else if (size == 0) {\n        elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new java.io.InvalidObjectException(\"Invalid size: \" + size);\n    }\n}\n\npublic ListIterator<E> listIterator(int index) {\n    rangeCheckForAdd(index);\n    return new ListItr(index);\n}\n\npublic ListIterator<E> listIterator() {\n    return new ListItr(0);\n}\n\npublic Iterator<E> iterator() {\n    return new Itr();\n}\n@Override\npublic void forEach(Consumer<? super E> action) {\n    Objects.requireNonNull(action);\n    final int expectedModCount = modCount;\n    final Object[] es = elementData;\n    final int size = this.size;\n    for (int i = 0; modCount == expectedModCount && i < size; i++)\n        action.accept(elementAt(es, i));\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n}\n```\n\n# 内部类\n\n## Itr类\n\n```java\nprivate class Itr implements Iterator<E> {\n    int cursor;       // index of next element to return\n    int lastRet = -1; // index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n\n    // prevent creating a synthetic constructor\n    Itr() {}\n\n    public boolean hasNext() {\n        return cursor != size;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public E next() {\n        checkForComodification();\n        int i = cursor;\n        if (i >= size)\n            throw new NoSuchElementException();\n        Object[] elementData = ArrayList.this.elementData;\n        if (i >= elementData.length)\n            throw new ConcurrentModificationException();\n        cursor = i + 1;\n        return (E) elementData[lastRet = i];\n    }\n\n    public void remove() {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        checkForComodification();\n\n        try {\n            ArrayList.this.remove(lastRet);\n            cursor = lastRet;\n            lastRet = -1;\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    @Override\n    public void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        final int size = ArrayList.this.size;\n        int i = cursor;\n        if (i < size) {\n            final Object[] es = elementData;\n            if (i >= es.length)\n                throw new ConcurrentModificationException();\n            for (; i < size && modCount == expectedModCount; i++)\n                action.accept(elementAt(es, i));\n            // update once at end to reduce heap write traffic\n            cursor = i;\n            lastRet = i - 1;\n            checkForComodification();\n        }\n    }\n\n    final void checkForComodification() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n}\n```\n\n## ListItr类\n\n```java\nprivate class ListItr extends Itr implements ListIterator<E> {\n    ListItr(int index) {\n        super();\n        cursor = index;\n    }\n\n    public boolean hasPrevious() {\n        return cursor != 0;\n    }\n\n    public int nextIndex() {\n        return cursor;\n    }\n\n    public int previousIndex() {\n        return cursor - 1;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public E previous() {\n        checkForComodification();\n        int i = cursor - 1;\n        if (i < 0)\n            throw new NoSuchElementException();\n        Object[] elementData = ArrayList.this.elementData;\n        if (i >= elementData.length)\n            throw new ConcurrentModificationException();\n        cursor = i;\n        return (E) elementData[lastRet = i];\n    }\n\n    public void set(E e) {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        checkForComodification();\n\n        try {\n            ArrayList.this.set(lastRet, e);\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    public void add(E e) {\n        checkForComodification();\n\n        try {\n            int i = cursor;\n            ArrayList.this.add(i, e);\n            cursor = i + 1;\n            lastRet = -1;\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n}\n```\n\n## SubList类\n\n```java\npublic List<E> subList(int fromIndex, int toIndex) {\n    subListRangeCheck(fromIndex, toIndex, size);\n    return new SubList<>(this, fromIndex, toIndex);\n}\nprivate static class SubList<E> extends AbstractList<E> implements RandomAccess {\n    private final ArrayList<E> root;\n    private final SubList<E> parent;\n    private final int offset;\n    private int size;\n\n    /**\n         * 构造任意ArrayList的子列表。\n         */\n    public SubList(ArrayList<E> root, int fromIndex, int toIndex) {\n        this.root = root;\n        this.parent = null;\n        this.offset = fromIndex;\n        this.size = toIndex - fromIndex;\n        this.modCount = root.modCount;\n    }\n\n    /**\n         * 构造另一个子列表的子列表。\n         */\n    private SubList(SubList<E> parent, int fromIndex, int toIndex) {\n        this.root = parent.root;\n        this.parent = parent;\n        this.offset = parent.offset + fromIndex;\n        this.size = toIndex - fromIndex;\n        this.modCount = parent.modCount;\n    }\n\n    public E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        checkForComodification();\n        E oldValue = root.elementData(offset + index);\n        root.elementData[offset + index] = element;\n        return oldValue;\n    }\n\n    public E get(int index) {\n        Objects.checkIndex(index, size);\n        checkForComodification();\n        return root.elementData(offset + index);\n    }\n\n    public int size() {\n        checkForComodification();\n        return size;\n    }\n\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n        checkForComodification();\n        root.add(offset + index, element);\n        updateSizeAndModCount(1);\n    }\n\n    public E remove(int index) {\n        Objects.checkIndex(index, size);\n        checkForComodification();\n        E result = root.remove(offset + index);\n        updateSizeAndModCount(-1);\n        return result;\n    }\n\n    protected void removeRange(int fromIndex, int toIndex) {\n        checkForComodification();\n        root.removeRange(offset + fromIndex, offset + toIndex);\n        updateSizeAndModCount(fromIndex - toIndex);\n    }\n\n    public boolean addAll(Collection<? extends E> c) {\n        return addAll(this.size, c);\n    }\n\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n        int cSize = c.size();\n        if (cSize==0)\n            return false;\n        checkForComodification();\n        root.addAll(offset + index, c);\n        updateSizeAndModCount(cSize);\n        return true;\n    }\n\n    public void replaceAll(UnaryOperator<E> operator) {\n        root.replaceAllRange(operator, offset, offset + size);\n    }\n\n    public boolean removeAll(Collection<?> c) {\n        return batchRemove(c, false);\n    }\n\n    public boolean retainAll(Collection<?> c) {\n        return batchRemove(c, true);\n    }\n\n    private boolean batchRemove(Collection<?> c, boolean complement) {\n        checkForComodification();\n        int oldSize = root.size;\n        boolean modified =\n            root.batchRemove(c, complement, offset, offset + size);\n        if (modified)\n            updateSizeAndModCount(root.size - oldSize);\n        return modified;\n    }\n\n    public boolean removeIf(Predicate<? super E> filter) {\n        checkForComodification();\n        int oldSize = root.size;\n        boolean modified = root.removeIf(filter, offset, offset + size);\n        if (modified)\n            updateSizeAndModCount(root.size - oldSize);\n        return modified;\n    }\n\n    public Object[] toArray() {\n        checkForComodification();\n        return Arrays.copyOfRange(root.elementData, offset, offset + size);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        checkForComodification();\n        if (a.length < size)\n            return (T[]) Arrays.copyOfRange(\n            root.elementData, offset, offset + size, a.getClass());\n        System.arraycopy(root.elementData, offset, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof List)) {\n            return false;\n        }\n\n        boolean equal = root.equalsRange((List<?>)o, offset, offset + size);\n        checkForComodification();\n        return equal;\n    }\n\n    public int hashCode() {\n        int hash = root.hashCodeRange(offset, offset + size);\n        checkForComodification();\n        return hash;\n    }\n\n    public int indexOf(Object o) {\n        int index = root.indexOfRange(o, offset, offset + size);\n        checkForComodification();\n        return index >= 0 ? index - offset : -1;\n    }\n\n    public int lastIndexOf(Object o) {\n        int index = root.lastIndexOfRange(o, offset, offset + size);\n        checkForComodification();\n        return index >= 0 ? index - offset : -1;\n    }\n\n    public boolean contains(Object o) {\n        return indexOf(o) >= 0;\n    }\n\n    public Iterator<E> iterator() {\n        return listIterator();\n    }\n\n    public ListIterator<E> listIterator(int index) {\n        checkForComodification();\n        rangeCheckForAdd(index);\n\n        return new ListIterator<E>() {\n            int cursor = index;\n            int lastRet = -1;\n            int expectedModCount = SubList.this.modCount;\n\n            public boolean hasNext() {\n                return cursor != SubList.this.size;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            public E next() {\n                checkForComodification();\n                int i = cursor;\n                if (i >= SubList.this.size)\n                    throw new NoSuchElementException();\n                Object[] elementData = root.elementData;\n                if (offset + i >= elementData.length)\n                    throw new ConcurrentModificationException();\n                cursor = i + 1;\n                return (E) elementData[offset + (lastRet = i)];\n            }\n\n            public boolean hasPrevious() {\n                return cursor != 0;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            public E previous() {\n                checkForComodification();\n                int i = cursor - 1;\n                if (i < 0)\n                    throw new NoSuchElementException();\n                Object[] elementData = root.elementData;\n                if (offset + i >= elementData.length)\n                    throw new ConcurrentModificationException();\n                cursor = i;\n                return (E) elementData[offset + (lastRet = i)];\n            }\n\n            public void forEachRemaining(Consumer<? super E> action) {\n                Objects.requireNonNull(action);\n                final int size = SubList.this.size;\n                int i = cursor;\n                if (i < size) {\n                    final Object[] es = root.elementData;\n                    if (offset + i >= es.length)\n                        throw new ConcurrentModificationException();\n                    for (; i < size && root.modCount == expectedModCount; i++)\n                        action.accept(elementAt(es, offset + i));\n                    // 在结束时更新一次以减少堆写入流量\n                    cursor = i;\n                    lastRet = i - 1;\n                    checkForComodification();\n                }\n            }\n\n            public int nextIndex() {\n                return cursor;\n            }\n\n            public int previousIndex() {\n                return cursor - 1;\n            }\n\n            public void remove() {\n                if (lastRet < 0)\n                    throw new IllegalStateException();\n                checkForComodification();\n\n                try {\n                    SubList.this.remove(lastRet);\n                    cursor = lastRet;\n                    lastRet = -1;\n                    expectedModCount = SubList.this.modCount;\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new ConcurrentModificationException();\n                }\n            }\n\n            public void set(E e) {\n                if (lastRet < 0)\n                    throw new IllegalStateException();\n                checkForComodification();\n\n                try {\n                    root.set(offset + lastRet, e);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new ConcurrentModificationException();\n                }\n            }\n\n            public void add(E e) {\n                checkForComodification();\n\n                try {\n                    int i = cursor;\n                    SubList.this.add(i, e);\n                    cursor = i + 1;\n                    lastRet = -1;\n                    expectedModCount = SubList.this.modCount;\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new ConcurrentModificationException();\n                }\n            }\n\n            final void checkForComodification() {\n                if (root.modCount != expectedModCount)\n                    throw new ConcurrentModificationException();\n            }\n        };\n    }\n\n    public List<E> subList(int fromIndex, int toIndex) {\n        subListRangeCheck(fromIndex, toIndex, size);\n        return new SubList<>(this, fromIndex, toIndex);\n    }\n\n    private void rangeCheckForAdd(int index) {\n        if (index < 0 || index > this.size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+this.size;\n    }\n\n    private void checkForComodification() {\n        if (root.modCount != modCount)\n            throw new ConcurrentModificationException();\n    }\n\n    private void updateSizeAndModCount(int sizeChange) {\n        SubList<E> slist = this;\n        do {\n            slist.size += sizeChange;\n            slist.modCount = root.modCount;\n            slist = slist.parent;\n        } while (slist != null);\n    }\n\n    public Spliterator<E> spliterator() {\n        checkForComodification();\n\n        // 由于后期绑定，此处未使用ArrayListSpliterator\n        return new Spliterator<E>() {\n            private int index = offset; // 当前索引，在前进/拆分时修改\n            private int fence = -1; // 直到使用为止；然后是最后一个索引之后的索引\n            private int expectedModCount; // 设置围栏时初始化\n\n            private int getFence() { // 首次使用时将栅栏初始化为大小\n                int hi; // (在方法for Each中出现了一个专门的变体)\n                if ((hi = fence) < 0) {\n                    expectedModCount = modCount;\n                    hi = fence = offset + size;\n                }\n                return hi;\n            }\n\n            public ArrayList<E>.ArrayListSpliterator trySplit() {\n                int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;\n                // 这里可以使用ArrayListSpliterator，因为源已经绑定\n                return (lo >= mid) ? null : // 除非范围太小，否则将范围减半\n                root.new ArrayListSpliterator(lo, index = mid, expectedModCount);\n            }\n\n            public boolean tryAdvance(Consumer<? super E> action) {\n                Objects.requireNonNull(action);\n                int hi = getFence(), i = index;\n                if (i < hi) {\n                    index = i + 1;\n                    @SuppressWarnings(\"unchecked\") E e = (E)root.elementData[i];\n                    action.accept(e);\n                    if (root.modCount != expectedModCount)\n                        throw new ConcurrentModificationException();\n                    return true;\n                }\n                return false;\n            }\n\n            public void forEachRemaining(Consumer<? super E> action) {\n                Objects.requireNonNull(action);\n                int i, hi, mc; // 提升机从回路进入和检查\n                ArrayList<E> lst = root;\n                Object[] a;\n                if ((a = lst.elementData) != null) {\n                    if ((hi = fence) < 0) {\n                        mc = modCount;\n                        hi = offset + size;\n                    }\n                    else\n                        mc = expectedModCount;\n                    if ((i = index) >= 0 && (index = hi) <= a.length) {\n                        for (; i < hi; ++i) {\n                            @SuppressWarnings(\"unchecked\") E e = (E) a[i];\n                            action.accept(e);\n                        }\n                        if (lst.modCount == mc)\n                            return;\n                    }\n                }\n                throw new ConcurrentModificationException();\n            }\n\n            public long estimateSize() {\n                return getFence() - index;\n            }\n\n            public int characteristics() {\n                return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;\n            }\n        };\n    }\n}\n```\n\n## ArrayListSpliterator类\n\n```java\n@Override\npublic Spliterator<E> spliterator() {\n    return new ArrayListSpliterator(0, -1, 0);\n}\nfinal class ArrayListSpliterator implements Spliterator<E> {   \n    private int index; // current index, modified on advance/split\n    private int fence; // -1 until used; then one past last index\n    private int expectedModCount; // initialized when fence set\n\n    /** Creates new spliterator covering the given range. */\n    ArrayListSpliterator(int origin, int fence, int expectedModCount) {\n        this.index = origin;\n        this.fence = fence;\n        this.expectedModCount = expectedModCount;\n    }\n\n    private int getFence() { // initialize fence to size on first use\n        int hi; // (a specialized variant appears in method forEach)\n        if ((hi = fence) < 0) {\n            expectedModCount = modCount;\n            hi = fence = size;\n        }\n        return hi;\n    }\n\n    public ArrayListSpliterator trySplit() {\n        int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;\n        return (lo >= mid) ? null : // divide range in half unless too small\n        new ArrayListSpliterator(lo, index = mid, expectedModCount);\n    }\n\n    public boolean tryAdvance(Consumer<? super E> action) {\n        if (action == null)\n            throw new NullPointerException();\n        int hi = getFence(), i = index;\n        if (i < hi) {\n            index = i + 1;\n            @SuppressWarnings(\"unchecked\") E e = (E)elementData[i];\n            action.accept(e);\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            return true;\n        }\n        return false;\n    }\n\n    public void forEachRemaining(Consumer<? super E> action) {\n        int i, hi, mc; // hoist accesses and checks from loop\n        Object[] a;\n        if (action == null)\n            throw new NullPointerException();\n        if ((a = elementData) != null) {\n            if ((hi = fence) < 0) {\n                mc = modCount;\n                hi = size;\n            }\n            else\n                mc = expectedModCount;\n            if ((i = index) >= 0 && (index = hi) <= a.length) {\n                for (; i < hi; ++i) {\n                    @SuppressWarnings(\"unchecked\") E e = (E) a[i];\n                    action.accept(e);\n                }\n                if (modCount == mc)\n                    return;\n            }\n        }\n        throw new ConcurrentModificationException();\n    }\n\n    public long estimateSize() {\n        return getFence() - index;\n    }\n\n    public int characteristics() {\n        return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;\n    }\n}\n```\n\n# 其他\n\n```java\nprivate static long[] nBits(int n) {\n    return new long[((n - 1) >> 6) + 1];\n}\nprivate static void setBit(long[] bits, int i) {\n    bits[i >> 6] |= 1L << i;\n}\nprivate static boolean isClear(long[] bits, int i) {\n    return (bits[i >> 6] & (1L << i)) == 0;\n}\n\n@Override\npublic boolean removeIf(Predicate<? super E> filter) {\n    return removeIf(filter, 0, size);\n}\n\nboolean removeIf(Predicate<? super E> filter, int i, final int end) {\n    Objects.requireNonNull(filter);\n    int expectedModCount = modCount;\n    final Object[] es = elementData;\n    \n    for (; i < end && !filter.test(elementAt(es, i)); i++)\n        ;\n    \n    if (i < end) {\n        final int beg = i;\n        final long[] deathRow = nBits(end - beg);\n        deathRow[0] = 1L;   // set bit 0\n        for (i = beg + 1; i < end; i++)\n            if (filter.test(elementAt(es, i)))\n                setBit(deathRow, i - beg);\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        modCount++;\n        int w = beg;\n        for (i = beg; i < end; i++)\n            if (isClear(deathRow, i - beg))\n                es[w++] = es[i];\n        shiftTailOverGap(es, w, end);\n        return true;\n    } else {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        return false;\n    }\n}\n\n@Override\npublic void replaceAll(UnaryOperator<E> operator) {\n    replaceAllRange(operator, 0, size);\n    // TODO(8203662): remove increment of modCount from ...\n    modCount++;\n}\n\nprivate void replaceAllRange(UnaryOperator<E> operator, int i, int end) {\n    Objects.requireNonNull(operator);\n    final int expectedModCount = modCount;\n    final Object[] es = elementData;\n    for (; modCount == expectedModCount && i < end; i++)\n        es[i] = operator.apply(elementAt(es, i));\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n}\n\n@Override\n@SuppressWarnings(\"unchecked\")\npublic void sort(Comparator<? super E> c) {\n    final int expectedModCount = modCount;\n    Arrays.sort((E[]) elementData, 0, size, c);\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    modCount++;\n}\n\nvoid checkInvariants() {\n    // 假定 size >= 0;\n    // 假定 size == elementData.length || elementData[size] == null;\n}\n```\n\n","categories":["Java Collection"]},{"title":"Graph","url":"/2024/01/25/algorithm-graph/","content":"\n| 类型                | 题号                                      | 完成 |\n| ------------------- | ----------------------------------------- | ---- |\n| 图的表示            | 🔴329. 矩阵中的最长递增路径                |      |\n|                     | 🔴1579.保证图可完全遍历                    |      |\n|                     | 🟡210. 课程表 II                           |      |\n|                     | 🔴980. 不同路径                            |      |\n|                     | 🟢1128. 等价多米诺骨牌对的数量             |      |\n|                     | 🟡133. 克隆图                              |      |\n|                     | 🟡1743. 从相邻元素对还原数组               |      |\n| 广度优先搜索（BFS） | 🔴127. 单词接龙                            |      |\n|                     | 🔴126. 单词接龙 II                         |      |\n|                     | 🟡207. 课程表                              |      |\n|                     | 🟡210. 课程表 II                           |      |\n|                     | 🟡113. 路径总和 II                         |      |\n|                     | 🟡542. 01 矩阵                             |      |\n|                     | 🟡200. 岛屿数量                            |      |\n|                     | 🟡117. 填充每个节点的下一个右侧节点指针 II |      |\n|                     | 🟡130. 被围绕的区域                        |      |\n|                     | 🟡1091. 二进制矩阵中的最短路径             |      |\n|                     | 🟡752. 打开转盘锁                          |      |\n|                     | 🟢733. 图像渲染                            |      |\n|                     | 🟡102. 二叉树的层序遍历                    |      |\n|                     | 🟡429. N 叉树的层序遍历                    |      |\n| 深度优先搜索（DFS   | 🟡130. 被围绕的区域                        |      |\n|                     | 🟡417. 太平洋大西洋水流问题                |      |\n|                     | 🟡200. 岛屿数量                            |      |\n|                     | 🟢104. 二叉树的最大深度                    |      |\n|                     | 🟢463. 岛屿的周长                          |      |\n|                     | 🟡695. 岛屿的最大面积                      |      |\n|                     | 🔴827. 最大人工岛                          |      |\n|                     | 🟡1219. 黄金矿工                           |      |\n|                     | 🟡690. 员工的重要性                        |      |\n|                     | 🟡113. 路径总和 II                         |      |\n|                     | 🟢226. 翻转二叉树                          |      |\n|                     | 🟡129. 求根节点到叶节点数字之和            |      |\n| 最小生成树问题      | 🟡1584. 连接所有点的最小费用               |      |\n|                     | 🟡1131. 绝对值表达式的最大值               |      |\n|                     | 🟡1631. 最小体力消耗路径                   |      |\n|                     | 🔴1489. 找到最小生成树里的关键边和伪关键边 |      |\n| 最短路径问题        | 🟡743. 网络延迟时间                        |      |\n|                     | 🔴127. 单词接龙                            |      |\n|                     | 🟡787. K 站中转内最便宜的航班              |      |\n|                     | 🟡994. 腐烂的橘子                          |      |\n|                     | 🔴882. 细分图中的可到达节点                |      |\n|                     | 🟢1030. 距离顺序排列矩阵单元格             |      |\n|                     | 🟡1162. 地图分析                           |      |\n|                     | 🟡1631. 最小体力消耗路径                   |      |\n| 图的连通性51)       | 🟡785. 判断二分图                          |      |\n|                     | 🟡面试题 04.01. 节点间通路                 |      |\n|                     | 🟡547. 省份数量                            |      |\n|                     | 🟡886. 可能的二分法                        |      |\n|                     | 🟡959. 由斜杠划分区域                      |      |\n|                     | 🟡990. 等式方程的可满足性                  |      |\n| 其它                | 🟡797. 所有可能的路径                      |      |\n|                     | 🟡1020. 飞地的数量                         |      |\n|                     | 🟡1254. 统计封闭岛屿的数目                 |      |\n|                     | 🟡841. 钥匙和房间                          |      |\n|                     | 🟢1971. 寻找图中是否存在路径               |      |\n|                     | 🟡684.冗余连接                             |      |\n|                     | 🔴685.冗余连接II                           |      |\n\n#  图的表示\n\n## 🔴329. 矩阵中的最长递增路径 \n\n## 🔴1579.保证图可完全遍历 \n\n##  🟡210. 课程表 II \n\n## 🔴980. 不同路径 \n\n## 🟢1128. 等价多米诺骨牌对的数量\n\n## 🟡133. 克隆图 \n\n## 🟡1743. 从相邻元素对还原数组\n\n#  广度优先搜索（BFS）\n\n## 🔴127. 单词接龙 \n\n## 🔴126. 单词接龙 II \n\n## 🟡207. 课程表\n\n## 🟡210. 课程表 II \n\n##  🟡113. 路径总和 II \n\n## 🟡542. 01 矩阵\n\n## 🟡200. 岛屿数量 \n\n## 🟡117. 填充每个节点的下一个右侧节点指针 II\n\n## 🟡130. 被围绕的区域\n\n## 🟡1091. 二进制矩阵中的最短路径\n\n## 🟡752. 打开转盘锁 \n\n## 🟢733. 图像渲染 \n\n## 🟡102. 二叉树的层序遍历 \n\n## 🟡429. N 叉树的层序遍历\n\n#  深度优先搜索（DFS）\n\n## 🟡130. 被围绕的区域\n\n## 🟡417. 太平洋大西洋水流问题\n\n## 🟡200. 岛屿数量\n\n## 🟢104. 二叉树的最大深度\n\n## 🟢463. 岛屿的周长\n\n## 🟡695. 岛屿的最大面积 \n\n## 🔴827. 最大人工岛\n\n## 🟡1219. 黄金矿工 \n\n## 🟡690. 员工的重要性\n\n## 🟡113. 路径总和 II \n\n##  🟢226. 翻转二叉树 \n\n## 🟡129. 求根节点到叶节点数字之和\n\n#  最小生成树问题\n\n## 🟡1584. 连接所有点的最小费用\n\n## 🟡1131. 绝对值表达式的最大值\n\n## 🟡1631. 最小体力消耗路径\n\n## 🔴1489. 找到最小生成树里的关键边和伪关键边\n\n#  最短路径问题\n\n## 🟡743. 网络延迟时间\n\n## 🔴127. 单词接龙\n\n## 🟡787. K 站中转内最便宜的航班\n\n## 🟡994. 腐烂的橘子\n\n## 🔴882. 细分图中的可到达节点\n\n## 🟢1030. 距离顺序排列矩阵单元格\n\n## 🟡1162. 地图分析 \n\n## 🟡1631. 最小体力消耗路径\n\n#  图的连通性\n\n## 🟡785. 判断二分图\n\n## 🟡面试题 04.01. 节点间通路\n\n## 🟡547. 省份数量\n\n## 🟡886. 可能的二分法 \n\n## 🟡959. 由斜杠划分区域\n\n## 🟡990. 等式方程的可满足性\n\n# 其它\n\n## 🟡797. 所有可能的路径\n\n## 🟡1020. 飞地的数量\n\n## 🟡1254. 统计封闭岛屿的数目\n\n## 🟡841. 钥匙和房间\n\n## 🟢1971. 寻找图中是否存在路径\n\n##  🟡684.冗余连接\n\n##  🔴685.冗余连接II\n","categories":["algorithm learning"]},{"title":"Coding Interviews Special","url":"/2024/01/25/problem-set-coding-interviews-special/","content":"\n# 挑战1：整数\n\n# 挑战2：数组\n\n# 挑战3：字符串\n\n# 挑战4：链表\n\n# 挑战5：哈希表\n\n# 挑战6：栈\n\n# 挑战7：队列\n\n# 挑战8：树\n\n# 挑战9：堆\n\n# 挑战10：前缀树\n\n# 挑战11：二分查找\n\n# 挑战12：排序\n\n# 挑战13：回溯法\n\n# 挑战14：动态规划\n\n# 挑战15：图\n\n# \n","tags":["reading notes"],"categories":["algorithm training"]},{"title":"Cracking the Coding Interview","url":"/2024/01/25/problem-set-cracking-the-coding-interview/","content":"\n# 数组与字符串\n\n# 链表\n\n# 栈与队列\n\n# 树与图\n\n# 位操作\n\n# 递归与动态规划\n\n# 排序与查找\n\n# 中等难题\n\n# 高难度题\n","tags":["reading notes"],"categories":["algorithm training"]},{"title":"LeetCode 75","url":"/2024/01/25/problem-set-leetcode-75/","content":"\n# 数组/字符串\n\n# 双指针\n\n# 滑动窗口\n\n# 前缀和\n\n# 哈希表/哈希集合\n\n# 栈\n\n# 队列\n\n# 链表\n\n# 二叉树-深度优先搜索\n\n# 二叉树-深度优先遍历\n\n# 二叉搜索树\n\n# 图-深度优先搜索\n\n# 图-广度优先搜索\n\n# 堆/优先队列\n\n# 二分查找\n\n# 回溯\n\n# 动态规划-一维\n\n# 动态规划-多维\n\n# 位运算\n\n# 前缀树\n\n# 区间集合\n\n# 单调栈\n\n","tags":["reading notes"],"categories":["algorithm training"]},{"title":"LeetCode top interview 150","url":"/2024/01/25/problem-set-top-interview-150/","content":"\n# 数组/字符串\n\n# 双指针\n\n# 滑动窗口\n\n# 矩阵\n\n# 哈希表\n\n# 区间\n\n# 栈\n\n# 链表\n\n# 二叉树\n\n# 二叉树层序遍历\n\n# 二叉搜索树\n\n# 图\n\n# 图的广度优先搜索\n\n# 字典树\n\n# 回溯\n\n# 分治\n\n# kadane算法\n\n# 二分算法\n\n# 堆\n\n# 位运算\n\n# 数学\n\n# 一维动态规划\n\n# 多维动态规划\n\n","tags":["reading notes"],"categories":["algorithm training"]},{"title":"LeetCode top 100","url":"/2024/01/25/problem-set-top-100/","content":"\n# 哈希\n\n# 双指针\n\n# 滑动窗口\n\n# 子串\n\n# 普通数组\n\n# 矩阵\n\n# 链表\n\n# 二叉树\n\n# 图论\n\n# 回溯\n\n# 二分查找\n\n# 栈\n\n# 堆\n\n# 贪心算法\n\n# 动态规划\n\n# 多维动态规划\n\n# 技巧\n","tags":["reading notes"],"categories":["algorithm training"]},{"title":"🟢2859. sum of values at indices with k set bits","url":"/2024/01/25/coding-2859-sum-of-values-at-indices-with-k-set-bits/","content":"\n# Description\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。\n>\n> 请你用整数形式返回 `nums` 中的特定元素之 **和** ，这些特定元素满足：其对应下标的二进制表示中恰存在 `k` 个置位。\n>\n> 整数的二进制表示中的 1 就是这个整数的 **置位** 。\n>\n> 例如，`21` 的二进制表示为 `10101` ，其中有 `3` 个置位。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,10,1,5,2], k = 1\n> 输出：13\n> 解释：下标的二进制表示是： \n> 0 = 0002\n> 1 = 0012\n> 2 = 0102\n> 3 = 0112\n> 4 = 1002 \n> 下标 1、2 和 4 在其二进制表示中都存在 k = 1 个置位。\n> 因此，答案为 nums[1] + nums[2] + nums[4] = 13 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,3,2,1], k = 2\n> 输出：1\n> 解释：下标的二进制表示是： \n> 0 = 002\n> 1 = 012\n> 2 = 102\n> 3 = 112\n> 只有下标 3 的二进制表示中存在 k = 2 个置位。\n> 因此，答案为 nums[3] = 1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `1 <= nums[i] <= 105`\n> - `0 <= k <= 10`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n\n# Solution\n\n```java\nclass Solution {\n    public int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n        int res=0;\n        for (int i = 0; i < nums.size(); i++) {\n            int t=Integer.bitCount(i);\n            if(t==k){\n                res+=nums.get(i);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Array","algorithm-Bit Manipulation"]},{"title":"🟢2765.longest alternating subarray","url":"/2024/01/23/coding-2765-longest-alternating-subarray/","content":"\n# Description\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` 。如果 `nums` 中长度为 `m` 的子数组 `s` 满足以下条件，我们称它是一个 **交替子数组** ：\n>\n> - `m` 大于 `1` 。\n> - `s1 = s0 + 1` 。\n> - 下标从 **0** 开始的子数组 `s` 与数组 `[s0, s1, s0, s1,...,s(m-1) % 2]` 一样。也就是说，`s1 - s0 = 1` ，`s2 - s1 = -1` ，`s3 - s2 = 1` ，`s4 - s3 = -1` ，以此类推，直到 `s[m - 1] - s[m - 2] = (-1)m` 。\n>\n> 请你返回 `nums` 中所有 **交替** 子数组中，最长的长度，如果不存在交替子数组，请你返回 `-1` 。\n>\n> 子数组是一个数组中一段连续 **非空** 的元素序列。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,3,4,3,4]\n> 输出：4\n> 解释：交替子数组有 [3,4] ，[3,4,3] 和 [3,4,3,4] 。最长的子数组为 [3,4,3,4] ，长度为4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,5,6]\n> 输出：2\n> 解释：[4,5] 和 [5,6] 是仅有的两个交替子数组。它们长度都为 2 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 100`\n> - `1 <= nums[i] <= 104`\n\n# Solution\n\n```java\nclass Solution {\n    public int alternatingSubarray(int[] nums) {\n        int max=1,flag=1,len=1;\n        for (int i = 1; i < nums.length; i++) {\n            if(nums[i]-nums[i-1]==flag){\n                len++;\n                flag*=-1;\n            }else if(nums[i]-nums[i-1]==1){\n                len=2;\n                flag=-1;\n            }else{\n                len=1;\n                flag=1;\n            }\n            max=Math.max(max,len);\n        }\n        return max==1?-1:max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n","tags":["algorithm-Array","algorithm-Enum"]},{"title":"🟡 670.maximum swap","url":"/2024/01/22/coding-670-maximum-swap/","content":"\n# Description\n\n> 给定一个非负整数，你**至多**可以交换一次数字中的任意两位。返回你能得到的最大值。\n>\n> **示例 1 :**\n>\n> ```\n> 输入: 2736\n> 输出: 7236\n> 解释: 交换数字2和数字7。\n> ```\n>\n> **示例 2 :**\n>\n> ```\n> 输入: 9973\n> 输出: 9973\n> 解释: 不需要交换。\n> ```\n>\n> **注意:**\n>\n> 1. 给定数字的范围是 [0, 108]\n>\n> Related Topics\n>\n> 贪心\n>\n> 数学\n\n# Solution\n\n```java\nclass Solution {\n    public int maximumSwap(int num) {\n        List<Integer>list=new ArrayList<>();\n        String string=String.valueOf(num);\n        int len=string.length();\n        char[]chars=string.toCharArray();\n        for (int i = 0; i < len; i++) {\n            list.add(chars[i]-'0');\n        }\n        Collections.sort(list);\n        Collections.reverse(list);\n        int big;\n        for (int i = 0; i < len; i++) {\n            if(list.get(i)!=chars[i]-'0'){\n                big=list.get(i);\n                char ch= (char) ('0'+big);\n                int index=0;\n                for (int j = len-1; j >= i+1; j--) {\n                    if(chars[j]==ch){\n                        index=j;\n                        break;\n                    }\n                }\n                char temp=chars[index];\n                chars[index]=chars[i];\n                chars[i]=temp;\n                return Integer.valueOf(String.copyValueOf(chars));\n            }\n        }\n        return num;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n)*\n","tags":["algorithm-Math","algorithm-Greedy"]},{"title":"🔹381th LeetCode Weekly Contest","url":"/2024/01/21/contest-weekly-381/","content":"\n|      | score | problem                        | tag                                       |\n| ---- | ----- | ------------------------------ | ----------------------------------------- |\n| ✅    | 3     | 🟢输入单词需要的最少按键次数 I  | array string greedy                       |\n| ✅    | 4     | 🟡输入单词需要的最少按键次数 II | greedy hash-table string counting sorting |\n|      | 5     | 🟡按距离统计房屋对数目 I        | BFS graph prefix-sum                      |\n|      | 7     | 🔴按距离统计房屋对数目 II       | BFS graph prefix-sum                      |\n\n# 🟢输入单词需要的最少按键次数 I\n\n> 给你一个字符串 `word`，由 **不同** 小写英文字母组成。\n>\n> 电话键盘上的按键与 **不同** 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 `2` 对应 `[\"a\",\"b\",\"c\"]`，我们需要按一次键来输入 `\"a\"`，按两次键来输入 `\"b\"`，按三次键来输入 `\"c\"`*。*\n>\n> 现在允许你将编号为 `2` 到 `9` 的按键重新映射到 **不同** 字母集合。每个按键可以映射到 **任意数量** 的字母，但每个字母 **必须** **恰好** 映射到 **一个** 按键上。你需要找到输入字符串 `word` 所需的 **最少** 按键次数。\n>\n> 返回重新映射按键后输入 `word` 所需的 **最少** 按键次数。\n>\n> 下面给出了一种电话键盘上字母到按键的映射作为示例。注意 `1`，`*`，`#` 和 `0` **不** 对应任何字母。\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png)\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png)\n>\n> ```\n> 输入：word = \"abcde\"\n> 输出：5\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"a\" -> 在按键 2 上按一次\n> \"b\" -> 在按键 3 上按一次\n> \"c\" -> 在按键 4 上按一次\n> \"d\" -> 在按键 5 上按一次\n> \"e\" -> 在按键 6 上按一次\n> 总成本为 1 + 1 + 1 + 1 + 1 = 5 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv1e2.png)\n>\n> ```\n> 输入：word = \"xycdefghij\"\n> 输出：12\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"x\" -> 在按键 2 上按一次\n> \"y\" -> 在按键 2 上按两次\n> \"c\" -> 在按键 3 上按一次\n> \"d\" -> 在按键 3 上按两次\n> \"e\" -> 在按键 4 上按一次\n> \"f\" -> 在按键 5 上按一次\n> \"g\" -> 在按键 6 上按一次\n> \"h\" -> 在按键 7 上按一次\n> \"i\" -> 在按键 8 上按一次\n> \"j\" -> 在按键 9 上按一次\n> 总成本为 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= word.length <= 26`\n> - `word` 仅由小写英文字母组成。\n> - `word` 中的所有字母互不相同。\n\n```java\nclass Solution {\n    public int minimumPushes(String word) {\n        int res=0;\n        for (int i = 0; i < word.length(); i++) {\n            res+=i/8+1;\n        }\n        return res;\n    }\n}\n```\n\n# 🟡输入单词需要的最少按键次数 II\n\n> 给你一个字符串 `word`，由 **不同** 小写英文字母组成。\n>\n> 电话键盘上的按键与 **不同** 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 `2` 对应 `[\"a\",\"b\",\"c\"]`，我们需要按一次键来输入 `\"a\"`，按两次键来输入 `\"b\"`，按三次键来输入 `\"c\"`*。*\n>\n> 现在允许你将编号为 `2` 到 `9` 的按键重新映射到 **不同** 字母集合。每个按键可以映射到 **任意数量** 的字母，但每个字母 **必须** **恰好** 映射到 **一个** 按键上。你需要找到输入字符串 `word` 所需的 **最少** 按键次数。\n>\n> 返回重新映射按键后输入 `word` 所需的 **最少** 按键次数。\n>\n> 下面给出了一种电话键盘上字母到按键的映射作为示例。注意 `1`，`*`，`#` 和 `0` **不** 对应任何字母。\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png)\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png)\n>\n> ```\n> 输入：word = \"abcde\"\n> 输出：5\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"a\" -> 在按键 2 上按一次\n> \"b\" -> 在按键 3 上按一次\n> \"c\" -> 在按键 4 上按一次\n> \"d\" -> 在按键 5 上按一次\n> \"e\" -> 在按键 6 上按一次\n> 总成本为 1 + 1 + 1 + 1 + 1 = 5 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv2e2.png)\n>\n> ```\n> 输入：word = \"xyzxyzxyzxyz\"\n> 输出：12\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"x\" -> 在按键 2 上按一次\n> \"y\" -> 在按键 3 上按一次\n> \"z\" -> 在按键 4 上按一次\n> 总成本为 1 * 4 + 1 * 4 + 1 * 4 = 12 。\n> 可以证明不存在其他成本更低的映射方案。\n> 注意按键 9 没有映射到任何字母：不必让每个按键都存在与之映射的字母，但是每个字母都必须映射到按键上。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/27/keypadv2.png)\n>\n> ```\n> 输入：word = \"aabbccddeeffgghhiiiiii\"\n> 输出：24\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"a\" -> 在按键 2 上按一次\n> \"b\" -> 在按键 3 上按一次\n> \"c\" -> 在按键 4 上按一次\n> \"d\" -> 在按键 5 上按一次\n> \"e\" -> 在按键 6 上按一次\n> \"f\" -> 在按键 7 上按一次\n> \"g\" -> 在按键 8 上按一次\n> \"h\" -> 在按键 9 上按两次\n> \"i\" -> 在按键 9 上按一次\n> 总成本为 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= word.length <= 105`\n> - `word` 仅由小写英文字母组成。\n\n```java\nclass Solution {\n    public int minimumPushes(String word) {\n        Map<Character,Integer>cnt=new TreeMap<>();\n        int res=0;\n        for (int i = 0; i < word.length(); i++) {\n            char key=word.charAt(i);\n            cnt.put(key,cnt.getOrDefault(key,0)+1);\n        }\n        List<Map.Entry<Character,Integer>>list=new ArrayList<>(cnt.entrySet());\n        Collections.sort(list, new Comparator<Map.Entry<Character, Integer>>() {\n            @Override\n            public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {\n                return o2.getValue()-o1.getValue();\n            }\n        });\n        for (int i=0;i< list.size();i++) {\n            res+=list.get(i).getValue()*(i/8+1);\n        }\n        return res;\n    }\n}\n```\n\n# 🟡按距离统计房屋对数目 I\n\n> 给你三个 **正整数** `n` 、`x` 和 `y` 。\n>\n> 在城市中，存在编号从 `1` 到 `n` 的房屋，由 `n` 条街道相连。对所有 `1 <= i < n` ，都存在一条街道连接编号为 `i` 的房屋与编号为 `i + 1` 的房屋。另存在一条街道连接编号为 `x` 的房屋与编号为 `y` 的房屋。\n>\n> 对于每个 `k`（`1 <= k <= n`），你需要找出所有满足要求的 **房屋对** `[house1, house2]` ，即从 `house1` 到 `house2` 需要经过的 **最少** 街道数为 `k` 。\n>\n> 返回一个下标从 **1** 开始且长度为 `n` 的数组 `result` ，其中 `result[k]` 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 **最少** 街道数为 `k` 。\n>\n> **注意**，`x` 与 `y` 可以 **相等** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example2.png)\n>\n> ```\n> 输入：n = 3, x = 1, y = 3\n> 输出：[6,0,0]\n> 解释：让我们检视每个房屋对\n> - 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。\n> - 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。\n> - 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。\n> - 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。\n> - 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。\n> - 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example3.png)\n>\n> ```\n> 输入：n = 5, x = 2, y = 4\n> 输出：[10,8,2,0,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。\n> - 对于 k == 4 和 k == 5，不存在满足要求的房屋对。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example5.png)\n>\n> ```\n> 输入：n = 4, x = 1, y = 1\n> 输出：[6,4,2,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。\n> - 对于 k == 4，不存在满足要求的房屋对。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n <= 100`\n> - `1 <= x, y <= n`\n\n\n\n# 🔴按距离统计房屋对数目 II\n\n> 给你三个 **正整数** `n` 、`x` 和 `y` 。\n>\n> 在城市中，存在编号从 `1` 到 `n` 的房屋，由 `n` 条街道相连。对所有 `1 <= i < n` ，都存在一条街道连接编号为 `i` 的房屋与编号为 `i + 1` 的房屋。另存在一条街道连接编号为 `x` 的房屋与编号为 `y` 的房屋。\n>\n> 对于每个 `k`（`1 <= k <= n`），你需要找出所有满足要求的 **房屋对** `[house1, house2]` ，即从 `house1` 到 `house2` 需要经过的 **最少** 街道数为 `k` 。\n>\n> 返回一个下标从 **1** 开始且长度为 `n` 的数组 `result` ，其中 `result[k]` 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 **最少** 街道数为 `k` 。\n>\n> **注意**，`x` 与 `y` 可以 **相等** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example2.png)\n>\n> ```\n> 输入：n = 3, x = 1, y = 3\n> 输出：[6,0,0]\n> 解释：让我们检视每个房屋对\n> - 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。\n> - 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。\n> - 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。\n> - 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。\n> - 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。\n> - 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example3.png)\n>\n> ```\n> 输入：n = 5, x = 2, y = 4\n> 输出：[10,8,2,0,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。\n> - 对于 k == 4 和 k == 5，不存在满足要求的房屋对。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example5.png)\n>\n> ```\n> 输入：n = 4, x = 1, y = 1\n> 输出：[6,4,2,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。\n> - 对于 k == 4，不存在满足要求的房屋对。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n <= 105`\n> - `1 <= x, y <= n`\n\n\n\n","tags":["contest"]},{"title":"🔸122th LeetCode Biweekly Contest","url":"/2024/01/20/contest-biweekly-122/","content":"\n|      | score | problem                          | tag                                                 |\n| ---- | ----- | -------------------------------- | --------------------------------------------------- |\n| ✅    | 3     | 🟢将数组分成最小总代价的子数组 I  | sorting array enum                                  |\n| ✅    | 4     | 🟡判断一个数组是否可以变为有序    | sorting array bit-munipulation                      |\n|      | 5     | 🟡通过操作使数组长度最小          | greedy array math number-theory                     |\n|      | 7     | 🔴将数组分成最小总代价的子数组 II | array hash-table sliding-window heap-priority-queue |\n\n# 🟢将数组分成最小总代价的子数组 I\n\n> 给你一个长度为 `n` 的整数数组 `nums` 。\n>\n> 一个数组的 **代价** 是它的 **第一个** 元素。比方说，`[1,2,3]` 的代价是 `1` ，`[3,4,1]` 的代价是 `3` 。\n>\n> 你需要将 `nums` 分成 `3` 个 **连续且没有交集** 的子数组。\n>\n> 请你返回这些子数组的 **最小** 代价 **总和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,12]\n> 输出：6\n> 解释：最佳分割成 3 个子数组的方案是：[1] ，[2] 和 [3,12] ，总代价为 1 + 2 + 3 = 6 。\n> 其他得到 3 个子数组的方案是：\n> - [1] ，[2,3] 和 [12] ，总代价是 1 + 2 + 12 = 15 。\n> - [1,2] ，[3] 和 [12] ，总代价是 1 + 3 + 12 = 16 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,4,3]\n> 输出：12\n> 解释：最佳分割成 3 个子数组的方案是：[5] ，[4] 和 [3] ，总代价为 5 + 4 + 3 = 12 。\n> 12 是所有分割方案里的最小总代价。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [10,3,1,1]\n> 输出：12\n> 解释：最佳分割成 3 个子数组的方案是：[10,3] ，[1] 和 [1] ，总代价为 10 + 1 + 1 = 12 。\n> 12 是所有分割方案里的最小总代价。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= n <= 50`\n>\n> - `1 <= nums[i] <= 50`\n>\n>\n\n```java\nclass Solution {\n    public int minimumCost(int[] nums) {\n        int res=0;\n        int min1_index=0,min1=Integer.MAX_VALUE,min2_index=0,min2=Integer.MAX_VALUE,min3_index=0,min3=Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<min1){\n                min1=nums[i];\n                min1_index=i;\n            }\n        }\n        res+=min1;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<min2&&i!=min1_index){\n                min2=nums[i];\n                min2_index=i;\n            }\n        }\n        res+=min2;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<min3&&i!=min1_index&&i!=min2_index){\n                min3=nums[i];\n                min3_index=i;\n            }\n        }\n        if(min1_index!=0&&min2_index!=0){\n            return res+nums[0];\n        }else{\n            return res+min3;\n        }\n    }\n}\n```\n\n- time：*O(n)*\n- space：*O(1)*\n\n看到一位佬写的题解，感觉自己写的好恶心😅\n\n```java\nclass Solution {\n    public int minimumCost(int[] nums) {\n        Arrays.sort(nums, 1, nums.length);\n        return nums[0] + nums[1] + nums[2];\n    }\n}\n```\n\n- time:*O(nlogn)*\n- space:*O(1)*\n\n# 🟡判断一个数组是否可以变为有序\n\n> 给你一个下标从 **0** 开始且全是 **正** 整数的数组 `nums` 。\n>\n> 一次 **操作** 中，如果两个 **相邻** 元素在二进制下数位为 **1** 的数目 **相同** ，那么你可以将这两个元素交换。你可以执行这个操作 **任意次** （**也可以 0 次**）。\n>\n> 如果你可以使数组变有序，请你返回 `true` ，否则返回 `false` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [8,4,2,30,15]\n> 输出：true\n> 解释：我们先观察每个元素的二进制表示。 2 ，4 和 8 分别都只有一个数位为 1 ，分别为 \"10\" ，\"100\" 和 \"1000\" 。15 和 30 分别有 4 个数位为 1 ：\"1111\" 和 \"11110\" 。\n> 我们可以通过 4 个操作使数组有序：\n> - 交换 nums[0] 和 nums[1] 。8 和 4 分别只有 1 个数位为 1 。数组变为 [4,8,2,30,15] 。\n> - 交换 nums[1] 和 nums[2] 。8 和 2 分别只有 1 个数位为 1 。数组变为 [4,2,8,30,15] 。\n> - 交换 nums[0] 和 nums[1] 。4 和 2 分别只有 1 个数位为 1 。数组变为 [2,4,8,30,15] 。\n> - 交换 nums[3] 和 nums[4] 。30 和 15 分别有 4 个数位为 1 ，数组变为 [2,4,8,15,30] 。\n> 数组变成有序的，所以我们返回 true 。\n> 注意我们还可以通过其他的操作序列使数组变得有序。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5]\n> 输出：true\n> 解释：数组已经是有序的，所以我们返回 true 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,16,8,4,2]\n> 输出：false\n> 解释：无法通过操作使数组变为有序。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `1 <= nums[i] <= 28`\n\n```java\nclass Solution {\n     public boolean canSortArray(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n           for (int j = 0; j < nums.length-i; j++) {\n                int bite1=Integer.bitCount(nums[j]);\n                int bite2=Integer.bitCount(nums[j+1]);\n                if(bite1==bite2&&nums[j]>nums[j+1]){\n                    int temp=nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                }\n            }\n        }\n        for (int i = 1; i < nums.length; i++) {\n            if(nums[i]<nums[i-1]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time：*O(n^2^)*\n- space：*O(1)*\n\n小小改进了一下，减少了循环次数\n\n```java\nclass Solution {\n     public boolean canSortArray(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = 0; j < nums.length-i; j++){\n                int bite1=Integer.bitCount(nums[j]);\n                int bite2=Integer.bitCount(nums[j+1]);\n                if(bite1==bite2&&nums[j]>nums[j+1]){\n                    int temp=nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                }else if(nums[j]>nums[j+1]){\n\t\t\t\t\treturn false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n两个可以复习的点：\n\n1.Integer.bitCount(num)函数：num转化为二进制后1的个数\n\n2.冒泡排序的两层循环：\n\n```java\nfor (int i = 1; i < nums.length; i++) {//循环次数为len-1\n    for (int j = 0; j < nums.length-i; j++) {//j:0~len-i-1\n        swap(arr[j],arr[j+1]);\n    }\n}\n```\n\n\n\n#  🟡通过操作使数组长度最小\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` ，它只包含 **正** 整数。\n>\n> 你的任务是通过进行以下操作 **任意次** （可以是 0 次） **最小化** `nums` 的长度：\n>\n> - 在 `nums` 中选择 **两个不同** 的下标 `i` 和 `j` ，满足 `nums[i] > 0` 且 `nums[j] > 0` 。\n> - 将结果 `nums[i] % nums[j]` 插入 `nums` 的结尾。\n> - 将 `nums` 中下标为 `i` 和 `j` 的元素删除。\n>\n> 请你返回一个整数，它表示进行任意次操作以后 `nums` 的 **最小长度** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,4,3,1]\n> 输出：1\n> 解释：使数组长度最小的一种方法是：\n> 操作 1 ：选择下标 2 和 1 ，插入 nums[2] % nums[1] 到数组末尾，得到 [1,4,3,1,3] ，然后删除下标为 2 和 1 的元素。\n> nums 变为 [1,1,3] 。\n> 操作 2 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [1,1,3,1] ，然后删除下标为 1 和 2 的元素。\n> nums 变为 [1,1] 。\n> 操作 3 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [1,1,0] ，然后删除下标为 1 和 0 的元素。\n> nums 变为 [0] 。\n> nums 的长度无法进一步减小，所以答案为 1 。\n> 1 是可以得到的最小长度。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,5,5,10,5]\n> 输出：2\n> 解释：使数组长度最小的一种方法是：\n> 操作 1 ：选择下标 0 和 3 ，插入 nums[0] % nums[3] 到数组末尾，得到 [5,5,5,10,5,5] ，然后删除下标为 0 和 3 的元素。\n> nums 变为 [5,5,5,5] 。\n> 操作 2 ：选择下标 2 和 3 ，插入 nums[2] % nums[3] 到数组末尾，得到 [5,5,5,5,0] ，然后删除下标为 2 和 3 的元素。\n> nums 变为 [5,5,0] 。\n> 操作 3 ：选择下标 0 和 1 ，插入 nums[0] % nums[1] 到数组末尾，得到 [5,5,0,0] ，然后删除下标为 0 和 1 的元素。\n> nums 变为 [0,0] 。\n> nums 的长度无法进一步减小，所以答案为 2 。\n> 2 是可以得到的最小长度。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [2,3,4]\n> 输出：1\n> 解释：使数组长度最小的一种方法是：\n> 操作 1 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [2,3,4,3] ，然后删除下标为 1 和 2 的元素。\n> nums 变为 [2,3] 。\n> 操作 2 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [2,3,1] ，然后删除下标为 1 和 0 的元素。\n> nums 变为 [1] 。\n> nums 的长度无法进一步减小，所以答案为 1 。\n> 1 是可以得到的最小长度。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `1 <= nums[i] <= 109`\n\n# 🔴将数组分成最小总代价的子数组 II\n\n> 给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和两个 **正** 整数 `k` 和 `dist` 。\n>\n> 一个数组的 **代价** 是数组中的 **第一个** 元素。比方说，`[1,2,3]` 的代价为 `1` ，`[3,4,1]` 的代价为 `3` 。\n>\n> 你需要将 `nums` 分割成 `k` 个 **连续且互不相交** 的子数组，满足 **第二** 个子数组与第 `k` 个子数组中第一个元素的下标距离 **不超过** `dist` 。换句话说，如果你将 `nums` 分割成子数组 `nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)]` ，那么它需要满足 `ik-1 - i1 <= dist` 。\n>\n> 请你返回这些子数组的 **最小** 总代价。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,2,6,4,2], k = 3, dist = 3\n> 输出：5\n> 解释：将数组分割成 3 个子数组的最优方案是：[1,3] ，[2,6,4] 和 [2] 。这是一个合法分割，因为 ik-1 - i1 等于 5 - 2 = 3 ，等于 dist 。总代价为 nums[0] + nums[2] + nums[5] ，也就是 1 + 2 + 2 = 5 。\n> 5 是分割成 3 个子数组的最小总代价。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [10,1,2,2,2,1], k = 4, dist = 3\n> 输出：15\n> 解释：将数组分割成 4 个子数组的最优方案是：[10] ，[1] ，[2] 和 [2,2,1] 。这是一个合法分割，因为 ik-1 - i1 等于 3 - 1 = 2 ，小于 dist 。总代价为 nums[0] + nums[1] + nums[2] + nums[3] ，也就是 10 + 1 + 2 + 2 = 15 。\n> 分割 [10] ，[1] ，[2,2,2] 和 [1] 不是一个合法分割，因为 ik-1 和 i1 的差为 5 - 1 = 4 ，大于 dist 。\n> 15 是分割成 4 个子数组的最小总代价。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [10,8,18,9], k = 3, dist = 1\n> 输出：36\n> 解释：将数组分割成 4 个子数组的最优方案是：[10] ，[8] 和 [18,9] 。这是一个合法分割，因为 ik-1 - i1 等于 2 - 1 = 1 ，等于 dist 。总代价为 nums[0] + nums[1] + nums[2] ，也就是 10 + 8 + 18 = 36 。\n> 分割 [10] ，[8,18] 和 [9] 不是一个合法分割，因为 ik-1 和 i1 的差为 3 - 1 = 2 ，大于 dist 。\n> 36 是分割成 3 个子数组的最小总代价。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `3 <= n <= 105`\n> - `1 <= nums[i] <= 109`\n> - `3 <= k <= n`\n> - `k - 2 <= dist <= n - 2`\n\n```java\n```\n\n","tags":["contest"]},{"title":"Java New Features","url":"/2024/01/20/java-new-features/","content":"\n","tags":["reading notes"],"categories":["Java"]},{"title":"Java Concurrent","url":"/2024/01/20/java-concurrent/","content":"\n","tags":["reading notes"],"categories":["Java"]},{"title":"Java JVM","url":"/2024/01/20/java-jvm/","content":"\n","tags":["reading notes"],"categories":["Java"]},{"title":"Java I/O","url":"/2024/01/20/java-io/","content":"\n","tags":["reading notes"],"categories":["Java"]},{"title":"Java Basics","url":"/2024/01/20/java-basics/","content":"\n","tags":["reading notes"],"categories":["Java"]},{"title":"🟢788. split strings by separator","url":"/2024/01/20/coding-2788-split-strings-by-separator/","content":"\n# Description\n\n> 给你一个字符串数组 `words` 和一个字符 `separator` ，请你按 `separator` 拆分 `words` 中的每个字符串。\n>\n> 返回一个由拆分后的新字符串组成的字符串数组，**不包括空字符串** 。\n>\n> **注意**\n>\n> - `separator` 用于决定拆分发生的位置，但它不包含在结果字符串中。\n> - 拆分可能形成两个以上的字符串。\n> - 结果字符串必须保持初始相同的先后顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：words = [\"one.two.three\",\"four.five\",\"six\"], separator = \".\"\n> 输出：[\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]\n> 解释：在本示例中，我们进行下述拆分：\n> \n> \"one.two.three\" 拆分为 \"one\", \"two\", \"three\"\n> \"four.five\" 拆分为 \"four\", \"five\"\n> \"six\" 拆分为 \"six\" \n> \n> 因此，结果数组为 [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words = [\"$easy$\",\"$problem$\"], separator = \"$\"\n> 输出：[\"easy\",\"problem\"]\n> 解释：在本示例中，我们进行下述拆分：\n> \n> \"$easy$\" 拆分为 \"easy\"（不包括空字符串）\n> \"$problem$\" 拆分为 \"problem\"（不包括空字符串）\n> \n> 因此，结果数组为 [\"easy\",\"problem\"] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words = [\"|||\"], separator = \"|\"\n> 输出：[]\n> 解释：在本示例中，\"|||\" 的拆分结果将只包含一些空字符串，所以我们返回一个空数组 [] 。 \n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= words.length <= 100`\n> - `1 <= words[i].length <= 20`\n> - `words[i]` 中的字符要么是小写英文字母，要么就是字符串 `\".,|$#@\"` 中的字符（不包括引号）\n> - `separator` 是字符串 `\".,|$#@\"` 中的某个字符（不包括引号）\n>\n> Related Topics\n>\n> 数组\n>\n> 字符串\n\n# Solution\n\n```java\nclass Solution {\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\n        List<String>res=new ArrayList<String>();\n        String pat;\n        if(separator=='.'||separator=='$'||separator=='|'){\n            pat=\"\\\\\"+separator;\n        }else {\n            pat=String.valueOf(separator);\n        }\n        for (String word : words) {\n            String[] splited = word.split(pat);\n            for (String str: splited) {\n                if(!str.isEmpty()){\n                    res.add(str);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n以为秒了，结果发现String.split()函数中涉及的正则表达式，之前不熟悉\n\n# Summary\n\n### 1.  '.'、'$'、'|'分别代表什么\n\n在正则表达式中，点号（`.`）、美元符号（`$`）和竖线（`|`）都有特殊的含义。\n\n- `.`（点号）：在正则表达式中，点号表示匹配任意单个字符，除了换行符。例如，正则表达式`a.b`可以匹配\"acb\"、“abb”、\"a1b\"等。\n- `$`（美元符号）：美元符号用于匹配字符串的结尾。例如，正则表达式`abc$`用于匹配以\"abc\"结尾的字符串。\n- `|`（竖线）：竖线用于表示选择操作，意味着\"或\"的关系。例如，正则表达式`a|b`表示匹配字符\"a\"或字符\"b\"。它可以用于多个模式的选择。\n\n需要注意的是，这些字符在正则表达式中具有特殊的意义，如果你想要匹配它们本身而不是其特殊含义，需要进行转义，即在字符前加上反斜杠（`\\.`, `\\$`, `\\|`）。\n\n### 2.还有其它类似字符吗\n\n除了`.`、`$`和`|`之外，还有许多其他在正则表达式中具有特殊含义的字符。下面列出了一些常用的特殊字符：\n\n- `*`：表示前一个字符出现零次或多次。例如，正则表达式`ab*c`可以匹配\"ac\"、“abc”、\"abbc\"等。\n- `+`：表示前一个字符出现一次或多次。例如，正则表达式`ab+c`可以匹配\"abc\"、“abbc”、\"abbbc\"等。\n- `?`：表示前一个字符出现零次或一次。例如，正则表达式`ab?c`可以匹配\"ac\"、“abc”。\n- `[]`：方括号用于创建一个字符类，表示匹配其中的任意一个字符。例如，正则表达式`[aeiou]`表示匹配任意一个元音字母。\n- `^`：在字符类的开头使用，表示取反操作或匹配字符串的开头。例如，正则表达式`[^0-9]`表示匹配任意一个非数字字符；而正则表达式`^abc`表示匹配以\"abc\"开头的字符串。\n- `()`：用于创建一个捕获组，可以对其中的内容进行分组和引用。例如，正则表达式`(ab)+`表示匹配一个或多个\"ab\"。\n\n这些特殊字符在正则表达式中常用于表示不同的模式和操作。如果你需要特别匹配这些字符本身，也需要使用反斜杠进行转义，例如`\\*`、`\\+`、`\\?`、`\\[`等。\n\n### 3.正则表达式还有什么需要注意的吗\n\n1. 特殊字符的转义：一些字符在正则表达式中具有特殊意义，比如`.`、`$`、`|`等。如果你想要匹配这些字符本身而不是其特殊意义，需要在其前面加上反斜杠进行转义，例如`\\.`、`\\$`、`\\|`。\n2. 字符类：方括号`[]`用于表示一个字符类，可以匹配其中任意一个字符。在字符类中的某些字符也具有特殊意义，比如`-`用于表示一个范围，比如`[a-z]`表示从小写字母a到z的任意一个字符。如果想要匹配字符类中的特殊字符本身，同样需要进行转义。\n3. 量词：量词用于指定一个模式出现的次数，比如`*`表示出现零次或多次，`+`表示出现一次或多次，`?`表示出现零次或一次。默认情况下，量词是贪婪的，即会尽量多地匹配字符。如果想要量词变为非贪婪模式，可以在量词后面加上`?`，例如`*?`、`+?`、`??`。\n4. 捕获组：括号`()`用于创建一个捕获组，可以通过编号引用捕获的内容。捕获组的编号从1开始，可以使用`\\1`、`\\2`等进行引用。\n5. 边界匹配：`^`表示匹配字符串的开头，`$`表示匹配字符串的结尾。如果想要匹配整个字符串，可以在正则表达式的两端加上这两个边界符。\n6. 负向匹配：`[^]`表示匹配任意不在括号中的字符。\n","tags":["algorithm-Array","algorithm-String"]},{"title":"creational pattern","url":"/2024/01/18/system-design-creational-pattern/","content":"\n","tags":["reading notes"],"categories":["system design"]},{"title":"Git","url":"/2024/01/18/tools-git/","content":"\n# git使用\n\n## 创建新仓库\n\n创建新文件夹，打开，然后执行\n`git init`\n以创建新的 git 仓库。\n\n\n\n## 检出仓库\n\n执行如下命令以创建一个本地仓库的克隆版本：\n`git clone /path/to/repository`\n如果是远端服务器上的仓库，你的命令会是这个样子：\n`git clone username@host:/path/to/repository`\n\n\n\n## 工作流\n\n你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 `工作目录`，它持有实际文件；第二个是 `暂存区（Index）`，它像个缓存区域，临时保存你的改动；最后是 `HEAD`，它指向你最后一次提交的结果。\n\n![img](https://rogerdudler.github.io/git-guide/img/trees.png)\n\n\n\n## 添加和提交\n\n你可以提出更改（把它们添加到暂存区），使用如下命令：\n`git add <filename>`\n`git add *`\n这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：\n`git commit -m \"代码提交信息\"`\n现在，你的改动已经提交到了 **HEAD**，但是还没到你的远端仓库。\n\n\n\n## 推送改动\n\n你的改动现在已经在本地仓库的 **HEAD** 中了。执行如下命令以将这些改动提交到远端仓库：\n`git push origin master`\n可以把 *master* 换成你想要推送的任何分支。\n\n如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：\n`git remote add origin <server>`\n如此你就能够将你的改动推送到所添加的服务器上去了。\n\n\n\n## 分支\n\n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n![img](https://rogerdudler.github.io/git-guide/img/branches.png)\n\n创建一个叫做“feature_x”的分支，并切换过去：\n`git checkout -b feature_x`\n切换回主分支：\n`git checkout master`\n再把新建的分支删掉：\n`git branch -d feature_x`\n除非你将分支推送到远端仓库，不然该分支就是 *不为他人所见的*：\n`git push origin <branch>`\n\n\n\n## 更新与合并\n\n要更新你的本地仓库至最新改动，执行：\n`git pull`\n以在你的工作目录中 *获取（fetch）* 并 *合并（merge）* 远端的改动。\n要合并其他分支到你的当前分支（例如 master），执行：\n`git merge <branch>`\n在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现*冲突（conflicts）*。 这时候就需要你修改这些文件来手动合并这些*冲突（conflicts）*。改完之后，你需要执行如下命令以将它们标记为合并成功：\n`git add <filename>`\n在合并改动之前，你可以使用如下命令预览差异：\n`git diff <source_branch> <target_branch>`\n\n\n\n## 标签\n\n为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 *1.0.0* 的标签：\n`git tag 1.0.0 1b2e1d63ff`\n*1b2e1d63ff* 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：\n`git log`\n你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。\n\n\n\n## log\n\n如果你想了解本地仓库的历史记录，最简单的命令就是使用:\n`git log`\n你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:\n`git log --author=bob`\n一个压缩后的每一条提交记录只占一行的输出:\n`git log --pretty=oneline`\n或者你想通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:\n`git log --graph --oneline --decorate --all`\n看看哪些文件改变了:\n`git log --name-status`\n这些只是你可以使用的参数中很小的一部分。更多的信息，参考：\n`git log --help`\n\n\n\n## 替换本地改动\n\n假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：\n`git checkout -- <filename>`\n此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n`git fetch origin`\n`git reset --hard origin/master`\n\n\n\n## 实用小贴士\n\n内建的图形化 git：\n`gitk`\n彩色的 git 输出：\n`git config color.ui true`\n显示历史记录时，每个提交的信息只显示一行：\n`git config format.pretty oneline`\n交互式添加文件到暂存区：\n`git add -i`\n","categories":["tools"]},{"title":"Java Collections","url":"/2024/01/18/java-collection/","content":"\n![image-20240127191723406](java-collection/image-20240127191723406.png)\n\n# Collection\n\n## List\n\n[ArrayList ⭐ ](http://localhost:4000/2024/01/27/java-collection-arraylist/)\n\n![image-20240126232307898](java-collection/image-20240126232307898.png)\n\n### CopyOnWriteArrayList⭐\n\n![image-20240127193301660](java-collection/image-20240127193301660.png)\n\n### LinkedList⭐\n\n![image-20240127190357309](java-collection/image-20240127190357309.png)\n\n### VECTOR\n\n![image-20240127190627752](java-collection/image-20240127190627752.png)\n\n### Stack\n\n![image-20240127190806370](java-collection/image-20240127190806370.png)\n\n## Queue\n\n### ArrayDeque\n\n![image-20240127190929640](java-collection/image-20240127190929640.png)\n\n### PriorityQueue⭐\n\n![image-20240127191119230](java-collection/image-20240127191119230.png)\n\n### ArrayBlockingQueue⭐\n\n![image-20240127193420751](java-collection/image-20240127193420751.png)\n\n### DelayQueue⭐\n\n![image-20240127193627278](java-collection/image-20240127193627278.png)\n\n## Set\n\n### HashSet\n\n![image-20240127191432195](java-collection/image-20240127191432195.png)\n\n### TreeSet\n\n![image-20240127192300881](java-collection/image-20240127192300881.png)\n\n### LinkedHashSet\n\n![image-20240127192820111](java-collection/image-20240127192820111.png)\n\n# Map\n\n### HashMap⭐\n\n![image-20240127192607813](java-collection/image-20240127192607813.png)\n\n### ConcurrentHashMap⭐\n\n![image-20240127193529472](java-collection/image-20240127193529472.png)\n\n### LinkedHashMap⭐\n\n![image-20240127192849570](java-collection/image-20240127192849570.png)\n\n### TreeMap\n\n![image-20240127192416766](java-collection/image-20240127192416766.png)\n\n### Hashtable\n\n![image-20240127193051985](java-collection/image-20240127193051985.png)\n\n","tags":["r"],"categories":["Java"]},{"title":"Algorithms","url":"/2024/01/18/cs-basics-algorithms/","content":"\n# 1. 搜索\n\n# 2. 排序\n\n# 3. 分治\n\n# 4. 回溯\n\n# 5. 动态规划\n\n# 6. 贪心\n","categories":["CS basics"]},{"title":"Data Structure","url":"/2024/01/18/cs-basics-data-structure/","content":"\n# 1. 数据结构绪论\n\n# 2. 数组与链表\n\n# 3. 栈与队列\n\n# 4. 哈希表\n\n# 5. 树\n\n# 6. 堆\n\n# 7. 图\n\n","categories":["CS basics"]},{"title":"Operating System","url":"/2024/01/18/cs-basics-operating-system/","content":"\n \n\n# 1. 计算机系统概述\n\n# 2. 进程与线程\n\n# 3. 内存管理\n\n# 4. 文件管理\n\n# 5. IO管理\n","categories":["CS basics"]},{"title":"Network","url":"/2024/01/18/cs-basics-network/","content":"\n# 1. 计算机网络体系结构\n\n![image-20240120214043276](cs-basics-network/image-20240120214043276.png)\n\n![image-20240120214803863](cs-basics-network/image-20240120214803863.png)\n\n![image-20240120214942082](cs-basics-network/image-20240120214942082.png)\n\n![image-20240120215004255](cs-basics-network/image-20240120215004255.png)\n\n# 2. 物理层\n\n![image-20240120215701701](cs-basics-network/image-20240120215701701.png)\n\n## 2.1 通信基础\n\n### 2.1.1物理层基本概念\n\n![image-20240120215854657](cs-basics-network/image-20240120215854657.png)\n\n![image-20240120215930135](cs-basics-network/image-20240120215930135.png)\n\n![image-20240120220531468](cs-basics-network/image-20240120220531468.png)\n\n### 2.1.2奈斯准则&香农定理\n\n![image-20240120221716246](cs-basics-network/image-20240120221716246.png)\n\n![image-20240120221820513](cs-basics-network/image-20240120221820513.png)\n\n![image-20240120221912500](cs-basics-network/image-20240120221912500.png)\n\n### 2.1.3编码与调制\n\n![image-20240120222053428](cs-basics-network/image-20240120222053428.png)\n\n![image-20240120222114377](cs-basics-network/image-20240120222114377.png)\n\n\n\n## 2.2 传输介质\n\n![image-20240129053740534](cs-basics-network/image-20240129053740534.png)\n\n# 3.数据链路层\n\n![image-20240129054350963](cs-basics-network/image-20240129054350963.png)\n","categories":["CS basics"]},{"title":"50 questions on High Frequency SQL","url":"/2024/01/18/database-sql-free-50/","content":"\n| 分类 | 题目                           | 完成 |\n| ---- | ------------------------------ | ---- |\n| 查询 | 🟢1757. 可回收且低脂的产品      | ✅    |\n|      | 🟢584. 寻找用户推荐人           | ✅    |\n|      | 🟢595. 大的国家                 | ✅    |\n|      | 🟢1148. 文章浏览 I              | ✅    |\n|      | 🟢1683. 无效的推文              | ✅    |\n| 连接 | 🟢1378.使用唯一标识码替换员工ID |      |\n|      |                                |      |\n|      |                                |      |\n\n#  查询\n\n## 🟢1757. 可回收且低脂的产品\n\n> 表：`Products`\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | product_id  | int     |\n> | low_fats    | enum    |\n> | recyclable  | enum    |\n> +-------------+---------+\n> product_id 是该表的主键（具有唯一值的列）。\n> low_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。\n> recyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。\n> ```\n>\n>  \n>\n> 编写解决方案找出既是低脂又是可回收的产品编号。\n>\n> 返回结果 **无顺序要求** 。\n>\n> 返回结果格式如下例所示：\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Products 表：\n> +-------------+----------+------------+\n> | product_id  | low_fats | recyclable |\n> +-------------+----------+------------+\n> | 0           | Y        | N          |\n> | 1           | Y        | Y          |\n> | 2           | N        | Y          |\n> | 3           | Y        | Y          |\n> | 4           | N        | N          |\n> +-------------+----------+------------+\n> 输出：\n> +-------------+\n> | product_id  |\n> +-------------+\n> | 1           |\n> | 3           |\n> +-------------+\n> 解释：\n> 只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。\n> ```\n\n```mysql\nselect product_id \nfrom products \nwhere low_fats='Y' and recyclable='Y'\n```\n\n## 🟢584. 寻找用户推荐人\n\n> 表: `Customer`\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | id          | int     |\n> | name        | varchar |\n> | referee_id  | int     |\n> +-------------+---------+\n> 在 SQL 中，id 是该表的主键列。\n> 该表的每一行表示一个客户的 id、姓名以及推荐他们的客户的 id。\n> ```\n>\n> 找出那些 **没有被** `id = 2` 的客户 **推荐** 的客户的姓名。\n>\n> 以 **任意顺序** 返回结果表。\n>\n> 结果格式如下所示。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入： \n> Customer 表:\n> +----+------+------------+\n> | id | name | referee_id |\n> +----+------+------------+\n> | 1  | Will | null       |\n> | 2  | Jane | null       |\n> | 3  | Alex | 2          |\n> | 4  | Bill | null       |\n> | 5  | Zack | 1          |\n> | 6  | Mark | 2          |\n> +----+------+------------+\n> 输出：\n> +------+\n> | name |\n> +------+\n> | Will |\n> | Jane |\n> | Bill |\n> | Zack |\n> +------+\n> ```\n\n```mysql\nselect name \nfrom customer \nwhere referee_id!=2 or referee_id is null\n```\n\n## 🟢595. 大的国家\n\n> `World` 表：\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | name        | varchar |\n> | continent   | varchar |\n> | area        | int     |\n> | population  | int     |\n> | gdp         | bigint  |\n> +-------------+---------+\n> name 是该表的主键（具有唯一值的列）。\n> 这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。\n> ```\n>\n>  \n>\n> 如果一个国家满足下述两个条件之一，则认为该国是 **大国** ：\n>\n> - 面积至少为 300 万平方公里（即，`3000000 km2`），或者\n> - 人口至少为 2500 万（即 `25000000`）\n>\n> 编写解决方案找出 **大国** 的国家名称、人口和面积。\n>\n> 按 **任意顺序** 返回结果表。\n>\n> 返回结果格式如下例所示。\n>\n>  \n>\n> **示例：**\n>\n> ```\n> 输入：\n> World 表：\n> +-------------+-----------+---------+------------+--------------+\n> | name        | continent | area    | population | gdp          |\n> +-------------+-----------+---------+------------+--------------+\n> | Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n> | Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n> | Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n> | Andorra     | Europe    | 468     | 78115      | 3712000000   |\n> | Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n> +-------------+-----------+---------+------------+--------------+\n> 输出：\n> +-------------+------------+---------+\n> | name        | population | area    |\n> +-------------+------------+---------+\n> | Afghanistan | 25500100   | 652230  |\n> | Algeria     | 37100000   | 2381741 |\n> +-------------+------------+---------+\n> ```\n\n```mysql\nselect name, population, area\nfrom world\nwhere area >=3000000 or population >=25000000\n```\n\n\n\n## 🟢1148. 文章浏览 I\n\n> `Views` 表：\n>\n> ```\n> +---------------+---------+\n> | Column Name   | Type    |\n> +---------------+---------+\n> | article_id    | int     |\n> | author_id     | int     |\n> | viewer_id     | int     |\n> | view_date     | date    |\n> +---------------+---------+\n> 此表可能会存在重复行。（换句话说，在 SQL 中这个表没有主键）\n> 此表的每一行都表示某人在某天浏览了某位作者的某篇文章。\n> 请注意，同一人的 author_id 和 viewer_id 是相同的。\n> ```\n>\n>  \n>\n> 请查询出所有浏览过自己文章的作者\n>\n> 结果按照 `id` 升序排列。\n>\n> 查询结果的格式如下所示：\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Views 表：\n> +------------+-----------+-----------+------------+\n> | article_id | author_id | viewer_id | view_date  |\n> +------------+-----------+-----------+------------+\n> | 1          | 3         | 5         | 2019-08-01 |\n> | 1          | 3         | 6         | 2019-08-02 |\n> | 2          | 7         | 7         | 2019-08-01 |\n> | 2          | 7         | 6         | 2019-08-02 |\n> | 4          | 7         | 1         | 2019-07-22 |\n> | 3          | 4         | 4         | 2019-07-21 |\n> | 3          | 4         | 4         | 2019-07-21 |\n> +------------+-----------+-----------+------------+\n> \n> 输出：\n> +------+\n> | id   |\n> +------+\n> | 4    |\n> | 7    |\n> +------+\n> ```\n\n```mysql\nselect  distinct author_id as 'id'\nfrom views\nwhere viewer_id=author_id\norder by author_id\n```\n\n## 🟢1683. 无效的推文\n\n> 表：`Tweets`\n>\n> ```\n> +----------------+---------+\n> | Column Name    | Type    |\n> +----------------+---------+\n> | tweet_id       | int     |\n> | content        | varchar |\n> +----------------+---------+\n> 在 SQL 中，tweet_id 是这个表的主键。\n> 这个表包含某社交媒体 App 中所有的推文。\n> ```\n>\n>  \n>\n> 查询所有无效推文的编号（ID）。当推文内容中的字符数**严格大于** `15` 时，该推文是无效的。\n>\n> 以**任意顺序**返回结果表。\n>\n> 查询结果格式如下所示：\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Tweets 表：\n> +----------+----------------------------------+\n> | tweet_id | content                          |\n> +----------+----------------------------------+\n> | 1        | Vote for Biden                   |\n> | 2        | Let us make America great again! |\n> +----------+----------------------------------+\n> \n> 输出：\n> +----------+\n> | tweet_id |\n> +----------+\n> | 2        |\n> +----------+\n> 解释：\n> 推文 1 的长度 length = 14。该推文是有效的。\n> 推文 2 的长度 length = 32。该推文是无效的。\n> ```\n\n```mysql\nselect tweet_id\nfrom tweets\nwhere  length(content)>15\n```\n\n# 连接\n\n##  🟢1378.使用唯一标识码替换员工ID2\n\n> `Employees` 表：\n>\n> ```\n> +---------------+---------+\n> | Column Name   | Type    |\n> +---------------+---------+\n> | id            | int     |\n> | name          | varchar |\n> +---------------+---------+\n> 在 SQL 中，id 是这张表的主键。\n> 这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。\n> ```\n>\n>  \n>\n> `EmployeeUNI` 表：\n>\n> ```\n> +---------------+---------+\n> | Column Name   | Type    |\n> +---------------+---------+\n> | id            | int     |\n> | unique_id     | int     |\n> +---------------+---------+\n> 在 SQL 中，(id, unique_id) 是这张表的主键。\n> 这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。\n> ```\n>\n>  \n>\n> 展示每位用户的 **唯一标识码（unique ID ）**；如果某位员工没有唯一标识码，使用 null 填充即可。\n>\n> 你可以以 **任意** 顺序返回结果表。\n>\n> 返回结果的格式如下例所示。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Employees 表:\n> +----+----------+\n> | id | name     |\n> +----+----------+\n> | 1  | Alice    |\n> | 7  | Bob      |\n> | 11 | Meir     |\n> | 90 | Winston  |\n> | 3  | Jonathan |\n> +----+----------+\n> EmployeeUNI 表:\n> +----+-----------+\n> | id | unique_id |\n> +----+-----------+\n> | 3  | 1         |\n> | 11 | 2         |\n> | 90 | 3         |\n> +----+-----------+\n> 输出：\n> +-----------+----------+\n> | unique_id | name     |\n> +-----------+----------+\n> | null      | Alice    |\n> | null      | Bob      |\n> | 2         | Meir     |\n> | 3         | Winston  |\n> | 1         | Jonathan |\n> +-----------+----------+\n> 解释：\n> Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。\n> Meir 的唯一标识码是 2 。\n> Winston 的唯一标识码是 3 。\n> Jonathan 唯一标识码是 1 。\n> ```\n\n```mysql\nselect e2.unique_id,e1.name\nfrom Employees e1\nleft join EmployeeUNI e2\non e1.id=e2.id\n```\n\n## 🟢1581. 进店却未进行过交易的顾客\n\n> 表：`Visits`\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | visit_id    | int     |\n> | customer_id | int     |\n> +-------------+---------+\n> visit_id 是该表中具有唯一值的列。\n> 该表包含有关光临过购物中心的顾客的信息。\n> ```\n>\n>  \n>\n> 表：`Transactions`\n>\n> ```\n> +----------------+---------+\n> | Column Name    | Type    |\n> +----------------+---------+\n> | transaction_id | int     |\n> | visit_id       | int     |\n> | amount         | int     |\n> +----------------+---------+\n> transaction_id 是该表中具有唯一值的列。\n> 此表包含 visit_id 期间进行的交易的信息。\n> ```\n>\n>  \n>\n> 有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个解决方案，来查找这些顾客的 ID ，以及他们只光顾不交易的次数。\n>\n> 返回以 **任何顺序** 排序的结果表。\n>\n> 返回结果格式如下例所示。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入:\n> Visits\n> +----------+-------------+\n> | visit_id | customer_id |\n> +----------+-------------+\n> | 1        | 23          |\n> | 2        | 9           |\n> | 4        | 30          |\n> | 5        | 54          |\n> | 6        | 96          |\n> | 7        | 54          |\n> | 8        | 54          |\n> +----------+-------------+\n> Transactions\n> +----------------+----------+--------+\n> | transaction_id | visit_id | amount |\n> +----------------+----------+--------+\n> | 2              | 5        | 310    |\n> | 3              | 5        | 300    |\n> | 9              | 5        | 200    |\n> | 12             | 1        | 910    |\n> | 13             | 2        | 970    |\n> +----------------+----------+--------+\n> 输出:\n> +-------------+----------------+\n> | customer_id | count_no_trans |\n> +-------------+----------------+\n> | 54          | 2              |\n> | 30          | 1              |\n> | 96          | 1              |\n> +-------------+----------------+\n> 解释:\n> ID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。\n> ID = 9 的顾客曾经逛过一次购物中心，并在 ID = 13 的访问期间进行了一笔交易。\n> ID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。\n> ID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。\n> ID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。\n> 如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。\n> ```\n","categories":["database"]},{"title":"🟢 2744. find maximum number of string pairs","url":"/2024/01/17/coding-2744-find-maximum-number-of-string-pairs/","content":"\n# Description\n\n> 给你一个下标从 **0** 开始的数组 `words` ，数组中包含 **互不相同** 的字符串。\n>\n> 如果字符串 `words[i]` 与字符串 `words[j]` 满足以下条件，我们称它们可以匹配：\n>\n> - 字符串 `words[i]` 等于 `words[j]` 的反转字符串。\n> - `0 <= i < j < words.length`\n>\n> 请你返回数组 `words` 中的 **最大** 匹配数目。\n>\n> 注意，每个字符串最多匹配一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\n> 输出：2\n> 解释：在此示例中，我们可以通过以下方式匹配 2 对字符串：\n> - 我们将第 0 个字符串与第 2 个字符串匹配，因为 word[0] 的反转字符串是 \"dc\" 并且等于 words[2]。\n> - 我们将第 1 个字符串与第 3 个字符串匹配，因为 word[1] 的反转字符串是 \"ca\" 并且等于 words[3]。\n> 可以证明最多匹配数目是 2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words = [\"ab\",\"ba\",\"cc\"]\n> 输出：1\n> 解释：在此示例中，我们可以通过以下方式匹配 1 对字符串：\n> - 我们将第 0 个字符串与第 1 个字符串匹配，因为 words[1] 的反转字符串 \"ab\" 与 words[0] 相等。\n> 可以证明最多匹配数目是 1 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words = [\"aa\",\"ab\"]\n> 输出：0\n> 解释：这个例子中，无法匹配任何字符串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= words.length <= 50`\n> - `words[i].length == 2`\n> - `words` 包含的字符串互不相同。\n> - `words[i]` 只包含小写英文字母。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 模拟\n\n# Solution\n\n```java\nclass Solution {\n    public int maximumNumberOfStringPairs(String[] words) {\n        Set<String>set=new HashSet<>();\n        int res=0;\n        for (int i = 0; i < words.length; i++) {\n            if(set.contains(words[i])){\n               res++;\n            }else{\n                StringBuilder temp=new StringBuilder(words[i]);\n                set.add(temp.reverse().toString());\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(n)*\n","tags":["algorithm-Array","algorithm-HashTable","algorithm-Simulation","algorithm-String"]},{"title":"🟡82. remove duplicates from sorted list ii","url":"/2024/01/15/coding-82-remove-duplicates-from-sorted-list-ii/","content":"\n# Description\n\n> 给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,3,4,4,5]\n> 输出：[1,2,5]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n>\n> ```\n> 输入：head = [1,1,1,2,3]\n> 输出：[2,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n# Solution\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head)  {\n        // 节点数为0,1\n        if(head==null||head.next==null){\n            return head;\n        }\n        // 节点为2\n        if(head.next.next==null&&head.val==head.next.val){\n            return null;\n        }else if(head.next.next==null){\n            return head;\n        }\n        // 确定head\n        ListNode p=head.next;\n        while(p!=null&&p.val==head.val){\n            while(p!=null&&p!=null&&p.val==head.val){\n                p=p.next;\n            }\n            head=p;\n            if(p!=null){\n                p=p.next;\n            }\n            //每次换了head之后再筛一下\n            if(head==null||head.next==null){\n                return head;\n            }\n            if(head.next.next==null&&head.val==head.next.val){\n                return null;\n            }else if(head.next.next==null){\n                return head;\n            }\n        }\n        // 中间，此时节点数>=3，而且前两个节点不相等\n        ListNode p1=head,p2=p1.next,p3=p2.next;\n        while(p3!=null){\n            if(p3.val==p2.val){\n                while(p3!=null&&p3.val==p2.val){\n                    p3=p3.next;\n                }\n                p1.next=p3;\n                p2=p3;\n                if(p2!=null){\n                    p3 = p2.next;\n                }\n\n            }else{\n                p1=p2;\n                p2=p3;\n                p3=p3.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            if (cur.next.val == cur.next.next.val) {\n                int x = cur.next.val;\n                while (cur.next != null && cur.next.val == x) {\n                    cur.next = cur.next.next;\n                }\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n","tags":["algorithm-Two Pointers","algorithm-Linked List"]},{"title":"🟢83. remove duplicates from sorted list","url":"/2024/01/14/coding-83-remove-duplicates-from-sorted-list/","content":"\n# Description\n\n> 给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n>\n> ```\n> 输入：head = [1,1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n>\n> ```\n> 输入：head = [1,1,2,3,3]\n> 输出：[1,2,3]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n\n# Solution\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode last=head,p=last.next;\n        while(p.next!=null) {//p不是最后一个\n            if (p.val == last.val) {\n                last.next = p.next;\n            }else{\n                last = p;\n            }\n            p = p.next;\n        }\n        if(p.val==last.val){\n            last.next=null;\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode ptr = head;\n        while(ptr != null && ptr.next != null) {\n            if(ptr.val == ptr.next.val) {\n                ptr.next = ptr.next.next;\n            } else {\n                ptr = ptr.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n","tags":["algorithm-Linked List"]},{"title":"🔹380th LeetCode Weekly Contest","url":"/2024/01/14/contest-weekly-380/","content":"\n|      | score | problem                      | tag                                                          |\n| ---- | ----- | ---------------------------- | ------------------------------------------------------------ |\n| ✅    | 3     | 🟢最大频率元素计数            | array hash-table counting                                    |\n| ✅    | 4     | 🟡找出数组中的美丽下标 I      | two-pointers string binary-search string-matching hash-function rolling-hash |\n|      | 5     | 🟡价值和小于等于 K 的最大数字 | bit-munipulation DP biary-s                                  |\n| ✅    | 6     | 🔴找出数组中的美丽下标 I      | two-pointers string binary-search string-matching hash-function rolling-hash |\n\n# 🟢最大频率元素计数\n\n> 给你一个由 **正整数** 组成的数组 `nums` 。\n>\n> 返回数组 `nums` 中所有具有 **最大** 频率的元素的 **总频率** 。\n>\n> 元素的 **频率** 是指该元素在数组中出现的次数。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,2,3,1,4]\n> 输出：4\n> 解释：元素 1 和 2 的频率为 2 ，是数组中的最大频率。\n> 因此具有最大频率的元素在数组中的数量是 4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5]\n> 输出：5\n> 解释：数组中的所有元素的频率都为 1 ，是最大频率。\n> 因此具有最大频率的元素在数组中的数量是 5 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `1 <= nums[i] <= 100`\n\n```java\nclass Solution {\n   public int maxFrequencyElements(int[] nums) {\n        int[] hashtable=new int[101];\n        int max=0,res=0;\n        for(int i=0;i<nums.length;i++){\n            hashtable[nums[i]]++;\n            max=Math.max(max,hashtable[nums[i]]);\n        }\n        for(int i=0;i<nums.length;i++){\n            if(hashtable[nums[i]]==max){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time：*O(n)*\n\n- space：*O(n)*\n\n# 🟡找出数组中的美丽下标 I\n\n> 给你一个下标从 **0** 开始的字符串 `s` 、字符串 `a` 、字符串 `b` 和一个整数 `k` 。\n>\n> 如果下标 `i` 满足以下条件，则认为它是一个 **美丽下标**：\n>\n> - `0 <= i <= s.length - a.length`\n>\n> - `s[i..(i + a.length - 1)] == a`\n>\n> - 存在下标`i`,`j`\n>\n>   使得：\n>\n>   - `0 <= j <= s.length - b.length`\n>   - `s[j..(j + b.length - 1)] == b`\n>   - `|j - i| <= k`\n>\n> 以数组形式按 **从小到大排序** 返回美丽下标。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n> 输出：[16,33]\n> 解释：存在 2 个美丽下标：[16,33]。\n> - 下标 16 是美丽下标，因为 s[16..17] == \"my\" ，且存在下标 4 ，满足 s[4..11] == \"squirrel\" 且 |16 - 4| <= 15 。\n> - 下标 33 是美丽下标，因为 s[33..34] == \"my\" ，且存在下标 18 ，满足 s[18..25] == \"squirrel\" 且 |33 - 18| <= 15 。\n> 因此返回 [16,33] 作为结果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\", a = \"a\", b = \"a\", k = 4\n> 输出：[0]\n> 解释：存在 1 个美丽下标：[0]。\n> - 下标 0 是美丽下标，因为 s[0..0] == \"a\" ，且存在下标 0 ，满足 s[0..0] == \"a\" 且 |0 - 0| <= 4 。\n> 因此返回 [0] 作为结果。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= k <= s.length <= 105`\n> - `1 <= a.length, b.length <= 10`\n> - `s`、`a`、和 `b` 只包含小写英文字母。\n\n第一思路，写的超时了：\n\n```java\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        int len_s=s.length(),len_a=a.length(),len_b=b.length();\n        List<Integer>res=new ArrayList<>();\n        for (int i = 0; i <= len_s-len_a; i++) {\n            if(s.substring(i,i+len_a).equals(a)){\n                for (int j = 0; j <= len_s-len_b; j++) {\n                    if(s.substring(j,j+len_b).equals(b)&&Math.abs(j-i)<=k){\n                        res.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O((n-m) ·(n-m))*\n\n- space:*O(1)*\n\n是一个不错的契机实战一下KMP算法：\n\n```java\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {        \n        List<Integer>list_a=kmp(s,a);\n        List<Integer>list_b=kmp(s,b);\n        List<Integer>res=new ArrayList<>();\n        for(int i=0;i<list_a.size();i++){\n           for(int j=0;j<list_b.size();j++){\n               if(Math.abs(list_a.get(i)-list_b.get(j))<=k){\n                   res.add(list_a.get(i));\n                   break;\n               }\n            }\n        }\n        return res;\n    } \n    List<Integer> kmp(String text, String pattern) {\n        List<Integer> res = new ArrayList<>();\n        int len = pattern.length();\n        int[] next = new int[len];\n        int j = 0;\n        for (int i = 1; i < len; i++) {\n            char ch = pattern.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            next[i] = j;\n        }        \n        j = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char ch = text.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            if (j == len) {\n                res.add(i - len + 1);\n                j = next[j - 1];\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time：*O(n)*\n\n- space:*O(n)*\n\n# 🟡价值和小于等于 K 的最大数字\n\n> 给你一个整数 `k` 和一个整数 `x` 。\n>\n> 令 `s` 为整数 `num` 的下标从 **1** 开始的二进制表示。我们说一个整数 `num` 的 **价值** 是满足 `i % x == 0` 且 `s[i]` 是 **设置位** 的 `i` 的数目。\n>\n> 请你返回 **最大** 整数 `num` ，满足从 `1` 到 `num` 的所有整数的 **价值** 和小于等于 `k` 。\n>\n> **注意：**\n>\n> - 一个整数二进制表示下 **设置位** 是值为 `1` 的数位。\n> - 一个整数的二进制表示下标从右到左编号，比方说如果 `s == 11100` ，那么 `s[4] == 1` 且 `s[2] == 0` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：k = 9, x = 1\n> 输出：6\n> 解释：数字 1 ，2 ，3 ，4 ，5 和 6 二进制表示分别为 \"1\" ，\"10\" ，\"11\" ，\"100\" ，\"101\" 和 \"110\" 。\n> 由于 x 等于 1 ，每个数字的价值分别为所有设置位的数目。\n> 这些数字的所有设置位数目总数是 9 ，所以前 6 个数字的价值和为 9 。\n> 所以答案为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：k = 7, x = 2\n> 输出：9\n> 解释：由于 x 等于 2 ，我们检查每个数字的偶数位。\n> 2 和 3 在二进制表示下的第二个数位为设置位，所以它们的价值和为 2 。\n> 6 和 7 在二进制表示下的第二个数位为设置位，所以它们的价值和为 2 。\n> 8 和 9 在二进制表示下的第四个数位为设置位但第二个数位不是设置位，所以它们的价值和为 2 。\n> 数字 1 ，4 和 5 在二进制下偶数位都不是设置位，所以它们的价值和为 0 。\n> 10 在二进制表示下的第二个数位和第四个数位都是设置位，所以它的价值为 2 。\n> 前 9 个数字的价值和为 6 。\n> 前 10 个数字的价值和为 8，超过了 k = 7 ，所以答案为 9 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= 10^15`\n> - `1 <= x <= 8`\n>\n> Related Topics\n>\n> 位运算\n>\n> 二分查找\n>\n> 动态规划\n\n“一个拥有良好学习态度的菜鸟是哪怕没有掌握高性能的算法，也要模拟到报错是超时再看题解”（扶额苦笑😅）\n\n![image-20240204223555996](contest-weekly-380/image-20240204223555996.png)\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution=new Solution();\n        System.out.println(solution.findMaximumNumber(3278539330613,5));\n    }\n}\nclass Solution {\n    public long findMaximumNumber(long k, int x) {\n        long res=1;\n        long sum=0;\n        while (sum<=k){\n            long count=func(res,x);\n            sum+=count;\n            if(sum>k){\n                return res-1;\n            }\n            res++;\n        }\n        return res;\n    }\n    long func(long num,int k){\n        long sum=0;\n        String binary = Long.toBinaryString(num);\n        for (int i = binary.length()-k; i>= 0; i-=k) {\n            sum+=  Long.parseLong(binary.charAt(i)+\"\");\n        }\n        return sum;\n    }\n}\n```\n\n\n\n\n\n# <spa🔴找出数组中的美丽下标 II\n\n> 给你一个下标从 **0** 开始的字符串 `s` 、字符串 `a` 、字符串 `b` 和一个整数 `k` 。\n>\n> 如果下标 `i` 满足以下条件，则认为它是一个 **美丽下标** ：\n>\n> - `0 <= i <= s.length - a.length`\n>\n> - `s[i..(i + a.length - 1)] == a`\n>\n> - 存在下标` i`,`j`\n>\n>    使得：\n>\n>   - `0 <= j <= s.length - b.length`\n>   - `s[j..(j + b.length - 1)] == b`\n>   - `|j - i| <= k`\n>\n> 以数组形式按 **从小到大排序** 返回美丽下标。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n> 输出：[16,33]\n> 解释：存在 2 个美丽下标：[16,33]。\n> - 下标 16 是美丽下标，因为 s[16..17] == \"my\" ，且存在下标 4 ，满足 s[4..11] == \"squirrel\" 且 |16 - 4| <= 15 。\n> - 下标 33 是美丽下标，因为 s[33..34] == \"my\" ，且存在下标 18 ，满足 s[18..25] == \"squirrel\" 且 |33 - 18| <= 15 。\n> 因此返回 [16,33] 作为结果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\", a = \"a\", b = \"a\", k = 4\n> 输出：[0]\n> 解释：存在 1 个美丽下标：[0]。\n> - 下标 0 是美丽下标，因为 s[0..0] == \"a\" ，且存在下标 0 ，满足 s[0..0] == \"a\" 且 |0 - 0| <= 4 。\n> 因此返回 [0] 作为结果。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= k <= s.length <= 5 * 105`\n> - `1 <= a.length, b.length <= 5 * 105`\n> - `s`、`a`、和 `b` 只包含小写英文字母。\n\n相对于之前的[🟡找出数组中的美丽下标 I](#head2) 对于得到的b位置数组的遍历进行了优化\n\n```java\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        List<Integer>list_a=kmp(s,a);\n        List<Integer>list_b=kmp(s,b);\n        List<Integer>res=new ArrayList<>();\n        //优化了遍历方式↓\n        int j = 0;\n        for (int i : list_a) {//对于每个a位置数组的元素，只需寻找到一个在范围内的b位置数组中元素存在\n            while (j < list_b.size() && list_b.get(j) < i - k) {\n                j++;//滑动指针到a位置数组的元素i的左领域之前\n            }\n            if (j < list_b.size() && Math.abs(list_b.get(j) - i) <= k) {//继续滑动到领域内，一旦发现符合的元素，就纳入i\n                res.add(i);\n            }\n        }\n        return res;\n    }\n    List<Integer> kmp(String text, String pattern) {\n        List<Integer> res = new ArrayList<>();\n        int len = pattern.length();\n        int[] next = new int[len];\n        int j = 0;\n        for (int i = 1; i < len; i++) {\n            char ch = pattern.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            next[i] = j;\n        }\n        j = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char ch = text.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            if (j == len) {\n                res.add(i - len + 1);\n                j = next[j - 1];\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time：*O(n)*\n\n\n- space:*O(n)*\n","tags":["contest"]},{"title":"🟢2085. count common words with one occurrence","url":"/2024/01/12/coding-2085-count-common-words-with-one-occurrence/","content":"\n# Description\n\n> 给你两个字符串数组 `words1` 和 `words2` ，请你返回在两个字符串数组中 **都恰好出现一次** 的字符串的数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n> 输出：2\n> 解释：\n> - \"leetcode\" 在两个数组中都恰好出现一次，计入答案。\n> - \"amazing\" 在两个数组中都恰好出现一次，计入答案。\n> - \"is\" 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。\n> - \"as\" 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。\n> 所以，有 2 个字符串在两个数组中都恰好出现了一次。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n> 输出：0\n> 解释：没有字符串在两个数组中都恰好出现一次。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n> 输出：1\n> 解释：唯一在两个数组中都出现一次的字符串是 \"ab\" 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= words1.length, words2.length <= 1000`\n> - `1 <= words1[i].length, words2[j].length <= 30`\n> - `words1[i]` 和 `words2[j]` 都只包含小写英文字母。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n# Solution\n\n```java\nclass Solution {\n    public int countWords(String[] words1, String[] words2) {\n        HashMap<String,Integer>hashMap1=new HashMap<>();\n        HashMap<String,Integer>hashMap2=new HashMap<>();\n        int cnt=0;\n        for (int i = 0; i < words1.length; i++) {\n            hashMap1.put(words1[i],hashMap1.getOrDefault(words1[i],0)+1);\n        }\n        for (int i = 0; i < words2.length; i++) {\n            hashMap2.put(words2[i],hashMap2.getOrDefault(words2[i],0)+1);\n        }\n        for (int i = 0; i < words2.length; i++) {\n            if(hashMap1.containsKey(words2[i])&&hashMap1.get(words2[i])==1&&hashMap2.get(words2[i])==1){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n+m)*\n- space:*O(n+m)*\n","tags":["algorithm-Array","algorithm-HashTable","algorithm-String","algorithm-Counting"]},{"title":"20-day special training","url":"/2023/12/24/problem-set-OD/","content":"\n| 天数                           | 主题                                          | 编号 | 题目                                                       | 是否完成 |\n| ------------------------------ | --------------------------------------------- | ---- | :--------------------------------------------------------- | -------- |\n| [ 第一天](#head2)              | [设计](#head3)                                | 1    | [🟢1603.设计停车系统](#head4)                               | ✅        |\n|                                | [ 栈](#head5)                                 | 2    | [ 🟢20.有效的括号](#head6)                                  | ✅        |\n|                                |                                               | 3    | [ 2023Q1A-括号检查](#head7)                                | ✅        |\n|                                | [ 队列](#head8)                               | 4🌵   | [ 🟢剑指offerⅡ041.滑动窗口的平均值](#head9)                 | ✅        |\n|                                | [作业](#head10)                               | 5    | [ 🟢1614.括号的最大嵌套深度](#head11)                       | ✅        |\n|                                |                                               | 6    | [ 🟢1047.删除字符串中的所有相邻重复项](#head12)             | ✅        |\n|                                |                                               | 7    | [ 2023Q1A-身高提供排序](#head13)                           | ✅        |\n| [ 第二天](#head14)             | [ 栈](#head15)                                | 8    | [ 🟡150.逆波兰表达式求值](#head16)                          | ✅        |\n|                                |                                               | 9    | [ 🔴224.基本计算器](#head17)                                |          |\n|                                |                                               | 10   | [🟡155.最小栈](#head18)                                     | ✅        |\n|                                |                                               | 11   | [ 🟡394.字符串解码](#head19)                                | ✅        |\n|                                | [ 作业](#head20)                              | 12   | [ 🟡71.简化路径](#head21)                                   | ✅        |\n|                                |                                               | 13   | [ 🟡946.检证栈序列](#head22)                                | ✅        |\n|                                |                                               | 14   | [ 2023Q1A-投篮大赛](#head23)                               | ✅        |\n|                                |                                               | 15   | [ 2023Q1A-解压缩算法](#head24)                             | ✅        |\n| [ 第三天](#head25)             | [ 哈希集合](#head26)                          | 16   | [ 🟢217.存在重复元素](#head27)                              | ✅        |\n|                                |                                               | 17   | [ 🟢349.两个数字的交集](#head28)                            | ✅        |\n|                                | [ 哈希表-用于统计频率](#head29)               | 18   | [ 🟢242.有效的字母异位词](#head30)                          | ✅        |\n|                                |                                               | 19   | [ 🟢383.赎金信](#head31)                                    | ✅        |\n|                                |                                               | 20   | [ 2023Q1A-集五福](#head32)                                 | ✅        |\n|                                |                                               | 21   | [ 2023Q1A-删除最少字符](#head33)                           | ✅        |\n|                                | [ 作业](#head34)                              | 22   | [ 🟢387.字符串中的第一个唯一字符](#head35)                  | ✅        |\n|                                |                                               | 23   | [ 🟢350.两个数组的交集Ⅱ](#head36)                           | ✅        |\n|                                |                                               | 24   | [ 2023Q1A-寻找关键钥匙](#head37)                           | ✅        |\n|                                |                                               | 25   | [ 2023Q1A-明明的随机数](#head38)                           | ✅        |\n|                                |                                               | 26   | [ 2023Q1A-统计匹配的二元组个数](#head39)                   | ✅        |\n| [ 第四天](#head40)             | [ 哈希表-用于下表查询](#head41)               | 27   | [ 🟢1.两数之和](#head42)                                    | ✅        |\n|                                |                                               | 28   | [ 🟢219.存在重复元素Ⅱ](#head43)                             | ✅        |\n|                                | [ 哈希表-用于元素配对](#head44)               | 29   | [ 🟢205.同构字符串](#head45)                                | ✅        |\n|                                |                                               | 30   | [🟡49.字母异位词分组](#head46)                              | ✅        |\n|                                | [ 作业](#head47)                              | 31   | [ 🟢290.单词规律](#head48)                                  | ✅        |\n|                                |                                               | 32   | [ 2023Q1A-字符串重新排序](#head49)                         | ✅        |\n|                                |                                               | 33   | [2023Q2B-选修课](#head50)                                  |          |\n|                                |                                               | 34   | [ 2023Q1A-相同数字的积木游戏](#head51)                     | ✅        |\n|                                |                                               | 35   | [ 2023Q1A-英文输入法](#head52)                             | ✅        |\n|                                |                                               | 36   | [ 2023Q1A-寻找密码](#head53)                               | ✅        |\n| [ 第五天](#head54)             | [ 单调栈](#head55)                            | 37   | [ 🟢1475.商品折扣后的最终价格](#head56)                     | ✅        |\n|                                |                                               | 38🌵  | [ 🟡739.每日温度](#head57)                                  | ✅        |\n|                                |                                               | 39   | [🔴42.接雨水](#head58)                                      |          |\n|                                | [ 栈与队列综合](#head59)                      | 40   | [ 🟢232.用栈实现队列](#head60)                              | ✅        |\n|                                | [ 作业](#head61)                              | 41   | [ 🟢225.用队列实现栈](#head62)                              | ✅        |\n|                                |                                               | 42   | [ 🟢496.下一个更大的元素Ⅰ](#head63)                         | ✅        |\n|                                |                                               | 43   | [ 2023Q1A-找朋友](#head64)                                 | ✅        |\n|                                |                                               | 44🌵  | [ 2023Q1A-删除重复数字后的最大数字](#head65)               | ✅        |\n|                                |                                               | 45🌵  | [ 2023Q1B-找最小数](#head66)                               | ✅        |\n| [ 第六天](#head67)             | [ 双指针-同向双指针](#head68)                 | 46   | [ 🟢88.合并两个有序数组](#head69)                           | ✅        |\n|                                |                                               | 47   | [ 🟢26.删除有序数组的重复项](#head70)                       | ✅        |\n|                                |                                               | 48   | [🟡80.删除有序数组的重复项Ⅱ](#head71)                       | ✅        |\n|                                |                                               | 49   | [🟢485.最大连续1的个数](#head72)                            | ✅        |\n|                                | [ 作业](#head73)                              | 50   | [ 🟢283.移动零](#head74)                                    | ✅        |\n|                                |                                               | 51   | [ 🟢27.移除数组](#head75)                                   | ✅        |\n|                                |                                               | 52   | [2023Q1A-最长的元音字符串](#head76)                        | ✅        |\n| [ 第七天](#head77)             | [ 相向双指针](#head78)                        | 53   | [ 🟢9.回文数](#head79)                                      | ✅        |\n|                                |                                               | 54   | [ 🟢125.验证回文数](#head80)                                | ✅        |\n|                                |                                               | 55   | [ 🟡167.两数之和Ⅱ-输入有序数组](#head81)                    | ✅        |\n|                                |                                               | 56   | [ 🟡11.盛水最多的容器](#head82)                             | ✅        |\n|                                |                                               | 57   | [ 🟡15.三数之和](#head83)                                   | ✅        |\n|                                |                                               | 58   | [🟡75.颜色分类](#head84)                                    | ✅        |\n|                                | [ 作业](#head85)                              | 59   | [ 🟢680.验证回文串Ⅱ](#head86)                               | ✅        |\n|                                |                                               | 60   | [ 2023Q1A-两数之和绝对值最小](#head87)                     | ✅        |\n|                                |                                               | 61   | [ 2023Q1A-双十一](#head88)                                 | ✅        |\n| [ 第八天](#head89)             | [ 贪心](#head90)                              | 62   | [ 🟢455.分发饼干](#head91)                                  | ✅        |\n|                                |                                               | 63   | [ 🟡134.加油站](#head92)                                    | ✅        |\n|                                |                                               | 64   | [ 🟢860.柠檬水找零](#head93)                                | ✅        |\n|                                |                                               | 65   | [ 🟢605.种花问题](#head94)                                  | ✅        |\n|                                |                                               | 66   | [ 🟡376.摆动序列](#head95)                                  | ✅        |\n|                                |                                               | 67   | [ 2023Q1A-快递货车](#head96)                               | ✅        |\n|                                | [ 作业](#head97)                              | 68   | [ 2023Q1A-停车找车位](#head98)                             | ✅        |\n|                                |                                               | 69   | [2023Q1A-卡片组成的最大数字](#head99)                      | ✅        |\n| [ 第九天](#head100)            | [ 贪心](#head101)                             | 70   | [ 🟡881.救生艇](#head102)                                   | ✅        |\n|                                |                                               | 71   | [ 🟡122.买卖股票的最佳时机Ⅱ](#head103)                      | ✅        |\n|                                |                                               | 72   | [ 🟡45.跳跃游戏Ⅱ](#head104)                                 |          |\n|                                |                                               | 73   | [ 🔴135.分发糖果](#head105)                                 |          |\n|                                | [ 作业](#head106)                             | 74   | [ 🟡55.跳跃游戏](#head107)                                  |          |\n|                                |                                               | 75   | [ 2023Q1A-卡片组成的最大数字](#head108)                    |          |\n|                                |                                               | 76   | [ 2023Q1A-贪心的商人](#head109)                            |          |\n|                                |                                               | 77   | [ 2023B-观看文艺汇演](#head110)                            |          |\n| [ 第十天](#head111)            | [ 滑动窗口-长度可变](#head112)                | 78   | [ 🟡3.无重复字符的最长字符](#head113)                       |          |\n|                                |                                               | 79   | [ 🟡209.长度最小的子数组](#head114)                         |          |\n|                                |                                               | 80   | [ 🟡904.水果成蓝](#head115)                                 |          |\n|                                |                                               | 81   | [ 🟡159.至多包含两个不同的字符的最长字串](#head116)         |          |\n|                                |                                               | 82   | [ 🟡340.至多包含k个不同的字符的最长字串](#head117)          |          |\n|                                |                                               | 83   | [ 🔴76.最小覆盖字串](#head118)                              |          |\n|                                |                                               | 84   | [ 2023Q1A-区块链文件转储系统](#head119)                    |          |\n|                                |                                               | 85   | [ 2023Q2-寻找符合要求的最长字串](#head120)                 |          |\n|                                | [ 作业](#head121)                             | 86   | [ 🟡1695.删除子数组的最大分数](#head122)                    |          |\n|                                |                                               | 87   | [ 🟡2024.考试的最大扰度](#head123)                          |          |\n|                                |                                               | 88   | [ 🟡1658.将x减到0的最小操作数](#head124)                    |          |\n|                                |                                               | 89   | [ 2023Q1A-完美走位](#head125)                              |          |\n| [ 第十一天](#head126)          | [ 滑动窗口-长度不可变](#head127)              | 90   | [ 🟢1984.学生分数的最小差值](#head128)                      |          |\n|                                |                                               | 91   | [ 🟡1456.定长子串中元音的最大数目](#head129)                |          |\n|                                |                                               | 92   | [ 🟡567.字符串的排列](#head130)                             |          |\n|                                |                                               | 93   | [ 🟡1052.爱生气的书店老板](#head131)                        |          |\n|                                |                                               | 94   | [ 2023Q1A-找出通过车辆最多颜色](#head132)                  |          |\n|                                |                                               | 95   | [ 2023Q1A-知识图谱新词挖掘](#head133)                      |          |\n|                                | [ 作业](#head134)                             | 96   | [ 🟢2269.找到一个数字的k美丽值](#head135)                   |          |\n|                                |                                               | 97   | [ 🟡1876.长度为三且字符不同的子字符串](#head136)            |          |\n|                                |                                               | 98   | [ 🟡438.找到字符串中所有字母异位词](#head137)               |          |\n| [ 第十二天](#head138)          | [ 序列DP-入门](#head139)                      | 99   | [🟢509.斐波那契数](#head140)                                |          |\n|                                |                                               | 100  | [ 🟢70.爬楼梯](#head141)                                    |          |\n|                                | [ 序列DP-路径问题](#head142)                  | 101  | [ 🟡62.不同路径](#head143)                                  |          |\n|                                |                                               | 102  | [ 🟡63.不同路径Ⅱ](#head144)                                 |          |\n|                                |                                               | 103  | [ 🟡64.最小路径和](#head145)                                |          |\n|                                | [ 序列DP-打家劫舍](#head146)                  | 104  | [ 🟡198.打家劫舍](#head147)                                 |          |\n|                                |                                               | 105  | [ 🟡213.打家劫舍Ⅱ](#head148)                                |          |\n|                                | [ 作业](#head149)                             | 106  | [ 🟢1137.第n个泰波那锲数](#head150)                         |          |\n|                                |                                               | 107  | [ 🟡120.三角形最小路径和](#head151)                         |          |\n|                                |                                               | 108  | [ 🟡931.下降路径最小和](#head152)                           |          |\n|                                |                                               | 109  | [ 2023Q1A-猴子爬山](#head153)                              |          |\n|                                |                                               | 110  | [ 2023Q2-超级玛丽过吊桥](#head154)                         |          |\n| [ 第十三天](#head155)          | [ 序列DP-最长递增子序列(LIS)](#head156)       | 111  | [ 🟡300.最长递增子序列](#head157)                           |          |\n|                                |                                               | 112  | [ 🟡673.最长递增子序列的个数](#head158)                     |          |\n|                                |                                               | 113  | [ 🟡334.递增的三元组](#head159)                             |          |\n|                                | [ 序列DP-最长公共子序列(LCS)](#head160)       | 114  | [ 🟡718.最长重复子数字](#head161)                           |          |\n|                                |                                               | 115  | [ 🟡1143.最长公共子序列](#head162)                          |          |\n|                                | [ 作业](#head163)                             | 116  | [ 面试题17.08马戏团人塔](#head164)                         |          |\n|                                |                                               | 117  | [ 🟡1035.不相交的线](#head165)                              |          |\n|                                |                                               | 118  | [ 2023Q1A-寻找重复代码](#head166)                          |          |\n|                                |                                               | 119  | [2023Q2-高速公路休息站充电规则](#head167)                  |          |\n| [ 第十四天](#head168)          | [ 状态DP-入门](#head169)                      | 120  | [🟡LCR 091.粉刷房子](#head170)                              |          |\n|                                | [ 状态DP-股票问题](#head171)                  | 121  | [ 🔴188.买卖股票的最佳时机Ⅳ](#head172)                      |          |\n|                                |                                               | 122  | [ 🟢121.买卖股票的最佳时机](#head173)                       |          |\n|                                |                                               | 123  | [ 🔴123.买卖股票的最佳时机Ⅲ](#head174)                      |          |\n|                                |                                               | 124  | [ 🟡122.买卖股票的最佳时机Ⅱ](#head175)                      |          |\n|                                |                                               | 125  | [ 🟡309.最佳买卖股票时机含冷冻期](#head176)                 |          |\n|                                |                                               | 126  | [ 🟡714.买卖股票的的最佳时机含手续费](#head177)             |          |\n|                                | [ 作业](#head178)                             | 127  | [ 2023Q1A-贪心的商人](#head179)                            |          |\n|                                |                                               | 128  | [2023Q1A-递增字符串](#head180)                             |          |\n| [ 第十五天](#head181)          | [ 背包DP-01背包](#head182)                    | 129  | [ 🟡494.目标和](#head183)                                   |          |\n|                                | [ 背包DP-完全背包](#head184)                  | 130  | [ 🟡322.零钱兑换](#head185)                                 |          |\n|                                |                                               | 131  | [ 🟡518.零钱兑换Ⅱ](#head186)                                |          |\n|                                | [ 作业](#head187)                             | 132  | [🟡416.分割等和子集](#head188)                              |          |\n|                                |                                               | 133  | [ 🟡1049.最后一块石头的重量Ⅱ](#head189)                     |          |\n| [ 第十六天](#head190)          | [ 二分查找-在排序数组中](#head191)            | 134  | [ 🟢35.搜索插入位置](#head192)                              |          |\n|                                |                                               | 135  | [🟢704.二分查找](#head193)                                  |          |\n|                                |                                               | 136  | [🟡34.在排序数组中查找元素的第一个和最后一个位置](#head194) |          |\n|                                | [ 二分查找-在数轴中](#head195)                | 137  | [ 🟢367.有效的完全平方数](#head196)                         |          |\n|                                |                                               | 138  | [🟢69.x 的平方根](#head197)                                 |          |\n|                                | [ 二分查找-利用问题的二段性](#head198)        | 139  | [ 🟡875.爱吃香蕉的珂珂](#head199)                           |          |\n|                                |                                               | 140  | [ 2023Q1A-开放日活动](#head200)                            |          |\n|                                |                                               | 141  | [ 2023B-食堂供餐](#head201)                                |          |\n|                                | [ 作业](#head202)                             | 142  | [🟢374.猜数字大小](#head203)                                |          |\n|                                |                                               | 143  | [ 🟡1011.在D天内送达包裹的能力](#head204)                   |          |\n|                                |                                               | 144  | [ 2023Q1A-农场施肥](#head205)                              |          |\n|                                |                                               | 145  | [ 2023B-最佳植树距离](#head206)                            |          |\n| [ 第十七天/第十八天](#head207) | [ DFS/BFS-前置问题](#head208)                 | 146  | [ 2023B-统计监控](#head209)                                |          |\n|                                | [ DFS/BFS-二维矩阵表示图(岛屿问题)](#head210) | 147  | [ 🟡200.岛屿数量](#head211)                                 |          |\n|                                |                                               | 148  | [ 🟡695.岛屿的最大面积](#head212)                           |          |\n|                                |                                               | 149  | [ 2023Q1A-开心消消乐](#head213)                            |          |\n|                                |                                               | 150  | [ 2023B-寻找最大价值的矿堆](#head214)                      |          |\n|                                | [ DFS/BFS-邻接矩阵表示图](#head215)           | 151  | [ 🟡547.省份数量](#head216)                                 |          |\n|                                |                                               | 152  | [ 2023Q1A-Linux发行版的数量](#head217)                     |          |\n|                                | [ DFS/BFS-邻接表表示图](#head218)             | 153  | [ 🟡841.钥匙和房间](#head219)                               |          |\n|                                | [ 作业](#head220)                             | 154  | [ 🟢463.岛屿的周长](#head221)                               |          |\n|                                |                                               | 155  | [ 🟢733.图像渲染](#head222)                                 |          |\n|                                |                                               | 156  | [ 2023Q2-广播服务器](#head223)                             |          |\n|                                |                                               | 157  | [ 2023Q1A-机器人活动区域](#head224)                        |          |\n| [ 第十九天](#head225)          | [ BFS](#head226)                              | 158  | [ 🟡994.腐烂的橘子](#head227)                               |          |\n|                                |                                               | 159  | [ 2023Q1-快速开租建站](#head228)                           |          |\n|                                | [ DFS](#head229)                              | 160  | [ 🟢1971.寻找图中是否存在路径](#head230)                    |          |\n|                                |                                               | 161  | [ 🟡1376.通知所有员工所需的时间](#head231)                  |          |\n|                                |                                               | 162  | [ 2023Q2-获取食物游戏](#head232)                           |          |\n|                                | [ 作业](#head233)                             | 163  | [ 2023Q2B-火星改造](#head234)                              |          |\n|                                |                                               | 164  | [ 2023Q2-士兵突击](#head235)                               |          |\n| [ 第二十天](#head236)          | [ 回溯算法](#head237)                         | 165  | [🔴51.N 皇后](#head238)                                     |          |\n|                                |                                               | 166  | [🔴37.解数独](#head239)                                     |          |\n|                                | [ 作业](#head240)                             | 167  | [ 2023Q1A-基站维修工程师](#head241)                        |          |\n|                                |                                               | 168  | [ 2023Q1-硬件产品销售方案](#head242)                       |          |\n|                                |                                               | 169  | [ 2023B-猜密码](#head243)                                  |          |\n\n# <span id=\"head1\"> 主要知识点</span>\n\n<table>   \n   <tr>\n    <th rowspan=\"2\">知识点</th>\n    <th colspan=\"2\">分类</th>\n  </tr>\n  <tr>\n    <th>分类一</th>\n    <th>分类二</th>\n  </tr>\n    <tr>        \n        <td>1.设计</td>     \n        <td></td>   \n        <td></td> \n    </tr>   \n    <tr> \n         <td rowspan=\"3\">2.栈&队列</td>     \n        <td>栈</td>  \n        <td></td> \n    </tr>   \n    <tr>       \n        <td>队列</td> \n        <td></td> \n    </tr>   \n    <tr>        \n        <td>栈和队列综合</td>   \n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"4\">3.哈希表</td>        \n        <td>哈希集合</td>   \n        <td></td> \n    </tr>   \n    <tr>          \n        <td rowspan=\"3\">哈希表</td>\n        <td>用于统计频率</td>   \n    </tr>   \n    <tr>        \n        <td>用于下表查询</td>   \n    </tr>   \n    <tr>        \n        <td>用于元素配对</td>   \n    </tr>   \n    <tr>     \n        <td rowspan=\"2\">4.双指针</td>   \n        <td>同向双指针</td> \n        <td></td> \n    </tr>   \n    <tr>      \n        <td>相向双指针</td> \n        <td></td> \n    </tr>   \n    <tr>     \n        <td>5.贪心</td>      \n        <td></td>  \n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"2\">6.滑动窗口</td>\n        <td>长度可变</td> \n        <td></td> \n    </tr>   \n    <tr>                 \n        <td>长度不可变</td>\n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"7\">7.DP</td>     \n        <td rowspan=\"3\">序列DP</td>\n        <td>入门</td>   \n    </tr>   \n    <tr>       \n        <td>路径问题</td>   \n    </tr>   \n    <tr>        \n        <td>打家劫舍问题</td>   \n    </tr>   \n    <tr>       \n        <td rowspan=\"2\">状态DP</td>\n        <td>入门</td>  \n    </tr>   \n    <tr>       \n        <td>股票问题</td>  \n    </tr>   \n    <tr>       \n        <td rowspan=\"2\">背包DP</td>\n        <td>01背包</td>  \n    </tr>   \n    <tr>        \n        <td>完全背包</td>  \n    </tr>   \n    <tr>    \n        <td rowspan=\"3\">8.二分查找</td>       \n        <td>在排序数组中</td>\n        <td></td> \n    </tr>   \n    <tr>       \n        <td>在数轴中</td>  \n        <td></td> \n    </tr>   \n    <tr>    \n        <td>利用问题的二段性</td>  \n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"6\">9.BFS&DFS</td>        \n        <td>前置问题</td>   \n        <td></td>\n    </tr>   \n    <tr>        \n        <td>二维矩阵表示图（岛屿问题）</td> \n        <td></td>\n    </tr>   \n    <tr>         \n        <td>邻接矩阵表示图</td>\n        <td></td>\n    </tr>   \n    <tr>         \n        <td>邻接表表示图</td>   \n        <td></td>\n    </tr>   \n    <tr>        \n        <td>BFS</td>   \n        <td></td>\n    </tr>   \n    <tr>        \n        <td>DFS</td>  \n        <td></td>\n    </tr>   \n    <tr>     \n        <td>10.回溯算法</td>     \n        <td></td>     \n        <td></td>   \n    </tr> \n</table>\n\n\n# <span id=\"head2\"> 第一天</span>\n\n## <span id=\"head3\">设计</span>\n\n### <span id=\"head4\"> 🟢1603.设计停车系统</span>\n\n> 请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。\n>\n> 请你实现 `ParkingSystem` 类：\n>\n> - `ParkingSystem(int big, int medium, int small)` 初始化 `ParkingSystem` 类，三个参数分别对应每种停车位的数目。\n> - `bool addCar(int carType)` 检查是否有 `carType` 对应的停车位。 `carType` 有三种类型：大，中，小，分别用数字 `1`， `2` 和 `3` 表示。**一辆车只能停在** `carType` 对应尺寸的停车位中。如果没有空车位，请返回 `false` ，否则将该车停入车位并返回 `true` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n> [[1, 1, 0], [1], [2], [3], [1]]\n> 输出：\n> [null, true, true, false, false]\n> \n> 解释：\n> ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\n> parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位\n> parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位\n> parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位\n> parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= big, medium, small <= 1000`\n> - `carType` 取值为 `1`， `2` 或 `3`\n> - 最多会调用 `addCar` 函数 `1000` 次\n>\n> Related Topics\n>\n> 设计\n>\n> 计数\n>\n> 模拟\n\n```java\nclass ParkingSystem {\n    int big_num;\n    int medium_num;\n    int small_num;\n\n    public ParkingSystem(int big, int medium, int small) {\n        this.big_num=big;\n        this.medium_num=medium;\n        this.small_num=small;\n    }\n    \n    public boolean addCar(int carType) {\n        switch (carType){\n            case 1:{\n                if(this.big_num>0){\n                    this.big_num--;\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n            case 2:{\n                if(this.medium_num>0){\n                    this.medium_num--;\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n            case 3:{\n                if(this.small_num>0){\n                    this.small_num--;\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n\n        }\n        return false;\n    }\n}\n```\n\n\n\n## <span id=\"head5\"> 栈</span>\n\n### <span id=\"head6\"> 🟢20.有效的括号</span>\n\n> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n>\n> 有效字符串需满足：\n>\n> 1. 左括号必须用相同类型的右括号闭合。\n> 2. 左括号必须以正确的顺序闭合。\n> 3. 每个右括号都有一个对应的相同类型的左括号。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"()\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"()[]{}\"\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"(]\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅由括号 `'()[]{}'` 组成\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\n    public boolean isValid(String s) {\n        Stack<Character>stack=new Stack<>();\n        for (char ch: s.toCharArray()) {\n            if(ch=='('||ch=='{'||ch=='['){\n                stack.push(ch);\n            } else if(!stack.isEmpty()&&ch==')'&&stack.peek()=='('){\n                stack.pop();\n            } else if(!stack.isEmpty()&&ch=='}'&&stack.peek()=='{') {\n                stack.pop();\n            }else if(!stack.isEmpty()&&ch==']'&&stack.peek()=='[') {\n                stack.pop();\n            }else {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n\n\n### <span id=\"head7\"> 2023Q1A-括号检查</span>\n\n[【华为OD统一考试B卷 | 100分】括号匹配（C++ Java JavaScript Python）_括号检查 华为od-CSDN博客](https://blog.csdn.net/banxia_frontend/article/details/130175261)\n\n> 题目描述给定一个字符串，里边可能包含“()”、“[]”、“{}”三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。若括号成对出现且嵌套关系正确，或该字符串中无括号字符，输出：true；若未正确使用括号字符，输出：false\n>\n> 实现时，无需考虑非法输入。\n>\n> 输入描述\n>\n> 无\n>\n> 输出描述\n>\n> 无\n>\n> 用例\n>\n> 输入 \n>\n> ```\n> (1+2)/(0.5+1)\n> ```\n>\n> 输出\n>\n> ```\n>  true\n> ```\n>\n> 说明 \n>\n> 无\n\n```java\nimport java.util.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        boolean flag=true;\n        Set<Character>set=new HashSet<>();\n        set.add('(');\n        set.add(')');\n        set.add('{');\n        set.add('}');\n        set.add('[');\n        set.add(']');\n\n        Scanner in=new Scanner(System.in);\n        String str=in.nextLine();\n        Stack<Character>stack=new Stack<>();\n        for (char ch:\n             str.toCharArray()) {\n            if(set.contains(ch)){\n                if(ch=='('||ch=='{'||ch=='['){\n                    stack.push(ch);\n                } else if (!stack.isEmpty() && (ch == ')' && stack.peek() == '(' ||ch=='}'&&stack.peek()=='{'||ch==']'&&stack.peek()=='[')) {\n                    stack.pop();\n                }else{\n                    flag=false;\n                }\n            }\n        }\n        if(stack.isEmpty()&&flag){\n            System.out.println(\"true\");\n        }else{\n            System.out.println(\"false\");\n        }\n\n    }\n}\n```\n\n\n\n## <span id=\"head8\"> 队列</span>\n\n### <span id=\"head9\"> 🟢剑指offerⅡ041.滑动窗口的平均值</span>\n\n> 给定一个窗口大小和一个整数数据流，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。\n>\n> 实现 `MovingAverage` 类：\n>\n> - `MovingAverage(int size)` 用窗口大小 `size` 初始化对象。\n> - `double next(int val)` 成员函数 `next` 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 `size` 个值的移动平均值，即滑动窗口里所有数字的平均值。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> inputs = [\"MovingAverage\", \"next\", \"next\", \"next\", \"next\"]\n> inputs = [[3], [1], [10], [3], [5]]\n> 输出：\n> [null, 1.0, 5.5, 4.66667, 6.0]\n> \n> 解释：\n> MovingAverage movingAverage = new MovingAverage(3);\n> movingAverage.next(1); // 返回 1.0 = 1 / 1\n> movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\n> movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\n> movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= size <= 1000`\n> - `-105 <= val <= 105`\n> - 最多调用 `next` 方法 `104` 次\n>\n> \n>\n> 注意：本题与主站 346 题相同： https://leetcode-cn.com/problems/moving-average-from-data-stream/\n>\n> Related Topics\n>\n> 设计\n>\n> 队列\n>\n> 数组\n>\n> 数据流\n\n```java\nclass MovingAverage {\n\n    /** Initialize your data structure here. */\n    Queue<Integer>q;\n    int size;\n\n    public MovingAverage(int size) {\n        this.size=size;\n        this.q=new LinkedList<>();\n    }\n    \n    public double next(int val) {\n        if(this.q.size()==this.size){//满了\n            q.poll();\n            Queue<Integer>t=new LinkedList<>();\n            int sum=0;\n            while(!this.q.isEmpty()){\n                int temp=this.q.poll();\n                sum+=temp;\n                t.offer(temp);\n            }\n            while(!t.isEmpty()){\n                int temp=t.poll();\n                this.q.offer(temp);\n            }\n            this.q.offer(val);\n            sum+=val;\n            return (double) sum/this.size;\n        }else{//还没满\n            Queue<Integer>t=new LinkedList<>();\n            int sum=0;\n            while(!this.q.isEmpty()){\n                int temp=this.q.poll();\n                sum+=temp;\n                t.offer(temp);\n            }\n            while(!t.isEmpty()){\n                int temp=t.poll();\n                this.q.offer(temp);\n            }\n            this.q.offer(val);\n            sum+=val;\n            return (double) sum/this.q.size();\n        }\n    }\n}\n```\n\n## <span id=\"head10\"> 作业</span>\n\n### <span id=\"head11\"> 🟢1614.括号的最大嵌套深度</span>\n\n> 如果字符串满足以下条件之一，则可以称之为 **有效括号字符串****（valid parentheses string**，可以简写为 **VPS**）：\n>\n> - 字符串是一个空字符串 `\"\"`，或者是一个不为 `\"(\"` 或 `\")\"` 的单字符。\n> - 字符串可以写为 `AB`（`A` 与 `B` 字符串连接），其中 `A` 和 `B` 都是 **有效括号字符串** 。\n> - 字符串可以写为 `(A)`，其中 `A` 是一个 **有效括号字符串** 。\n>\n> 类似地，可以定义任何有效括号字符串 `S` 的 **嵌套深度** `depth(S)`：\n>\n> - `depth(\"\") = 0`\n> - `depth(C) = 0`，其中 `C` 是单个字符的字符串，且该字符不是 `\"(\"` 或者 `\")\"`\n> - `depth(A + B) = max(depth(A), depth(B))`，其中 `A` 和 `B` 都是 **有效括号字符串**\n> - `depth(\"(\" + A + \")\") = 1 + depth(A)`，其中 `A` 是一个 **有效括号字符串**\n>\n> 例如：`\"\"`、`\"()()\"`、`\"()(()())\"` 都是 **有效括号字符串**（嵌套深度分别为 0、1、2），而 `\")(\"` 、`\"(()\"` 都不是 **有效括号字符串** 。\n>\n> 给你一个 **有效括号字符串** `s`，返回该字符串的 `s` **嵌套深度** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"(1+(2*3)+((8)/4))+1\"\n> 输出：3\n> 解释：数字 8 在嵌套的 3 层括号中。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"(1)+((2))+(((3)))\"\n> 输出：3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 100`\n> - `s` 由数字 `0-9` 和字符 `'+'`、`'-'`、`'*'`、`'/'`、`'('`、`')'` 组成\n> - 题目数据保证括号表达式 `s` 是 **有效的括号表达式**\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public int maxDepth(String s) {\n        Stack<Character>stack=new Stack<>();\n        int depth=0;\n        for (char ch:\n             s.toCharArray()) {\n            if(ch=='('){\n                stack.push(ch);\n                depth=Math.max(depth,stack.size());\n            } else if (ch==')') {\n                stack.pop();\n            }\n        }\n        return depth;\n    }\n}\n```\n\n### <span id=\"head12\"> 🟢1047.删除字符串中的所有相邻重复项</span>\n\n> 给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。\n>\n> 在 S 上反复执行重复项删除操作，直到无法继续删除。\n>\n> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\"abbaca\"\n> 输出：\"ca\"\n> 解释：\n> 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> 1. `1 <= S.length <= 20000`\n> 2. `S` 仅由小写英文字母组成。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        Stack<Character>stack=new Stack<>();\n        for (char ch:\n             s.toCharArray()) {\n            if(stack.isEmpty()){\n                stack.push(ch);\n            }else{\n                char temp=stack.peek();\n                if(temp==ch){\n                    stack.pop();\n                }else{\n                    stack.push(ch);\n                }\n            }\n        }\n        StringBuilder sb=new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}\n```\n\n### <span id=\"head13\"> 2023Q1A-身高提供排序</span>\n\n> ![image-20240111162226447](23-12-24-algorithm-OD/image-20240111162226447.png)\n\n```java\nimport java.util.*;\nclass Student{\n    int i,height,weight;\n    Student(int i,int height){\n        this.i=i;\n        this.height=height;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        Student[]students=new Student[n];\n        for (int i = 0; i < n; i++) {\n            students[i]=new Student(i+1,in.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            students[i].weight=in.nextInt();\n        }\n\n        Comparator<Student>camp=new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2){\n                if(o1.height!= o2.height){\n                    return o1.height-o2.height;\n                }else if(o1.weight!=o2.weight){\n                    return o1.weight- o2.weight;\n                }else{\n                    return o1.i-o2.i;\n                }\n            }\n        };\n        Arrays.sort(students,camp);\n        for (int i = 0; i < n; i++) {\n            System.out.print(students[i].i+\" \");\n        }\n\n    }\n}\n```\n\n\n\n# <span id=\"head14\"> 第二天</span>\n\n## <span id=\"head15\"> 栈</span>\n\n### <span id=\"head16\"> 🟡150.逆波兰表达式求值</span>\n\n> 给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。\n>\n> 请你计算该表达式。返回一个表示表达式值的整数。\n>\n> **注意：**\n>\n> - 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。\n> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n> - 两个整数之间的除法总是 **向零截断** 。\n> - 表达式中不含除零运算。\n> - 输入是一个根据逆波兰表示法表示的算术表达式。\n> - 答案及所有中间计算结果可以用 **32 位** 整数表示。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n> 输出：9\n> 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n> 输出：6\n> 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n> 输出：22\n> 解释：该算式转化为常见的中缀算术表达式为：\n>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n> = ((10 * (6 / (12 * -11))) + 17) + 5\n> = ((10 * (6 / -132)) + 17) + 5\n> = ((10 * 0) + 17) + 5\n> = (0 + 17) + 5\n> = 17 + 5\n> = 22\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= tokens.length <= 104`\n> - `tokens[i]` 是一个算符（`\"+\"`、`\"-\"`、`\"*\"` 或 `\"/\"`），或是在范围 `[-200, 200]` 内的一个整数\n>\n> \n>\n> **逆波兰表达式：**\n>\n> 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n>\n> - 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。\n> - 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。\n>\n> 逆波兰表达式主要有以下两个优点：\n>\n> - 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。\n> - 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer>stack=new Stack<>();\n        for (String str:\n             tokens) {\n            switch (str.charAt(0)){\n                case '+':{\n                    int num1=stack.pop();\n                    int num2=stack.pop();\n                    stack.push(num2+num1);\n                    break;\n                }\n                case '-':{\n                    if(str.length()==1){\n                        int num1=stack.pop();\n                        int num2=stack.pop();\n                        stack.push(num2-num1);\n                    }else{\n                        stack.push(convert2(str));\n                    }\n                    break;\n                }\n                case '*' :{\n                    int num1=stack.pop();\n                    int num2=stack.pop();\n                    stack.push(num2*num1);\n                    break;\n                }\n                case '/' :{\n                    int num1=stack.pop();\n                    int num2=stack.pop();\n                    stack.push(num2/num1);\n                    break;\n                }\n                default:{\n                    stack.push(convert2(str));\n                }\n            }\n        }\n        return stack.pop();\n    }\n    int convert2(String s){\n        if(s.charAt(0)=='-') {\n            return -convert1(s.substring(1));\n        }else{\n            return convert1(s);\n        }\n    }\n    int convert1(String s){\n        int sum=0,len=s.length();\n        int k=1;\n        for (int i = len-1; i >=0 ; i--) {\n            sum+=(s.charAt(i)-'0')*k;\n            k*=10;\n        }\n        return sum;\n    }\n}\n```\n\n### <span id=\"head17\"> 🔴224.基本计算器</span>\n\n> 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。\n>\n> 注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"1 + 1\"\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \" 2-1 + 2 \"\n> 输出：3\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"(1+(4+5+2)-3)+(6+8)\"\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 3 * 105`\n> - `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成\n> - `s` 表示一个有效的表达式\n> - '+' 不能用作一元运算(例如， \"+1\" 和 `\"+(2 + 3)\"` 无效)\n> - '-' 可以用作一元运算(即 \"-1\" 和 `\"-(2 + 3)\"` 是有效的)\n> - 输入中不存在两个连续的操作符\n> - 每个数字和运行的计算将适合于一个有符号的 32位 整数\n>\n> Related Topics\n>\n> 栈\n>\n> 递归\n>\n> 数学\n>\n> 字符串\n\n```java\n```\n\n### <span id=\"head18\">🟡155.最小栈</span>\n\n> 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n>\n> 实现 `MinStack` 类:\n>\n> - `MinStack()` 初始化堆栈对象。\n> - `void push(int val)` 将元素val推入堆栈。\n> - `void pop()` 删除堆栈顶部的元素。\n> - `int top()` 获取堆栈顶部的元素。\n> - `int getMin()` 获取堆栈中的最小元素。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入：\n> [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n> [[],[-2],[0],[-3],[],[],[],[]]\n> \n> 输出：\n> [null,null,null,null,-3,null,0,-2]\n> \n> 解释：\n> MinStack minStack = new MinStack();\n> minStack.push(-2);\n> minStack.push(0);\n> minStack.push(-3);\n> minStack.getMin();   --> 返回 -3.\n> minStack.pop();\n> minStack.top();      --> 返回 0.\n> minStack.getMin();   --> 返回 -2.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-231 <= val <= 231 - 1`\n> - `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用\n> - `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n\n```java\nclass MinStack {\n    LinkedList<Integer>list;\n    int min;\n    public MinStack() {\n        this.list=new LinkedList<>();\n        this.min=Integer.MAX_VALUE;\n    }    \n    public void push(int val) {\n        this.list.add(val);\n        this.min=Math.min(this.min,val);\n    }    \n    public void pop() {\n        int temp=list.getLast();\n        this.list.removeLast();\n        if(temp==this.min){\n            this.min=Integer.MAX_VALUE;\n            for (int i = 0; i < this.list.size(); i++) {\n                this.min=Math.min(this.min,this.list.get(i));\n            }\n        }\n    }    \n    public int top() {\n        return this.list.getLast();\n    }\n    public int getMin() {\n        return this.min;\n    }\n}\n```\n\n\n\n### <span id=\"head19\"> 🟡394.字符串解码</span>\n\n> 给定一个经过编码的字符串，返回它解码后的字符串。\n>\n> 编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n>\n> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n>\n> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"3[a]2[bc]\"\n> 输出：\"aaabcbc\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"3[a2[c]]\"\n> 输出：\"accaccacc\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"2[abc]3[cd]ef\"\n> 输出：\"abcabccdcdcdef\"\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：s = \"abc3[cd]xyz\"\n> 输出：\"abccdcdcdxyz\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 30`\n> - `s` 由小写英文字母、数字和方括号 `'[]'` 组成\n> - `s` 保证是一个 **有效** 的输入。\n> - `s` 中所有整数的取值范围为 `[1, 300]`\n>\n> Related Topics\n>\n> 栈\n>\n> 递归\n>\n> 字符串\n\n```java\nclass Solution {\n    public String decodeString(String s){\n        Stack<Character>stack=new Stack<>();\n        for(char ch: s.toCharArray()){\n            if(ch!=']'){\n                stack.push(ch);\n            }else{\n                StringBuilder str=new StringBuilder();\n                while(!stack.isEmpty()&&stack.peek()!='['){\n                    str.append(stack.pop());\n                }\n                stack.pop();//排出[\n                StringBuilder num=new StringBuilder();\n                while(!stack.isEmpty()&&stack.peek()>='0'&&stack.peek()<='9'){\n                    num.append(stack.pop());\n                }\n                String build=builder(Integer.valueOf(num.reverse().toString()),str.reverse().toString());\n                for (int i = 0; i < build.length(); i++) {\n                    stack.push(build.charAt(i));\n                }\n            }\n        }\n        StringBuilder res=new StringBuilder();\n        while(!stack.isEmpty()){\n            res.append(stack.pop());\n        }\n        return res.reverse().toString();\n\n    }\n\n    String builder(int num,String str) {\n        StringBuilder sb=new StringBuilder();\n        for (int i = 0; i < num; i++) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n## <span id=\"head20\"> 作业</span>\n\n### <span id=\"head21\"> 🟡71.简化路径</span>\n\n> 给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。\n>\n> 在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。\n>\n> 请注意，返回的 **规范路径** 必须遵循下述格式：\n>\n> - 始终以斜杠 `'/'` 开头。\n> - 两个目录名之间必须只有一个斜杠 `'/'` 。\n> - 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。\n> - 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。\n>\n> 返回简化后得到的 **规范路径** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：path = \"/home/\"\n> 输出：\"/home\"\n> 解释：注意，最后一个目录名后面没有斜杠。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：path = \"/../\"\n> 输出：\"/\"\n> 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：path = \"/home//foo/\"\n> 输出：\"/home/foo\"\n> 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：path = \"/a/./b/../../c/\"\n> 输出：\"/c\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= path.length <= 3000`\n> - `path` 由英文字母，数字，`'.'`，`'/'` 或 `'_'` 组成。\n> - `path` 是一个有效的 Unix 风格绝对路径。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public String simplifyPath(String path) {\n        String[]splited=path.split(\"[//]+\");\n        Stack<String> stack=new Stack<>();\n        for (int i = 0; i < splited.length; i++) {\n            if(Objects.equals(splited[i], \"\")){\n                continue;\n            }\n            if(stack.isEmpty()){\n                if( !Objects.equals(splited[i], \".\") && !Objects.equals(splited[i], \"..\")){\n                    stack.push(splited[i]);\n                }\n            }else{\n                switch (splited[i]){\n                    case \".\":{\n                        break;\n                    }\n                    case \"..\":{\n                        stack.pop();\n                        break;\n                    }\n                    default:{\n                        stack.push(splited[i]);\n                    }\n                }\n            }\n        }\n        String res=\"\";\n        if(stack.isEmpty()){\n            res+=\"/\";\n        }else{\n            int index=0;\n            while (index<stack.size()){\n                res+=\"/\";\n                res+=stack.get(index);\n                index++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head22\"> 🟡946.检证栈序列</span>\n\n> 给定 `pushed` 和 `popped` 两个序列，每个序列中的 **值都不重复**，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 `true`；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n> 输出：true\n> 解释：我们可以按以下顺序执行：\n> push(1), push(2), push(3), push(4), pop() -> 4,\n> push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n> 输出：false\n> 解释：1 不能在 2 之前弹出。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= pushed.length <= 1000`\n> - `0 <= pushed[i] <= 1000`\n> - `pushed` 的所有元素 **互不相同**\n> - `popped.length == pushed.length`\n> - `popped` 是 `pushed` 的一个排列\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 模拟\n\n```java\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        Stack<Integer>stack=new Stack<>();\n        int len=popped.length;\n        int idx=0;\n        for (int i = 0; i < len; i++) {\n            if(stack.isEmpty()){\n                stack.push(pushed[idx++]);\n            }\n            if(stack.peek()!=popped[i]&&stack.contains(popped[i])){\n                return false;\n            }\n           while(stack.peek()!=popped[i]){\n               stack.push(pushed[idx++]);\n           }\n           stack.pop();\n        }\n        return true;\n    }\n}\n```\n\n\n\n### <span id=\"head23\"> 2023Q1A-投篮大赛</span>\n\n> ![image-20240111203435403](23-12-24-algorithm-OD/image-20240111203435403.png)\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        String[] splited= string.split(\" \");\n        Stack<Integer>stack=new Stack<>();\n        for (String str: splited) {\n             switch (str.charAt(0)){\n                 case 'C':{\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     stack.pop();\n                     break;\n                 }\n                 case 'D':{\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     int temp=stack.peek();\n                     stack.push(temp*2);                     \n                     break;\n                 }\n                 case '+':{\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     int num1=stack.pop();\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     int num2=stack.peek();\n                     stack.push(num1);\n                     stack.push(num1+num2);\n                     break;\n                 }\n                 default:{\n                     try{\n                         stack.push(Integer.valueOf(str));\n                     }catch (NumberFormatException e){\n                         System.out.println(-1);\n                         return;\n                     }\n\n                 }\n             }\n        }\n        int sum=0;\n        while(!stack.isEmpty()){\n            sum+=stack.pop();\n        }\n        System.out.println(sum);\n    }\n}\n```\n\n\n\n### <span id=\"head24\"> 2023Q1A-解压缩算法</span>\n\n> ![image-20240111211130956](23-12-24-algorithm-OD/image-20240111211130956.png)\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        StringBuilder res=new StringBuilder();\n\n        String[]strings=string.split(\"[0-9]+\");\n        String[]nums=string.split(\"[a-z]+\");\n\n        List<String>str_list=new ArrayList<>();\n        for (int i = 0; i < strings.length; i++) {\n            if(strings[i]!=\"\"){\n                str_list.add(strings[i]);\n                //筛选@\n                for (int j = 0; j < strings[i].length(); j++) {\n                    if(strings[i].charAt(j)>'z'||strings[i].charAt(j)<'a'){\n                        System.out.println(\"!error\");\n                        return;\n                    }\n                }\n            }\n        }\n        //筛选uuuu\n        int cnt=0;\n        char last_ch=str_list.get(0).charAt(0);\n        for (int i = 0; i < str_list.size(); i++) {\n            for (int j = 0; j < str_list.get(i).length(); j++) {\n                if(i==0&&j==0){\n                    continue;\n                }\n                if(str_list.get(i).charAt(j)==last_ch){\n                    cnt++;\n                }else{\n                    cnt=0;\n                }\n                if(cnt>3){\n                    System.out.println(\"!error\");\n                    return;\n                }\n            }\n        }\n\n        List<Integer>num_list=new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(!Objects.equals(nums[i], \"\")){\n                num_list.add(Integer.valueOf(nums[i]));\n            }\n        }\n        //筛选1h 2h\n        for (int i = 0; i < num_list.size(); i++) {\n            if(num_list.get(i)<3){\n                System.out.println(\"!error\");\n                return;\n            }\n        }\n        int idx=0;\n        if(string.charAt(0)>='a'&&string.charAt(0)<='z'){//字母开头\n            res.append(str_list.get(idx++));\n        }\n        for (int i = 0; i < num_list.size(); i++) {\n            for (int j = 0; j < num_list.get(i); j++) {\n                res.append(str_list.get(idx).charAt(0));\n            }\n            if(str_list.get(idx).length()>1){\n                for (int j = 1; j < str_list.get(idx).length(); j++) {\n                    res.append(str_list.get(idx).charAt(j));\n                }\n            }\n            idx++;\n        }\n        System.out.println(res);\n    }\n}\n```\n\n贴一个短的学习一下：\n\n```java\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        String pat = \"[^0-9a-z]\";//\n        String num = \"\";\n        String res = \"\";\n        Pattern pattern = Pattern.compile(pat);\n        Matcher matcher = pattern.matcher(s);\n        if (matcher.find()) {\n            res = \"!error\";\n        } else {\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (Character.isDigit(c)) {\n                    num += c;\n                } else if (!num.equals(\"\")) {\n                    if (Integer.parseInt(num) <= 2) {\n                        res = \"!error\";\n                        break;\n                    } else {\n                        for (int j = 0; j < Integer.parseInt(num); j++) {\n                            res += c;\n                        }\n                        num = \"\";\n                    }\n                } else {\n                    res += c;\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\n```\n\n\n\n# <span id=\"head25\"> 第三天</span>\n\n## <span id=\"head26\"> 哈希集合</span>\n\n### <span id=\"head27\"> 🟢217.存在重复元素</span>\n\n> 给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,1,1,3,3,4,3,2,4,2]\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(set.contains(nums[i])){\n                return true;\n            }else{\n                set.add(nums[i]);\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n### <span id=\"head28\"> 🟢349.两个数字的交集</span>\n\n> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[9,4]\n> 解释：[4,9] 也是可通过的\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        int[] hashtable=new int[1001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable[nums1[i]]=1;\n        }\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < nums2.length; i++) {\n            if(hashtable[nums2[i]]==1) {\n                set.add(nums2[i]);\n            }\n        }\n        System.out.println(set);\n        int[]res=new int[set.size()];\n        int idx=0;\n        Iterator<Integer> it=set.iterator();\n        while(it.hasNext()){\n            res[idx++]=it.next();\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head29\"> 哈希表-用于统计频率</span>\n\n### <span id=\"head30\"> 🟢242.有效的字母异位词</span>\n\n> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。\n>\n> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"anagram\", t = \"nagaram\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"rat\", t = \"car\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, t.length <= 5 * 104`\n> - `s` 和 `t` 仅包含小写字母\n>\n> \n>\n> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int[]hashtable=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < t.length(); i++) {\n            hashtable[t.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtable[i]!=0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### <span id=\"head31\"> 🟢383.赎金信</span>\n\n> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n>\n> 如果可以，返回 `true` ；否则返回 `false` 。\n>\n> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ransomNote = \"a\", magazine = \"b\"\n> 输出：false\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"ab\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"aab\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= ransomNote.length, magazine.length <= 105`\n> - `ransomNote` 和 `magazine` 由小写英文字母组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[]hashtaable=new int[26];\n        for (int i = 0; i < magazine.length(); i++) {\n            hashtaable[magazine.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < ransomNote.length(); i++) {\n            hashtaable[ransomNote.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtaable[i]<0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head32\"> 2023Q1A-集五福</span>\n\n> **题目描述**\n> 集五福作为近年来大家喜闻乐见迎新春活动，集合爱国福、富强福、和谐福、友善福、敬业福即可分享超大红包。以 0 和 1 组成的长度为 5 的字符串代表每个人所得到的福卡，每一位代表一种福卡，1 表示已经获得该福卡，单类型福卡不超过 1 张，随机抽取一个小于 10 人团队，求该团队最多可以集齐多少套五福？\n>\n> **输入描述**\n> 输入若干个由0、1组成的长度等于5的字符串，代表团队中每个人福卡获得情况 \n>\n> 注意1：1人也可以是一个团队 \n>\n> 注意2：1人可以有0到5张福卡，但福卡不能重复\n>\n> **输出描述**\n> 输出该团队最多能凑齐多少套五福\n>\n> **示例一**\n> **输入**\n>\n> ```\n> 11001,11101\n> ```\n>\n> **输出**\n>\n> ```\n> 0\n> ```\n>\n> **示例二**\n> **输入**\n>\n> ```\n> 11101,10111\n> ```\n>\n> **输出**\n>\n> ```\n> 1\n> ```\n\n### <span id=\"head33\"> 2023Q1A-删除最少字符</span>\n\n> **题目描述**\n> 删除字符串中出现次数最少的字符，如果多个字符出现次数一样则都删除\n>\n> **输入描述**\n> 输入只包含小写字母\n>\n> **输出描述**\n> 输出删除后剩余的字符，若删除后字符串长度为0，则输出empty\n>\n> **示例一**\n> **输入**\n>\n> ```\n> abcdd\n> ```\n>\n> **输出**\n>\n> ```\n> dd\n> ```\n>\n> **示例二**\n> **输入**\n>\n> ```\n> aabbccdd\n> ```\n>\n> **输出**\n>\n> ```\n> empty\n> ```\n\n## <span id=\"head34\"> 作业</span>\n\n### <span id=\"head35\"> 🟢387.字符串中的第一个唯一字符</span>\n\n> 给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"leetcode\"\n> 输出: 0\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"loveleetcode\"\n> 输出: 2\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"aabb\"\n> 输出: -1\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length <= 105`\n> - `s` 只包含小写字母\n>\n> Related Topics\n>\n> 队列\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character,Integer>map=new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+1);\n        }\n        int res=-1;\n        for (int i = 0; i < s.length(); i++) {\n            if(map.get(s.charAt(i))==1){\n                res=i;\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head36\"> 🟢350.两个数组的交集Ⅱ</span>\n\n> 给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2,2]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[4,9]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> \n>\n> ***\\*进阶\\**：**\n>\n> - 如果给定的数组已经排好序呢？你将如何优化你的算法？\n> - 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？\n> - 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        HashMap<Integer,Integer>map1=new HashMap<>();\n        HashMap<Integer,Integer>map2=new HashMap<>();\n        for (int i = 0; i < nums1.length; i++) {\n            map1.put(nums1[i],map1.getOrDefault(nums1[i],0)+1);\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(map1.containsKey(nums2[i])){\n                map2.put(nums2[i],map2.getOrDefault(nums2[i],0)+1);\n            }\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(map1.containsKey(nums2[i])){\n                int temp=Math.min(map1.get(nums2[i]),map2.get(nums2[i]));\n                map2.put(nums2[i],temp);\n            }\n        }\n        int len=0;\n        for (int num:\n             map2.values()) {\n            len+=num;\n        }\n        int[]res=new int[len];\n        int index=0;\n        for (Map.Entry<Integer,Integer> entry:\n             map2.entrySet()) {\n            for (int i = 0; i < entry.getValue(); i++) {\n                res[index++]=entry.getKey();\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n不如4个月之前写的：\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        int[]hashtable1=new int[1001];\n        int[]hashtable2=new int[1001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable1[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            hashtable2[nums2[i]]++;\n        }\n        ArrayList<Integer> al=new ArrayList<>();\n        for (int i = 0; i < 1001; i++) {\n            if(hashtable1[i]>hashtable2[i]){\n                hashtable1[i]=hashtable2[i];\n            }\n            for (int j = 0; j < hashtable1[i]; j++) {\n                al.add(i);\n            }\n        }\n        int[]res=new int[al.size()];\n        for (int i = 0; i < al.size(); i++) {\n            res[i]=al.get(i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head37\"> 2023Q1A-寻找关键钥匙</span>\n\n> #### 题目描述\n>\n> ​\t\t小强正在参加《密室逃生》游戏，当前关卡要求找到符合给定密码 `K`（升序的不重复小写字母组成）的箱子，并给出箱子编号，箱子编号为 `1~N`。 \n>\n> ​\t\t每个箱子中都有一个字符串 `s`，字符串由大写字母，小写字母，数字，标点符号，空格组成，需要在这些字符串中找出所有的字母，忽略大小写且去重后排列出对应的密码串，并返回匹配密码的箱子序号。 \n>\n> ​\t\t注意：满足条件的箱子不超过 `1` 个。\n>\n> #### 输入\n>\n> ​        第一行为表示密码 K 的字符串 \n>\n> ​        第二行为一系列箱子 boxes，为字符串数组样式，以空格分隔 \n>\n> ​        箱子 N 数量满足 1<=N<=10000，代表每一个箱子的字符串 s 的长度满足 0 <= s.length <= 50，密码为仅包含小写字母的升序字符串，且不存在重复字母，密码 K 长度满足1 <= K.length <= 26\n>\n> #### 输出\n>\n> ​\t\t返回对应箱子编号，如不存在符合要求的密码箱，则返回`-1`\n>\n> #### 样例输入 复制\n>\n> ```plain\n> abc\n> s,sdf134 A2c4b\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 2\n> ```\n\n```java\nimport java.util.*;\n\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String key=in.nextLine();\n        String strings=in.nextLine();\n        int res=-1;\n        String[]splited=strings.split(\" \");\n        for (int i = 0; i < splited.length; i++) {\n            if(builder(splited[i]).equals(key)){\n                res=i+1;\n            }\n        }\n        System.out.println(res);\n    }\n    static String builder(String str) {\n        StringBuilder sb=new StringBuilder();\n        ArrayList<Character>list=new ArrayList<>();\n        for (int i = 0; i < str.length(); i++) {\n            char ch=str.charAt(i);\n            if(ch>='a'&&ch<='z'){\n                list.add(ch);\n            }\n            if(ch>='A'&&ch<='Z'){\n                list.add((char)(ch+'a'-'A'));\n            }\n        }\n        Collections.sort(list);\n        for (char ch:\n             list) {\n            sb.append(ch);\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n\n\n### <span id=\"head38\"> 2023Q1A-明明的随机数</span>\n\n> #### 题目描述\n>\n> ​\t\t明明生成了`N` 个 `1` 至 `500` 之间的随机整数。请你**删去其中重复的数字**，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数**从小到大排序**，按照排好的顺序输出。 \n>\n> ​\t\t数据范围： `1 ≤ N ≤ 1000` ，输入的数字大小 `val` 满足 `1 ≤ val ≤ 500`  \n>\n> \n>\n> #### 输入\n>\n> ​\t\t第一行先输入随机整数的个数 `N` 。 接下来的 `N` 行每行输入一个整数，代表明明生成的随机数。 \n>\n> \n>\n> #### 输出\n>\n> ​        输出多行，表示输入数据处理后的结果。\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 3\n> 2\n> 2\n> 1\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 1\n> 2\n> ```\n\n```java\nimport java.util.*;\n\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        Set<Integer>set=new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            set.add(in.nextInt());\n        }\n        for (Integer integer : set) {\n            System.out.println(integer);\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head39\"> 2023Q1A-统计匹配的二元组个数</span>\n\n> #### 题目描述\n>\n> ​\t\t给定两个数组 `A` 和 `B`，若数组 `A` 的某个元素 `A[i]` 与数组 `B` 中的某个元素 `B[j]` 满足 `A[i]==B[j]`，则寻找到一个匹配的二元组`(i,j)` ，请统计再这两个数组 `A` 和 `B` 中，一共存在多少个这样的二元组。 \n>\n> \n>\n> #### 输入\n>\n> 第一行输入数组 A 的长度 M ； \n>\n> 第一行输入数组 B 的长度 N ；\n>\n>  第三行输入数组 A 的值； \n>\n> 第四行输入数组 B 的值。 1 ≤ M, N ≤ 100000 A，B 数组中数值的取值均小于 100000\n>\n> #### 输出\n>\n> 输出匹配的二元组个数\n>\n> ## 示例一\n>\n> ### 输入\n>\n> ```plaintext\n> 5\n> 4\n> 1 2 3 4 5\n> 4 3 2 1\n> ```\n>\n> Copy\n>\n> ### 输出\n>\n> ```plaintext\n> 4\n> ```\n>\n> Copy\n>\n> ### 说明\n>\n> 若下标从 00 开始，则匹配的二元组分别为`(0,3), (1,2), (2,1), (3,0)`，共计 44 个\n>\n> ## 示例二\n>\n> ### 输入\n>\n> ```plaintext\n> 6\n> 3\n> 1 2 4 4 2 1\n> 1 2 3\n> ```\n>\n> Copy\n>\n> ### 输出\n>\n> ```plaintext\n> 4\n> ```\n>\n> Copy\n>\n> ### 说明\n>\n> 若下标从 00 开始，则匹配的二元组分别为`(0,0), (1,1), (4,1), (5,0)`，共计 44 个\n>\n> ## 备注\n\n```java\nimport java.util.*;\n\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt(),m=in.nextInt();\n        int[]hashtable=new int[1000001];\n        for (int i = 0; i < n; i++) {\n            hashtable[in.nextInt()]++;\n        }\n        int cnt=0;\n        for (int i = 0; i < m; i++) {\n            int num=in.nextInt();\n            if(hashtable[num]>0){\n                cnt+=hashtable[num];\n            }\n        }\n        System.out.println(cnt);\n    }\n}\n```\n\n\n\n# <span id=\"head40\"> 第四天</span>\n\n## <span id=\"head41\"> 哈希表-用于下表查询</span>\n\n### <span id=\"head42\"> 🟢1.两数之和</span>\n\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n>\n> 你可以按任意顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,4], target = 6\n> 输出：[1,2]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,3], target = 6\n> 输出：[0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 104`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n> - **只会存在一个有效答案**\n>\n> \n>\n> **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> hashmap=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            hashmap.put(nums[i],i);\n        }\n        int[]res=new int[2];\n        for (int i = 0; i < nums.length; i++) {\n            if(hashmap.containsKey(target-nums[i])&&i!=hashmap.get(target-nums[i])){\n                res[0]=i;\n                res[1]=hashmap.get(target-nums[i]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head43\"> 🟢219.存在重复元素Ⅱ</span>\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1], k = 3\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,0,1,1], k = 1\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,3,1,2,3], k = 2\n> 输出：false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n> - `0 <= k <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(map.containsKey(nums[i])&&Math.abs(i-map.get(nums[i]))<=k){\n                return true;\n            }else{\n                map.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n## <span id=\"head44\"> 哈希表-用于元素配对</span>\n\n### <span id=\"head45\"> 🟢205.同构字符串</span>\n\n> 给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。\n>\n> 如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。\n>\n> 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入：s = \"egg\", t = \"add\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"foo\", t = \"bar\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"paper\", t = \"title\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - `1 <= s.length <= 5 * 104`\n> - `t.length == s.length`\n> - `s` 和 `t` 由任意有效的 ASCII 字符组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        Map<Character,Character> map=new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(map.containsKey(s.charAt(i))){\n                if(map.get(s.charAt(i))!=t.charAt(i)){\n                    return false;\n                }\n            }else {\n                if (!map.containsValue(t.charAt(i))) {\n                    map.put(s.charAt(i), t.charAt(i));\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head46\">🟡49.字母异位词分组</span>\n\n> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n>\n> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n> 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: strs = [\"\"]\n> 输出: [[\"\"]]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: strs = [\"a\"]\n> 输出: [[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 104`\n> - `0 <= strs[i].length <= 100`\n> - `strs[i]` 仅包含小写字母\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>>res=new ArrayList<>();\n        Map<String,Integer>map=new HashMap<>();\n        int index=0;\n        for (int i = 0; i < strs.length; i++) {\n            String key=sort(strs[i]);\n            if(!map.containsKey(key)){\n                map.put(key,index);\n                List<String>list=new ArrayList<>();\n                list.add(strs[i]);\n                res.add(index++,list);\n            }else{\n                int pos=map.get(key);\n                res.get(pos).add(strs[i]);\n            }\n        }\n        return res;\n    }\n    String sort(String str){\n        char[]chars=str.toCharArray();\n        Arrays.sort(chars);\n        return String.copyValueOf(chars);\n    }\n}\n```\n\n## <span id=\"head47\"> 作业</span>\n\n### <span id=\"head48\"> 🟢290.单词规律</span>\n\n> 给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。\n>\n> 这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。\n>\n> \n>\n> **示例1:**\n>\n> ```\n> 输入: pattern = \"abba\", s = \"dog cat cat dog\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入:pattern = \"abba\", s = \"dog cat cat fish\"\n> 输出: false\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: pattern = \"aaaa\", s = \"dog cat cat dog\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= pattern.length <= 300`\n> - `pattern` 只包含小写英文字母\n> - `1 <= s.length <= 3000`\n> - `s` 只包含小写英文字母和 `' '`\n> - `s` **不包含** 任何前导或尾随对空格\n> - `s` 中每个单词都被 **单个空格** 分隔\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String s) {\n        String[]splited=s.split(\" \");\n        if(splited.length!=pattern.length()){\n            return false;\n        }\n        Map<Character,String> map=new HashMap<>();\n        for (int i = 0; i < pattern.length(); i++) {\n            if(map.containsKey(pattern.charAt(i))){\n                if(!map.get(pattern.charAt(i)).equals(splited[i])){\n                    return false;\n                }\n            }else{\n                if(!map.containsValue(splited[i])){\n                    map.put(pattern.charAt(i),splited[i]);\n                }else{\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head49\"> 2023Q1A-字符串重新排序</span>\n\n> #### 题目描述\n>\n> 给定一个字符串 s，s 包含以空格分隔的若干个单词，请对 s 进行如下处理后输出：\n> \\1. 单词内部调整：对每个单词字母重新按字典序排序；\n> \\2. 单词间顺序调整：\n>   a. 统计每个单词出现的次数，并按次数降序排列；\n>   b. 次数相同时，按单词长度升序排列；\n>   c. 次数和单词长度均相同时，按字典序升序排列。\n> 请输出处理后的字符串，每个单词以一个空格分隔。\n>\n> #### 输入\n>\n> 一行字符串，每个字符取值范围为[a-z, A-Z, 0-9] 以及空格\" \"\n>\n> 字符串长度范围：[1, 1000]\n>\n> #### 输出\n>\n> 重新排序后的字符串，每个单词间隔 1 个空格，且首尾无空格\n>\n> #### 样例输入 复制\n>\n> ```plain\n> This is an apple\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> an is This aelpp\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        String[]splited=string.split(\" \");\n        Map<String,Integer>map=new HashMap<>();\n        for (int i = 0; i < splited.length; i++) {\n            char[]chars=splited[i].toCharArray();\n            Arrays.sort(chars);\n            String key=String.copyValueOf(chars);\n            map.put(key,map.getOrDefault(key,0)+1);\n        }\n        Comparator<Map.Entry>comp=new Comparator<Map.Entry>() {\n            @Override\n            public int compare(Map.Entry o1, Map.Entry o2) {\n                if((int)o1.getValue()!=(int)o2.getValue()){\n                    return (int)o2.getValue()-(int)o1.getValue();\n                } else if (o1.getKey().toString().length()!=o2.getKey().toString().length()) {\n                    return o1.getKey().toString().length()-o2.getKey().toString().length();\n                }else {\n                    return o1.getKey().toString().compareTo(o2.getKey().toString());\n                }\n            }\n        };\n        List<Map.Entry<?, ?>> entries = new ArrayList<>(map.entrySet());\n        Collections.sort(entries, comp);\n        for (int i = 0; i < entries.size(); i++) {\n            for (int j = 0; j < (int)entries.get(i).getValue(); j++) {\n                System.out.print(entries.get(i).getKey()+\" \");\n            }\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head50\">2023Q2B-选修课</span>\n\n> #### 题目描述\n>\n> 现有两门选修课，每门选修课都有一部分学生选修，每个学生都有选修课的成绩，需要你找出同时选修了两门选修课的学生，先按照班级进行划分，班级编号小的先输出，每个班级按照两门选修课成绩和的降序排序，成绩相同时按照学生的学号升序排序。\n>\n> #### 输入\n>\n> ​\t\t第一行为第一门选修课学生的成绩，第二行为第二门选修课学生的成绩，每行数据中学生之间以英文分号分隔，每个学生的学号和成绩以英文逗号分隔，学生学号的格式为 `8` 位数字(`2` 位院系编号+入学年份后 `2` 位+院系内部 `1` 位专业编号+所在班级 `3` 位学号)，学生成绩的取值范围为 `[0,100]` 之间的整数，两门选修课选修学生数的取值范围为 `[1-2000]` 之间的整数。 \n>\n> \n>\n> #### 输出\n>\n> 同时选修了两门选修课的学生的学号，如果没有同时选修两门选修课的学生输出 NULL，否则，先按照班级划分，班级编号小的先输出，每个班级先输出班级编号(学号前五位)，然后另起一行输出这个班级同时选修两门选修课的学生学号，学号按照要求排序(按照两门选修课成绩和的降序，成绩和相同时按照学号升序)，学生之间以英文分号分隔。\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 01202021,75;01201033,95;01202008,80;01203006,90;01203088,100\n> 01202008,70;01203088,85;01202111,80;01202021,75;01201100,88\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 01202\n> 01202008;01202021\n> 01203\n> 01203088\n> ```\n\n### <span id=\"head51\"> 2023Q1A-相同数字的积木游戏</span>\n\n> #### 题目描述\n>\n> ​\t\t小华和小薇一起通过玩积木游戏学习数学。他们有很多积木，每个积木块上都有一个数字，积木块上的数字可能相同。小华随机拿一些积木挨着排成一排，请小薇找到这排积木中数字相同且所处位置最远的 `2` 块积木块，计算他们的距离。小薇请你帮忙替她解决这个问题。 \n>\n> \n>\n> #### 输入\n>\n> ​\t\t第一行输入为 `N` ，表示小华排成一排的积木总数。 接下来 `N` 行每行一个数字，表示小花排成一排的积木上数字。 \n>\n> \n>\n> #### 输出\n>\n> ​        相同数字的积木的位置最远距离；如果所有积木数字都不相同，请返回 -1\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 5\n> 1\n> 2\n> 3\n> 1\n> 4\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 3\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n= in.nextInt();\n        int max=-1;\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int key=in.nextInt();\n            if(map.containsKey(key)){\n                if(i-map.get(key)>max){\n                    max=i-map.get(key);\n                }\n            }else{\n                map.put(key,i);\n            }\n        }\n        System.out.println(max);\n    }\n}\n\n```\n\n\n\n### <span id=\"head52\"> 2023Q1A-英文输入法</span>\n\n> #### 题目描述\n>\n> 主管期望你来实现英文输入法单词联想功能，需求如下： \n>\n> \\1. 依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词。 \n>\n> \\2. 按字典序输出联想到的单词序列，如果联想不到，请输出用户输入的单词前缀。 \n>\n> \n>\n> 注意：\n>\n> \\1. 英文单词联想时区分大小写 \n>\n> \\2. 缩略形式如\"don’t\" 判定为两个单词 \"don\"和 “t” \n>\n> \\3. 输出的单词序列不能有重复单词，且只能是英文单词，不能有标点符号\n>\n> #### 输入\n>\n> 输入两行。 \n>\n> 首行输入一段由英文单词word和标点构成的语句str，接下来一行为一个英文单词前缀pre。 \n>\n> 0 < word.length() <= 20\n>\n> 0 < str.length() <= 10000，0 < pre.length() <= 20\n>\n> #### 输出\n>\n> 输出符合要求的单词序列或单词前缀。存在多个时，单词之间以单个空格分割\n>\n> #### 样例输入 复制\n>\n> ```plain\n> I love you\n> He\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> He\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String string= in.nextLine();\n        String put=in.nextLine();\n        String[]splited=string.split(\"[^A-Za-z]\");\n        List<String>res=new ArrayList<>();\n        for (int i = 0; i < splited.length; i++) {\n            if(splited[i].startsWith(put)){\n                res.add(splited[i]);\n            }\n        }\n        Collections.sort(res);\n        if(res.isEmpty()){\n            System.out.println(put);\n        }else{\n            for (int i = 0; i < res.size(); i++) {\n                System.out.print(res.get(i)+\" \");\n            }\n        }\n    }\n}\n\n```\n\n\n\n### <span id=\"head53\"> 2023Q1A-寻找密码</span>\n\n> #### 题目描述\n>\n> ​        小王在进行游戏大闯关，有一个关卡需要输入一个密码才能通过，密码获得的条件如下：在一个密码本中，每一页都有一个由 26 个小写字母组成的若干位密码，从它的末尾开始依次去掉一位得到的新密码也在密码本中存在。请输出符合要求的密码，如果由多个符合要求的密码，则返回字典序最大的密码。若没有符合要求的密码，则返回空字符串。\n>\n> #### 输入\n>\n> ​\t\t密码本由一个字符串数组组成，不同元素之间使用空格隔开，每一个元素代表密码本每一页的密码。 \n>\n> #### 输出\n>\n> ​        一 个字符串\n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> h he hel hell hello\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> hello\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String string= in.nextLine();\n        String[]splited=string.split(\" \");\n        Set<String> set = new HashSet<>(Arrays.asList(splited));\n        Comparator<String>comparator=new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                if(o1.length()!=o2.length()){\n                    return o1.length()-o2.length();\n                }else{\n                    return o1.compareTo(o2);\n                }\n            }\n        };\n        Arrays.sort(splited,comparator);\n        List<String>res=new ArrayList<>();\n        for (int i = splited.length-1;i >= 0; i--) {\n            int flag=1;\n            for (int j = 0; j < splited[i].length()-1; j++) {\n                if(!set.contains(splited[i].substring(0,j+1))){\n                    flag=0;\n                    break;\n                }\n            }\n            if(flag==1){\n                res.add(splited[i]);\n            }\n        }\n        if(res.isEmpty()){\n            System.out.println();\n        }else{\n            System.out.println(res.get(0));\n        }\n    }\n}\n```\n\n# <span id=\"head54\"> 第五天</span>\n\n## <span id=\"head55\"> 单调栈</span>\n\n### <span id=\"head56\"> 🟢1475.商品折扣后的最终价格</span>\n\n> 给你一个数组 `prices` ，其中 `prices[i]` 是商店里第 `i` 件商品的价格。\n>\n> 商店里正在进行促销活动，如果你要买第 `i` 件商品，那么你可以得到与 `prices[j]` 相等的折扣，其中 `j` 是满足 `j > i` 且 `prices[j] <= prices[i]` 的 **最小下标** ，如果没有满足条件的 `j` ，你将没有任何折扣。\n>\n> 请你返回一个数组，数组中第 `i` 个元素是折扣后你购买商品 `i` 最终需要支付的价格。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [8,4,6,2,3]\n> 输出：[4,2,4,2,3]\n> 解释：\n> 商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n> 商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n> 商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n> 商品 3 和 4 都没有折扣。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,2,3,4,5]\n> 输出：[1,2,3,4,5]\n> 解释：在这个例子中，所有商品都没有折扣。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：prices = [10,1,1,6]\n> 输出：[9,0,1,6]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 500`\n> - `1 <= prices[i] <= 10^3`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] finalPrices(int[] prices) {\n        int len= prices.length;\n        Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isEmpty()&&prices[stack.peek()]>=prices[i]){\n                System.out.println(prices[i]+\"  \"+prices[stack.peek()]);\n                prices[stack.peek()]-=prices[i];\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return prices;\n    }\n}\n```\n\n### <span id=\"head57\"> 🟡739.每日温度</span>\n\n> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: temperatures = [73,74,75,71,69,72,76,73]\n> 输出: [1,1,4,2,1,1,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: temperatures = [30,40,50,60]\n> 输出: [1,1,1,0]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: temperatures = [30,60,90]\n> 输出: [1,1,0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= temperatures.length <= 105`\n> - `30 <= temperatures[i] <= 100`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n       int len= temperatures.length;\n       int[]res=new int[len];\n       Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isEmpty()&&temperatures[stack.peek()]<temperatures[i]){\n                res[stack.peek()]=i-stack.peek();\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return res;\n    }\n}\n```\n\n### <span id=\"head58\">🔴42.接雨水</span>\n\n## <span id=\"head59\"> 栈与队列综合</span>\n\n### <span id=\"head60\"> 🟢232.用栈实现队列</span>\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n>\n> 实现 `MyQueue` 类：\n>\n> - `void push(int x)` 将元素 x 推到队列的末尾\n> - `int pop()` 从队列的开头移除并返回元素\n> - `int peek()` 返回队列开头的元素\n> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n>\n> **说明：**\n>\n> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> \n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\n>\n> \n>\n> **进阶：**\n>\n> - 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyQueue {\n    Stack<Integer>s1=new Stack<>();\n    Stack<Integer>s2=new Stack<>();    \n    public void push(int x) {\n        s2Tos1();\n        s1.push(x);\n        s1Tos2();\n    }    \n    public int pop() {\n        return s2.pop();\n    }    \n    public int peek() {\n        return s2.peek();\n    }    \n    public boolean empty() {\n        return s2.empty();\n    }\n    void s1Tos2(){\n        while(!s1.isEmpty()){\n            s2.push(s1.pop());\n        }\n    }\n    void s2Tos1(){\n        while(!s2.isEmpty()){\n            s1.push(s2.pop());\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head61\"> 作业</span>\n\n### <span id=\"head62\"> 🟢225.用队列实现栈</span>\n\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n>\n> 实现 `MyStack` 类：\n>\n> - `void push(int x)` 将元素 x 压入栈顶。\n> - `int pop()` 移除并返回栈顶元素。\n> - `int top()` 返回栈顶元素。\n> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **注意：**\n>\n> - 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。\n> - 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 2, 2, false]\n> \n> 解释：\n> MyStack myStack = new MyStack();\n> myStack.push(1);\n> myStack.push(2);\n> myStack.top(); // 返回 2\n> myStack.pop(); // 返回 2\n> myStack.empty(); // 返回 False\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`\n> - 每次调用 `pop` 和 `top` 都保证栈不为空\n>\n> \n>\n> **进阶：**你能否仅用一个队列来实现栈。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyStack {\n\n    Queue<Integer>in;\n    Queue<Integer>out;\n\n    public MyStack() {\n        this.in=new LinkedList<>();\n        this.out=new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        this.in.offer(x);\n    }\n    \n    public int pop() {\n        in2out();\n        int res=this.in.poll();\n        out2in();\n        return res;\n    }\n    \n    public int top() {\n        in2out();\n        int res=this.in.peek();\n        this.out.offer(in.poll());\n        out2in();\n        return res;\n    }\n    \n    public boolean empty() {\n        return this.in.isEmpty();\n    }\n    void out2in(){//\n        while(!this.out.isEmpty()){\n            this.in.offer(this.out.poll());\n        }\n    }\n    void in2out(){\n\n        int size=this.in.size();\n        for (int i = 0; i < size-1; i++) {\n            this.out.offer(this.in.poll());\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head63\"> 🟢496.下一个更大的元素Ⅰ</span>\n\n> `nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。\n>\n> 给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。\n>\n> 对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。\n>\n> 返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n> 输出：[-1,3,-1]\n> 解释：nums1 中每个值的下一个更大元素如下所述：\n> - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n> - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n> - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [2,4], nums2 = [1,2,3,4].\n> 输出：[3,-1]\n> 解释：nums1 中每个值的下一个更大元素如下所述：\n> - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。\n> - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length <= nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 104`\n> - `nums1`和`nums2`中所有整数 **互不相同**\n> - `nums1` 中的所有整数同样出现在 `nums2` 中\n>\n> \n>\n> **进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 哈希表\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int len=nums1.length;\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < len; i++) {\n            map.put(nums1[i],i);\n        }\n        int[]res=new int[len];\n        Arrays.fill(res,-1);\n        Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < nums2.length; i++) {\n            while(!stack.isEmpty()&&nums2[stack.peek()]<nums2[i]){\n                int pre=nums2[stack.pop()];\n                if(map.containsKey(pre)){\n                    res[map.get(pre)]=nums2[i];\n                }\n            }\n            stack.push(i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head64\"> 2023Q1A-找朋友</span>\n\n> #### 题目描述\n>\n> 在学校中，N个小朋友站成一队， 第i个小朋友的身高为height[i]，第i个小朋友可以看到的右边的第一个比自己身高更高的小朋友j，那么j是i的好朋友（j > i）。\n>\n> 请重新生成一个列表，对应位置的输出是每个小朋友的好朋友位置，如果没有看到好朋友，请在该位置用0代替。小朋友人数范围是 [0, 40000]。\n>\n> #### 输入\n>\n> 第一行输入N，表示有N个小朋友 \n>\n> 第二行输入N个小朋友的身高height[i]，都是整数\n>\n> #### 输出\n>\n> 输出N个小朋友的好朋友的位置\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 8\n> 123 124 125 121 119 122 126 123\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 1 2 6 5 5 6 0 0\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        int[]arr=new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i]=in.nextInt();\n        }\n        int[]res=new int[n];\n        Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while(!stack.isEmpty()&&arr[stack.peek()]<arr[i]){\n                res[stack.pop()]=i;\n            }\n            stack.push(i);\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.print(res[i]+\" \");\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head65\"> 2023Q1A-删除重复数字后的最大数字</span>\n\n> #### 题目描述\n>\n> 一个长整型数字，消除重复的数字后，得到最大的一个数字。 \n>\n> 如 12341 ，消除重复的 1，可得到 1234 或 2341，取最大值 2341。 \n>\n> 如 42234，消除 4 得到 4223 或者 2234 ，再消除 2，得到 423 或 234，取最大值 423。\n>\n> #### 输入\n>\n> 输入一个数字，范围 [1, 100000]\n>\n> #### 输出\n>\n> 输出经过删除操作后的最大值\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 12341\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 2341\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        Stack<Character>stack=new Stack<>();\n        for (int i = 0; i < string.length(); i++) {\n            char ch=string.charAt(i);\n            if(stack.contains(ch)){\n                continue;\n            }\n            while(!stack.isEmpty()&&stack.peek()<ch&&string.indexOf(stack.peek(),i)!=-1){\n                stack.pop();\n            }\n            stack.push(ch);\n        }\n        int size= stack.size();\n        int res=0,k=1;\n        for (int i = size-1; i >= 0; i--) {\n            int temp=stack.get(i)-'0';\n            res+=temp*k;\n            k*=10;\n        }\n        System.out.print(res);\n    }\n}\n```\n\n\n\n### <span id=\"head66\"> 2023Q1B-找最小数</span>\n\n> #### 题目描述\n>\n> 给一个正整数 NUM1，计算出新正整数 NUM2。NUM2 为 NUM1 中移除 N 位数字后的结果，需要使得 NUM2 的值最小。\n>\n> #### 输入\n>\n> \\1. 输入的第一行为一个字符串，字符串由 0-9 字符组成，记录正整数 NUM1，NUM1 长度小于 32。 \n>\n> \\2. 输入的第二行为需要移除的数字的个数，小于 NUM1 长度。\n>\n> #### 输出\n>\n> 输出一个数字字符串，记录最小值 NUM2。\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 2615371\n> 4\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 131\n> ```\n\n```java\nimport java.util.*;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution=new Solution();\n        Scanner in=new Scanner(System.in);\n        String num=in.next();\n        int k=in.nextInt();\n        System.out.println(solution.removeKdigits(num,k));\n    }\n}\nclass Solution {\n    public String removeKdigits(String num, int k) {\n        int len=num.length();\n        Stack<Character>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            char ch=num.charAt(i);\n            while (!stack.isEmpty()&&k>0&&stack.peek()>ch){\n                stack.pop();\n                k--;\n            }\n            stack.push(num.charAt(i));\n        }\n        for (int i = 0; i < k; i++) {\n            stack.pop();\n        }\n        StringBuilder res=new StringBuilder();\n        for (Character character : stack) {\n\n            res.append(character);\n        }\n        return res.isEmpty()?\"0\":res.toString();\n    }\n}\n```\n\n\n\n# <span id=\"head67\"> 第六天</span>\n\n## <span id=\"head68\"> 双指针-同向双指针</span>\n\n### <span id=\"head69\"> 🟢88.合并两个有序数组</span>\n\n> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。\n>\n> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。\n>\n> **注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n> 输出：[1,2,2,3,5,6]\n> 解释：需要合并 [1,2,3] 和 [2,5,6] 。\n> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [1], m = 1, nums2 = [], n = 0\n> 输出：[1]\n> 解释：需要合并 [1] 和 [] 。\n> 合并结果是 [1] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n> 输出：[1]\n> 解释：需要合并的数组是 [] 和 [1] 。\n> 合并结果是 [1] 。\n> 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `nums1.length == m + n`\n> - `nums2.length == n`\n> - `0 <= m, n <= 200`\n> - `1 <= m + n <= 200`\n> - `-109 <= nums1[i], nums2[j] <= 109`\n>\n> \n>\n> **进阶：**你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        for (int i = 0; i < n; i++) {\n            nums1[m+i]=nums2[i];\n        }\n        Arrays.sort(nums1);\n    }\n}\n```\n\n### <span id=\"head70\"> 🟢26.删除有序数组的重复项</span>\n\n> 给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。\n>\n> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：\n>\n> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。\n> - 返回 `k` 。\n>\n> **判题标准:**\n>\n> 系统会用下面的代码来测试你的题解:\n>\n> ```\n> int[] nums = [...]; // 输入数组\n> int[] expectedNums = [...]; // 长度正确的期望答案\n> \n> int k = removeDuplicates(nums); // 调用\n> \n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n> ```\n>\n> 如果所有断言都通过，那么您的题解将被 **通过**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2,_]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **升序** 排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len= nums.length;\n        int i=0,j=1;\n        while(j<len){\n            while (j<len&&nums[j]==nums[i]){\n                j++;\n            }\n            if(j>=len) {\n                break;\n            }\n            int temp=nums[j];\n            nums[j]=nums[i+1];\n            nums[i+1]=temp;\n            i++;\n            j++;\n            if(j>=len) {\n                break;\n            }\n        }\n        return i+1;\n    }\n}\n```\n\n\n\n### <span id=\"head71\">🟡80.删除有序数组的重复项Ⅱ</span>\n\n> 给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。\n>\n> 不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n>\n> \n>\n> **说明：**\n>\n> 为什么返回数值是整数，但输出的答案是数组呢？\n>\n> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n> 你可以想象内部操作如下:\n>\n> ```\n> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\n> int len = removeDuplicates(nums);\n> \n> // 在函数里修改输入数组对于调用者是可见的。\n> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n> for (int i = 0; i < len; i++) {\n>     print(nums[i]);\n> }\n> ```\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,1,2,2,3]\n> 输出：5, nums = [1,1,2,2,3]\n> 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,1,2,3,3]\n> 输出：7, nums = [0,0,1,1,2,3,3]\n> 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按升序排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len= nums.length;\n        int i=1,j=i,cnt=1;\n        if(len<=2){\n            return len;\n        }\n        for (; i < len; i++) {\n            if(nums[i]==nums[i-1]){\n                cnt++;\n            }else{\n                cnt=1;\n            }\n            if(cnt==3){\n                int temp=nums[i];\n                j=i+1;\n                while (j<len&&nums[j]==temp){\n                    j++;\n                }\n                if(j>=len){\n                    break;\n                }\n                for (int k = 0; k < len-j; k++) {\n                    nums[i+k]=nums[j+k];\n                }\n                for (int k = 0; k < j-i; k++) {\n                    nums[len-1-k]=temp;\n                }\n                cnt=1;\n            }\n        }\n        int cnt_=1;\n        for (int k = 1; k < len; k++) {\n            if(nums[k]<nums[k-1]){\n                return k;\n            }\n            if(nums[k]==nums[k-1]){\n                cnt_++;\n            }else{\n                cnt_=1;\n            }\n            if(cnt_==3){\n                return k;\n            }\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head72\">🟢485.最大连续1的个数</span>\n\n> 给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,0,1,1,1]\n> 输出：3\n> 解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：nums = [1,0,1,1,0,1]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `nums[i]` 不是 `0` 就是 `1`.\n>\n> Related Topics\n>\n> 数组\n\n```java\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int len=nums.length;\n        int res=0,cnt=0;\n        for (int i = 0; i < len; i++) {\n            if(nums[i]==1){\n                cnt++;\n            }else{\n                cnt=0;\n            }\n            res=Math.max(res,cnt);\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head73\"> 作业</span>\n\n### <span id=\"head74\"> 🟢283.移动零</span>\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len=nums.length;\n        int i=0,j=1;\n        while (j<len){\n            while (i<len&&nums[i]!=0){\n                i++;\n            }\n            if(i>=len){\n                return;\n            }\n            j=i+1;\n            while (j<len&&nums[j]==0){\n                j++;\n            }\n            if(j>=len){\n                return;\n            }\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head75\"> 🟢27.移除数组</span>\n\n> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n>\n> \n>\n> **说明:**\n>\n> 为什么返回数值是整数，但输出的答案是数组呢?\n>\n> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n> 你可以想象内部操作如下:\n>\n> ```\n> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n> int len = removeElement(nums, val);\n> \n> // 在函数里修改输入数组对于调用者是可见的。\n> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n> for (int i = 0; i < len; i++) {\n>     print(nums[i]);\n> }\n> ```\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,2,2,3], val = 3\n> 输出：2, nums = [2,2]\n> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2\n> 输出：5, nums = [0,1,4,0,3]\n> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= nums.length <= 100`\n> - `0 <= nums[i] <= 50`\n> - `0 <= val <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int len= nums.length;\n        int i=0,j=1;\n        while (i<len){\n            while (i<len&&nums[i]!=val){\n                i++;\n            }\n            j=i+1;\n            if(i>=len){\n                break;\n            }\n            while (j<len&&nums[j]==val){\n                j++;\n            }\n            if(j>=len){\n                break;\n            }\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n        }\n        return i;\n    }\n}\n```\n\n\n\n### <span id=\"head76\">2023Q1A-最长的元音字符串</span>\n\n> #### 题目描述\n>\n> ​\t\t\t定义当一个字符串只有元音字母`(a,e,i,o,u,A,E,I,O,U)`组成,称为元音字符串，现给定一个字符串，请找出其中最长的元音字符串，并返回其长度，如果找不到请返回`0`。字符串中**任意一个连续字符组成的****子序列****称为该字符串的子串。**  \t\n>\n> \n>\n> #### 输入\n>\n> ​\t\t一个字符串`s`。字符串长度满足`0 < len(s) < 10^5`，字符串仅由字符`a-z`或`A-Z`组成 \n>\n> \n>\n> #### 输出\n>\n> ​\t\t一个整数，表示最长的元音字符子串的长度。 \n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> asdbuiodevauufgh\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 3\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int res=0,cnt=0;\n        String yuanyin=\"aeiouAEIOU\";\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        int len=string.length();\n        for (int i = 0; i < len; i++) {\n            if(yuanyin.contains(string.charAt(i)+\"\")){\n                cnt++;\n            }else{\n                cnt=0;\n            }\n            res=Math.max(res,cnt);\n        }\n        System.out.println(res);\n    }\n}\n```\n\n\n\n# <span id=\"head77\"> 第七天</span>\n\n## <span id=\"head78\"> 相向双指针</span>\n\n### <span id=\"head79\"> 🟢9.回文数</span>\n\n> 给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n>\n> 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n>\n> - 例如，`121` 是回文，而 `123` 不是。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 121\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = -121\n> 输出：false\n> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：x = 10\n> 输出：false\n> 解释：从右向左读, 为 01 。因此它不是一个回文数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-231 <= x <= 231 - 1`\n>\n> \n>\n> **进阶：**你能不将整数转为字符串来解决这个问题吗？\n>\n> Related Topics\n>\n> 数学\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String str=String.valueOf(x);\n        int i=0,j=str.length()-1;\n        while(i<j){\n            if(str.charAt(i)!=str.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head80\"> 🟢125.验证回文数</span>\n\n> 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。\n>\n> 字母和数字都属于字母数字字符。\n>\n> 给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"A man, a plan, a canal: Panama\"\n> 输出：true\n> 解释：\"amanaplanacanalpanama\" 是回文串。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"race a car\"\n> 输出：false\n> 解释：\"raceacar\" 不是回文串。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \" \"\n> 输出：true\n> 解释：在移除非字母数字字符之后，s 是一个空字符串 \"\" 。\n> 由于空字符串正着反着读都一样，所以是回文串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 2 * 105`\n> - `s` 仅由可打印的 ASCII 字符组成\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"[^a-zA-Z0-9]+\",\"\");\n        s=s.toLowerCase();\n        int len=s.length();\n        int i=0,j=len-1;\n        while(i<j){\n            if(s.charAt(i)!=s.charAt(j)){\n                return false;\n            }\n            j--;\n            i++;\n        }\n        return true;\n    }\n}\n```\n\n\n\n### <span id=\"head81\"> 🟡167.两数之和Ⅱ-输入有序数组</span>\n\n> 给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。\n>\n> 以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。\n>\n> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。\n>\n> 你所设计的解决方案必须只使用常量级的额外空间。\n>\n> **示例 1：**\n>\n> ```\n> 输入：numbers = [2,7,11,15], target = 9\n> 输出：[1,2]\n> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：numbers = [2,3,4], target = 6\n> 输出：[1,3]\n> 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：numbers = [-1,0], target = -1\n> 输出：[1,2]\n> 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= numbers.length <= 3 * 104`\n> - `-1000 <= numbers[i] <= 1000`\n> - `numbers` 按 **非递减顺序** 排列\n> - `-1000 <= target <= 1000`\n> - **仅存在一个有效答案**\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int len= numbers.length;\n        int i=0,j=len-1;\n        int[]res=new int[2];\n        while (i<j){\n            int sum=numbers[i]+numbers[j];\n            if(sum==target){\n                res[0]=i+1;\n                res[1]=j+1;\n                break;\n            }else if(sum>target){\n                j--;\n            }else{\n                i++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head82\"> 🟡11.盛水最多的容器</span>\n\n> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n>\n> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n>\n> 返回容器可以储存的最大水量。\n>\n> **说明：**你不能倾斜容器。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)\n>\n> ```\n> 输入：[1,8,6,2,5,4,8,3,7]\n> 输出：49 \n> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：height = [1,1]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == height.length`\n> - `2 <= n <= 105`\n> - `0 <= height[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int res=0;\n        int len=height.length;\n        int i=0,j=len-1;\n        while (i<j){\n            int area=(j-i)*Math.min(height[i], height[j]);\n            res=Math.max(res,area);\n            if(height[j]<height[i]){\n                j--;\n            }else{\n                i++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n### <span id=\"head83\"> 🟡15.三数之和</span>\n\n> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n>\n> 你返回所有和为 `0` 且不重复的三元组。\n>\n> **注意：**答案中不可以包含重复的三元组。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-1,0,1,2,-1,-4]\n> 输出：[[-1,-1,2],[-1,0,1]]\n> 解释：\n> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\n> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\n> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n> 注意，输出的顺序和三元组的顺序并不重要。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,1]\n> 输出：[]\n> 解释：唯一可能的三元组和不为 0 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [0,0,0]\n> 输出：[[0,0,0]]\n> 解释：唯一可能的三元组和为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= nums.length <= 3000`\n> - `-105 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        int len= nums.length;\n        Arrays.sort(nums);\n        List<List<Integer>>res=new ArrayList<>();\n        for (int i = 0; i < len; i++) {\n            if(nums[i]>0){\n                return res;\n            }\n            while (i>0&&i<len&&nums[i]==nums[i-1]){\n                i++;\n            }\n            int left=i+1,right=len-1;\n            while (left<right){\n                int sum=nums[i]+nums[left]+nums[right];\n                if(sum<0){\n                    left++;\n                } else if (sum>0) {\n                    right--;\n                }else{\n                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));\n                    while (left<right&&nums[left]==nums[left+1]){\n                        left++;\n                    }\n                    while (left<right&&nums[right]==nums[right-1]){\n                        right--;\n                    }\n                    left++;\n                    right--;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n### <span id=\"head84\">🟡75.颜色分类</span>\n\n> 给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n>\n> 我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。\n>\n> \n>\n> 必须在不使用库内置的 sort 函数的情况下解决这个问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,0,2,1,1,0]\n> 输出：[0,0,1,1,2,2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,0,1]\n> 输出：[0,1,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 300`\n> - `nums[i]` 为 `0`、`1` 或 `2`\n>\n> \n>\n> **进阶：**\n>\n> - 你能想出一个仅使用常数空间的一趟扫描算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int n0=0,n1=0;\n        for (int i = 0; i < nums.length; i++) {\n            int num=nums[i];\n            nums[i]=2;\n            if(num<2){\n                nums[n1++]=1;\n            }\n            if(num<1){\n                nums[n0++]=0;\n            }\n        }\n    }\n}\n```\n\n## <span id=\"head85\"> 作业</span>\n\n### <span id=\"head86\"> 🟢680.验证回文串Ⅱ</span>\n\n> 给你一个字符串 `s`，**最多** 可以从中删除一个字符。\n>\n> 请你判断 `s` 是否能成为回文字符串：如果能，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"aba\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abca\"\n> 输出：true\n> 解释：你可以删除字符 'c' 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"abc\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s` 由小写英文字母组成\n>\n> Related Topics\n>\n> 贪心\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean validPalindrome(String s) {\n        int len=s.length();\n        int i=0,j=len-1;\n        while (i<j){\n            if(s.charAt(i)!=s.charAt(j)){\n                 return  check(s,i,j-1)||check(s,i+1,j);\n            }else{\n                i++;\n                j--;\n            }\n        }\n        return true;\n    }\n    boolean check(String s,int i,int j){\n        while (i<j){\n            if(s.charAt(i)!=s.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head87\"> 2023Q1A-两数之和绝对值最小</span>\n\n> #### 题目描述\n>\n> ​        给定一个整数数组nums，请你在该数组中找出两个数，使得这两个数的和的绝对值abs(nums[x] + nums[y])为最小值并按从小到大返回这两个数以及它们和的绝对值。每种输入只会对应一个答案。数组中同一个元素不能使用两遍。\n>\n> #### 输入\n>\n> ​\t\t一个通过空格分割的整数序列字符串，最多`1000`个整数，且整数数值范围是`[-65535,65535]` \n>\n> \n>\n> #### 输出\n>\n> ​\t\t两个数以及两数之和绝对值 \n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> -1 -3 7 5 11 15\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> -3 5 2\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String[]splited=in.nextLine().split(\" \");\n        int len= splited.length;\n        int[]arr=new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i]=Integer.parseInt(splited[i]);\n        }\n        int min=Integer.MAX_VALUE,num1=0,num2=0;\n        Arrays.sort(arr);\n        for (int i = 0; i < len; i++) {\n            for (int j = i+1; j < len; j++) {\n                int sub=Math.abs(arr[j]+arr[i]);\n                if(sub<min){\n                    num1=arr[i];\n                    num2=arr[j];\n                    min=sub;\n                }\n            }\n        }\n        System.out.println(num1+\" \"+num2+\" \"+min);\n    }\n}\n```\n\n\n\n### <span id=\"head88\"> 2023Q1A-双十一</span>\n\n> #### 题目描述\n>\n> 双十一众多商品进行打折销售，小明想购买一些自己心仪的商品，但由于受购买资金限制，所以他决定从众多心意商品中购买 `3` 件，而且想尽可能的花完资金，现在请你设计一个程序帮助小明计算尽可能花费的最大资金额。 \n>\n> \n>\n> #### 输入\n>\n> 第一行为整型数组 `M`，数组长度小于`100`，数组元素记录单个商品的价格； 单个商品价格小于`1000`； 第二行输入为购买资金的额度`R`，`R < 100000`。 \n>\n> \n>\n> #### 输出\n>\n> 输出为满足上述条件的最大花费额度 如果不存在满足上述条件的商品请返回-1\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 23,26,36,27\n> 78\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 76\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        String[]splited=string.split(\",\");\n        int len= splited.length;\n        int[]arr=new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i]=Integer.parseInt(splited[i]);\n        }\n        int target= Integer.parseInt(in.nextLine());\n        Arrays.sort(arr);\n        List<Integer>list=new ArrayList<>();\n        for (int i = 0; i < len; i++) {\n            for (int j = i+1; j < len; j++) {\n                for (int k = j+1; k < len; k++) {\n                    int sum=arr[i]+arr[j]+arr[k];\n                    if(sum<=target){\n                        list.add(sum);\n                    }\n                }\n            }\n        }\n        Collections.sort(list);\n        if(list.size()==0){\n            System.out.println(-1);\n        }else{\n            System.out.println(list.get(list.size()-1));\n        }\n\n    }\n}\n```\n\n\n\n# <span id=\"head89\"> 第八天</span>\n\n## <span id=\"head90\"> 贪心</span>\n\n### <span id=\"head91\"> 🟢455.分发饼干</span>\n\n> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n>\n> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n>\n> **示例 1:**\n>\n> ```\n> 输入: g = [1,2,3], s = [1,1]\n> 输出: 1\n> 解释: \n> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n> 所以你应该输出1。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: g = [1,2], s = [1,2,3]\n> 输出: 2\n> 解释: \n> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n> 你拥有的饼干数量和尺寸都足以让所有孩子满足。\n> 所以你应该输出2.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= g.length <= 3 * 104`\n> - `0 <= s.length <= 3 * 104`\n> - `1 <= g[i], s[j] <= 231 - 1`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        int cnt=0;\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i=0,j=0;\n        while (i<g.length&&j<s.length){\n            if(g[i]<=s[j]){\n                cnt++;\n                i++;\n                j++;\n            } else if (i<g.length) {\n                j++;\n            }else{\n                i++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n\n\n### <span id=\"head92\"> 🟡134.加油站</span>\n\n> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。\n>\n> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。\n>\n> 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n> 输出: 3\n> 解释:\n> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n> 因此，3 可为起始索引。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: gas = [2,3,4], cost = [3,4,3]\n> 输出: -1\n> 解释:\n> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n> 因此，无论怎样，你都不可能绕环路行驶一周。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `gas.length == n`\n> - `cost.length == n`\n> - `1 <= n <= 105`\n> - `0 <= gas[i], cost[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int totalTank = 0;  // 总剩余油量\n        int currentTank = 0;  // 当前剩余油量\n        int startStation = 0;  // 起始加油站\n\n        for (int i = 0; i < gas.length; i++) {\n            totalTank += gas[i] - cost[i];\n            currentTank += gas[i] - cost[i];\n\n            // 如果当前剩余油量为负，则无法到达下一个加油站，将起始加油站设为下一个加油站\n            if (currentTank < 0) {\n                startStation = i + 1;\n                currentTank = 0;\n            }\n        }\n\n        // 如果总剩余油量小于0，则无法绕行一圈\n        if (totalTank < 0) {\n            return -1;\n        } else {\n            return startStation;\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head93\"> 🟢860.柠檬水找零</span>\n\n> 在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n>\n> 每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n>\n> 注意，一开始你手头没有任何零钱。\n>\n> 给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：bills = [5,5,5,10,20]\n> 输出：true\n> 解释：\n> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n> 由于所有客户都得到了正确的找零，所以我们输出 true。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：bills = [5,5,10,10,20]\n> 输出：false\n> 解释：\n> 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n> 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n> 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n> 由于不是每位顾客都得到了正确的找零，所以答案是 false。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= bills.length <= 105`\n> - `bills[i]` 不是 `5` 就是 `10` 或是 `20`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n```java\nclass Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int five=0,ten=0;\n        for (int i = 0; i < bills.length; i++) {\n            if(bills[i]==5){\n                five++;\n            } else if (bills[i]==10) {\n                if(five>=1){\n                    five--;\n                    ten++;\n                }else{\n                    return false;\n                }\n            }else {\n                if(five>=1&&ten>=1){\n                    five--;\n                    ten--;\n                }else if(five>=3){\n                    five-=3;\n                }else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### <span id=\"head94\"> 🟢605.种花问题</span>\n\n> 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n>\n> 给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：flowerbed = [1,0,0,0,1], n = 1\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：flowerbed = [1,0,0,0,1], n = 2\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= flowerbed.length <= 2 * 104`\n> - `flowerbed[i]` 为 `0` 或 `1`\n> - `flowerbed` 中不存在相邻的两朵花\n> - `0 <= n <= flowerbed.length`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n```java\nclass Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int len= flowerbed.length;\n        if(len==1&&flowerbed[0]==0){\n            n--;\n        }else{\n            if(flowerbed[0]==0&&flowerbed[1]==0){\n                flowerbed[0]=1;\n                n--;\n            }\n            if(flowerbed[len-1]==0&&flowerbed[len-2]==0){\n                flowerbed[len-1]=1;\n                n--;\n            }\n            for (int i = 1; i < len-1; i++) {\n                if(flowerbed[i-1]==0&&flowerbed[i]==0&&flowerbed[i+1]==0){\n                    flowerbed[i]=1;\n                    n--;\n                }\n            }\n        }\n        return n<=0;\n    }\n}\n```\n\n\n\n### <span id=\"head95\"> 🟡376.摆动序列</span>\n\n> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n>\n> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。\n> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n>\n> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n>\n> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,7,4,9,2,5]\n> 输出：6\n> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,17,5,10,13,15,10,5,16,8]\n> 输出：7\n> 解释：这个序列包含几个长度为 7 摆动序列。\n> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5,6,7,8,9]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `0 <= nums[i] <= 1000`\n>\n> \n>\n> **进阶：**你能否用 `O(n)` 时间复杂度完成此题?\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int wiggleMaxLength(int[] nums) {\n        int len= nums.length;\n        List<Integer>list=new ArrayList<>();\n        list.add(nums[0]);\n        for (int i = 1; i < len; i++) {\n            if(nums[i]!=nums[i-1]){\n                list.add(nums[i]);\n            }\n        }\n        int size= list.size();\n        if(size==1){\n            return 1;\n        }\n        if(size==2&& list.get(0)!=list.get(1)){\n            return 2;\n        } else if (size==2) {\n            return 1;\n        }\n        int cnt=2,flag=list.get(1)-list.get(0);\n        for (int i = 2; i < list.size(); i++) {\n            int sub=list.get(i)- list.get(i-1);\n            if(sub*flag<0){\n                cnt++;\n                flag=sub;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n\n\n### <span id=\"head96\"> 2023Q1A-快递货车</span>\n\n> #### 题目描述\n>\n> ​        一辆具有最大载重量的运送快递的货车正在运送若干重量不一的快递中，试计算出该货车最多能运载的快递数目。快递数量最多为1000个，货车的最大载重最为50000。 注：不考虑快递的体积。\n>\n> #### 输入\n>\n> ​\t\t第一行输入每个快递的重量，用英文逗号隔开，如 `5,10,2,11` 第二行输入货车的最大载重量，如 `20` \n>\n> \n>\n> #### 输出\n>\n> ​\t\t输出最多能装多少个快递，如 `3` \n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> 5,10,2,11\n> 20\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 3\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String[] splited=in.nextLine().split(\",\");\n        int len= splited.length;\n        int[]arr=new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i]=Integer.parseInt(splited[i]);\n        }\n        int target=in.nextInt();\n        int cnt=0,sum=0;\n        Arrays.sort(arr);\n        for (int i = 0; i < len; i++) {\n            if(sum+arr[i]<=target){\n                sum+=arr[i];\n                cnt++;\n            }else {\n                break;\n            }\n        }\n        System.out.println(cnt);\n    }\n}\n\n```\n\n\n\n## <span id=\"head97\"> 作业</span>\n\n### <span id=\"head98\"> 2023Q1A-停车找车位</span>\n\n> #### 题目描述\n>\n> 停车场有一横排车位，0 代表没有停车，1 代表有车。至少停了一辆车在车位上，也至少有一个空位没有停车。 为了防剐蹭，需为停车人找到一个车位，使得距停车人的车最近的车辆的距离是最大的，返回此时的最大距离。\n>\n> #### 输入\n>\n> ​\t\t1、一个用半角逗号分割的停车标识字符串，停车标识为 `0` 或 `1`，`0` 为空位，`1` 为已停车。 \n>\n> ​\t\t2、停车位最多 `100` 个。 \n>\n> \n>\n> #### 输出\n>\n> ​\t\t输出一个整数记录最大距离。 \n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> 1,0,0,0,0,1,0,0,1,0,1\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 2\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String[] splited=in.nextLine().split(\",\");\n        int len= splited.length;\n        int[]arr=new int[len];\n        for (int i = 0; i < len; i++) {\n            arr[i]=Integer.parseInt(splited[i]);\n        }\n        int cnt=0,max=0,start=0,end=len-1;\n        while (start<len&&arr[start]==0){\n            start++;\n        }\n        while (end>=0&&arr[end]==0){\n            end--;\n        }\n        max=Math.max(start,len-end-1);\n        for (int i = start; i < end; i++) {\n            if(arr[i]==0){\n                cnt++;\n            }else{\n                cnt=0;\n            }\n            max=Math.max(max,(cnt+1)/2);\n        }\n        System.out.println(max);\n    }\n}\n```\n\n\n\n### <span id=\"head99\">2023Q1A-卡片组成的最大数字</span>\n\n> #### 题目描述\n>\n> ​\t\t小组中每个人都有一张卡片，卡片上是`6`位以内的正整数，组员将卡片连起来可以组成多种数字。计算可以组成的最大数字。 \n>\n> \n>\n> #### 输入\n>\n> ​\t\t由`,`分割的多个正整数字符串，不需要考虑非数字异常情况。小组中最多有`25`个人。 \n>\n> \n>\n> #### 输出\n>\n> ​\t\t最大数字字符串 \n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> 22,221\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 22221\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String[] splited=in.nextLine().split(\",\");\n        Arrays.sort(splited,(a,b)->{\n            return (b+a).compareTo(a+b);\n        });\n        for (String str:\n             splited) {\n            System.out.print(str);\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head100\"> 第九天</span>\n\n\n\n## <span id=\"head101\"> 贪心</span>\n\n### <span id=\"head102\"> 🟡881.救生艇</span>\n\n> 给定数组 `people` 。`people[i]`表示第 `i` 个人的体重 ，**船的数量不限**，每艘船可以承载的最大重量为 `limit`。\n>\n> 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 `limit`。\n>\n> 返回 *承载所有人所需的最小船数* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：people = [1,2], limit = 3\n> 输出：1\n> 解释：1 艘船载 (1, 2)\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：people = [3,2,2,1], limit = 3\n> 输出：3\n> 解释：3 艘船分别载 (1, 2), (2) 和 (3)\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：people = [3,5,3,4], limit = 5\n> 输出：4\n> 解释：4 艘船分别载 (3), (3), (4), (5)\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= people.length <= 5 * 104`\n> - `1 <= people[i] <= limit <= 3 * 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        int cnt=0;\n        int len=people.length;\n        Arrays.sort(people);\n        for (int i = len-1; i >=0; i--) {\n            if(people[i]==limit){\n                cnt++;\n            } else if (people[i]<limit) {\n                break;\n            }\n        }\n        int i=0,j=len-cnt-1;\n        while (i<=j){\n            int sum=people[i]+people[j];\n            if(sum<=limit){\n                cnt++;\n                i++;\n                j--;\n            }else{\n                cnt++;\n                j--;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n\n\n### <span id=\"head103\"> 🟡122.买卖股票的最佳时机Ⅱ</span>\n\n> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n>\n> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n>\n> 返回 *你能获得的 **最大** 利润* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [7,1,5,3,6,4]\n> 输出：7\n> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n>      总利润为 4 + 3 = 7 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,2,3,4,5]\n> 输出：4\n> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n>      总利润为 4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：prices = [7,6,4,3,1]\n> 输出：0\n> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 3 * 104`\n> - `0 <= prices[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution{\n    public int maxProfit(int[] prices) {\n        int res=0;\n        for (int i = 1; i < prices.length; i++) {\n            if(prices[i]-prices[i-1]>0){\n                res+=prices[i]-prices[i-1];\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head104\"> 🟡45.跳跃游戏Ⅱ</span>\n\n> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。\n>\n> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:\n>\n> - `0 <= j <= nums[i]`\n> - `i + j < n`\n>\n> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [2,3,1,1,4]\n> 输出: 2\n> 解释: 跳到最后一个位置的最小跳跃数是 2。\n>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [2,3,0,1,4]\n> 输出: 2\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= nums.length <= 104`\n> - `0 <= nums[i] <= 1000`\n> - 题目保证可以到达 `nums[n-1]`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\n```\n\n\n\n### <span id=\"head105\"> 🔴135.分发糖果</span>\n\n> `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。\n>\n> 你需要按照以下要求，给这些孩子分发糖果：\n>\n> - 每个孩子至少分配到 `1` 个糖果。\n> - 相邻两个孩子评分更高的孩子会获得更多的糖果。\n>\n> 请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ratings = [1,0,2]\n> 输出：5\n> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ratings = [1,2,2]\n> 输出：4\n> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。\n>      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == ratings.length`\n> - `1 <= n <= 2 * 104`\n> - `0 <= ratings[i] <= 2 * 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n## <span id=\"head106\"> 作业</span>\n\n### <span id=\"head107\"> 🟡55.跳跃游戏</span>\n\n### <span id=\"head108\"> 2023Q1A-卡片组成的最大数字</span>\n\n### <span id=\"head109\"> 2023Q1A-贪心的商人</span>\n\n### <span id=\"head110\"> 2023B-观看文艺汇演</span>\n\n# <span id=\"head111\"> 第十天</span>\n\n## <span id=\"head112\"> 滑动窗口-长度可变</span>\n\n### <span id=\"head113\"> 🟡3.无重复字符的最长字符</span>\n\n\n\n### <span id=\"head114\"> 🟡209.长度最小的子数组</span>\n\n### <span id=\"head115\"> 🟡904.水果成蓝</span>\n\n### <span id=\"head116\"> 🟡159.至多包含两个不同的字符的最长字串</span>\n\n### <span id=\"head117\"> 🟡340.至多包含k个不同的字符的最长字串</span>\n\n### <span id=\"head118\"> 🔴76.最小覆盖字串</span>\n\n### <span id=\"head119\"> 2023Q1A-区块链文件转储系统</span>\n\n### <span id=\"head120\"> 2023Q2-寻找符合要求的最长字串</span>\n\n## <span id=\"head121\"> 作业</span>\n\n### <span id=\"head122\"> 🟡1695.删除子数组的最大分数</span>\n\n### <span id=\"head123\"> 🟡2024.考试的最大扰度</span>\n\n### <span id=\"head124\"> 🟡1658.将x减到0的最小操作数</span>\n\n### <span id=\"head125\"> 2023Q1A-完美走位</span>\n\n# <span id=\"head126\"> 第十一天</span>\n\n## <span id=\"head127\"> 滑动窗口-长度不可变</span>\n\n### <span id=\"head128\"> 🟢1984.学生分数的最小差值</span>\n\n### <span id=\"head129\"> 🟡1456.定长子串中元音的最大数目</span>\n\n### <span id=\"head130\"> 🟡567.字符串的排列</span>\n\n### <span id=\"head131\"> 🟡1052.爱生气的书店老板</span>\n\n### <span id=\"head132\"> 2023Q1A-找出通过车辆最多颜色</span>\n\n### <span id=\"head133\"> 2023Q1A-知识图谱新词挖掘</span>\n\n## <span id=\"head134\"> 作业</span>\n\n### <span id=\"head135\"> 🟢2269.找到一个数字的k美丽值</span>\n\n### <span id=\"head136\"> 🟡1876.长度为三且字符不同的子字符串</span>\n\n### <span id=\"head137\"> 🟡438.找到字符串中所有字母异位词</span>\n\n# <span id=\"head138\"> 第十二天</span>\n\n## <span id=\"head139\"> 序列DP-入门</span>\n\n### <span id=\"head140\">🟢509.斐波那契数</span>\n\n### <span id=\"head141\"> 🟢70.爬楼梯</span>\n\n## <span id=\"head142\"> 序列DP-路径问题</span>\n\n### <span id=\"head143\"> 🟡62.不同路径</span>\n\n### <span id=\"head144\"> 🟡63.不同路径Ⅱ</span>\n\n### <span id=\"head145\"> 🟡64.最小路径和</span>\n\n## <span id=\"head146\"> 序列DP-打家劫舍</span>\n\n### <span id=\"head147\"> 🟡198.打家劫舍</span>\n\n### <span id=\"head148\"> 🟡213.打家劫舍Ⅱ</span>\n\n## <span id=\"head149\"> 作业</span>\n\n### <span id=\"head150\"> 🟢1137.第n个泰波那锲数</span>\n\n### <span id=\"head151\"> 🟡120.三角形最小路径和</span>\n\n### <span id=\"head152\"> 🟡931.下降路径最小和</span>\n\n### <span id=\"head153\"> 2023Q1A-猴子爬山</span>\n\n### <span id=\"head154\"> 2023Q2-超级玛丽过吊桥</span>\n\n# <span id=\"head155\"> 第十三天</span>\n\n## <span id=\"head156\"> 序列DP-最长递增子序列(LIS)</span>\n\n### <span id=\"head157\"> 🟡300.最长递增子序列</span>\n\n### <span id=\"head158\"> 🟡673.最长递增子序列的个数</span>\n\n### <span id=\"head159\"> 🟡334.递增的三元组</span>\n\n## <span id=\"head160\"> 序列DP-最长公共子序列(LCS)</span>\n\n### <span id=\"head161\"> 🟡718.最长重复子数字</span>\n\n### <span id=\"head162\"> 🟡1143.最长公共子序列</span>\n\n## <span id=\"head163\"> 作业</span>\n\n### <span id=\"head164\"> 面试题17.08马戏团人塔</span>\n\n### <span id=\"head165\"> 🟡1035.不相交的线</span>\n\n### <span id=\"head166\"> 2023Q1A-寻找重复代码</span>\n\n### <span id=\"head167\">2023Q2-高速公路休息站充电规则</span>\n\n# <span id=\"head168\"> 第十四天</span>\n\n## <span id=\"head169\"> 状态DP-入门</span>\n\n### <span id=\"head170\">🟡LCR 091.粉刷房子</span>\n\n## <span id=\"head171\"> 状态DP-股票问题</span>\n\n### <span id=\"head172\"> 🔴188.买卖股票的最佳时机Ⅳ</span>\n\n### <span id=\"head173\"> 🟢121.买卖股票的最佳时机</span>\n\n### <span id=\"head174\"> 🔴123.买卖股票的最佳时机Ⅲ</span>\n\n### <span id=\"head175\"> 🟡122.买卖股票的最佳时机Ⅱ</span>\n\n### <span id=\"head176\"> 🟡309.最佳买卖股票时机含冷冻期</span>\n\n### <span id=\"head177\"> 🟡714.买卖股票的的最佳时机含手续费</span>\n\n## <span id=\"head178\"> 作业</span>\n\n### <span id=\"head179\"> 2023Q1A-贪心的商人</span>\n\n### <span id=\"head180\">2023Q1A-递增字符串</span>\n\n# <span id=\"head181\"> 第十五天</span>\n\n## <span id=\"head182\"> 背包DP-01背包</span>\n\n### <span id=\"head183\"> 🟡494.目标和</span>\n\n## <span id=\"head184\"> 背包DP-完全背包</span>\n\n### <span id=\"head185\"> 🟡322.零钱兑换</span>\n\n### <span id=\"head186\"> 🟡518.零钱兑换Ⅱ</span>\n\n## <span id=\"head187\"> 作业</span>\n\n### <span id=\"head188\">🟡416.分割等和子集</span>\n\n### <span id=\"head189\"> 🟡1049.最后一块石头的重量Ⅱ</span>\n\n# <span id=\"head190\"> 第十六天</span>\n\n## <span id=\"head191\"> 二分查找-在排序数组中</span>\n\n### <span id=\"head192\"> 🟢35.搜索插入位置</span>\n\n### <span id=\"head193\">🟢704.二分查找</span>\n\n### <span id=\"head194\">🟡34.在排序数组中查找元素的第一个和最后一个位置</span>\n\n## <span id=\"head195\"> 二分查找-在数轴中</span>\n\n### <span id=\"head196\"> 🟢367.有效的完全平方数</span>\n\n### <span id=\"head197\">🟢69.x 的平方根</span>\n\n## <span id=\"head198\"> 二分查找-利用问题的二段性</span>\n\n### <span id=\"head199\"> 🟡875.爱吃香蕉的珂珂</span>\n\n### <span id=\"head200\"> 2023Q1A-开放日活动</span>\n\n### <span id=\"head201\"> 2023B-食堂供餐</span>\n\n## <span id=\"head202\"> 作业</span>\n\n### <span id=\"head203\">🟢374.猜数字大小</span>\n\n### <span id=\"head204\"> 🟡1011.在D天内送达包裹的能力</span>\n\n### <span id=\"head205\"> 2023Q1A-农场施肥</span>\n\n### <span id=\"head206\"> 2023B-最佳植树距离</span>\n\n# <span id=\"head207\"> 第十七天/第十八天</span>\n\n## <span id=\"head208\"> DFS/BFS-前置问题</span>\n\n### <span id=\"head209\"> 2023B-统计监控</span>\n\n## <span id=\"head210\"> DFS/BFS-二维矩阵表示图(岛屿问题)</span>\n\n### <span id=\"head211\"> 🟡200.岛屿数量</span>\n\n### <span id=\"head212\"> 🟡695.岛屿的最大面积</span>\n\n### <span id=\"head213\"> 2023Q1A-开心消消乐</span>\n\n### <span id=\"head214\"> 2023B-寻找最大价值的矿堆</span>\n\n## <span id=\"head215\"> DFS/BFS-邻接矩阵表示图</span>\n\n### <span id=\"head216\"> 🟡547.省份数量</span>\n\n### <span id=\"head217\"> 2023Q1A-Linux发行版的数量</span>\n\n## <span id=\"head218\"> DFS/BFS-邻接表表示图</span>\n\n### <span id=\"head219\"> 🟡841.钥匙和房间</span>\n\n## <span id=\"head220\"> 作业</span>\n\n### <span id=\"head221\"> 🟢463.岛屿的周长</span>\n\n### <span id=\"head222\"> 🟢733.图像渲染</span>\n\n### <span id=\"head223\"> 2023Q2-广播服务器</span>\n\n### <span id=\"head224\"> 2023Q1A-机器人活动区域</span>\n\n# <span id=\"head225\"> 第十九天</span>\n\n## <span id=\"head226\"> BFS</span>\n\n### <span id=\"head227\"> 🟡994.腐烂的橘子</span>\n\n### <span id=\"head228\"> 2023Q1-快速开租建站</span>\n\n## <span id=\"head229\"> DFS</span>\n\n### <span id=\"head230\"> 🟢1971.寻找图中是否存在路径</span>\n\n### <span id=\"head231\"> 🟡1376.通知所有员工所需的时间</span>\n\n### <span id=\"head232\"> 2023Q2-获取食物游戏</span>\n\n## <span id=\"head233\"> 作业</span>\n\n### <span id=\"head234\"> 2023Q2B-火星改造</span>\n\n### <span id=\"head235\"> 2023Q2-士兵突击</span>\n\n# <span id=\"head236\"> 第二十天</span>\n\n## <span id=\"head237\"> 回溯算法</span>\n\n### <span id=\"head238\">🔴51.N 皇后</span>\n\n### <span id=\"head239\"> 🔴37.解数独</span>\n\n## <span id=\"head240\"> 作业</span>\n\n### <span id=\"head241\"> 2023Q1A-基站维修工程师</span>\n\n### <span id=\"head242\"> 2023Q1-硬件产品销售方案</span>\n\n### <span id=\"head243\"> 2023B-猜密码</span>\n","categories":["algorithm training"]},{"title":"🟢836. rectangle overlap","url":"/2023/11/26/coding-836-rectangle-overlap/","content":"\n# Description\n\n> 矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。\n>\n> 如果相交的面积为 **正** ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n>\n> 给出两个矩形 `rec1` 和 `rec2` 。如果它们重叠，返回 `true`；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `rect1.length == 4`\n> - `rect2.length == 4`\n> - `-109 <= rec1[i], rec2[i] <= 109`\n> - `rec1` 和 `rec2` 表示一个面积不为零的有效矩形\n\n# Solution\n\n```java\nclass Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        if(rec1[0]<=rec2[0]&&rec1[1]<=rec2[1]) {//1\n            if(rec2[0]<rec1[2]&&rec2[1]<rec1[3]){\n                return true;\n            }else{\n                return false;\n            }\n        }else if(rec1[0]<=rec2[0]){//2\n            if(rec2[0]<=rec1[2]&&rec2[3]>=rec1[1]){\n                return true;\n            }else{\n                return false;\n            }\n        } else if (rec1[1]<=rec2[1]) {//4\n            if(rec2[1]<=rec1[3]&&rec2[2]>=rec1[0]){\n                return true;\n            }else{\n                return false;\n            }\n        }else{//3\n            if(rec2[2]>rec1[0]&&rec2[3]>rec1[1]){\n                return true;\n            }else{\n                return false;\n            }\n        }\n    }\n}\n```\n\n- time:*O(1)*\n\n- space:*O(1)*\n","tags":["algorithm-Math","algorithm-Geometry"]},{"title":"Monotonic Stack","url":"/2023/09/11/algorithm-monotonic-stack/","content":"\n\n\n| 分类       | 题号                                       | 完成 |\n| ---------- | ------------------------------------------ | ---- |\n| 单调栈     | 739. 每日温度                              |      |\n|            | 1475. 商品折扣后的最终价格 1212            |      |\n|            | 496. 下一个更大元素 I                      |      |\n|            | 503. 下一个更大元素 II                     |      |\n|            | 1019. 链表中的下一个更大节点 1571          |      |\n|            | 962. 最大宽度坡 1608                       |      |\n|            | 901. 股票价格跨度 1709                     |      |\n|            | 1124. 表现良好的最长时间段 1908            |      |\n|            | 456. 132 模式 ~2000                        |      |\n|            | 2866. 美丽塔 II 2072                       |      |\n|            | 2454. 下一个更大元素 IV 2175               |      |\n|            | 2289. 使数组按非递减顺序排列 2482          |      |\n|            | 1776. 车队 II 2531                         |      |\n|            | 2832. 每个元素为最大值的最大范围（会员题） |      |\n| 矩形系列   | 84. 柱状图中最大的矩形                     |      |\n|            | 85. 最大矩形                               |      |\n|            | 1504. 统计全 1 子矩形 1845                 |      |\n| 字典序最小 | 316. 去除重复字母                          |      |\n|            | 316 扩展：重复个数不超过 limit             |      |\n|            | 402. 移掉 K 位数字 ~1800                   |      |\n|            | 1673. 找出最具竞争力的子序列 1802          |      |\n|            | 321. 拼接最大数                            |      |\n| 贡献法     | 907. 子数组的最小值之和 1976               |      |\n|            | 2104. 子数组范围和（最大值-最小值）        |      |\n|            | 1856. 子数组最小乘积的最大值 2051          |      |\n|            | 2818. 操作使得分最大 2397                  |      |\n|            | 2281. 巫师的总力量和（最小值×和） 2621     |      |\n\n# 单调栈\n\n## 739. 每日温度\n\n## 1475. 商品折扣后的最终价格 1212\n\n## 496. 下一个更大元素 I\n\n## 503. 下一个更大元素 II\n\n## 1019. 链表中的下一个更大节点 1571\n\n## 962. 最大宽度坡 1608\n\n## 901. 股票价格跨度 1709\n\n## 1124. 表现良好的最长时间段 1908\n\n## 456. 132 模式 ~2000\n\n## 2866. 美丽塔 II 2072\n\n## 2454. 下一个更大元素 IV 2175\n\n## 2289. 使数组按非递减顺序排列 2482\n\n## 1776. 车队 II 2531\n\n## 2832. 每个元素为最大值的最大范围（会员题）\n\n# 矩形系列\n\n## 84. 柱状图中最大的矩形\n\n## 85. 最大矩形\n\n## 1504. 统计全 1 子矩形 1845\n\n# 字典序最小\n\n## 316. 去除重复字母\n\n## 316 扩展：重复个数不超过 limit\n\n## 402. 移掉 K 位数字 ~1800\n\n## 1673. 找出最具竞争力的子序列 1802\n\n## 321. 拼接最大数\n\n# 贡献法\n\n## 907. 子数组的最小值之和 1976\n\n## 2104. 子数组范围和（最大值-最小值） \n\n## 1856. 子数组最小乘积的最大值 2051\n\n## 2818. 操作使得分最大 2397\n\n## 2281. 巫师的总力量和（最小值×和） 2621\n\n","categories":["algorithm learning"]},{"title":"Dynamic Programming","url":"/2023/09/10/algorithm-dp/","content":"\n| 类型         | 题号                             | 完成 |\n| ------------ | -------------------------------- | ---- |\n| 01背包问题   | 🟡416. 分割等和子集               |      |\n|              | 🟡474. 一和零                     |      |\n|              | 🟡494. 目标和                     |      |\n|              | 🟡1049. 最后一块石头的重量 II     |      |\n|              | 🔴805. 数组的均值分割             |      |\n| 完全背包问题 | 🟡139. 单词拆分                   |      |\n|              | 🟡279. 完全平方数                 |      |\n|              | 🟡322. 零钱兑换                   |      |\n|              | 🟡377. 组合总和 Ⅳ                 |      |\n|              | 🟡518. 零钱兑换 II                |      |\n| 一维DP       | 🔴32. 最长有效括号                |      |\n|              | 🟢70. 爬楼梯                      |      |\n|              | 🟡120. 三角形最小路径和           |      |\n|              | 🟡91. 解码方法                    |      |\n|              | 🟡131. 分割回文串                 |      |\n|              | 🔴132. 分割回文串 II              |      |\n|              | 🟢121. 买卖股票的最佳时机         |      |\n| 二维DP       | 🟡5. 最长回文子串                 |      |\n|              | 🟡97. 交错字符串                  |      |\n|              | 🟡62. 不同路径                    |      |\n|              | 🟡64. 最小路径和                  |      |\n|              | 🟡72. 编辑距离                    |      |\n|              | 🔴115. 不同的子序列               |      |\n| 三维DP       | 🔴87. 扰乱字符串                  |      |\n| 线性DP       | 🔴10. 正则表达式匹配              |      |\n|              | 🟡44. 通配符匹配                  |      |\n|              | 🟡53. 最大子数组和                |      |\n|              | 🟡72. 编辑距离                    |      |\n|              | 🟡122. 买卖股票的最佳时机 II      |      |\n|              | 🔴123. 买卖股票的最佳时机 III     |      |\n|              | 🟡128. 最长连续序列               |      |\n|              | 🟡152. 乘积最大子数组             |      |\n|              | 🟡198. 打家劫舍                   |      |\n|              | 🟡213. 打家劫舍 II                |      |\n|              | 🟡300. 最长递增子序列             |      |\n|              | 🟡319. 灯泡开关                   |      |\n|              | 🔴354. 俄罗斯套娃信封问题         |      |\n|              | 🟡714. 买卖股票的最佳时机含手续费 |      |\n|              | 🔴887. 鸡蛋掉落                   |      |\n|              | 🟡1143. 最长公共子序列            |      |\n|              | 🔴940. 不同的子序列 II            |      |\n|              | 🔴1092. 最短公共超序列            |      |\n|              | 🟡1463. 摘樱桃 II                 |      |\n|              | 🟡1696. 跳跃游戏 VI               |      |\n| 区间DP       | 🔴312. 戳气球                     |      |\n|              | 🟡516. 最长回文子序列             |      |\n|              | 🔴664. 奇怪的打印机               |      |\n|              | 🔴730. 统计不同回文子序列         |      |\n|              | 🟡1039. 多边形三角剖分的最低得分  |      |\n|              | 🟡813. 最大平均值和的分组         |      |\n|              | 🔴1278. 分割回文串                |      |\n| 树形DP       | 🔴124. 二叉树中的最大路径和       |      |\n|              | 🟡337. 打家劫舍 III               |      |\n|              | 🟢543. 二叉树的直径               |      |\n| 数位DP       | 🔴233. 数字 1 的个数              |      |\n|              | 🔴902. 最大为 N 的数字组合65)     |      |\n|              | 🟡1015. 可被 K 整除的最小整数     |      |\n|              | 🔴600. 不含连续1的非负整数        |      |\n|              | 🔴1012. 至少有 1 位重复的数字     |      |\n| 状态压缩DP   | 🟡464. 我能赢吗                   |      |\n|              | 🟡526. 优美的排列                 |      |\n|              | 🟡935. 骑士拨号器                 |      |\n|              | 🔴1349. 参加考试的最大学生数      |      |\n|              | 🟡1986. 完成任务的最少工作时间段  |      |\n| 计数型DP     | 🟡62. 不同路径                    |      |\n|              | 🟡63. 不同路径 II                 |      |\n|              | 🟡96. 不同的二叉搜索树            |      |\n| 递推型DP     | 🟢70. 爬楼梯                      |      |\n|              | 🟢509. 斐波那契数                 |      |\n|              | 🟡935. 骑士拨号器                 |      |\n|              | 🟡957. N天后的牢房                |      |\n|              | 🟢1137. 第 N 个泰波那契数         |      |\n| 概率型DP     | 🟡808. 分汤                       |      |\n|              | 🟡837. 新 21 点                   |      |\n| 博弈型DP     | 🟢292. Nim游戏                    |      |\n|              | 🟡794. 有效的井字游戏             |      |\n|              | 🟡877. 石子游戏                   |      |\n|              | 🟡1140. 石子游戏 II               |      |\n|              | 🟢1275. 找出井字棋的获胜者        |      |\n|              | 🟡1690. 石子游戏 VII              |      |\n| 乘法原理     | 🔴2147.分隔长廊的方案数           |      |\n\n\n\n\n\n# 01背包问题\n\n## 🟡416. 分割等和子集 \n\n## 🟡474. 一和零 \n\n## 🟡494. 目标和 \n\n## 🟡1049. 最后一块石头的重量 II\n\n## 🔴805. 数组的均值分割\n\n# 完全背包问题\n\n## 🟡139. 单词拆分 \n\n## 🟡279. 完全平方数 \n\n## 🟡322. 零钱兑换 \n\n## 🟡377. 组合总和 Ⅳ \n\n## 🟡518. 零钱兑换 II\n\n# 一维DP\n\n## 🔴32. 最长有效括号 \n\n## 🟢70. 爬楼梯\n\n## 🟡120. 三角形最小路径和\n\n## 🟡91. 解码方法 \n\n## 🟡131. 分割回文串\n\n## 🔴132. 分割回文串 II \n\n## 🟢121. 买卖股票的最佳时机\n\n# 二维DP\n\n## 🟡5. 最长回文子串\n\n## 🟡97. 交错字符串 \n\n## 🟡62. 不同路径 \n\n## 🟡64. 最小路径和\n\n## 🟡72. 编辑距离\n\n## 🔴115. 不同的子序列\n\n# 三维DP\n\n## 🔴87. 扰乱字符串\n\n# 线性DP\n\n## 🔴10. 正则表达式匹配\n\n## 🟡44. 通配符匹配 \n\n## 🟡53. 最大子数组和\n\n## 🟡72. 编辑距离 \n\n## 🟡122. 买卖股票的最佳时机 II\n\n## 🔴123. 买卖股票的最佳时机 III \n\n## 🟡128. 最长连续序列 \n\n## 🟡152. 乘积最大子数组 \n\n## 🟡198. 打家劫舍 \n\n## 🟡213. 打家劫舍 II \n\n## 🟡300. 最长递增子序列 \n\n## 🟡319. 灯泡开关 \n\n## 🔴354. 俄罗斯套娃信封问题 \n\n## 🟡714. 买卖股票的最佳时机含手续费 \n\n## 🔴887. 鸡蛋掉落 \n\n## 🟡1143. 最长公共子序列 \n\n## 🔴940. 不同的子序列 II \n\n## 🔴1092. 最短公共超序列 \n\n## 🟡1463. 摘樱桃 II \n\n## 🟡1696. 跳跃游戏 VI\n\n# 区间DP\n\n## 🔴312. 戳气球 \n\n## 🟡516. 最长回文子序列\n\n## 🔴664. 奇怪的打印机\n\n## 🔴730. 统计不同回文子序列 \n\n## 🟡1039. 多边形三角剖分的最低得分\n\n## 🟡813. 最大平均值和的分组\n\n## 🔴1278. 分割回文串\n\n# 树形DP\n\n## 🔴124. 二叉树中的最大路径和 \n\n## 🟡337. 打家劫舍 III \n\n## 🟢543. 二叉树的直径\n\n# 数位DP\n\n## 🔴233. 数字 1 的个数\n\n## 🔴902. 最大为 N 的数字组合\n\n## 🟡1015. 可被 K 整除的最小整数\n\n## 🔴600. 不含连续1的非负整数\n\n## 🔴1012. 至少有 1 位重复的数字\n\n# 状态压缩DP\n\n## 🟡464. 我能赢吗\n\n## 🟡526. 优美的排列\n\n## 🟡935. 骑士拨号器 \n\n## 🔴1349. 参加考试的最大学生数\n\n## 🟡1986. 完成任务的最少工作时间段\n\n# 计数型DP\n\n## 🟡62. 不同路径 \n\n## 🟡63. 不同路径 II\n\n## 🟡96. 不同的二叉搜索树\n\n# 递推型DP\n\n## 🟢70. 爬楼梯\n\n## 🟢509. 斐波那契数\n\n## 🟡935. 骑士拨号器 \n\n## 🟡957. N天后的牢房\n\n## 🟢1137. 第 N 个泰波那契数\n\n# 概率型DP\n\n## 🟡808. 分汤\n\n## 🟡837. 新 21 点\n\n# 博弈型DP\n\n## 🟢292. Nim游戏\n\n## 🟡794. 有效的井字游戏 \n\n## 🟡877. 石子游戏 \n\n## 🟡1140. 石子游戏 II \n\n## 🟢1275. 找出井字棋的获胜者\n\n## 🟡1690. 石子游戏 VII\n\n# 乘法原理\n\n## 🔴2147.分隔长廊的方案数\n\n\n","categories":["algorithm learning"]},{"title":"Greedy","url":"/2023/09/09/algorithm-greedy/","content":"\n| 类型   | 题号                             | 完成 |\n| ------ | -------------------------------- | ---- |\n| 区间类 | 🟢455. 分发饼干2                  |      |\n|        | 🟡435. 无重叠区间                 |      |\n|        | 🟡452. 用最少数量的箭引爆气球     |      |\n|        | 🟡763. 划分字母区间               |      |\n|        | 🟡55. 跳跃游戏                    |      |\n|        | 🟡45. 跳跃游戏 II                 |      |\n|        | 🟡56. 合并区间                    |      |\n|        | 🟡1353. 最多可以参加的会议数目    |      |\n|        | 🔴1520. 最多的不重叠子字符串      |      |\n|        | 🟡738. 单调递增的数字             |      |\n| 峰谷类 | 🟡122. 买卖股票的最佳时机 II      |      |\n|        | 🟡714. 买卖股票的最佳时机含手续费 |      |\n|        | 🟡 376. 摆动序列                  |      |\n|        | 🔴135. 分发糖果                   |      |\n| 钱币类 | 🟡322. 零钱兑换                   |      |\n|        | 🟢860. 柠檬水找零                 |      |\n|        | 🟢1342. 将数字变成 0 的操作次数   |      |\n| 任务类 | 🟡621. 任务调度器                 |      |\n|        | 🟡1705. 吃苹果的最大数目          |      |\n| 矩形类 | 🟡1630. 等差子数组                |      |\n|        | 🟡870. 优势洗牌                   |      |\n|        | 🟡1262. 可被三整除的最大和        |      |\n| 其它   | 🟢1005.K 次取反后最大化的数组和   |      |\n|        | 🟡406. 根据身高重建队列           |      |\n|        | 🟡53. 最大子数组和                |      |\n|        | 🟡134.加油站                      |      |\n|        | 🔴968. 监控二叉树                 |      |\n\n# 区间类\n\n## 🟢455. 分发饼干\n\n## 🟡435. 无重叠区间 \n\n## 🟡452. 用最少数量的箭引爆气球 \n\n## 🟡763. 划分字母区间\n\n## 🟡55. 跳跃游戏\n\n## 🟡45. 跳跃游戏 II\n\n## 🟡56. 合并区间\n\n## 🟡1353. 最多可以参加的会议数目 \n\n## 🔴1520. 最多的不重叠子字符串\n\n## 🟡738. 单调递增的数字\n\n# 峰谷类\n\n## 🟡122. 买卖股票的最佳时机 II \n\n## 🟡714. 买卖股票的最佳时机含手续费 \n\n## 🟡 376. 摆动序列 \n\n## 🔴135. 分发糖果\n\n# 钱币类\n\n## 🟡322. 零钱兑换 \n\n## 🟢860. 柠檬水找零\n\n## 🟢1342. 将数字变成 0 的操作次数\n\n# 任务类\n\n## 🟡621. 任务调度器 \n\n## 🟡1705. 吃苹果的最大数目\n\n# 矩形类\n\n## 🟡1630. 等差子数组\n\n## 🟡870. 优势洗牌\n\n## 🟡1262. 可被三整除的最大和\n\n# 其它\n\n## 🟢1005.K 次取反后最大化的数组和\n\n## 🟡406. 根据身高重建队列\n\n## 🟡53. 最大子数组和\n\n## 🟡134.加油站\n\n## 🔴968. 监控二叉树\n","categories":["algorithm learning"]},{"title":"Back Traking","url":"/2023/09/08/algorithm-backtraking/","content":"\n|   分类   | 题号                   | 完成 |\n| :------: | :--------------------- | :--: |\n|   组合   | 🟡77. 组合              |  ✅   |\n|          | 🟡17.电话号码的字母组合 |  ✅   |\n|          | 🟡216. 组合总和 III     |  ✅   |\n|          | 🟡39.组合总和           |  ✅   |\n|          | 🟡40. 组合总和 II       |  ✅   |\n|   分割   | 🟡131. 分割回文串       |  ✅   |\n|          | 🟡93. 复原 IP 地址      |  ✅   |\n|   子集   | 🟡78. 子集              |  ✅   |\n|          | 🟡90. 子集 II           |  ✅   |\n|          | 🟡491. 递增子序列       |  ✅   |\n|   排列   | 🟡46.全排列             |  ✅   |\n|          | 🟡47. 全排列 II         |  ✅   |\n| 棋盘问题 | 🔴51. N 皇后            |  ✅   |\n|          | 🔴37. 解数独            |  ✅   |\n|   其他   | 🔴332. 重新安排行程     |      |\n\n#  组合\n\n## 🟡77. 组合\n\n> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。\n>\n> 你可以按 **任何顺序** 返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 4, k = 2\n> 输出：\n> [\n> [2,4],\n> [3,4],\n> [2,3],\n> [1,2],\n> [1,3],\n> [1,4],\n> ]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1, k = 1\n> 输出：[[1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 20`\n> - `1 <= k <= n`\n>\n> Related Topics\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>> res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> combine(int n, int k) {\n        backtracking(n,k,1);\n        return res;\n    }\n\n    void backtracking(int n, int k, int num) {\n        if (path.size()==k) {\n            res.add(new ArrayList(path));\n            return;\n        }\n        for (int i=num;i<=n;i++) {\n            path.add(i);\n            backtracking(n,k,i+1); // 递归\n            path.removeLast();\n        }\n    }\n}\n```\n\n- time:*O(n^k+1^)*\n\n- space:*O(C~n~^k^)*\n\n##  🟡17.电话号码的字母组合\n\n> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。\n>\n> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：digits = \"23\"\n> 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：digits = \"\"\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：digits = \"2\"\n> 输出：[\"a\",\"b\",\"c\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= digits.length <= 4`\n> - `digits[i]` 是范围 `['2', '9']` 的一个数字。\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 回溯\n\n```java\nclass Solution {\n    List<String> res=new ArrayList<>();\n    StringBuilder path=new StringBuilder();\n    String[]string={\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    public List<String> letterCombinations(String digits) {\n        if(digits.length()==0){\n            return res;\n        }\n        backtraking(0,digits);//\n        return res;\n    }\n    void backtraking(int num,String digits){//\n        if(path.length()==digits.length()){\n            res.add(path.toString());\n            return;\n        }\n        for (int i = 0; i < string[digits.charAt(num)-'2'].length(); i++) {//\n            path.append(string[digits.charAt(num)-'2'].charAt(i));//\n            backtraking(num+1,digits);//\n            path.deleteCharAt(path.length()-1);\n        }\n    }\n}\n```\n\n- time:*O(3^n^·4^m^)*\n\n- space:*O(1)*\n\n##  🟡216. 组合总和 III\n\n> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：\n>\n> - 只使用数字1到9\n> - 每个数字 **最多使用一次**\n>\n> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: k = 3, n = 7\n> 输出: [[1,2,4]]\n> 解释:\n> 1 + 2 + 4 = 7\n> 没有其他符合的组合了。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: k = 3, n = 9\n> 输出: [[1,2,6], [1,3,5], [2,3,4]]\n> 解释:\n> 1 + 2 + 6 = 9\n> 1 + 3 + 5 = 9\n> 2 + 3 + 4 = 9\n> 没有其他符合的组合了。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: k = 4, n = 1\n> 输出: []\n> 解释: 不存在有效的组合。\n> 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `2 <= k <= 9`\n> - `1 <= n <= 60`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        backtracking(k,n,1,0);\n        return res;\n    }\n    void backtracking(int k,int n,int start,int sum){\n        if(path.size()==k&&sum==n){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i <= 9; i++) {\n            path.add(i);\n            sum+=i;\n            backtracking(k,n,i+1,sum);\n            path.removeLast();\n            sum-=i;\n        }\n    }\n}\n```\n\n- time:*O(9^k^)*\n\n- space:*O(k)*\n\n##  🟡39.组合总和\n\n> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。\n>\n> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n>\n> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：candidates = [2,3,6,7], target = 7\n> 输出：[[2,2,3],[7]]\n> 解释：\n> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n> 7 也是一个候选， 7 = 7 。\n> 仅有这两种组合。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: candidates = [2,3,5], target = 8\n> 输出: [[2,2,2,2],[2,3,3],[3,5]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入: candidates = [2], target = 1\n> 输出: []\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= candidates.length <= 30`\n> - `2 <= candidates[i] <= 40`\n> - `candidates` 的所有元素 **互不相同**\n> - `1 <= target <= 40`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>> res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\n        Arrays.sort(candidates);\n        backtracking(candidates,target,0,0);\n        return res;\n    }\n    void backtracking(int[] candidates,int target,int start,int sum){\n        if(sum==target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i < candidates.length ; i++) {\n            if(sum+candidates[i]>target){\n                break;\n            }\n            path.add(candidates[i]);\n            backtracking(candidates,target,i,sum+candidates[i]);\n            path.removeLast();\n        }\n    }\n}\n```\n\n- time:*O(n^target^)*\n\n- space:*O(k)*\n\n## 🟡40. 组合总和 II\n\n> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。\n>\n> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。\n>\n> **注意：**解集不能包含重复的组合。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: candidates = [10,1,2,7,6,1,5], target = 8,\n> 输出:\n> [\n> [1,1,6],\n> [1,2,5],\n> [1,7],\n> [2,6]\n> ]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: candidates = [2,5,2,1,2], target = 5,\n> 输出:\n> [\n> [1,2,2],\n> [5]\n> ]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= candidates.length <= 100`\n> - `1 <= candidates[i] <= 50`\n> - `1 <= target <= 30`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer> > res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target){\n        Arrays.sort(candidates);\n        backtracking(candidates,target,0,0);\n        return res;\n    }\n    void backtracking(int[] candidates,int target,int start,int sum){\n        if(sum==target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i < candidates.length ; i++) {\n            if(sum+candidates[i]>target){\n                break;\n            }\n            if(i>start&&candidates[i]==candidates[i-1]){//key：同一层的树节点去重\n                continue;\n            }\n            path.add(candidates[i]);\n            sum+=candidates[i];\n            backtracking(candidates,target,i+1,sum);\n            path.removeLast();\n            sum-=candidates[i];\n        }\n    }\n}\n```\n\n- time:*O(n^target^)*\n\n- space:*O(k)*\n\n## 🟡131. 分割回文串\n\n> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。\n>\n> **回文串** 是正着读和反着读都一样的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"aab\"\n> 输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"a\"\n> 输出：[[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 16`\n> - `s` 仅由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<String>> res=new ArrayList<>();\n    LinkedList<String> path=new LinkedList<>();\n    public List<List<String>> partition(String s) {\n        if(s.length()==1){\n            path.add(s);\n            res.add(path);\n            return res;\n        }\n        backtraking(0,s);//\n        return res;\n    }\n    void backtraking(int start,String s){//\n        if(start==s.length()){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start+1; i <= s.length(); i++) {//\n            if(isHuiWen(s.substring(start,i))){\n                path.add(s.substring(start,i));//\n                backtraking(i,s);//\n                path.removeLast();\n            }\n        }\n    }\n    boolean isHuiWen(String str){\n        int i=0,j=str.length()-1;\n        if(j==0){\n            return true;\n        }\n        if(j<0){\n            return false;\n        }\n        while(i<j){\n            if(str.charAt(i)!=str.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(2n^n^)*\n\n- space:*O(k)*\n\n## 🟡93. 复原 IP 地址\n\n> **有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。\n>\n> - 例如：`\"0.1.2.201\"` 和` \"192.168.1.1\"` 是 **有效** IP 地址，但是 `\"0.011.255.245\"`、`\"192.168.1.312\"` 和 `\"192.168@1.1\"` 是 **无效** IP 地址。\n>\n> 给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"25525511135\"\n> 输出：[\"255.255.11.135\",\"255.255.111.35\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"0000\"\n> 输出：[\"0.0.0.0\"]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"101023\"\n> 输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 20`\n> - `s` 仅由数字组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 回溯\n\n```java\nclass Solution {\n    List<String>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    public List<String> restoreIpAddresses(String s) {\n        backtraking(0,s);//\n        return res;\n    }\n    void backtraking(int start,String s){//O(n^)\n        if(path.size()==4&&start==s.length()){\n            res.add(build((path)));//\n            return;\n        }\n        if(path.size()>4){\n            return;\n        }\n        for (int i = start+1; i <=s.length(); i++) {\n            if(s.substring(start,i).length()>1&&s.substring(start,i).charAt(0)=='0'){\n                break;\n            }\n            int temp=convert(s.substring(start,i));\n            if(temp<=255&&temp>=0){\n                path.add(temp);\n                backtraking(i,s);\n                path.removeLast();\n            }\n        }\n    }\n    String build(LinkedList<Integer> al){//O(1)\n        StringBuilder sb=new StringBuilder();\n        sb.append(al.get(0));\n        for (int i = 1; i < 4; i++) {\n            sb.append('.');\n            sb.append(al.get(i));\n        }\n        return sb.toString();\n    }\n    int convert(String str){//O(str.length())\n        int out=0,k=1,i=str.length()-1;\n        while(i>=0){\n            out+=k*(str.charAt(i)-'0');\n            k*=10;\n            i--;\n        }\n        return out;\n    }\n}\n```\n\n- time:\n\n- space:\n\n#  子集\n\n## 🟡78. 子集\n\n> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。\n>\n> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0]\n> 输出：[[],[0]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 10`\n> - `-10 <= nums[i] <= 10`\n> - `nums` 中的所有元素 **互不相同**\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        backtraking(0,nums);\n        return res;\n    }\n    void backtraking(int start,int[]nums){\n        res.add(new ArrayList<>(path));\n        for (int i = start; i < nums.length; i++) {\n            path.add(nums[i]);\n            backtraking(i+1,nums);\n            path.removeLast();\n        }\n    }\n}\n```\n\n- time:*O(2^n^ · n)*\n\n- space:*O(n)*\n\n## 🟡90. 子集 II\n\n> 给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n>\n> 解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。\n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,2]\n> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0]\n> 输出：[[],[0]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 10`\n> - `-10 <= nums[i] <= 10`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        backtraking(0,nums);\n        return res;\n    }\n    void backtraking(int start,int[]nums){\n        res.add(new ArrayList<>(path));\n        for (int i = start; i < nums.length; i++) {\n            if(i>start&&nums[i]==nums[i-1]){\n                continue;\n            }\n            path.add(nums[i]);\n            backtraking(i+1,nums);\n            path.removeLast();\n        }\n    }\n}\n```\n\n- time:*O(2^n^ · n)*\n\n- space:*O(n)*\n\n## 🟡491. 递增子序列\n\n> 给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。\n>\n> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,6,7,7]\n> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,4,3,2,1]\n> 输出：[[4,4]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 15`\n> - `-100 <= nums[i] <= 100`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 哈希表\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    Set<String>set=new TreeSet<>();\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        backtraking(0,nums);\n        return res;\n    }\n    void backtraking(int start,int[]nums){\n        if(check(path)&&!set.contains(path.toString())){\n            res.add(new ArrayList<>(path));\n            set.add(path.toString());\n        }\n\n        for (int i = start; i < nums.length; i++) {\n            if(i>start&&nums[i]==nums[i-1]){\n                continue;\n            }\n            path.add(nums[i]);\n            backtraking(i+1,nums);\n            path.removeLast();\n        }\n    }\n    boolean check(List<Integer>al){\n        if(al.size()<2){\n            return false;\n        }\n        for (int i = 1; i < al.size(); i++) {\n            if(al.get(i)<al.get(i-1)){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(2^n^ · n)*\n\n- space:*O(n)*\n\n#  排列\n\n##  🟡46.全排列\n\n> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1]\n> 输出：[[0,1],[1,0]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：[[1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 6`\n> - `-10 <= nums[i] <= 10`\n> - `nums` 中的所有整数 **互不相同**\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    boolean[] used;\n    public List<List<Integer>> permute(int[] nums) {\n        int len= nums.length;\n        if(len==0){\n            return res;\n        }\n        used=new boolean[len];\n        backtraking(nums);\n        return res;\n    }\n    void backtraking(int[]nums){\n        if(path.size()==nums.length){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if(used[i]){\n                continue;\n            }\n            path.add(nums[i]);\n            used[i]=true;\n            backtraking(nums);\n            path.removeLast();\n            used[i]=false;\n        }\n    }\n}\n```\n\n- time:*O(n!)*\n\n- space:*O(n)*\n\n## 🟡47. 全排列 II\n\n> 给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：\n> [[1,1,2],\n> [1,2,1],\n> [2,1,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 8`\n> - `-10 <= nums[i] <= 10`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    Set<String>set=new TreeSet<>();\n    boolean[] used;\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        int len= nums.length;\n        if(len==0){\n            return res;\n        }\n        used=new boolean[len];\n        backtraking(nums);\n        return res;\n    }\n    void backtraking(int[]nums){\n        if(path.size()==nums.length&&!set.contains(path.toString())){\n            res.add(new ArrayList<>(path));\n            set.add(path.toString());\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if(used[i]){\n                continue;\n            }\n            path.add(nums[i]);\n            used[i]=true;\n            backtraking(nums);\n            path.removeLast();\n            used[i]=false;\n        }\n    }\n}\n```\n\n- time:*O(n!)*\n\n- space:*O(n)*\n\n#  棋盘问题\n\n## 🔴51. N 皇后\n\n> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\n>\n> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。\n>\n> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。\n>\n> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\n>\n> ```\n> 输入：n = 4\n> 输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n> 解释：如上图所示，4 皇后问题存在两个不同的解法。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1\n> 输出：[[\"Q\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 9`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<String>> res=new ArrayList<>();\n    LinkedList<String> path=new LinkedList<>();\n    public List<List<String>> solveNQueens(int n) {\n        backtraking(0,n);\n        return res;\n    }\n    void backtraking(int start,int n){\n        if(path.size()==n){\n            res.add(new ArrayList<>(path));\n        }\n        for (int i = 0; i < n; i++) {\n            boolean flag=true;//\n            for (int j = 0; j < path.size(); j++) {\n                int index=path.get(j).indexOf('Q');\n                if(index==i){\n                    flag=false;\n                }\n                if(Math.abs(index-i)==Math.abs(j- path.size())){\n                    flag=false;\n                }\n            }\n            if(flag){\n                path.add(build(n,i));\n                backtraking(i+1,n);\n                path.removeLast();\n            }\n        }\n    }\n    String build(int n,int k){\n        StringBuilder sb=new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if(i==k){\n                sb.append(\"Q\");\n            }else{\n                sb.append(\".\");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n- time:*O(n!)*\n\n- space:*O(n)*\n\n## 🔴37. 解数独\n\n> 编写一个程序，通过填充空格来解决数独问题。\n>\n> 数独的解法需 **遵循如下规则**：\n>\n> 1. 数字 `1-9` 在每一行只能出现一次。\n> 2. 数字 `1-9` 在每一列只能出现一次。\n> 3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）\n>\n> 数独部分空格内已填入了数字，空白格用 `'.'` 表示。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](23-9-8-algorithm-backtraking/250px-sudoku-by-l2g-20050714svg.png)\n>\n> ```\n> 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n> 输出：[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n> 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：\n> ```\n>\n> ![img](23-9-8-algorithm-backtraking/250px-sudoku-by-l2g-20050714_solutionsvg.png)\n>\n> \n>\n> **提示：**\n>\n> - `board.length == 9`\n> - `board[i].length == 9`\n> - `board[i][j]` 是一位数字或者 `'.'`\n> - 题目数据 **保证** 输入数独仅有一个解\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 回溯\n>\n> 矩阵\n\n```java\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        backtraking(board);\n        return;\n    }\n    boolean backtraking(char[][] board){\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if(board[i][j]!='.'){\n                    continue;\n                }else{\n                    for (char k = '1'; k <= '9'; k++) {\n                        if(check(i,j,k,board)){\n                            board[i][j]=k;\n                            if(backtraking(board)){\n                                return true;\n                            }\n                            board[i][j]='.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    boolean check(int i,int j,char k,char[][] board){\n        for (int l = 0; l < 9; l++) {\n            if(board[i][l]==k){\n                return false;\n            }\n            if(board[l][j]==k){\n                return false;\n            }\n        }\n        int row=(i/3)*3,col=(j/3)*3;\n        for (int l = 0; l < 3; l++) {\n            for (int m = 0; m < 3; m++) {\n                if(board[row+l][col+m]==k){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(9^81^)*\n\n- space:*O(1)*\n\n\n# 其他\n\n## 🔴332. 重新安排行程\n\n> 给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\n>\n> 所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\n>\n> - 例如，行程 `[\"JFK\", \"LGA\"]` 与 `[\"JFK\", \"LGB\"]` 相比就更小，排序更靠前。\n>\n> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)\n>\n> ```\n> 输入：tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n> 输出：[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)\n>\n> ```\n> 输入：tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n> 输出：[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n> 解释：另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] ，但是它字典排序更大更靠后。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= tickets.length <= 300`\n> - `tickets[i].length == 2`\n> - `fromi.length == 3`\n> - `toi.length == 3`\n> - `fromi` 和 `toi` 由大写英文字母组成\n> - `fromi != toi`\n>\n> Related Topics\n>\n> 深度优先搜索\n>\n> 图\n>\n> 欧拉回路\n\n```java\n\n```\n\n","categories":["algorithm learning"]},{"title":"Tree & BiTree","url":"/2023/09/07/algorithm-tree&bitree/","content":"\n| 类型               | 做法                       | 题号                                    | 完成 |\n| ------------------ | -------------------------- | --------------------------------------- | ---- |\n| 二叉树的遍历       |                            | 🟢144. 二叉树的前序遍历                  | ✅    |\n|                    |                            | 🟢94. 二叉树的中序遍历                   | ✅    |\n|                    |                            | 🟢145. 二叉树的后序遍历                  | ✅    |\n|                    |                            | 🟡102. 二叉树的层序遍历                  | ✅    |\n|                    |                            | 🟡107.二叉树的层次遍历II                 | ✅    |\n|                    |                            | 🟡103. 二叉树的锯齿形层序遍历            | ✅    |\n|                    |                            | 🟡429.N叉树的层序遍历                    | ✅    |\n| 二叉树的构造与修改 |                            | 🟡105. 从前序与中序遍历序列构造二叉树    | ✅    |\n|                    |                            | 🟡106. 从中序与后序遍历序列构造二叉树    | ✅    |\n|                    |                            | 🟡889. 根据前序和后序遍历构造二叉树      |      |\n|                    |                            | 🟢226. 翻转二叉树                        | ✅    |\n|                    |                            | 🟢617. 合并二叉树                        | ✅    |\n| 二叉树的搜索问题   | 用DFS或BFS均可解决的问题   | 🟡513. 找树左下角的值                    | ✅    |\n|                    |                            | 🟡515. 在每个树行中找最大值              | ✅    |\n|                    |                            | 🟡623. 在二叉树中增加一行                | ✅    |\n|                    |                            | 🟡199. 二叉树的右视图                    | ✅    |\n|                    | 需要两次搜索才能解决的问题 | 🟡655. 输出二叉树                        |      |\n|                    |                            | 🟡865. 具有所有最深节点的最小子树        |      |\n|                    |                            | 🔴834. 树中距离之和                      |      |\n|                    |                            | 🟡1339. 分裂二叉树的最大乘积             |      |\n|                    |                            | 🟡863. 二叉树中所有距离为 K 的结点       |      |\n|                    |                            | 🟢101. 对称二叉树                        |      |\n|                    |                            | 🟢222. 完全二叉树的节点个数              |      |\n|                    |                            | 🟢404. 左叶子之和                        | ✅    |\n|                    |                            | 🟡 513. 找树左下角的值                   |      |\n| 二叉树的路径问题   | 自顶向下路径问题           | 🟢257. 二叉树的所有路径                  |      |\n|                    |                            | 🟡面试题04.12.求和路径                   |      |\n|                    |                            | 🟢112.路径总和                           |      |\n|                    |                            | 🟡437. 路径总和 III                      |      |\n|                    |                            | 🟡988. 从叶结点开始的最小字符串          |      |\n|                    | 非自顶向下路径问题         | 🔴124. 二叉树中的最大路径和              |      |\n|                    |                            | 🟡687. 最长同值路径                      |      |\n|                    |                            | 🟢543. 二叉树的直径                      |      |\n| 二叉树属性问题     |                            | 🟢104. 二叉树的最大深度                  |      |\n|                    |                            | 🟢111. 二叉树的最小深度                  |      |\n| 二叉树公共祖先问题 |                            | 🟡235. 二叉搜索树的最近公共祖先          |      |\n|                    |                            | 236.二叉树的最近公共祖先                |      |\n|                    |                            | 🔴1483. 树节点的第 K 个祖先              |      |\n| 二叉搜索树         |                            | 🟡98.验证二叉搜索树                      |      |\n|                    |                            | 🟡173. 二叉搜索树迭代器                  |      |\n|                    |                            | 🟡701. 二叉搜索树中的插入操作            |      |\n|                    |                            | 🟡669. 修剪二叉搜索树                    |      |\n|                    |                            | 🟡450. 删除二叉搜索树中的节点            |      |\n|                    |                            | 🟡230. 二叉搜索树中第K小的元素           |      |\n|                    |                            | 🟡235. 二叉搜索树的最近公共祖先          |      |\n|                    |                            | 🟢108.将有序数组转换为二叉搜索树         |      |\n|                    |                            | 🟢783. 二叉搜索树节点最小距离            |      |\n|                    |                            | 🟢538.把二叉搜索树转换为累加树           |      |\n|                    |                            | 🟡1038. 从二叉搜索树到更大和树           |      |\n| 平衡二叉树         |                            | 🟢110. 平衡二叉树                        |      |\n|                    |                            | 🟡109. 有序链表转换二叉搜索树            |      |\n|                    |                            | 🟡1382. 将二叉搜索树变平衡               |      |\n| 待定               |                            | 🟢637.二叉树的层平均值                   |      |\n|                    |                            | 🟢700.二叉搜索树中的搜索                 |      |\n|                    |                            | 🟢530.二叉搜索树的最小绝对差             |      |\n|                    |                            | 🟢501.二叉搜索树中的众数                 |      |\n|                    |                            | 🟡116.填充每个节点的下一个右侧节点指针   |      |\n|                    |                            | 🟡117.填充每个节点的下一个右侧节点指针II |      |\n|                    |                            | 🟡654.最大二叉树                         |      |\n\n#  二叉树的遍历\n\n## 🟢144. 二叉树的前序遍历 \n\n> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[1,2,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> **示例 4：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)\n>\n> ```\n> 输入：root = [1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 5：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)\n>\n> ```\n> 输入：root = [1,null,2]\n> 输出：[1,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶：**递归算法很简单，你可以通过迭代算法完成吗？\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        preOrder(res,root);\n        return res;        \n    }\n    void preOrder(List<Integer> list,TreeNode root){\n        if(root==null){\n            return;\n        }\n        list.add(root.val);\n        preOrder(list,root.left);\n        preOrder(list,root.right);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null)s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n                s.push(node);\n                s.push(null);\n            }else{\n                s.pop();\n                node=s.pop();\n                res.add(node.val);//\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢94. 二叉树的中序遍历\n\n> 给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[1,3,2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶:** 递归算法很简单，你可以通过迭代算法完成吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        inOrder(res,root);\n        return res;\n    }\n    void inOrder(List<Integer>list,TreeNode root){\n        if(root==null){\n            return;\n        }\n        inOrder(list,root.left);\n        list.add(root.val);\n        inOrder(list,root.right);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null){\n            s.push(root);\n        }\n        while(!s.empty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                s.push(node);\n                s.push(null);\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.peek();\n                s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢145. 二叉树的后序遍历 \n\n> 给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        postOrder(res,root);\n        return res;\n    }\n    void postOrder(List<Integer> res,TreeNode root){\n        if(root==null){\n            return;\n        }\n        postOrder(res,root.left);\n        postOrder(res,root.right);\n        res.add(root.val);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null){\n            s.push(root);\n        }\n        while(!s.empty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();                \n                s.push(node);\n                s.push(null);\n                if(node.right!=null){\n                    s.push(node.right);\n                }                \n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.peek();\n                s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡102. 二叉树的层序遍历 \n\n> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[3],[9,20],[15,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-1000 <= Node.val <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            List<Integer>list=new ArrayList<>();\n            while (size-->0){\n                TreeNode node=queue.poll();\n                list.add(node.val);\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡107.二叉树的层次遍历II\n\n> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[15,7],[9,20],[3]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-1000 <= Node.val <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> res=new ArrayList<>();\n        Queue<TreeNode> q=new LinkedList<>();\n        if(root==null){\n            return res;\n        }\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            List<Integer> l=new ArrayList<>();\n            while(len-->0){\n                TreeNode node=q.poll();\n                l.add(node.val);\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res.add(l);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n##  🟡103. 二叉树的锯齿形层序遍历\n\n> 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[3],[20,9],[15,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            List<Integer>list=new ArrayList<>();\n            while (size-->0){\n                TreeNode node=queue.poll();\n                list.add(node.val);\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            if(res.size()%2==1){\n                Collections.reverse(list);\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡429.N叉树的层序遍历\n\n> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。\n>\n> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n>\n> ```\n> 输入：root = [1,null,3,2,4,null,5,6]\n> 输出：[[1],[3,2,4],[5,6]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n>\n> ```\n> 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树的高度不会超过 `1000`\n> - 树的节点总数在 `[0, 10^4]` 之间\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res=new LinkedList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<Node>q=new LinkedList<>() ;\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            List<Integer>l=new LinkedList<>();\n            while(len-->0){\n                Node node=q.poll();\n                l.add(node.val);\n                List<Node> n=node.children;\n                for (int i = 0; i < n.size(); i++) {\n                    q.offer(n.get(i));\n                }\n            }\n            res.add(l);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n# 二叉树的构造与修改\n\n## 🟡105. 从前序与中序遍历序列构造二叉树 \n\n> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n>\n> ```\n> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n> 输出: [3,9,20,null,null,15,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: preorder = [-1], inorder = [-1]\n> 输出: [-1]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= preorder.length <= 3000`\n> - `inorder.length == preorder.length`\n> - `-3000 <= preorder[i], inorder[i] <= 3000`\n> - `preorder` 和 `inorder` 均 **无重复** 元素\n> - `inorder` 均出现在 `preorder`\n> - `preorder` **保证** 为二叉树的前序遍历序列\n> - `inorder` **保证** 为二叉树的中序遍历序列\n>\n> Related Topics\n>\n> 树\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 二叉树\n\n```java\nclass Solution {\n    int[]preOrder;\n    int[]inOrder;\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        preOrder=preorder;\n        inOrder=inorder;\n        int len= preOrder.length;\n        TreeNode res=new TreeNode(preOrder[0]);\n        recursion(res,0,0,len-1);\n        return res;\n    }\n    void recursion(TreeNode root,int base,int left,int right){\n        if(left>=right){\n            return;\n        }\n        int i=left;\n        while (i<right&&inOrder[i]!=preOrder[base]){\n            i++;\n        }\n        int left_cnt=i-left;\n        int right_cnt=right-i;\n        if(left_cnt>0){\n            root.left=new TreeNode(preOrder[base+1]);\n            recursion(root.left,base+1,left,i-1);\n        }\n        if(right_cnt>0){\n            root.right=new TreeNode(preOrder[base+1+left_cnt]);\n            recursion(root.right,base+1+left_cnt,i+1,right);\n        }\n\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡106. 从中序与后序遍历序列构造二叉树 \n\n> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n>\n> ```\n> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n> 输出：[3,9,20,null,null,15,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：inorder = [-1], postorder = [-1]\n> 输出：[-1]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= inorder.length <= 3000`\n> - `postorder.length == inorder.length`\n> - `-3000 <= inorder[i], postorder[i] <= 3000`\n> - `inorder` 和 `postorder` 都由 **不同** 的值组成\n> - `postorder` 中每一个值都在 `inorder` 中\n> - `inorder` **保证**是树的中序遍历\n> - `postorder` **保证**是树的后序遍历\n>\n> Related Topics\n>\n> 树\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 二叉树\n\n```java\nclass Solution {\n    int[]inOrder;\n    int[]postOrder;\n    int len;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        inOrder=inorder;\n        postOrder=postorder;\n        len= inorder.length;\n        TreeNode res=new TreeNode(postOrder[len-1]);\n        recursion(res,len-1,0,len-1);\n        return res;\n    }\n    void recursion(TreeNode root,int base,int left,int right){\n        if(root==null||left>=right){\n            return;\n        }\n        int i=left;\n        while (i<right&&inOrder[i]!=postOrder[base]){\n            i++;\n        }\n        int left_cnt=i-left;\n        int right_cnt=right-i;\n        if(left_cnt>0){\n            root.left=new TreeNode(postOrder[base-right_cnt-1]);\n            recursion(root.left,base-right_cnt-1,left,i-1);\n        }\n        if(right_cnt>0){\n            root.right=new TreeNode(postOrder[base-1]);\n            recursion(root.right,base-1,i+1,right);\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡889. 根据前序和后序遍历构造二叉树\n\n> 给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。\n>\n> 如果存在多个答案，您可以返回其中 **任何** 一个。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)\n>\n> ```\n> 输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n> 输出：[1,2,3,4,5,6,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: preorder = [1], postorder = [1]\n> 输出: [1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= preorder.length <= 30`\n> - `1 <= preorder[i] <= preorder.length`\n> - `preorder` 中所有值都 **不同**\n> - `postorder.length == preorder.length`\n> - `1 <= postorder[i] <= postorder.length`\n> - `postorder` 中所有值都 **不同**\n> - 保证 `preorder` 和 `postorder` 是同一棵二叉树的前序遍历和后序遍历\n>\n> Related Topics\n>\n> 树\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 二叉树\n\n```java\n```\n\n\n\n## 🟢226. 翻转二叉树\n\n> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3,6,9]\n> 输出：[4,7,2,9,6,3,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n>\n> ```\n> 输入：root = [2,1,3]\n> 输出：[2,3,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目范围在 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null){\n            return null;\n        }\n        if(root.left==null&&root.right==null){\n            return root;\n        } else if (root.left==null) {\n            root.left=root.right;\n            root.right=null;\n        } else if (root.right==null) {\n            root.right=root.left;\n            root.left=null;\n        }else {\n            TreeNode temp=root.left;\n            root.left=root.right;\n            root.right=temp;\n        }\n        invertTree(root.left);\n        invertTree(root.right);\n        return root;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢617. 合并二叉树\n\n> 给你两棵二叉树： `root1` 和 `root2` 。\n>\n> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。\n>\n> 返回合并后的二叉树。\n>\n> **注意:** 合并过程必须从两个树的根节点开始。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)\n>\n> ```\n> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n> 输出：[3,4,5,5,4,null,7]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root1 = [1], root2 = [1,2]\n> 输出：[2,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 两棵树中的节点数目在范围 `[0, 2000]` 内\n> - `-104 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        if(root1==null&&root2==null){\n            return null;\n        } else if (root1==null) {\n            return root2;\n        } else if (root2==null) {\n            return root1;\n        }else {\n            root1.val+=root2.val;\n            root1.left=mergeTrees(root1.left,root2.left);\n            root1.right=mergeTrees(root1.right,root2.right);\n            return root1;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n#  二叉树的搜索问题\n\n## 用DFS或BFS均可解决的问题： \n\n## 🟡513. 找树左下角的值 \n\n> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。\n>\n> 假设二叉树中至少有一个节点。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)\n>\n> ```\n> 输入: root = [2,1,3]\n> 输出: 1\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)\n>\n> ```\n> 输入: [1,2,3,4,null,5,6,null,null,7]\n> 输出: 7\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 二叉树的节点个数的范围是 `[1,104]`\n> - `-231 <= Node.val <= 231 - 1`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        int res=root.val;\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            res=queue.peek().val;\n            while (size-->0){\n                TreeNode node=queue.poll();\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    int max;\n    int res;\n    public int findBottomLeftValue(TreeNode root) {\n        max=1;\n        res=root.val;\n        preOrder(root,1);\n        return res;\n    }\n    void preOrder(TreeNode root,int depth){\n        if(root==null){\n            return;\n        }\n        if(depth>max){\n            max=depth;\n            res= root.val;\n        }\n        preOrder(root.left,depth+1);\n        preOrder(root.right,depth+1);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡515. 在每个树行中找最大值 \n\n> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。\n>\n> \n>\n> **示例1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)\n>\n> ```\n> 输入: root = [1,3,2,5,3,null,9]\n> 输出: [1,3,9]\n> ```\n>\n> **示例2：**\n>\n> ```\n> 输入: root = [1,2,3]\n> 输出: [1,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 二叉树的节点个数的范围是 `[0,104]`\n> - `-231 <= Node.val <= 231 - 1`\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode> queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            int max=queue.peek().val;\n            while (size-->0){\n                TreeNode node=queue.poll();\n                max=Math.max(max,node.val);\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            res.add(max);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡623. 在二叉树中增加一行 \n\n> 给定一个二叉树的根 `root` 和两个整数 `val` 和 `depth` ，在给定的深度 `depth` 处添加一个值为 `val` 的节点行。\n>\n> 注意，根节点 `root` 位于深度 `1` 。\n>\n> 加法规则如下:\n>\n> - 给定整数 `depth`，对于深度为 `depth - 1` 的每个非空树节点 `cur` ，创建两个值为 `val` 的树节点作为 `cur` 的左子树根和右子树根。\n> - `cur` 原来的左子树应该是新的左子树根的左子树。\n> - `cur` 原来的右子树应该是新的右子树根的右子树。\n> - 如果 `depth == 1 `意味着 `depth - 1` 根本没有深度，那么创建一个树节点，值 `val `作为整个原始树的新根，而原始树就是新根的左子树。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg)\n>\n> ```\n> 输入: root = [4,2,6,3,1,5], val = 1, depth = 2\n> 输出: [4,1,1,2,null,null,6,3,1,5]\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg)\n>\n> ```\n> 输入: root = [4,2,null,3,1], val = 1, depth = 3\n> 输出:  [4,2,null,1,1,3,null,null,1]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 节点数在 `[1, 104]` 范围内\n> - 树的深度在 `[1, 104]`范围内\n> - `-100 <= Node.val <= 100`\n> - `-105 <= val <= 105`\n> - `1 <= depth <= the depth of tree + 1`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\n        if(depth==1){\n            TreeNode new_root=new TreeNode(val);\n            new_root.left=root;\n            return new_root;\n        }\n        int cur_depth=0;\n        preOrder(root,val,depth,1);\n        return root;\n    }\n    void preOrder(TreeNode root, int val, int depth,int cur_depth){\n        if(root==null){\n            return;\n        }\n        if(cur_depth==depth-1){\n            TreeNode left=new TreeNode(val);\n            left.left=root.left;\n            root.left=left;\n            TreeNode right=new TreeNode(val);\n            right.right=root.right;\n            root.right=right;\n        }\n        preOrder(root.left,val,depth,cur_depth+1);\n        preOrder(root.right,val,depth,cur_depth+1);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)* \n\n## 🟡199. 二叉树的右视图 \n\n> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\n>\n> ```\n> 输入: [1,2,3,null,5,null,4]\n> 输出: [1,3,4]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: [1,null,3]\n> 输出: [1,3]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: []\n> 输出: []\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 二叉树的节点个数的范围是 `[0,100]`\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>queue=new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            int size=queue.size();\n            int element=queue.peek().val;\n            while (size-->0){\n                TreeNode node=queue.poll();\n                element=node.val;\n                if(node.left!=null){\n                    queue.offer(node.left);\n                }\n                if(node.right!=null){\n                    queue.offer(node.right);\n                }\n            }\n            res.add(element);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)* \n\n## 需要两次搜索才能解决的问题： \n\n## 🟡655. 输出二叉树 \n\n> 给你一棵二叉树的根节点 `root` ，请你构造一个下标从 **0** 开始、大小为 `m x n` 的字符串矩阵 `res` ，用以表示树的 **格式化布局** 。构造此格式化布局矩阵需要遵循以下规则：\n>\n> - 树的 **高度** 为 `height` ，矩阵的行数 `m` 应该等于 `height + 1` 。\n> - 矩阵的列数 `n` 应该等于 `2height+1 - 1` 。\n> - **根节点** 需要放置在 **顶行** 的 **正中间** ，对应位置为 `res[0][(n-1)/2]` 。\n> - 对于放置在矩阵中的每个节点，设对应位置为 `res[r][c]` ，将其左子节点放置在 `res[r+1][c-2height-r-1]` ，右子节点放置在 `res[r+1][c+2height-r-1]` 。\n> - 继续这一过程，直到树中的所有节点都妥善放置。\n> - 任意空单元格都应该包含空字符串 `\"\"` 。\n>\n> 返回构造得到的矩阵 `res` 。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg)\n>\n> ```\n> 输入：root = [1,2]\n> 输出：\n> [[\"\",\"1\",\"\"],\n>  [\"2\",\"\",\"\"]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg)\n>\n> ```\n> 输入：root = [1,2,3,null,4]\n> 输出：\n> [[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n>  [\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n>  [\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数在范围 `[1, 210]` 内\n> - `-99 <= Node.val <= 99`\n> - 树的深度在范围 `[1, 10]` 内\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\n```\n\n\n\n## 🟡865. 具有所有最深节点的最小子树 \n\n> 给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。\n>\n> 返回包含原始树中所有 **最深节点** 的 *最小子树* 。\n>\n> 如果一个节点在 **整个树** 的任意节点之间具有最大的深度，则该节点是 **最深的** 。\n>\n> 一个节点的 **子树** 是该节点加上它的所有后代的集合。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4]\n> 输出：[2,7,4]\n> 解释：\n> 我们返回值为 2 的节点，在图中用黄色标记。\n> 在图中用蓝色标记的是树的最深的节点。\n> 注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> 解释：根节点是树中最深的节点。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [0,1,3,null,2]\n> 输出：[2]\n> 解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数量在 `[1, 500]` 范围内。\n> - `0 <= Node.val <= 500`\n> - 每个节点的值都是 **独一无二** 的。\n>\n> \n>\n> **注意：**本题与力扣 1123 重复：[https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves](https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/)\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 哈希表\n>\n> 二叉树\n\n```java\n```\n\n\n\n## 🔴834. 树中距离之和 \n\n## 🟡1339. 分裂二叉树的最大乘积 \n\n## 🟡863. 二叉树中所有距离为 K 的结点 \n\n## 🟢101. 对称二叉树 \n\n## 🟢222. 完全二叉树的节点个数 \n\n## 🟢404. 左叶子之和 \n\n> 给定二叉树的根节点 `root` ，返回所有左叶子之和。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)\n>\n> ```\n> 输入: root = [3,9,20,null,null,15,7] \n> 输出: 24 \n> 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: root = [1]\n> 输出: 0\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 节点数在 `[1, 1000]` 范围内\n> - `-1000 <= Node.val <= 1000`\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    int sum = 0;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        dfs(root);\n        return sum;\n    }\n\n    void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        if (root.left != null) {\n            if (root.left.left == null && root.left.right == null) {\n                sum += root.left.val;\n            }\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            dfs(root.right);\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡 513. 找树左下角的值\n\n#  二叉树的路径问题\n\n##  自顶向下路径问题：\n\n## 🟢257. 二叉树的所有路径 \n\n## 🟡面试题04.12.求和路径 \n\n## 🟢112.路径总和 \n\n## 🟡437. 路径总和 III \n\n## 🟡988. 从叶结点开始的最小字符串 \n\n##  非自顶向下路径问题：\n\n## 🔴124. 二叉树中的最大路径和 \n\n## 🟡687. 最长同值路径 \n\n## 🟢543. 二叉树的直径\n\n#  二叉树属性问题\n\n## 🟢104. 二叉树的最大深度 \n\n## 🟢111. 二叉树的最小深度 \n\n#  二叉树公共祖先问题\n\n## 🟡235. 二叉搜索树的最近公共祖先 \n\n## 🟡236.二叉树的最近公共祖先\n\n> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n> 输出：3\n> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n> 输出：5\n> 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1,2], p = 1, q = 2\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[2, 105]` 内。\n> - `-109 <= Node.val <= 109`\n> - 所有 `Node.val` `互不相同` 。\n> - `p != q`\n> - `p` 和 `q` 均存在于给定的二叉树中。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    static LinkedList<TreeNode> l=new LinkedList<>();\n    static LinkedList<TreeNode> l1,l2;\n    static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        l.add(root);\n        backTracking(root,p,0);\n        backTracking(root,q,1);\n        int index=0;\n        while(index< l1.size()&&index<l2.size()&&l1.get(index)==l2.get(index)){\n            index++;\n        }\n        return l1.get(index-1);\n    }\n    static void backTracking(TreeNode root, TreeNode node,int num){\n        if(root==node){\n            if(num==0){\n                l1= (LinkedList) l.clone();\n            }else{\n                l2= (LinkedList) l.clone();\n            }\n            return;\n        }\n        if(root.left!=null){\n            l.add(root.left);\n            backTracking(root.left,node,num);\n            l.removeLast();\n        }\n        if(root.right!=null){\n            l.add(root.right);\n            backTracking(root.right,node,num);\n            l.removeLast();\n        }\n    }\n}\n```\n\n\n\n## 🔴1483. 树节点的第 K 个祖先\n\n#  二叉搜索树\n\n##  🟡98.验证二叉搜索树\n\n## 🟡173. 二叉搜索树迭代器 \n\n## 🟡701. 二叉搜索树中的插入操作\n\n## 🟡669. 修剪二叉搜索树\n\n## 🟡450. 删除二叉搜索树中的节点 \n\n## 🟡230. 二叉搜索树中第K小的元素 \n\n## 🟡235. 二叉搜索树的最近公共祖先 \n\n##  🟢108.将有序数组转换为二叉搜索树\n\n## 🟢783. 二叉搜索树节点最小距离 \n\n##  🟢538.把二叉搜索树转换为累加树\n\n## 🟡1038. 从二叉搜索树到更大和树\n\n#  平衡二叉树\n\n## 🟢110. 平衡二叉树 \n\n## 🟡109. 有序链表转换二叉搜索树 \n\n## 🟡1382. 将二叉搜索树变平衡\n\n# 待定\n\n##  🟢637.二叉树的层平均值\n\n> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[3.00000,14.50000,11.00000]\n> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n> 因此返回 [3, 14.5, 11] 。\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)\n>\n> ```\n> 输入：root = [3,9,20,15,7]\n> 输出：[3.00000,14.50000,11.00000]\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - 树中节点数量在 `[1, 104]` 范围内\n> - `-231 <= Node.val <= 231 - 1`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            double sum=0,cnt=len;\n            while(len-->0){\n                TreeNode node=q.poll();\n                sum+=node.val;\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res.add(sum/cnt);\n        }\n        return res;\n    }\n}\n```\n\n\n\n\n\n##  🟢700.二叉搜索树中的搜索\n\n> 给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。\n>\n> 你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3], val = 2\n> 输出：[2,1,3]\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3], val = 5\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 数中节点数在 `[1, 5000]` 范围内\n> - `1 <= Node.val <= 107`\n> - `root` 是二叉搜索树\n> - `1 <= val <= 107`\n>\n> Related Topics\n>\n> 树\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root==null||root.val==val){\n            return root;\n        }\n        if(val<root.val){\n            return searchBST(root.left, val);\n        }else{\n            return searchBST(root.right, val);\n        }\n    }\n}\n```\n\n##  🟢530.二叉搜索树的最小绝对差\n\n> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。\n>\n> 差值是一个正数，其数值等于两值之差的绝对值。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)\n>\n> ```\n> 输入：root = [4,2,6,1,3]\n> 输出：1\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)\n>\n> ```\n> 输入：root = [1,0,48,null,null,12,49]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目范围是 `[2, 104]`\n> - `0 <= Node.val <= 105`\n>\n> \n>\n> **注意：**本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int getMinimumDifference(TreeNode root) {\n        int res=Integer.MAX_VALUE;\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        int last=root.val;\n        TreeNode p=root;\n        while(p.left!=null){\n            p=p.left;\n        }\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                s.push(node);\n                s.push(null);\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.pop();\n                if(Math.abs(last- node.val)<res&&Math.abs(last- node.val)!=0){\n                    res=Math.abs(last- node.val);\n                }\n                last= node.val;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟢501.二叉搜索树中的众数\n\n> 给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。\n>\n> 如果树中有不止一个众数，可以按 **任意顺序** 返回。\n>\n> 假定 BST 满足如下定义：\n>\n> - 结点左子树中所含节点的值 **小于等于** 当前节点的值\n> - 结点右子树中所含节点的值 **大于等于** 当前节点的值\n> - 左子树和右子树都是二叉搜索树\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)\n>\n> ```\n> 输入：root = [1,null,2,2]\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [0]\n> 输出：[0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[1, 104]` 内\n> - `-105 <= Node.val <= 105`\n>\n> \n>\n> **进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int[] findMode(TreeNode root) {\n        List<Integer>al=new ArrayList<>();\n        Map<Integer,Integer>map=new HashMap<>();\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            map.put(node.val,map.getOrDefault(node.val,0)+1);\n            if(node.right!=null){\n                s.push(node.right);\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n        }\n        int max=Collections.max(map.values());\n        Iterator it=map.entrySet().iterator();\n        while(it.hasNext()){\n            Map.Entry entry=(Map.Entry) it.next();\n            if((int) entry.getValue()==max){\n                al.add((int) entry.getKey());\n            }\n        }\n        int len=al.size();\n        int[]res=new int[len];\n        for (int i = 0; i < len; i++) {\n            res[i]=al.get(i);\n        }\n        return res;\n    }\n}\n```\n\n## 🟡116.填充每个节点的下一个右侧节点指针\n\n> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n>\n> ```\n> struct Node {\n> int val;\n> Node *left;\n> Node *right;\n> Node *next;\n> }\n> ```\n>\n> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。\n>\n> 初始状态下，所有 next 指针都被设置为 `NULL`。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)\n>\n> ```\n> 输入：root = [1,2,3,4,5,6,7]\n> 输出：[1,#,2,3,#,4,5,6,7,#]\n> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n> ```\n>\n> \n>\n> **示例 2:**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数量在 `[0, 212 - 1]` 范围内\n> - `-1000 <= node.val <= 1000`\n>\n> \n>\n> **进阶：**\n>\n> - 你只能使用常量级额外空间。\n> - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 链表\n>\n> 二叉树\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null){\n            return root;\n        }\n        root.next=null;\n        Queue<Node>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->1){\n                Node node=q.poll();\n                node.next=q.peek();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }                \n            }\n            Node node=q.poll();\n            node.next=null;\n            if(node.left!=null){\n                q.offer(node.left);\n            }\n            if(node.right!=null){\n                q.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n\n\n## 🟡117.填充每个节点的下一个右侧节点指针II\n\n> 给定一个二叉树：\n>\n> ```\n> struct Node {\n> int val;\n> Node *left;\n> Node *right;\n> Node *next;\n> }\n> ```\n>\n> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。\n>\n> 初始状态下，所有 next 指针都被设置为 `NULL` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)\n>\n> ```\n> 输入：root = [1,2,3,4,5,null,7]\n> 输出：[1,#,2,3,#,4,5,7,#]\n> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中的节点数在范围 `[0, 6000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> **进阶：**\n>\n> - 你只能使用常量级额外空间。\n> - 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 链表\n>\n> 二叉树\n\n同上一题的代码,一字没动.\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null){\n            return root;\n        }\n        root.next=null;\n        Queue<Node>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->1){\n                Node node=q.poll();\n                node.next=q.peek();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }                \n            }\n            Node node=q.poll();\n            node.next=null;\n            if(node.left!=null){\n                q.offer(node.left);\n            }\n            if(node.right!=null){\n                q.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n##  🟡654.最大二叉树\n\n> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:\n>\n> 1. 创建一个根节点，其值为 `nums` 中的最大值。\n> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。\n> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。\n>\n> 返回 *`nums` 构建的* ***最大二叉树\\*** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)\n>\n> ```\n> 输入：nums = [3,2,1,6,0,5]\n> 输出：[6,3,5,null,2,0,null,null,1]\n> 解释：递归调用如下所示：\n> - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n>     - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n>         - 空数组，无子节点。\n>         - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n>             - 空数组，无子节点。\n>             - 只有一个元素，所以子节点是一个值为 1 的节点。\n>     - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n>         - 只有一个元素，所以子节点是一个值为 0 的节点。\n>         - 空数组，无子节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)\n>\n> ```\n> 输入：nums = [3,2,1]\n> 输出：[3,null,2,null,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `0 <= nums[i] <= 1000`\n> - `nums` 中的所有整数 **互不相同**\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 数组\n>\n> 分治\n>\n> 二叉树\n>\n> 单调栈\n\n```java\nclass Solution {\n    TreeNode res;\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        res=new TreeNode(nums[getMaxIndex(nums,0, nums.length-1)]);\n        dfs(res,nums,0,nums.length-1,getMaxIndex(nums,0, nums.length-1));\n        return res;\n    }\n    void dfs(TreeNode node,int[] arr,int from,int to,int index){\n        if(from<index){\n            node.left=new TreeNode(arr[getMaxIndex(arr,from,index-1)]);\n        }\n        if(index<to){\n            node.right=new TreeNode(arr[getMaxIndex(arr,index+1,to)]);\n        }\n        if(node.left!=null){\n            dfs(node.left,arr,from,index-1,getMaxIndex(arr,from,index-1));\n        }\n        if(node.right!=null){\n            dfs(node.right,arr,index+1,to,getMaxIndex(arr,index+1,to));\n        }\n    }\n    int getMaxIndex(int[]arr,int i,int j){\n        if(i==j){\n            return i;\n        }\n        int maxindex=i;\n        for (int k = i+1; k <= j; k++) {\n            if(arr[maxindex]<arr[k]){\n                maxindex=k;\n            }\n        }\n        return maxindex;\n    }\n}\n```\n\n","categories":["algorithm learning"]},{"title":"Stack & Queue","url":"/2023/09/06/algorithm-stack&queue/","content":"\n| 类型                 | 题号                                   | 完成 |\n| -------------------- | -------------------------------------- | ---- |\n| 栈的实现             | 🟢232. 用栈实现队列                     | ✅    |\n|                      | 🟢225. 用队列实现栈                     | ✅    |\n|                      | 🟢面试题 03.01. 三合一                  | ✅    |\n|                      | 🟡1441. 用栈操作构建数组                | ✅    |\n| 单调栈               | 🟢496. 下一个更大元素 I                 |      |\n|                      | 🔴84. 柱状图中最大的矩形                |      |\n|                      | 🟡739. 每日温度                         |      |\n|                      | 🟡901. 股票价格跨度                     |      |\n|                      | 🔴42. 接雨水                            |      |\n| 最小/大栈            | 🟢面试题 03.02. 栈的最小值              | ✅    |\n|                      | 🔴716. 最大栈                           |      |\n| 字符串去重问题       | 🟡316.去除重复字母                      |      |\n|                      | 🟢1047. 删除字符串中的所有相邻重复项    | ✅    |\n|                      | 🟡1209. 删除字符串中的所有相邻重复项 II |      |\n|                      | 🟡1081.不同字符的最小子序列             |      |\n| 栈与括号匹配         | 🟢20. 有效的括号                        | ✅    |\n|                      | 🟡636. 函数的独占时间                   |      |\n|                      | 🔴591. 标签验证器                       |      |\n|                      | 🔴32. 最长有效括号                      |      |\n| 表达式求值           | 🟡150. 逆波兰表达式求值                 |      |\n|                      | 🔴224. 基本计算器                       |      |\n|                      | 🟡227. 基本计算器 II                    |      |\n|                      | 🔴772. 基本计算器 III                   |      |\n|                      | 🔴770. 基本计算器 IV                    |      |\n| 用栈访问最后若干元素 | 🟢682. 棒球比赛                         |      |\n|                      | 🟡71. 简化路径                          |      |\n|                      | 🟡388. 文件的最长绝对路径               |      |\n| 递归                 | 🟡385. 迷你语法分析器                   |      |\n|                      | 🟡341. 扁平化嵌套列表迭代器             |      |\n|                      | 🟡394. 字符串解码                       |      |\n| 滑动窗口最大值问题   | 🔴239. 滑动窗口最大值                   |      |\n| 求前 K 个高频元素    | 🟡347. 前K个高频元素                    |      |\n|                      | 🟡692. 前K个高频单词                    |      |\n\n#  栈的实现\n\n## 🟢232. 用栈实现队列 \n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n>\n> 实现 `MyQueue` 类：\n>\n> - `void push(int x)` 将元素 x 推到队列的末尾\n> - `int pop()` 从队列的开头移除并返回元素\n> - `int peek()` 返回队列开头的元素\n> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n>\n> **说明：**\n>\n> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> \n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\n>\n> \n>\n> **进阶：**\n>\n> - 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyQueue {\n    Stack<Integer>in;\n    Stack<Integer>out;\n    public MyQueue() {\n        this.in=new Stack<>();\n        this.out=new Stack<>();\n    }\n    \n    public void push(int x) {\n        this.in.push(x);\n    }\n    \n    public int pop() {\n        in2out();\n        int temp=this.out.pop();\n        out2in();\n        return temp;\n    }\n    \n    public int peek() {\n        in2out();\n        int temp=this.out.peek();\n        out2in();\n        return temp;\n    }\n    \n    public boolean empty() {\n        return this.in.isEmpty();\n    }\n    void in2out(){\n        while (!this.in.isEmpty()){\n            this.out.push(this.in.pop());\n        }\n    }\n    void out2in(){\n        while (!this.out.isEmpty()){\n            this.in.push(this.out.pop());\n        }\n    }\n}\n```\n\n\n\n## 🟢225. 用队列实现栈\n\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n>\n> 实现 `MyStack` 类：\n>\n> - `void push(int x)` 将元素 x 压入栈顶。\n> - `int pop()` 移除并返回栈顶元素。\n> - `int top()` 返回栈顶元素。\n> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **注意：**\n>\n> - 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。\n> - 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 2, 2, false]\n> \n> 解释：\n> MyStack myStack = new MyStack();\n> myStack.push(1);\n> myStack.push(2);\n> myStack.top(); // 返回 2\n> myStack.pop(); // 返回 2\n> myStack.empty(); // 返回 False\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`\n> - 每次调用 `pop` 和 `top` 都保证栈不为空\n>\n> \n>\n> **进阶：**你能否仅用一个队列来实现栈。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyStack {\n    Queue<Integer> in;\n    Queue<Integer>out;\n    public MyStack() {\n        this.in=new LinkedList<>();\n        this.out=new LinkedList<>();\n    }\n\n    public void push(int x) {\n        this.in.offer(x);\n    }\n\n    public int pop() {\n        int temp=this.in.peek();\n        while (!this.in.isEmpty()){\n            temp=this.in.peek();\n            if(this.in.size()==1){\n                this.in.poll();\n            }else {\n                this.out.offer(this.in.poll());\n            }\n        }\n        while (!this.out.isEmpty()){\n            this.in.offer(this.out.poll());\n        }\n        return temp;\n    }\n\n    public int top() {\n        int temp=this.in.peek();\n        while (!this.in.isEmpty()){\n            temp=this.in.peek();\n            this.out.offer(this.in.poll());\n        }\n        while (!this.out.isEmpty()){\n            this.in.offer(this.out.poll());\n        }\n        return temp;\n    }\n\n    public boolean empty() {\n        return this.in.isEmpty();\n    }\n\n}\n```\n\n\n\n## 🟢面试题 03.01. 三合一 \n\n> 三合一。描述如何只用一个数组来实现三个栈。\n>\n> 你应该实现`push(stackNum, value)`、`pop(stackNum)`、`isEmpty(stackNum)`、`peek(stackNum)`方法。`stackNum`表示栈下标，`value`表示压入的值。\n>\n> 构造函数会传入一个`stackSize`参数，代表每个栈的大小。\n>\n> **示例1:**\n>\n> ```\n>  输入：\n> [\"TripleInOne\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"isEmpty\"]\n> [[1], [0, 1], [0, 2], [0], [0], [0], [0]]\n>  输出：\n> [null, null, null, 1, -1, -1, true]\n> 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。\n> ```\n>\n> **示例2:**\n>\n> ```\n>  输入：\n> [\"TripleInOne\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"peek\"]\n> [[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]\n>  输出：\n> [null, null, null, null, 2, 1, -1, -1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= stackNum <= 2`\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 数组\n\n```java\nclass TripleInOne {\n    int[][]stack;\n    int[]size;\n    public TripleInOne(int stackSize) {\n        this.stack=new int[3][stackSize];\n        this.size=new int[3];\n    }\n    \n    public void push(int stackNum, int value) {\n        if(size[stackNum]<this.stack[stackNum].length){\n            this.stack[stackNum][size[stackNum]]=value;\n            this.size[stackNum]++;\n        }\n    }\n    \n    public int pop(int stackNum) {\n        if(this.size[stackNum]>0){\n            this.size[stackNum]--;\n            return this.stack[stackNum][this.size[stackNum]];\n        }else {\n            return -1;\n        }\n    }\n    \n    public int peek(int stackNum) {\n        if(this.size[stackNum]>0){\n            return this.stack[stackNum][this.size[stackNum]-1];\n        }else {\n            return -1;\n        }\n    }\n    \n    public boolean isEmpty(int stackNum) {\n        return this.size[stackNum]==0;\n    }\n}\n```\n\n\n\n## 🟡1441. 用栈操作构建数组\n\n> 给你一个数组 `target` 和一个整数 `n`。每次迭代，需要从 `list = { 1 , 2 , 3 ..., n }` 中依次读取一个数字。\n>\n> 请使用下述操作来构建目标数组 `target` ：\n>\n> - `\"Push\"`：从 `list` 中读取一个新元素， 并将其推入数组中。\n> - `\"Pop\"`：删除数组中的最后一个元素。\n> - 如果目标数组构建完成，就停止读取更多元素。\n>\n> 题目数据保证目标数组严格递增，并且只包含 `1` 到 `n` 之间的数字。\n>\n> 请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：target = [1,3], n = 3\n> 输出：[\"Push\",\"Push\",\"Pop\",\"Push\"]\n> 解释： \n> 读取 1 并自动推入数组 -> [1]\n> 读取 2 并自动推入数组，然后删除它 -> [1]\n> 读取 3 并自动推入数组 -> [1,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：target = [1,2,3], n = 3\n> 输出：[\"Push\",\"Push\",\"Push\"]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：target = [1,2], n = 4\n> 输出：[\"Push\",\"Push\"]\n> 解释：只需要读取前 2 个数字就可以停止。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= target.length <= 100`\n> - `1 <= n <= 100`\n> - `1 <= target[i] <= n`\n> - `target` 严格递增\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 模拟\n\n```java\nclass Solution {\n    public List<String> buildArray(int[] target, int n) {\n        List<String> res=new ArrayList<>();\n        int num=1;\n        for (int i = 0; i <target.length ; i++) {\n            if(target[i]==num){\n                res.add(\"Push\");\n            }else {\n                for (int j = 0; j < target[i]-num; j++) {\n                    res.add(\"Push\");\n                    res.add(\"Pop\");\n                }\n                res.add(\"Push\");\n            }\n            num=target[i]+1;\n        }\n        return res;\n    }\n}\n```\n\n\n\n#  单调栈\n\n## 🟢496. 下一个更大元素 I \n\n## 🔴84. 柱状图中最大的矩形\n\n## 🟡739. 每日温度 \n\n## 🟡901. 股票价格跨度 \n\n## 🔴42. 接雨水\n\n#  最小/大栈\t\n\n## 🟢面试题 03.02. 栈的最小值 \n\n> 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。\n>\n> \n>\n> **示例：**\n>\n> ```\n> MinStack minStack = new MinStack();\n> minStack.push(-2);\n> minStack.push(0);\n> minStack.push(-3);\n> minStack.getMin();   --> 返回 -3.\n> minStack.pop();\n> minStack.top(); --> 返回 0.\n> minStack.getMin(); --> 返回 -2.\n> ```\n>\n> \n>\n> \n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n\n```java\nclass MinStack {\n    Stack<Integer>stack;\n    int min;\n\n    /** initialize your data structure here. */\n    public MinStack() {\n        stack=new Stack<>();\n        min=Integer.MAX_VALUE;\n    }\n    \n    public void push(int x) {\n        this.min=Math.min(this.min,x);\n        this.stack.push(x);\n    }\n    \n    public void pop() {\n        if(this.stack.peek()==this.min){\n            int new_min=Integer.MAX_VALUE;\n            this.stack.pop();\n            Stack<Integer>temp=(Stack<Integer>)this.stack.clone();\n            while (!temp.isEmpty()){\n                new_min=Math.min(new_min,temp.pop());\n            }\n            this.min=new_min;\n        }else {\n            this.stack.pop();\n        }\n\n    }\n    \n    public int top() {\n        return this.stack.peek();\n    }\n    \n    public int getMin() {\n        return this.min;\n    }\n}\n```\n\n\n\n## 🔴716. 最大栈\n\n#  字符串去重问题\n\n## 🟡316.去除重复字母 \n\n> 给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"bcabc\"\n> 输出：\"abc\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"cbacdcbc\"\n> 输出：\"acdb\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 由小写英文字母组成\n>\n> \n>\n> **注意：**该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同\n>\n> Related Topics\n>\n> 栈\n>\n> 贪心\n>\n> 字符串\n>\n> 单调栈\n\n```java\n```\n\n\n\n## 🟢1047. 删除字符串中的所有相邻重复项\n\n> 给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。\n>\n> 在 S 上反复执行重复项删除操作，直到无法继续删除。\n>\n> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\"abbaca\"\n> 输出：\"ca\"\n> 解释：\n> 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> 1. `1 <= S.length <= 20000`\n> 2. `S` 仅由小写英文字母组成。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        Stack<Character>stack=new Stack<>();\n        stack.push(s.charAt(0));\n        for (int i = 1; i < s.length(); i++) {\n            if(!stack.isEmpty()&&stack.peek()==s.charAt(i)){\n                stack.pop();\n            }else {\n                stack.push(s.charAt(i));\n            }\n        }\n        String res=\"\";\n        for (int i = 0; i < stack.size(); i++) {\n            res+=stack.get(i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟡1209. 删除字符串中的所有相邻重复项 II \n\n> 给你一个字符串 `s`，「`k` 倍重复项删除操作」将会从 `s` 中选择 `k` 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。\n>\n> 你需要对 `s` 重复进行无限次这样的删除操作，直到无法继续为止。\n>\n> 在执行完所有删除操作后，返回最终得到的字符串。\n>\n> 本题答案保证唯一。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abcd\", k = 2\n> 输出：\"abcd\"\n> 解释：没有要删除的内容。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"deeedbbcccbdaa\", k = 3\n> 输出：\"aa\"\n> 解释： \n> 先删除 \"eee\" 和 \"ccc\"，得到 \"ddbbbdaa\"\n> 再删除 \"bbb\"，得到 \"dddaa\"\n> 最后删除 \"ddd\"，得到 \"aa\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"pbbcggttciiippooaais\", k = 2\n> 输出：\"ps\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 10^5`\n> - `2 <= k <= 10^4`\n> - `s` 中只含有小写英文字母。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\n```\n\n\n\n##  🟡1081.不同字符的最小子序列\n\n> \n\n#  栈与括号匹配\n\n## 🟢20. 有效的括号 \n\n> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n>\n> 有效字符串需满足：\n>\n> 1. 左括号必须用相同类型的右括号闭合。\n> 2. 左括号必须以正确的顺序闭合。\n> 3. 每个右括号都有一个对应的相同类型的左括号。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"()\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"()[]{}\"\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"(]\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅由括号 `'()[]{}'` 组成\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character>stack=new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{'){\n                stack.push(s.charAt(i));\n            }else if(!stack.isEmpty()){\n                if(stack.peek()=='('&&s.charAt(i)==')'\n                ||stack.peek()=='['&&s.charAt(i)==']'\n                ||stack.peek()=='{'&&s.charAt(i)=='}'){\n                    stack.pop();\n                }else {\n                    return false;\n                }\n            }else {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n\n\n## 🟡636. 函数的独占时间 \n\n> 有一个 **单线程** CPU 正在运行一个含有 `n` 道函数的程序。每道函数都有一个位于 `0` 和 `n-1` 之间的唯一标识符。\n>\n> 函数调用 **存储在一个 [调用栈](https://baike.baidu.com/item/调用栈/22718047?fr=aladdin) 上** ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 **当前正在执行的函数** 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。\n>\n> 给你一个由日志组成的列表 `logs` ，其中 `logs[i]` 表示第 `i` 条日志消息，该消息是一个按 `\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"` 进行格式化的字符串。例如，`\"0:start:3\"` 意味着标识符为 `0` 的函数调用在时间戳 `3` 的 **起始开始执行** ；而 `\"1:end:2\"` 意味着标识符为 `1` 的函数调用在时间戳 `2` 的 **末尾结束执行**。注意，函数可以 **调用多次，可能存在递归调用** 。\n>\n> 函数的 **独占时间** 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 `2` 单位时间，另一次调用执行 `1` 单位时间，那么该函数的 **独占时间** 为 `2 + 1 = 3` 。\n>\n> 以数组形式返回每个函数的 **独占时间** ，其中第 `i` 个下标对应的值表示标识符 `i` 的函数的独占时间。\n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/04/05/diag1b.png)\n>\n> ```\n> 输入：n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n> 输出：[3,4]\n> 解释：\n> 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 \n> 函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 \n> 函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 \n> 所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n> 输出：[8]\n> 解释：\n> 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n> 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n> 函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n> 函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n> 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n> 所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n> 输出：[7,1]\n> 解释：\n> 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n> 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n> 函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n> 函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n> 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n> 所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 \n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\n> 输出：[8,1]\n> ```\n>\n> **示例 5：**\n>\n> ```\n> 输入：n = 1, logs = [\"0:start:0\",\"0:end:0\"]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 100`\n> - `1 <= logs.length <= 500`\n> - `0 <= function_id < n`\n> - `0 <= timestamp <= 109`\n> - 两个开始事件不会在同一时间戳发生\n> - 两个结束事件不会在同一时间戳发生\n> - 每道函数都有一个对应 `\"start\"` 日志的 `\"end\"` 日志\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n\n```java\n\n```\n\n\n\n## 🔴591. 标签验证器 \n\n## 🔴32. 最长有效括号\n\n#  表达式求值\n\n## 🟡150. 逆波兰表达式求值\n\n## 🔴224. 基本计算器\n\n## 🟡227. 基本计算器 II \n\n## 🔴772. 基本计算器 III \n\n## 🔴770. 基本计算器 IV\n\n#  用栈访问最后若干元素\n\n## 🟢682. 棒球比赛 \n\n## 🟡71. 简化路径 \n\n##  🟡388. 文件的最长绝对路径\n\n#  递归\n\n## 🟡385. 迷你语法分析器 \n\n##  🟡341. 扁平化嵌套列表迭代器\n\n## 🟡394. 字符串解码\n\n#  滑动窗口最大值问题\n\n## 🔴239. 滑动窗口最大值\n\n# 求前 K 个高频元素\n\n## 🟡347. 前K个高频元素 \n\n## 🟡692. 前K个高频单词\n\n\n\n","categories":["algorithm learning"]},{"title":"Two Pointers","url":"/2023/09/05/algorithm-twopointers/","content":"\n| 类型         | 题号                             | 完成 |\n| ------------ | -------------------------------- | ---- |\n| 对撞指针问题 | 🟢1. 两数之和                     | ✅    |\n|              | 🟢 344. 反转字符串                | ✅    |\n|              | 🟢345. 反转字符串中的元音字母     | ✅    |\n|              | 🟢125. 验证回文串                 | ✅    |\n|              | 🟡11. 盛最多水的容器              | ✅    |\n|              | 🟡15. 三数之和                    | ✅    |\n|              | 🟡18. 四数之和                    | ✅    |\n|              | 🟡167. 两数之和 II - 输入有序数组 | ✅    |\n|              | 🟢88. 合并两个有序数组            | ✅    |\n|              | 🟢283. 移动零                     | ✅    |\n|              | 🟢 27. 移除元素                   | ✅    |\n|              | 🟢455. 分发饼干                   | ✅    |\n|              | 🟢561. 数组拆分                   | ✅    |\n|              | 🟢9. 回文数                       | ✅    |\n| 快慢指针问题 | 🟢876. 链表的中间结点             | ✅    |\n|              | 🟢206. 反转链表                   | ✅    |\n|              | 🟡19. 删除链表的倒数第 N 个结点   | ✅    |\n|              | 🟢141. 环形链表                   | ✅    |\n|              | 🟡142. 环形链表 II                | ✅    |\n|              | 🟢21. 合并两个有序链表            | ✅    |\n|              | 🟢26. 删除有序数组中的重复项      | ✅    |\n|              | 🟢83. 删除排序链表中的重复元素    | ✅    |\n|              | 🟡82. 删除排序链表中的重复元素 II |      |\n|              | 🟡86. 分隔链表                    |      |\n|              | 🟢234. 回文链表                   |      |\n| 滑动窗口问题 | 🟡209. 长度最小的子数组           |      |\n|              | 🟡5. 最长回文子串                 |      |\n|              | 🔴76. 最小覆盖子串                |      |\n|              | 🟡80. 删除有序数组中的重复项 II   |      |\n|              | 🟡457. 环形数组是否存在循环       |      |\n|              | 🟡718. 最长重复子数组             |      |\n| 其它         | 🟢977. 有序数组的平方             | ✅    |\n|              | 🟢344. 反转字符串                 | ✅    |\n|              | 🟢LCR 122. 路径加密               | ✅    |\n|              | 🟡151. 反转字符串中的单词         | ✅    |\n|              | 🟢面试题 02.07. 链表相交          | ✅    |\n\n#  对撞指针问题\n\n## 🟢1. 两数之和 \n\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n>\n> 你可以按任意顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,4], target = 6\n> 输出：[1,2]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,3], target = 6\n> 输出：[0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 104`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n> - **只会存在一个有效答案**\n>\n> \n>\n> **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[]arr=nums.clone();\n        Arrays.sort(arr);\n        int i=0,j= nums.length-1;\n        while (i<j){\n            int sum=arr[i]+arr[j];\n            if(sum<target){\n                i++;\n            }else if(sum>target){\n                j--;\n            }else {\n                int k=findIndex(nums,arr[i],0);\n                int l=findIndex(nums,arr[j],1);\n                return new int[]{k,l};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    int findIndex(int[]arr,int target,int flag){\n        if(flag==0){\n            for (int i = 0; i < arr.length; i++) {\n                if(arr[i]==target){\n                    return i;\n                }\n            }\n        }else {\n            for (int i = arr.length-1; i >= 0; i--) {\n                if(arr[i]==target){\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n\n- time:*O(n^2^)*      这道题出现在这里很奇怪😅\n- space:*O(n)*\n\n## 🟢 344. 反转字符串 \n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n>\n> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int i=0,j=s.length-1;\n        while (i<j){\n            char temp=s[i];\n            s[i]=s[j];\n            s[j]=temp;\n            i++;\n            j--;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢345. 反转字符串中的元音字母\n\n> 给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。\n>\n> 元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现不止一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"hello\"\n> 输出：\"holle\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"leetcode\"\n> 输出：\"leotcede\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 3 * 105`\n> - `s` 由 **可打印的 ASCII** 字符组成\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseVowels(String s) {\n        char[]chars=s.toCharArray();\n        Set<Character>set=new HashSet<>();\n        set.add('a');\n        set.add('e');\n        set.add('i');\n        set.add('o');\n        set.add('u');\n        set.add('A');\n        set.add('E');\n        set.add('I');\n        set.add('O');\n        set.add('U');\n        int i=0,j=s.length()-1;\n        while (i<j){\n            while (i<j&&!set.contains(chars[i])){\n                i++;\n            }\n            while (i<j&&!set.contains(chars[j])){\n                j--;\n            }\n            if(i>=j){\n                break;\n            }\n            char temp=chars[i];\n            chars[i]=chars[j];\n            chars[j]=temp;\n            i++;\n            j--;\n        }\n        return String.copyValueOf(chars);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢125. 验证回文串 \n\n> 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。\n>\n> 字母和数字都属于字母数字字符。\n>\n> 给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"A man, a plan, a canal: Panama\"\n> 输出：true\n> 解释：\"amanaplanacanalpanama\" 是回文串。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"race a car\"\n> 输出：false\n> 解释：\"raceacar\" 不是回文串。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \" \"\n> 输出：true\n> 解释：在移除非字母数字字符之后，s 是一个空字符串 \"\" 。\n> 由于空字符串正着反着读都一样，所以是回文串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 2 * 105`\n> - `s` 仅由可打印的 ASCII 字符组成\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        s=s.toLowerCase().replaceAll(\"[^0-9a-z]\",\"\");\n        int i=0,j=s.length()-1;\n        while (i<j){\n            if(s.charAt(i)!=s.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡11. 盛最多水的容器\n\n> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n>\n> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n>\n> 返回容器可以储存的最大水量。\n>\n> **说明：**你不能倾斜容器。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)\n>\n> ```\n> 输入：[1,8,6,2,5,4,8,3,7]\n> 输出：49 \n> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：height = [1,1]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == height.length`\n> - `2 <= n <= 105`\n> - `0 <= height[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int max=0;\n        int i=0,j= height.length-1;\n        while (i<j){\n            max=Math.max(max,(j-i)*Math.min(height[i],height[j]));\n            if(height[i]<=height[j]){\n                i++;\n            }else {\n                j--;\n            }\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡15. 三数之和 \n\n> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n>\n> 你返回所有和为 `0` 且不重复的三元组。\n>\n> **注意：**答案中不可以包含重复的三元组。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-1,0,1,2,-1,-4]\n> 输出：[[-1,-1,2],[-1,0,1]]\n> 解释：\n> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\n> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\n> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n> 注意，输出的顺序和三元组的顺序并不重要。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,1]\n> 输出：[]\n> 解释：唯一可能的三元组和不为 0 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [0,0,0]\n> 输出：[[0,0,0]]\n> 解释：唯一可能的三元组和为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= nums.length <= 3000`\n> - `-105 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>>res=new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length-2; i++) {\n            while (i!=0&&i<nums.length&&nums[i]==nums[i-1]){\n                i++;\n            }\n            if(i==nums.length||nums[i]>0){\n                return res;\n            }\n            int left=i+1,right=nums.length-1;\n            while (left<right){\n                int sum=nums[i]+nums[left]+nums[right];\n                if(sum<0){\n                    left++;\n                }else if(sum>0){\n                    right--;\n                }else {\n                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));\n                    while (left+1<right&&nums[left+1]==nums[left]){\n                        left++;\n                    }\n                    while (right-1>left&&nums[right-1]==nums[right]){\n                        right--;\n                    }\n                    left++;\n                    right--;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡18. 四数之和 \n\n> 给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：\n>\n> - `0 <= a, b, c, d < n`\n> - `a`、`b`、`c` 和 `d` **互不相同**\n> - `nums[a] + nums[b] + nums[c] + nums[d] == target`\n>\n> 你可以按 **任意顺序** 返回答案 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,0,-1,0,-2,2], target = 0\n> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,2,2,2,2], target = 8\n> 输出：[[2,2,2,2]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 200`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        List<List<Integer>>res=new ArrayList<>();\n        int len= nums.length;\n        for (int i = 0; i < len-3; i++) {\n            if(nums[i]>0&&nums[i]>target){//剪枝一\n                return res;\n            }\n            while(i>0&&i<len&&nums[i]==nums[i-1]){//去重一\n                i++;\n            }\n            for (int j = i+1; j < len-2; j++) {\n                if(nums[i]>0&&nums[i]+nums[j]>target){//剪枝二\n                    return res;\n                }\n                while(j>i+1&&j<len&&nums[j]==nums[j-1]){//去重二\n                    j++;\n                }\n                int left=j+1,right=len-1;\n                while (left<right){\n                    int sum=nums[i]+nums[j]+nums[left]+nums[right];\n                    if(sum<target){\n                        left++;\n                    }else if(sum>target){\n                        right--;\n                    }else {\n                        List<Integer>list=new ArrayList<>();\n                        list.add(nums[i]);\n                        list.add(nums[j]);\n                        list.add(nums[left]);\n                        list.add(nums[right]);\n                        res.add(list);\n                        while(left<right&&nums[left]==nums[left+1]){//去重三\n                            left++;\n                        }\n                        while(left<right&&nums[right]==nums[right-1]){//去重四\n                            right--;\n                        }\n                        left++;\n                        right--;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^3^)*\n- space:*O(n)*\n\n## 🟡167. 两数之和 II - 输入有序数组 \n\n> 给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。\n>\n> 以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。\n>\n> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。\n>\n> 你所设计的解决方案必须只使用常量级的额外空间。\n>\n> **示例 1：**\n>\n> ```\n> 输入：numbers = [2,7,11,15], target = 9\n> 输出：[1,2]\n> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：numbers = [2,3,4], target = 6\n> 输出：[1,3]\n> 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：numbers = [-1,0], target = -1\n> 输出：[1,2]\n> 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= numbers.length <= 3 * 104`\n> - `-1000 <= numbers[i] <= 1000`\n> - `numbers` 按 **非递减顺序** 排列\n> - `-1000 <= target <= 1000`\n> - **仅存在一个有效答案**\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 二分查找\n\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left=0,right=numbers.length-1;\n        while(left<right){\n            int sum=numbers[left]+numbers[right];\n            if(sum==target){\n                return new int[]{left+1,right+1};\n            } else if (sum<target) {\n                left++;\n            }else {\n                right--;\n            }\n        }\n        return new int[]{-1,-1};\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n\n\n## 🟢88. 合并两个有序数组 \n\n> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。\n>\n> 请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。\n>\n> **注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n> 输出：[1,2,2,3,5,6]\n> 解释：需要合并 [1,2,3] 和 [2,5,6] 。\n> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [1], m = 1, nums2 = [], n = 0\n> 输出：[1]\n> 解释：需要合并 [1] 和 [] 。\n> 合并结果是 [1] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n> 输出：[1]\n> 解释：需要合并的数组是 [] 和 [1] 。\n> 合并结果是 [1] 。\n> 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `nums1.length == m + n`\n> - `nums2.length == n`\n> - `0 <= m, n <= 200`\n> - `1 <= m + n <= 200`\n> - `-109 <= nums1[i], nums2[j] <= 109`\n>\n> \n>\n> **进阶：**你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int idx1 = m - 1, idx2 = n - 1;\n        if(n==0){\n            return;\n        }\n        if(m==0){\n            while (idx2>=0){\n                nums1[idx2] = nums2[idx2];\n                idx2--;\n            }\n            return;\n        }\n        int idx = nums1.length - 1;\n        while (idx >= 0) {\n            if (nums1[idx1] > nums2[idx2]) {\n                nums1[idx] = nums1[idx1];\n                idx1--;\n                if (idx1 < 0) {\n                    break;\n                }\n            } else {\n                nums1[idx] = nums2[idx2];\n                idx2--;\n                if (idx2 < 0) {\n                    break;\n                }\n            }\n            idx--;\n        }\n        while (idx2>=0){\n            nums1[idx2] = nums2[idx2];\n            idx2--;\n        }\n    }\n}\n```\n\n- time:*O(m+n)*\n- space:*O(n)*\n\n## 🟢283. 移动零 \n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len = nums.length;\n        for (int i = 0; i < len - 1; i++) {\n            for (int j = 1; j < len - i; j++) {\n                if (nums[j - 1] == 0) {\n                    int temp = nums[j];\n                    nums[j] = nums[j - 1];\n                    nums[j - 1] = temp;\n                }\n            }\n        }\n    }\n}\n```\n\n- time:O(n^2^)\n- space:O(1)\n\n## 🟢 27. 移除元素 \n\n> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n>\n> \n>\n> **说明:**\n>\n> 为什么返回数值是整数，但输出的答案是数组呢?\n>\n> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n> 你可以想象内部操作如下:\n>\n> ```\n> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n> int len = removeElement(nums, val);\n> \n> // 在函数里修改输入数组对于调用者是可见的。\n> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n> for (int i = 0; i < len; i++) {\n>     print(nums[i]);\n> }\n> ```\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,2,2,3], val = 3\n> 输出：2, nums = [2,2]\n> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2\n> 输出：5, nums = [0,1,3,0,4]\n> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= nums.length <= 100`\n> - `0 <= nums[i] <= 50`\n> - `0 <= val <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int len = nums.length;\n        int cnt = 0;\n        for (int i = 0; i < len; i++) {\n            if (nums[i] == val) {\n                cnt++;\n            }\n        }\n        for (int i = 0; i < len - 1; i++) {\n            for (int j = 1; j < len - i; j++) {\n                if (nums[j - 1] == val) {\n                    int temp = nums[j];\n                    nums[j] = nums[j - 1];\n                    nums[j - 1] = temp;\n                }\n            }\n        }\n        return len - cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n##  🟢455. 分发饼干 \n\n> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n>\n> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n>\n> **示例 1:**\n>\n> ```\n> 输入: g = [1,2,3], s = [1,1]\n> 输出: 1\n> 解释: \n> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n> 所以你应该输出1。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: g = [1,2], s = [1,2,3]\n> 输出: 2\n> 解释: \n> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n> 你拥有的饼干数量和尺寸都足以让所有孩子满足。\n> 所以你应该输出2.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= g.length <= 3 * 104`\n> - `0 <= s.length <= 3 * 104`\n> - `1 <= g[i], s[j] <= 231 - 1`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        int cnt = 0;\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int idx=0;\n        for (int i = 0; i < g.length; i++) {\n            int temp=0;\n            while (idx<s.length){\n                if(g[i]<=s[idx]){\n                    cnt++;\n                    s[idx]=0;\n                    temp=idx;\n                    break;\n                }\n                idx++;\n            }\n            idx=temp;\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n·log n+n·m)*\n- space:*O(1)*\n\n## 🟢561. 数组拆分 \n\n> 给定长度为 `2n` 的整数数组 `nums` ，你的任务是将这些数分成 `n` 对, 例如 `(a1, b1), (a2, b2), ..., (an, bn)` ，使得从 `1` 到 `n` 的 `min(ai, bi)` 总和最大。\n>\n> 返回该 **最大总和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,4,3,2]\n> 输出：4\n> 解释：所有可能的分法（忽略元素顺序）为：\n> 1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n> 2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n> 3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\n> 所以最大总和为 4\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [6,2,6,5,1,2]\n> 输出：9\n> 解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 104`\n> - `nums.length == 2 * n`\n> - `-104 <= nums[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 计数排序\n>\n> 排序\n\n```java\nclass Solution {\n    public int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum=0;\n        for (int i = 0; i < nums.length; i+=2) {\n            sum+=nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n- time:*O(n·log n)*\n- space:*O(1)*\n\n## 🟢9. 回文数\n\n> 给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n>\n> 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n>\n> - 例如，`121` 是回文，而 `123` 不是。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 121\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = -121\n> 输出：false\n> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：x = 10\n> 输出：false\n> 解释：从右向左读, 为 01 。因此它不是一个回文数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-231 <= x <= 231 - 1`\n>\n> \n>\n> **进阶：**你能不将整数转为字符串来解决这个问题吗？\n>\n> Related Topics\n>\n> 数学\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String str=String.valueOf(x);\n        int i=0,j=str.length()-1;\n        while(i<j){\n            if(str.charAt(i)!=str.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n#  快慢指针问题\n\n## 🟢876. 链表的中间结点 \n\n> 给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。\n>\n> 如果有两个中间结点，则返回第二个中间结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[3,4,5]\n> 解释：链表只有一个中间结点，值为 3 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5,6]\n> 输出：[4,5,6]\n> 解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表的结点数范围是 `[1, 100]`\n> - `1 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast=fast.next.next;\n            slow=slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢206. 反转链表 \n\n> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n>\n> ```\n> 输入：head = [1,2]\n> 输出：[2,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[0, 5000]`\n> - `-5000 <= Node.val <= 5000`\n>\n> \n>\n> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode fast=head,slow=fast;\n        ListNode res=new ListNode (0);//头插法\n        while(fast!=null){\n            fast=fast.next;\n            slow.next=res.next;\n            res.next=slow;\n            slow=fast;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡19. 删除链表的倒数第 N 个结点 \n\n> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [1], n = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1,2], n = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中结点的数目为 `sz`\n> - `1 <= sz <= 30`\n> - `0 <= Node.val <= 100`\n> - `1 <= n <= sz`\n>\n> \n>\n> **进阶：**你能尝试使用一趟扫描实现吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head.next==null){\n            return null;\n        }\n        ListNode fast=head,slow=fast;\n        for (int i = 0; i < n; i++) {\n            fast=fast.next;\n        }\n        if(fast==null){\n            return head.next;\n        }else {\n            fast=fast.next;\n            while (fast!=null){\n                slow=slow.next;\n                fast=fast.next;\n            }\n            slow.next=slow.next.next;\n            return head;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢141. 环形链表\n\n> 给你一个链表的头节点 `head` ，判断链表中是否有环。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。\n>\n> *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)\n>\n> ```\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：true\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> ```\n> 输入：head = [1,2], pos = 0\n> 输出：true\n> 解释：链表中有一个环，其尾部连接到第一个节点。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> ```\n> 输入：head = [1], pos = -1\n> 输出：false\n> 解释：链表中没有环。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[0, 104]`\n> - `-105 <= Node.val <= 105`\n> - `pos` 为 `-1` 或者链表中的一个 **有效索引** 。\n>\n> \n>\n> **进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head, fast = slow;\n        while (slow != null) {\n            slow = slow.next;\n            if(fast!=null&&fast.next!=null){\n                fast = fast.next.next;\n            }else {\n                return false;\n            }\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡142. 环形链表 II \n\n> 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n>\n> **不允许修改** 链表。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>\n> ```\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> ```\n> 输入：head = [1,2], pos = 0\n> 输出：返回索引为 0 的链表节点\n> 解释：链表中有一个环，其尾部连接到第一个节点。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> ```\n> 输入：head = [1], pos = -1\n> 输出：返回 null\n> 解释：链表中没有环。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围在范围 `[0, 104]` 内\n> - `-105 <= Node.val <= 105`\n> - `pos` 的值为 `-1` 或者链表中的一个有效索引\n>\n> \n>\n> **进阶：**你是否可以使用 `O(1)` 空间解决此题？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(1)*\n\n## 🟢21. 合并两个有序链表 \n\n> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n>\n> ```\n> 输入：l1 = [1,2,4], l2 = [1,3,4]\n> 输出：[1,1,2,3,4,4]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：l1 = [], l2 = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：l1 = [], l2 = [0]\n> 输出：[0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 两个链表的节点数目范围是 `[0, 50]`\n> - `-100 <= Node.val <= 100`\n> - `l1` 和 `l2` 均按 **非递减顺序** 排列\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        if (list1 == null) {\n            return list2;\n        }\n        if (list2 == null) {\n            return list1;\n        }\n        ListNode res = new ListNode(0);\n        ListNode p = res;\n        ListNode p1 = list1, p2 = list2;\n        while (p1 != null && p2 != null) {\n            if (p1.val <= p2.val) {\n                p.next = p1;\n                p = p1;\n                p1 = p1.next;\n            } else {\n                p.next = p2;\n                p = p2;\n                p2 = p2.next;\n            }\n        }\n        if (p1 == null) {\n            p.next = p2;\n            p = p2;\n        }\n        if (p2 == null) {\n            p.next = p1;\n            p = p1;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢 26. 删除有序数组中的重复项 \n\n> 给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。\n>\n> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：\n>\n> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。\n> - 返回 `k` 。\n>\n> **判题标准:**\n>\n> 系统会用下面的代码来测试你的题解:\n>\n> ```\n> int[] nums = [...]; // 输入数组\n> int[] expectedNums = [...]; // 长度正确的期望答案\n> \n> int k = removeDuplicates(nums); // 调用\n> \n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n> ```\n>\n> 如果所有断言都通过，那么您的题解将被 **通过**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2,_]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **非严格递增** 排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i = 0, j = 0;\n        int len = nums.length;\n        while (i < len) {\n            while (j < len && nums[j] == nums[i]) {\n                j++;\n            }\n            if (i + 1 < len && j < len && j - i > 1) {\n                nums[i + 1] = nums[j];\n            }\n            i++;\n            if(j>=len) {\n                break;\n            }\n        }\n        return i;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢83. 删除排序链表中的重复元素\n\n> 给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n>\n> ```\n> 输入：head = [1,1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n>\n> ```\n> 输入：head = [1,1,2,3,3]\n> 输出：[1,2,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n>\n> Related Topics\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode i = head, j = head;\n        while (i != null) {\n            while (j!=null&&j.val==i.val){\n                j=j.next;\n            }\n            if(j==null){\n                i.next=null;\n            }\n            if(i!=null&&j!=null&&j!=i.next){\n               i.next=j;\n            }\n            i = i.next;\n\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡82. 删除排序链表中的重复元素 II \n\n\n\n## 🟡86. 分隔链表 \n\n## 🟢234. 回文链表\n\n#  滑动窗口问题\n\n## 🟡209. 长度最小的子数组 \n\n## 🟡5. 最长回文子串 \n\n## 🔴76. 最小覆盖子串\n\n##  🟡80. 删除有序数组中的重复项 II \n\n## 🟡457. 环形数组是否存在循环 \n\n## 🟡718. 最长重复子数组\n\n\n\n# 🟢977. 有序数组的平方\n\n> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-4,-1,0,3,10]\n> 输出：[0,1,9,16,100]\n> 解释：平方后，数组变为 [16,1,0,9,100]\n> 排序后，数组变为 [0,1,9,16,100]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [-7,-3,2,3,11]\n> 输出：[4,9,9,49,121]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **非递减顺序** 排序\n>\n> \n>\n> **进阶：**\n>\n> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int len= nums.length;\n        int i=0,j=len-1,index=j;\n        int[]res=new int[len];\n        while(index>=0&&i<=j){\n            if(nums[i]*nums[i]>nums[j]*nums[j]){\n                res[index--]=nums[i]*nums[i++];\n            }else{\n                res[index--]=nums[j]*nums[j--];\n            }\n        }\n        return res;\n    }\n}\n```\n\n# 🟢344. 反转字符串\n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n>\n> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int i=0,j=s.length-1;\n        while(i<j){\n            char temp=s[i];\n            s[i]=s[j];\n            s[j]=temp;\n            i++;\n            j--;\n        }\n    }\n}\n```\n\n\n\n# 428🟢LCR 122. 路径加密\n\n> 假定一段路径记作字符串 `path`，其中以 \"`.`\" 作为分隔符。现需将路径加密，加密方法为将 `path` 中的分隔符替换为空格 \"` `\"，请返回加密后的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：path = \"a.aef.qerf.bb\"\n> \n> 输出：\"a aef qerf bb\"\n> ```\n>\n> \n>\n> **限制：**\n>\n> ```\n> 0 <= path.length <= 10000\n> ```\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public String pathEncryption(String path) {\n        return path.replace('.',' ');\n    }\n}\n```\n\n还是用双指针(单指针)做一下：\n\n```java\nclass Solution {\n    public String pathEncryption(String path) {\n        char[]chars=path.toCharArray();\n        for (int i = 0; i < path.length(); i++) {\n            if(chars[i]=='.'){\n                chars[i]=' ';\n            }\n        }\n        return String.copyValueOf(chars);\n    }\n}\n```\n\n# 🟡151. 反转字符串中的单词\n\n> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n>\n> **单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n>\n> 返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n>\n> **注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"the sky is blue\"\n> 输出：\"blue is sky the\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"  hello world  \"\n> 输出：\"world hello\"\n> 解释：反转后的字符串中不能存在前导空格和尾随空格。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a good   example\"\n> 输出：\"example good a\"\n> 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 包含英文大小写字母、数字和空格 `' '`\n> - `s` 中 **至少存在一个** 单词\n>\n> \n>\n> \n>\n> **进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        String[]strings=s.split(\"[ ]+\");\n        StringBuilder sb=new StringBuilder();\n        for (int i = strings.length-1; i >=0 ; i--) {\n            sb.append(strings[i]+\" \");\n        }\n        return sb.toString().trim();\n    }\n}\n```\n\n还是用双指针做一下：\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        int len=s.length();\n        if(len==1&&s.charAt(0)==' '){\n            return \"\";\n        }else if(len==1){\n            return s;\n        }\n        String string=removespace(s);\n        len=string.length();\n        string=reverse(string,0,string.length()-1);\n        int i=0,j=1;\n        while(i<len){\n            while(j<len&&string.charAt(j)!=' '){\n                j++;// j指向空格\n            }\n            string=reverse(string,i,j-1);\n            i=j+1;\n            j=i;\n        }\n        return string;\n    }\n    String removespace(String str){\n        int len=str.length();\n        StringBuilder sb=new StringBuilder();\n        int i=0,j=len-1;\n        while(str.charAt(i)==' '){\n            i++;\n        }\n        while(str.charAt(j)==' '){\n            j--;\n        }\n        while(i<=j){\n            if(str.charAt(i)!=' '||str.charAt(i-1)!=' '){\n                sb.append(str.charAt(i));\n            }\n            i++;\n        }\n        return sb.toString();\n    }\n    String reverse(String str,int i,int j){\n        StringBuilder sb=new StringBuilder(str);\n        while(i<j){\n            char temp=sb.charAt(i);\n            sb.setCharAt(i,sb.charAt(j));\n            sb.setCharAt(j,temp);\n            i++;\n            j--;\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n\n\n# 🟢面试题 02.07. 链表相交\n\n> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。\n>\n> 图示两个链表在节点 `c1` 开始相交**：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n>\n> 题目数据 **保证** 整个链式结构中不存在环。\n>\n> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n>\n> \n>\n> **示例 1：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n>\n> ```\n> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n> 输出：Intersected at '8'\n> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n> ```\n>\n> **示例 2：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n>\n> ```\n> 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n> 输出：Intersected at '2'\n> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n> 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n> ```\n>\n> **示例 3：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n>\n> ```\n> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n> 输出：null\n> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n> 这两个链表不相交，因此返回 null 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `listA` 中节点数目为 `m`\n> - `listB` 中节点数目为 `n`\n> - `0 <= m, n <= 3 * 104`\n> - `1 <= Node.val <= 105`\n> - `0 <= skipA <= m`\n> - `0 <= skipB <= n`\n> - 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`\n> - 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`\n>\n> \n>\n> **进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null||headB==null){\n            return null;\n        }\n        int lenA=1,lenB=1;\n        ListNode ptr=headA;\n        while(ptr!=null){\n            lenA++;\n            ptr=ptr.next;\n        }\n        ptr=headB;\n        while(ptr!=null){\n            lenB++;\n            ptr=ptr.next;\n        }\n        int i=lenA-Math.min(lenA,lenB);\n        int j=lenB-Math.min(lenA,lenB);\n        for (; Math.min(i,j) < Math.min(lenA,lenB); i++,j++) {\n            if(get(headA,i)==null){\n                return null;\n            }\n            if(get(headA,i).equals(get(headB,j))){\n                return get(headA,i);\n            }\n        }\n        return null;\n    }\n    ListNode get(ListNode head,int n){\n        ListNode ptr=head;\n        for (int i = 0; i < n; i++) {\n            ptr=ptr.next;\n        }\n        return ptr;\n    }\n}\n```\n\n","categories":["algorithm learning"]},{"title":"Strings","url":"/2023/09/04/algorithm-strings/","content":"\n| 类型               | 题号                                   | 完成 |\n| ------------------ | -------------------------------------- | ---- |\n| 字符               | 🟢520. 检测大写字母                     | ✅    |\n| 回文串的定义       | 🟢125. 验证回文串                       | ✅    |\n| 公共前缀           | 🟢14. 最长公共前缀                      | ✅    |\n| 单词               | 🟢434. 字符串中的单词数                 | ✅    |\n|                    | 🟢58. 最后一个单词的长度                | ✅    |\n| 字符串的反转       | 🟢344. 反转字符串                       | ✅    |\n|                    | 🟢 541. 反转字符串 II                   | ✅    |\n|                    | 🟢557. 反转字符串中的单词 III           | ✅    |\n|                    | 🟡151. 翻转字符串里的单词               | ✅    |\n| 字符的统计         | 🟢387. 字符串中的第一个唯一字符         | ✅    |\n|                    | 🟢389. 找不同                           | ✅    |\n|                    | 🟢383. 赎金信                           | ✅    |\n|                    | 🟢242. 有效的字母异位词                 | ✅    |\n|                    | 🟡49. 字母异位词分组                    | ✅    |\n|                    | 🟡451. 根据字符出现频率排序             | ✅    |\n|                    | 🟡423. 从英文中重建数字                 | ✅    |\n|                    | 🟢657. 机器人能否返回原点               | ✅    |\n|                    | 🟢551. 学生出勤记录 I                   | ✅    |\n|                    | 🟢696. 计数二进制子串                   |      |\n|                    | 🟡467. 环绕字符串中唯一的子字符串       |      |\n| 数字与字符串间转换 | 🟡299. 猜数字游戏                       | ✅    |\n|                    | 🟡412. Fizz Buzz                        | ✅    |\n|                    | 🟢 506. 相对名次                        | ✅    |\n|                    | 🟡539. 最小时间差                       | ✅    |\n|                    | 🟡 553. 最优除法                        |      |\n|                    | 🟡537. 复数乘法                         | ✅    |\n|                    | 🟡592. 分数加减运算                     | ✅    |\n|                    | 🟡640. 求解方程                         | ✅    |\n|                    | 🟡38. 外观数列                          | ✅    |\n|                    | Run-Length编码：🟡443. 压缩字符串       | ✅    |\n|                    | 🟡 8. 字符串转换整数 (atoi)             |      |\n|                    | 🟢 13. 罗马数字转整数                   | ✅    |\n|                    | 🟡12. 整数转罗马数字                    | ✅    |\n|                    | 🔴273. 整数转换英文表示                 |      |\n|                    | 🟡 165. 比较版本号                      |      |\n|                    | 🟡481. 神奇字符串                       |      |\n| 子序列             | 🟢392. 判断子序列                       | ✅    |\n|                    | 🟡524. 通过删除字母匹配到字典里最长单词 | ✅    |\n|                    | 🟢 521. 最长特殊序列 Ⅰ                  | ✅    |\n|                    | 🟡522. 最长特殊序列 II                  |      |\n| 高精度运算         | 🟢66. 加一                              | ✅    |\n|                    | 🟢67. 二进制求和                        | ✅    |\n|                    | 🟢415. 字符串相加                       | ✅    |\n|                    | 🟡43. 字符串相乘                        |      |\n|                    | 🟡306. 累加数                           |      |\n| 字符串变换         | 🟢482. 密钥格式化                       |      |\n|                    | 🟡6. Z 字形变换                         |      |\n|                    | 🔴68. 文本左右对齐                      |      |\n| 字符串匹配         | Rabin-Karp 算法：🟢28. 实现 strStr()    |      |\n|                    | 🟡686. 重复叠加字符串匹配 61)           |      |\n|                    | 🟢459. 重复的子字符串62)                |      |\n|                    | KMP算法：🔴214. 最短回文串              |      |\n|                    | Boyer-Moore算法：819. 最常见的单词     |      |\n| 中心拓展法         | 🟡5. 最长回文子串                       |      |\n|                    | 🟡647. 回文子串                         |      |\n| 符串排序算法       | 🟡75.颜色分类                           |      |\n|                    | 🟡451. 根据字符出现频率排序             |      |\n|                    | 🟡179. 最大数                           |      |\n|                    | 🟡937. 重新排列日志文件                 |      |\n| 字符串压缩算法     | Run-Length 编码：🟡443. 压缩字符串      |      |\n|                    | 🔴297. 二叉树的序列化与反序列化         |      |\n| 字符串搜索算法     | 🟡17. 电话号码的字母组合                |      |\n|                    | 🟡22. 括号生成                          |      |\n|                    | 🔴30. 串联所有单词的子串                |      |\n| 字符串编辑距离算法 | 🟡583. 两个字符串的删除操作             |      |\n|                    | 🟡1143. 最长公共子序列                  |      |\n| 正则表达式         | 🔴10. 正则表达式匹配                    |      |\n|                    | 🔴65. 有效数字                          |      |\n| 其它               | 🟢LCR 122. 路径加密                     |      |\n|                    | 🟢LCR 182. 动态口令                     |      |\n|                    | 🟢28.找出字符串中第一个匹配项的下标     |      |\n\n#  字符\n\n## 🟢520. 检测大写字母\n\n> 我们定义，在以下情况时，单词的大写用法是正确的：\n>\n> - 全部字母都是大写，比如 `\"USA\"` 。\n> - 单词中所有字母都不是大写，比如 `\"leetcode\"` 。\n> - 如果单词不只含有一个字母，只有首字母大写， 比如 `\"Google\"` 。\n>\n> 给你一个字符串 `word` 。如果大写用法正确，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：word = \"USA\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：word = \"FlaG\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= word.length <= 100`\n> - `word` 由小写和大写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean detectCapitalUse(String word) {\n        int len=word.length();\n        char last=word.charAt(len-1);\n        if(last>='A'&&last<='Z'){\n            for (int i = 0; i < len-1; i++) {\n                if(word.charAt(i)>='a'&&word.charAt(i)<='z'){\n                    return false;\n                }\n            }\n        }else {\n            for (int i = 1; i < len-1; i++) {\n                if(word.charAt(i)>='A'&&word.charAt(i)<='Z'){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 回文串的定义\n\n## 🟢125. 验证回文串\n\n> 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。\n>\n> 字母和数字都属于字母数字字符。\n>\n> 给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"A man, a plan, a canal: Panama\"\n> 输出：true\n> 解释：\"amanaplanacanalpanama\" 是回文串。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"race a car\"\n> 输出：false\n> 解释：\"raceacar\" 不是回文串。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \" \"\n> 输出：true\n> 解释：在移除非字母数字字符之后，s 是一个空字符串 \"\" 。\n> 由于空字符串正着反着读都一样，所以是回文串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 2 * 105`\n> - `s` 仅由可打印的 ASCII 字符组成\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        String str=s.toLowerCase().replaceAll(\"[^a-z0-9]\",\"\");\n        int len=str.length();\n        int i=0,j=len-1;\n        while (i<j){\n            if(str.charAt(i)!=str.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n\n\n# 公共前缀\n\n## 🟢14. 最长公共前缀\n\n> 编写一个函数来查找字符串数组中的最长公共前缀。\n>\n> 如果不存在公共前缀，返回空字符串 `\"\"`。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：strs = [\"flower\",\"flow\",\"flight\"]\n> 输出：\"fl\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：strs = [\"dog\",\"racecar\",\"car\"]\n> 输出：\"\"\n> 解释：输入不存在公共前缀。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 200`\n> - `0 <= strs[i].length <= 200`\n> - `strs[i]` 仅由小写英文字母组成\n>\n> Related Topics\n>\n> 字典树\n>\n> 字符串\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int len=strs.length;\n        String res=strs[0];\n        for (int i = 1; i < len; i++) {\n            if(strs[i].startsWith(res)){\n                continue;\n            }else{\n                while (!strs[i].startsWith(res.substring(0,res.length()-1))){\n                    res=res.substring(0,res.length()-1);\n                }\n                res=res.substring(0,res.length()-1);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n# 单词\n\n## 🟢434. 字符串中的单词数\n\n> 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。\n>\n> 请注意，你可以假定字符串里不包括任何不可打印的字符。\n>\n> **示例:**\n>\n> ```\n> 输入: \"Hello, my name is John\"\n> 输出: 5\n> 解释: 这里的单词是指连续的不是空格的字符，所以 \"Hello,\" 算作 1 个单词。\n> ```\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public int countSegments(String s) {\n        String[] splited=s.split(\"[ ]+\");\n        int res=0;\n        for (int i = 0; i < splited.length; i++) {\n            if(!Objects.equals(splited[i], \"\")){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟢58. 最后一个单词的长度\n\n> 给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。\n>\n> **单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"Hello World\"\n> 输出：5\n> 解释：最后一个单词是“World”，长度为5。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"   fly me   to   the moon  \"\n> 输出：4\n> 解释：最后一个单词是“moon”，长度为4。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"luffy is still joyboy\"\n> 输出：6\n> 解释：最后一个单词是长度为6的“joyboy”。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅有英文字母和空格 `' '` 组成\n> - `s` 中至少存在一个单词\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        String [] splited = s.split(\"[ ]+\");\n        return splited[splited.length-1].length();\n    }\n}\n```\n\n\n\n# 字符串的反转\n\n## 🟢344. 反转字符串 \n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n>\n> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int len=s.length;\n        int i=0,j=len-1;\n        while (i<j){\n            char temp=s[i];\n            s[i]=s[j];\n            s[j]=temp;\n            i++;\n            j--;\n        }\n    }\n}\n```\n\n\n\n## 🟢 541. 反转字符串 II \n\n> 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。\n>\n> - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。\n> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abcdefg\", k = 2\n> 输出：\"bacdfeg\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\", k = 2\n> 输出：\"bacd\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅由小写英文组成\n> - `1 <= k <= 104`\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseStr(String s, int k) {\n        StringBuilder sb=new StringBuilder(s);\n        for (int i = 0; i < sb.length(); i+=2*k) {\n            int l=i,r=i+k-1;\n            if(r>=sb.length()){\n                r=sb.length()-1;\n            }\n            while (l<r){\n                char temp=sb.charAt(l);\n                sb.setCharAt(l,sb.charAt(r));\n                sb.setCharAt(r,temp);\n                l++;\n                r--;\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n## 🟢557. 反转字符串中的单词 III \n\n> 给定一个字符串 `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"Let's take LeetCode contest\"\n> 输出：\"s'teL ekat edoCteeL tsetnoc\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入： s = \"Mr Ding\"\n> 输出：\"rM gniD\"\n> ```\n>\n> \n>\n> ***\\**\\*\\*\\*提示：\\*\\*\\*\\*\\****\n>\n> - `1 <= s.length <= 5 * 104`\n> - `s` 包含可打印的 **ASCII** 字符。\n> - `s` 不包含任何开头或结尾空格。\n> - `s` 里 **至少** 有一个词。\n> - `s` 中的所有单词都用一个空格隔开。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        String[]splited=s.split(\"[ ]+\");\n        StringBuilder res=new StringBuilder();\n        for (int i = 0; i < splited.length; i++) {\n            if(i!=0){\n                res.append(\" \");\n            }\n            res.append(new StringBuilder(splited[i]).reverse());\n        }\n        return res.toString();\n    }\n}\n```\n\n\n\n## 🟡151. 翻转字符串里的单词\n\n> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n>\n> **单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n>\n> 返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n>\n> **注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"the sky is blue\"\n> 输出：\"blue is sky the\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"  hello world  \"\n> 输出：\"world hello\"\n> 解释：反转后的字符串中不能存在前导空格和尾随空格。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a good   example\"\n> 输出：\"example good a\"\n> 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 包含英文大小写字母、数字和空格 `' '`\n> - `s` 中 **至少存在一个** 单词\n>\n> \n>\n> \n>\n> **进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        String[]splited=s.split(\"[ ]+\");\n        StringBuilder res=new StringBuilder();\n        for (int i = splited.length-1; i >= 0; i--) {\n            if(!splited[i].equals(\"\")){\n                if(i!= splited.length-1){\n                    res.append(\" \");\n                }\n                res.append(splited[i]);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n\n\n# 字符的统计\n\n## 🟢387. 字符串中的第一个唯一字符 \n\n> 给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"leetcode\"\n> 输出: 0\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"loveleetcode\"\n> 输出: 2\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"aabb\"\n> 输出: -1\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length <= 105`\n> - `s` 只包含小写字母\n>\n> Related Topics\n>\n> 队列\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public int firstUniqChar(String s) {\n        int[] hashtable=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if(hashtable[s.charAt(i)-'a']==1){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n\n\n## 🟢389. 找不同 \n\n> 给定两个字符串 `s` 和 `t` ，它们只包含小写字母。\n>\n> 字符串 `t` 由字符串 `s` 随机重排，然后在随机位置添加一个字母。\n>\n> 请找出在 `t` 中被添加的字母。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abcd\", t = \"abcde\"\n> 输出：\"e\"\n> 解释：'e' 是那个被添加的字母。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"\", t = \"y\"\n> 输出：\"y\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= s.length <= 1000`\n> - `t.length == s.length + 1`\n> - `s` 和 `t` 只包含小写字母\n>\n> Related Topics\n>\n> 位运算\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public char findTheDifference(String s, String t) {\n        int[]hashtable=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < t.length(); i++) {\n            if(hashtable[t.charAt(i)-'a']==0){\n                return t.charAt(i);\n            }else{\n                hashtable[t.charAt(i)-'a']--;\n            }\n        }\n        return 'a';\n    }\n}\n```\n\n\n\n## 🟢383. 赎金信 \n\n> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n>\n> 如果可以，返回 `true` ；否则返回 `false` 。\n>\n> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ransomNote = \"a\", magazine = \"b\"\n> 输出：false\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"ab\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"aab\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= ransomNote.length, magazine.length <= 105`\n> - `ransomNote` 和 `magazine` 由小写英文字母组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[]hashtable=new int[26];\n        for (int i = 0; i <magazine.length() ; i++) {\n            hashtable[magazine.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < ransomNote.length(); i++) {\n            if(hashtable[ransomNote.charAt(i)-'a']==0){\n                return false;\n            }else{\n                hashtable[ransomNote.charAt(i)-'a']--;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n## 🟢242. 有效的字母异位词\n\n> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。\n>\n> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"anagram\", t = \"nagaram\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"rat\", t = \"car\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, t.length <= 5 * 104`\n> - `s` 和 `t` 仅包含小写字母\n>\n> \n>\n> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length()){\n            return false;\n        }\n        int[]hashtable=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < t.length(); i++) {\n            if(hashtable[t.charAt(i)-'a']==0){\n                return false;\n            }else{\n                hashtable[t.charAt(i)-'a']--;\n            }\n\n        }\n        return true;\n    }\n}\n```\n\n\n\n## 🟡49. 字母异位词分组\n\n> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n>\n> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n> 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: strs = [\"\"]\n> 输出: [[\"\"]]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: strs = [\"a\"]\n> 输出: [[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 104`\n> - `0 <= strs[i].length <= 100`\n> - `strs[i]` 仅包含小写字母\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>>res=new ArrayList<>();\n        Map<String,Integer>map=new HashMap<>();\n        int len= strs.length;\n        for (int i = 0; i < len; i++) {\n            char[]chars=strs[i].toCharArray().clone();\n            Arrays.sort(chars);\n            String key=String.copyValueOf(chars);\n            if(map.containsKey(key)){\n                res.get(map.get(key)).add(strs[i]);\n            }else{\n                map.put(key,map.size());\n                res.add(new ArrayList<>());\n                res.get(map.get(key)).add(strs[i]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟡451. 根据字符出现频率排序\n\n> 给定一个字符串 `s` ，根据字符出现的 **频率** 对其进行 **降序排序** 。一个字符出现的 **频率** 是它出现在字符串中的次数。\n>\n> 返回 *已排序的字符串* 。如果有多个答案，返回其中任何一个。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"tree\"\n> 输出: \"eert\"\n> 解释: 'e'出现两次，'r'和't'都只出现一次。\n> 因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"cccaaa\"\n> 输出: \"cccaaa\"\n> 解释: 'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n> 注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"Aabb\"\n> 输出: \"bbAa\"\n> 解释: 此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n> 注意'A'和'a'被认为是两种不同的字符。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length <= 5 * 105`\n> - `s` 由大小写英文字母和数字组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 桶排序\n>\n> 计数\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public String frequencySort(String s) {\n        Map<Character,Integer> map=new TreeMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\n        }\n        List<Map.Entry<Character,Integer>>list=new ArrayList<Map.Entry<Character,Integer>>(map.entrySet());\n        Collections.sort(list, new Comparator<Map.Entry<Character, Integer>>() {\n            @Override\n            public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {\n                return o2.getValue().compareTo(o1.getValue());\n            }\n        });\n        System.out.println(map);\n        String res=\"\";\n        for (int i = 0; i < list.size(); i++) {\n            for (int j = 0; j < list.get(i).getValue(); j++) {\n                res+=list.get(i).getKey();\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟡423. 从英文中重建数字\n\n> 给你一个字符串 `s` ，其中包含字母顺序打乱的用英文单词表示的若干数字（`0-9`）。按 **升序** 返回原始的数字。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"owoztneoer\"\n> 输出：\"012\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"fviefuro\"\n> 输出：\"45\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 为 `[\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"]` 这些字符之一\n> - `s` 保证是一个符合题目要求的字符串\n>\n> Related Topics\n>\n> 哈希表\n>\n> 数学\n>\n> 字符串\n\n```java\nclass Solution {\n    public String originalDigits(String s) {\n        int[]hashtable=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        int[]arr=new int[10];\n        arr[0]=hashtable['z'-'a'];\n        arr[1]=hashtable['o'-'a']-hashtable['z'-'a']-hashtable['w'-'a']-hashtable['u'-'a'];\n        arr[2]=hashtable['w'-'a'];\n        arr[3]=hashtable['h'-'a']-hashtable['g'-'a'];\n        arr[4]=hashtable['u'-'a'];\n        arr[5]=hashtable['f'-'a']-hashtable['u'-'a'];\n        arr[6]=hashtable['x'-'a'];\n        arr[7]=hashtable['s'-'a']-hashtable['x'-'a'];\n        arr[8]=hashtable['g'-'a'];\n        arr[9]=hashtable['i'-'a']-hashtable['g'-'a']-hashtable['x'-'a']-hashtable['f'-'a']\n                +hashtable['u'-'a'];\n        String res=\"\";\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i]; j++) {\n                res+=String.valueOf(i);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟢657. 机器人能否返回原点\n\n> 在二维平面上，有一个机器人从原点 `(0, 0)` 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 **`(0, 0)` 处结束**。\n>\n> 移动顺序由字符串 `moves` 表示。字符 `move[i]` 表示其第 `i` 次移动。机器人的有效动作有 `R`（右），`L`（左），`U`（上）和 `D`（下）。\n>\n> 如果机器人在完成所有动作后返回原点，则返回 `true`。否则，返回 `false`。\n>\n> **注意：**机器人“面朝”的方向无关紧要。 `“R”` 将始终使机器人向右移动一次，`“L”` 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: moves = \"UD\"\n> 输出: true\n> 解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: moves = \"LL\"\n> 输出: false\n> 解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= moves.length <= 2 * 104`\n> - `moves` 只包含字符 `'U'`, `'D'`, `'L'` 和 `'R'`\n>\n> Related Topics\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x=0,y=0;\n        for (int i = 0; i < moves.length(); i++) {\n            switch (moves.charAt(i)){\n                case 'U':{\n                    y++;\n                    break;\n                }\n                case 'D':{\n                    y--;\n                    break;\n                }\n                case 'L':{\n                    x--;\n                    break;\n                }\n                case 'R':{\n                    x++;\n                    break;\n                }\n            }\n        }\n        return x==0&&y==0;\n    }\n}\n```\n\n\n\n## 🟢551. 学生出勤记录 I \n\n> 给你一个字符串 `s` 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n>\n> - `'A'`：Absent，缺勤\n> - `'L'`：Late，迟到\n> - `'P'`：Present，到场\n>\n> 如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励：\n>\n> - 按 **总出勤** 计，学生缺勤（`'A'`）**严格** 少于两天。\n> - 学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（`'L'`）记录。\n>\n> 如果学生可以获得出勤奖励，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"PPALLP\"\n> 输出：true\n> 解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"PPALLL\"\n> 输出：false\n> 解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 1000`\n> - `s[i]` 为 `'A'`、`'L'` 或 `'P'`\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean checkRecord(String s) {\n        int cnt=0,len=0;\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i)=='A'){\n                cnt++;\n            }\n            if(i!=0&&s.charAt(i)=='L'&&s.charAt(i-1)=='L'){\n                len++;\n            } else if (s.charAt(i)=='L') {\n                len=1;\n            }\n            if(cnt>=2||len>=3){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n##  🟢696. 计数二进制子串 \n\n> 给定一个字符串 `s`，统计并返回具有相同数量 `0` 和 `1` 的非空（连续）子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是成组连续的。\n>\n> 重复出现（不同位置）的子串也要统计它们出现的次数。\n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"00110011\"\n> 输出：6\n> 解释：6 个子串满足具有相同数量的连续 1 和 0 ：\"0011\"、\"01\"、\"1100\"、\"10\"、\"0011\" 和 \"01\" 。\n> 注意，一些重复出现的子串（不同位置）要统计它们出现的次数。\n> 另外，\"00110011\" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"10101\"\n> 输出：4\n> 解释：有 4 个子串：\"10\"、\"01\"、\"10\"、\"01\" ，具有相同数量的连续 1 和 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 为 `'0'` 或 `'1'`\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\n```\n\n\n\n## 🟡467. 环绕字符串中唯一的子字符串\n\n> 定义字符串 `base` 为一个 `\"abcdefghijklmnopqrstuvwxyz\"` 无限环绕的字符串，所以 `base` 看起来是这样的：\n>\n> - `\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\"`.\n>\n> 给你一个字符串 `s` ，请你统计并返回 `s` 中有多少 **不同****非空子串** 也在 `base` 中出现。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"a\"\n> 输出：1\n> 解释：字符串 s 的子字符串 \"a\" 在 base 中出现。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"cac\"\n> 输出：2\n> 解释：字符串 s 有两个子字符串 (\"a\", \"c\") 在 base 中出现。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"zab\"\n> 输出：6\n> 解释：字符串 s 有六个子字符串 (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") 在 base 中出现。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - s 由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n\n```java\n```\n\n\n\n\n\n# 数字与字符串间转换\n\n## 🟡299. 猜数字游戏 \n\n> 你在和朋友一起玩 [猜数字（Bulls and Cows）](https://baike.baidu.com/item/猜数字/83200?fromtitle=Bulls+and+Cows&fromid=12003488&fr=aladdin)游戏，该游戏规则如下：\n>\n> 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：\n>\n> - 猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\"，公牛），\n> - 有多少位属于数字猜对了但是位置不对（称为 \"Cows\"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。\n>\n> 给你一个秘密数字 `secret` 和朋友猜测的数字 `guess` ，请你返回对朋友这次猜测的提示。\n>\n> 提示的格式为 `\"xAyB\"` ，`x` 是公牛个数， `y` 是奶牛个数，`A` 表示公牛，`B` 表示奶牛。\n>\n> 请注意秘密数字和朋友猜测的数字都可能含有重复数字。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：secret = \"1807\", guess = \"7810\"\n> 输出：\"1A3B\"\n> 解释：数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n> \"1807\"\n>   |\n> \"7810\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：secret = \"1123\", guess = \"0111\"\n> 输出：\"1A1B\"\n> 解释：数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n> \"1123\"        \"1123\"\n>   |      or     |\n> \"0111\"        \"0111\"\n> 注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= secret.length, guess.length <= 1000`\n> - `secret.length == guess.length`\n> - `secret` 和 `guess` 仅由数字组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public String getHint(String secret, String guess) {\n        int a=0,b=0;\n        int[]arr1=new int[10];\n        int[]arr2=new int[10];\n        for (int i = 0; i < secret.length(); i++) {\n            if(secret.charAt(i)==guess.charAt(i)){\n                a++;\n            }else{\n                arr1[secret.charAt(i)-'0']++;\n                arr2[guess.charAt(i)-'0']++;\n            }\n        }\n        for (int i = 0; i < 10; i++) {\n            b+=Math.min(arr1[i],arr2[i]);\n        }\n        return a+\"A\"+b+\"B\";\n    }\n}\n```\n\n\n\n## 🟢412. Fizz Buzz\n\n> 给你一个整数 `n` ，找出从 `1` 到 `n` 各个整数的 Fizz Buzz 表示，并用字符串数组 `answer`（**下标从 1 开始**）返回结果，其中：\n>\n> - `answer[i] == \"FizzBuzz\"` 如果 `i` 同时是 `3` 和 `5` 的倍数。\n> - `answer[i] == \"Fizz\"` 如果 `i` 是 `3` 的倍数。\n> - `answer[i] == \"Buzz\"` 如果 `i` 是 `5` 的倍数。\n> - `answer[i] == i` （以字符串形式）如果上述条件全不满足。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 3\n> 输出：[\"1\",\"2\",\"Fizz\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 5\n> 输出：[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：n = 15\n> 输出：[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 104`\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public List<String> fizzBuzz(int n) {\n        List<String>res=new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if(i%3==0&&i%5==0){\n                res.add(\"FizzBuzz\");\n            } else if (i%3==0) {\n                res.add(\"Fizz\");\n            } else if (i%5==0) {\n                res.add(\"Buzz\");\n            }else {\n                res.add(String.valueOf(i));\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟢 506. 相对名次\n\n> 给你一个长度为 `n` 的整数数组 `score` ，其中 `score[i]` 是第 `i` 位运动员在比赛中的得分。所有得分都 **互不相同** 。\n>\n> 运动员将根据得分 **决定名次** ，其中名次第 `1` 的运动员得分最高，名次第 `2` 的运动员得分第 `2` 高，依此类推。运动员的名次决定了他们的获奖情况：\n>\n> - 名次第 `1` 的运动员获金牌 `\"Gold Medal\"` 。\n> - 名次第 `2` 的运动员获银牌 `\"Silver Medal\"` 。\n> - 名次第 `3` 的运动员获铜牌 `\"Bronze Medal\"` 。\n> - 从名次第 `4` 到第 `n` 的运动员，只能获得他们的名次编号（即，名次第 `x` 的运动员获得编号 `\"x\"`）。\n>\n> 使用长度为 `n` 的数组 `answer` 返回获奖，其中 `answer[i]` 是第 `i` 位运动员的获奖情况。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：score = [5,4,3,2,1]\n> 输出：[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\n> 解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：score = [10,3,8,9,4]\n> 输出：[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\n> 解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == score.length`\n> - `1 <= n <= 104`\n> - `0 <= score[i] <= 106`\n> - `score` 中的所有值 **互不相同**\n>\n> Related Topics\n>\n> 数组\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n        int len= score.length;\n        PriorityQueue<Integer>heap=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2-o1;\n            }\n        });\n        String[]res=new String[len];\n        for (int i = 0; i < len; i++) {\n            heap.offer(score[i]);\n        }\n        int cnt=1;\n        while (!heap.isEmpty()){\n            for (int i = 0; i < len; i++) {\n                if(heap.peek()==score[i]){\n                    if(cnt==1){\n                        res[i]=\"Gold Medal\";\n                    } else if (cnt==2) {\n                        res[i]=\"Silver Medal\";\n                    } else if (cnt==3) {\n                        res[i]=\"Bronze Medal\";\n                    }else {\n                        res[i]=String.valueOf(cnt);\n                    }\n                    heap.poll();\n                    break;\n                }\n            }\n            cnt++;\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟡539. 最小时间差\n\n> 给定一个 24 小时制（小时:分钟 **\"HH:MM\"**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：timePoints = [\"23:59\",\"00:00\"]\n> 输出：1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= timePoints.length <= 2 * 104`\n> - `timePoints[i]` 格式为 **\"HH:MM\"**\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public int findMinDifference(List<String> timePoints) {\n        int res=Integer.MAX_VALUE;\n        int len=timePoints.size();\n        for (int i = 0; i < len; i++) {\n            for (int j = i+1; j < len; j++) {\n                res=Math.min(res,getDuration(timePoints.get(i),timePoints.get(j)));\n                if(res==0){\n                    return 0;\n                }\n            }\n        }\n        return res;\n    }\n    int getDuration(String a,String b){\n        int numA=Integer.parseInt(a.substring(0,2))*60+Integer.parseInt(a.substring(3,5));\n        int numB=Integer.parseInt(b.substring(0,2))*60+Integer.parseInt(b.substring(3,5));\n        int small=Math.min(numA,numB);\n        int big=Math.max(numA,numB);\n        return Math.min(big-small,24*60+small-big);\n    }\n}\n```\n\n\n\n## 🟡 553. 最优除法 \n\n> 给定一正整数数组 `nums`**，**`nums` 中的相邻整数将进行浮点除法。例如， [2,3,4] -> 2 / 3 / 4 。\n>\n> - 例如，`nums = [2,3,4]`，我们将求表达式的值 `\"2/3/4\"`。\n>\n> 但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。\n>\n> 以字符串格式返回具有最大值的对应表达式。\n>\n> **注意：**你的表达式不应该包含多余的括号。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: [1000,100,10,2]\n> 输出: \"1000/(100/10/2)\"\n> 解释: 1000/(100/10/2) = 1000/((100/10)/2) = 200\n> 但是，以下加粗的括号 \"1000/((100/10)/2)\" 是冗余的，\n> 因为他们并不影响操作的优先级，所以你需要返回 \"1000/(100/10/2)\"。\n> \n> 其他用例:\n> 1000/(100/10)/2 = 50\n> 1000/(100/(10/2)) = 50\n> 1000/100/10/2 = 0.5\n> 1000/100/(10/2) = 2\n> ```\n>\n> \n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [2,3,4]\n> 输出: \"2/(3/4)\"\n> 解释: (2/(3/4)) = 8/3 = 2.667\n> 可以看出，在尝试了所有的可能性之后，我们无法得到一个结果大于 2.667 的表达式。\n> ```\n>\n> \n>\n> **说明:**\n>\n> - `1 <= nums.length <= 10`\n> - `2 <= nums[i] <= 1000`\n> - 对于给定的输入只有一种最优除法。\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n>\n> 动态规划\n\n```java\n```\n\n\n\n## 🟡537. 复数乘法\n\n> [复数](https://baike.baidu.com/item/复数/254365?fr=aladdin) 可以用字符串表示，遵循 `\"**实部**+**虚部**i\"` 的形式，并满足下述条件：\n>\n> - `实部` 是一个整数，取值范围是 `[-100, 100]`\n> - `虚部` 也是一个整数，取值范围是 `[-100, 100]`\n> - `i2 == -1`\n>\n> 给你两个字符串表示的复数 `num1` 和 `num2` ，请你遵循复数表示形式，返回表示它们乘积的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num1 = \"1+1i\", num2 = \"1+1i\"\n> 输出：\"0+2i\"\n> 解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num1 = \"1+-1i\", num2 = \"1+-1i\"\n> 输出：\"0+-2i\"\n> 解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 \n> ```\n>\n> \n>\n> **提示：**\n>\n> - `num1` 和 `num2` 都是有效的复数表示。\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public String complexNumberMultiply(String num1, String num2) {\n        String[]strings1=num1.split(\"[+]\");\n        String[]strings2=num2.split(\"[+]\");\n        int x1=Integer.parseInt(strings1[0]);\n        int x2=Integer.parseInt(strings1[1].substring(0,strings1[1].length()-1));\n        int y1=Integer.parseInt(strings2[0]);\n        int y2=Integer.parseInt(strings2[1].substring(0,strings2[1].length()-1));\n        int z1=x1*y1-x2*y2;\n        int z2=x1*y2+x2*y1;\n        return z1+\"+\"+z2+\"i\";\n    }\n}\n```\n\n\n\n## 🟡592. 分数加减运算\n\n> 给定一个表示分数加减运算的字符串 `expression` ，你需要返回一个字符串形式的计算结果。\n>\n> 这个结果应该是不可约分的分数，即[最简分数](https://baike.baidu.com/item/最简分数)。 如果最终结果是一个整数，例如 `2`，你需要将它转换成分数形式，其分母为 `1`。所以在上述例子中, `2` 应该被转换为 `2/1`。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: expression = \"-1/2+1/2\"\n> 输出: \"0/1\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: expression = \"-1/2+1/2+1/3\"\n> 输出: \"1/3\"\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: expression = \"1/3-1/2\"\n> 输出: \"-1/6\"\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 输入和输出字符串只包含 `'0'` 到 `'9'` 的数字，以及 `'/'`, `'+'` 和 `'-'`。\n> - 输入和输出分数格式均为 `±分子/分母`。如果输入的第一个分数或者输出的分数是正数，则 `'+'` 会被省略掉。\n> - 输入只包含合法的**最简分数**，每个分数的**分子**与**分母**的范围是 [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。\n> - 输入的分数个数范围是 [1,10]。\n> - **最终结果**的分子与分母保证是 32 位整数范围内的有效整数。\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public String fractionAddition(String expression) {\n        String[]numbers=expression.split(\"[^0-9/]\");\n        String[]ops_arr=expression.split(\"[0-9/]+\");\n        int GCD=1;\n        List<Character>ops=new ArrayList<>();\n        List<Integer>ups=new ArrayList<>();\n        List<Integer>downs=new ArrayList<>();\n        for (int i = 0; i < ops_arr.length; i++) {\n            if(ops_arr[i]!=\"\"){\n                ops.add(ops_arr[i].charAt(0));\n            }\n        }\n        for (int i = 0; i < numbers.length; i++) {\n            if(numbers[i]!=\"\"){\n                String[]num=numbers[i].split(\"[/]\");\n                ups.add(Integer.parseInt(num[0]));\n                downs.add(Integer.parseInt(num[1]));\n                GCD=lcm(GCD,Integer.parseInt(num[1]));\n            }\n        }\n        int resUp=0,resDown=GCD;\n        for (int i = 0; i < ups.size(); i++) {\n            int a=ups.get(i)*resDown/downs.get(i);\n            if(ops.size()==ups.size()){\n                resUp+=ops.get(i)=='+'?a:-a;\n            }else {\n                if(i==0){\n                    resUp+=a;\n                }else {\n                    resUp+=ops.get(i-1)=='+'?a:-a;\n                }\n            }\n            System.out.println(resUp+\" \"+resDown);\n        }\n        if(resUp==0){\n            resDown=1;\n        }else {\n            int temp=gcd(resUp,resDown);\n            resUp/=temp;\n            resDown/=temp;\n        }\n        if(resDown<0){\n            resDown*=-1;\n            resUp*=-1;\n        }\n        return resUp+\"/\"+resDown;\n    }\n    int lcm(int a,int b){\n        return a/gcd(a,b)*b;\n    }\n    int gcd(int a,int b){\n        return b==0?a:gcd(b,a%b);\n    }\n}\n```\n\n\n\n## 🟡640. 求解方程 \n\n> 求解一个给定的方程，将`x`以字符串 `\"x=#value\"` 的形式返回。该方程仅包含 `'+'` ， `'-'` 操作，变量 `x` 和其对应系数。\n>\n> 如果方程没有解或存在的解不为整数，请返回 `\"No solution\"` 。如果方程有无限解，则返回 `“Infinite solutions”` 。\n>\n> 题目保证，如果方程中只有一个解，则 'x' 的值是一个整数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: equation = \"x+5-3+x=6+x-2\"\n> 输出: \"x=2\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: equation = \"x=x\"\n> 输出: \"Infinite solutions\"\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: equation = \"2x=x\"\n> 输出: \"x=0\"\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `3 <= equation.length <= 1000`\n> - `equation` 只有一个 `'='`.\n> - 方程由绝对值在 `[0, 100]` 范围内且无任何前导零的整数和变量 `'x'` 组成。\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public String solveEquation(String equation) {\n        int leftxsum=fuc(equation.split(\"[=]\")[0])[0];\n        int leftnumsum=fuc(equation.split(\"[=]\")[0])[1];\n        int rightxsum=fuc(equation.split(\"[=]\")[1])[0];\n        int rightnumsum=fuc(equation.split(\"[=]\")[1])[1];\n        if(leftxsum-rightxsum==0&&rightnumsum-leftnumsum==0){\n            return \"Infinite solutions\";\n        } else if (leftxsum-rightxsum==0) {\n            return \"No solution\";\n        }else {\n            int x=(rightnumsum-leftnumsum)/(leftxsum-rightxsum);\n            return \"x=\"+x;\n        }\n    }\n    int[]fuc(String str){\n        int[]res=new int[2];\n        String[]ver=str.split(\"[+-]\");\n        String[]ops=str.split(\"[^+-]\");\n        List<String>verlist=new ArrayList<>();\n        List<Character>opslist=new ArrayList<>();\n        for (int i = 0; i < ver.length; i++) {\n            if(ver[i]!=\"\"){\n                verlist.add(ver[i]);\n            }\n        }\n        for (int i = 0; i < ops.length; i++) {\n            if(ops[i]!=\"\"){\n                opslist.add(ops[i].charAt(0));\n            }\n        }\n        int xsum=0,numsum=0;\n        int index=opslist.size()-1;\n        for (int i = verlist.size()-1; i >=0; i--) {\n            int size=verlist.get(i).length();\n            if(verlist.get(i).charAt(size-1)=='x'){\n                if(verlist.get(i).charAt(0)=='x'){\n                    if(index>=0){\n                        xsum+=opslist.get(index)=='+'?1:-1;\n                    }else {\n                        xsum++;\n                    }\n                }else{\n                    if(index>=0){\n                        xsum+=opslist.get(index)=='+'?Integer.parseInt(verlist.get(i).substring(0,size-1)):-Integer.parseInt(verlist.get(i).substring(0,size-1));\n                    }else {\n                        xsum+=Integer.parseInt(verlist.get(i).substring(0,size-1));\n                    }\n                }\n            }else {\n                if(index>=0){\n                    numsum+=opslist.get(index)=='+'?Integer.parseInt(verlist.get(i)):-Integer.parseInt(verlist.get(i));\n                }else {\n                    numsum+=Integer.parseInt(verlist.get(i));\n                }\n            }\n            index--;\n        }\n        res[0]=xsum;\n        res[1]=numsum;\n        return res;\n    }\n}\n```\n\n\n\n## 🟡38. 外观数列 \n\n> 给定一个正整数 `n` ，输出外观数列的第 `n` 项。\n>\n> 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\n>\n> 你可以将其视作是由递归公式定义的数字字符串序列：\n>\n> - `countAndSay(1) = \"1\"`\n> - `countAndSay(n)` 是对 `countAndSay(n-1)` 的描述，然后转换成另一个数字字符串。\n>\n> 前五项如下：\n>\n> ```\n> 1.     1\n> 2.     11\n> 3.     21\n> 4.     1211\n> 5.     111221\n> 第一项是数字 1 \n> 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\"\n> 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\"\n> 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \"1211\"\n> 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"111221\"\n> ```\n>\n> 要 **描述** 一个数字字符串，首先要将字符串分割为 **最小** 数量的组，每个组都由连续的最多 **相同字符** 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\n>\n> 例如，数字字符串 `\"3322251\"` 的描述如下图：\n>\n> ![img](https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png)\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 1\n> 输出：\"1\"\n> 解释：这是一个基本样例。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 4\n> 输出：\"1211\"\n> 解释：\n> countAndSay(1) = \"1\"\n> countAndSay(2) = 读 \"1\" = 一 个 1 = \"11\"\n> countAndSay(3) = 读 \"11\" = 二 个 1 = \"21\"\n> countAndSay(4) = 读 \"21\" = 一 个 2 + 一 个 1 = \"12\" + \"11\" = \"1211\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 30`\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        if(n==1){\n            return \"1\";\n        }\n        String last=countAndSay(n-1);\n        StringBuilder sb=new StringBuilder();\n        char ch=last.charAt(0);\n        int cnt=1;\n        for (int i = 1; i < last.length(); i++) {\n            if(last.charAt(i)==ch){\n                cnt++;\n            }else {\n                sb.append(String.valueOf(cnt)+String.valueOf(ch));\n                cnt=1;\n            }\n            ch=last.charAt(i);\n        }\n        sb.append(String.valueOf(cnt)+String.valueOf(ch));\n        return sb.toString();\n    }\n}\n```\n\n\n\n## 🟡443. 压缩字符串 \n\n> 给你一个字符数组 `chars` ，请使用下述算法压缩：\n>\n> 从一个空字符串 `s` 开始。对于 `chars` 中的每组 **连续重复字符** ：\n>\n> - 如果这一组长度为 `1` ，则将字符追加到 `s` 中。\n> - 否则，需要向 `s` 追加字符，后跟这一组的长度。\n>\n> 压缩后得到的字符串 `s` **不应该直接返回** ，需要转储到字符数组 `chars` 中。需要注意的是，如果组长度为 `10` 或 `10` 以上，则在 `chars` 数组中会被拆分为多个字符。\n>\n> 请在 **修改完输入数组后** ，返回该数组的新长度。\n>\n> 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n> 输出：返回 6 ，输入数组的前 6 个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n> 解释：\"aa\" 被 \"a2\" 替代。\"bb\" 被 \"b2\" 替代。\"ccc\" 被 \"c3\" 替代。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：chars = [\"a\"]\n> 输出：返回 1 ，输入数组的前 1 个字符应该是：[\"a\"]\n> 解释：唯一的组是“a”，它保持未压缩，因为它是一个字符。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n> 输出：返回 4 ，输入数组的前 4 个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。\n> 解释：由于字符 \"a\" 不重复，所以不会被压缩。\"bbbbbbbbbbbb\" 被 “b12” 替代。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= chars.length <= 2000`\n> - `chars[i]` 可以是小写英文字母、大写英文字母、数字或符号\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public int compress(char[] chars) {\n        int cnt=1;\n        char last=chars[0];\n        StringBuilder sb=new StringBuilder();\n        for (int i = 1; i < chars.length; i++) {\n            if(chars[i]==last){\n                cnt++;\n            }else{\n                sb.append(String.valueOf(last));\n                if(cnt>1){\n                    sb.append(String.valueOf(cnt));\n                }\n                cnt=1;\n            }\n            last=chars[i];\n        }\n        sb.append(String.valueOf(last));\n        if(cnt>1){\n            sb.append(String.valueOf(cnt));\n        }\n        for (int i = 0; i < sb.length(); i++) {\n            chars[i]= sb.charAt(i);\n        }\n        return sb.length();\n    }\n}\n```\n\n\n\n## 🟡 8. 字符串转换整数 (atoi) \n\n> 请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。\n>\n> 函数 `myAtoi(string s)` 的算法如下：\n>\n> 1. 读入字符串并丢弃无用的前导空格\n> 2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。\n> 3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。\n> 4. 将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。\n> 5. 如果整数数超过 32 位有符号整数范围 `[−231,  231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被固定为 `−231` ，大于 `231 − 1` 的整数应该被固定为 `231 − 1` 。\n> 6. 返回整数作为最终结果。\n>\n> **注意：**\n>\n> - 本题中的空白字符只包括空格字符 `' '` 。\n> - 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"42\"\n> 输出：42\n> 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n> 第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n>          ^\n> 第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n>          ^\n> 第 3 步：\"42\"（读入 \"42\"）\n>            ^\n> 解析得到整数 42 。\n> 由于 \"42\" 在范围 [-231, 231 - 1] 内，最终结果为 42 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"   -42\"\n> 输出：-42\n> 解释：\n> 第 1 步：\"   -42\"（读入前导空格，但忽视掉）\n>             ^\n> 第 2 步：\"   -42\"（读入 '-' 字符，所以结果应该是负数）\n>              ^\n> 第 3 步：\"   -42\"（读入 \"42\"）\n>                ^\n> 解析得到整数 -42 。\n> 由于 \"-42\" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"4193 with words\"\n> 输出：4193\n> 解释：\n> 第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n>          ^\n> 第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n>          ^\n> 第 3 步：\"4193 with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n>              ^\n> 解析得到整数 4193 。\n> 由于 \"4193\" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= s.length <= 200`\n> - `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成\n>\n> Related Topics\n>\n> 字符串\n\n```java\n```\n\n\n\n## 🟢 13. 罗马数字转整数 \n\n> 罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n>\n> ```\n> 字符          数值\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> ```\n>\n> 例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n>\n> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n>\n> - `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n> - `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。\n> - `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n>\n> 给定一个罗马数字，将其转换成整数。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"III\"\n> 输出: 3\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"IV\"\n> 输出: 4\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"IX\"\n> 输出: 9\n> ```\n>\n> **示例 4:**\n>\n> ```\n> 输入: s = \"LVIII\"\n> 输出: 58\n> 解释: L = 50, V= 5, III = 3.\n> ```\n>\n> **示例 5:**\n>\n> ```\n> 输入: s = \"MCMXCIV\"\n> 输出: 1994\n> 解释: M = 1000, CM = 900, XC = 90, IV = 4.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 15`\n> - `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`\n> - 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内\n> - 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n> - IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n> - 关于罗马数字的详尽书写规则，可以参考 [罗马数字 - Mathematics ](https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article)。\n>\n> Related Topics\n>\n> 哈希表\n>\n> 数学\n>\n> 字符串\n\n```java\nimport java.util.Map;\nimport java.util.TreeMap;\n\nclass Solution {\n    public int romanToInt(String s) {\n        Map<Character,Integer> map=new TreeMap<>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        int res=0;\n        for (int i = 0; i < s.length(); i++) {\n            if(i<s.length()-1){\n                if(s.charAt(i)=='I'){\n                    if(s.charAt(i+1)=='V'){\n                        res+=4;\n                        i++;\n                    }else if(s.charAt(i+1)=='X'){\n                        res+=9;\n                        i++;\n                    }else {\n                        res+=map.get(s.charAt(i));\n                    }\n                } else if (s.charAt(i)=='X') {\n                    if(s.charAt(i+1)=='L'){\n                        res+=40;\n                        i++;\n                    }else if(s.charAt(i+1)=='C'){\n                        res+=90;\n                        i++;\n                    }else {\n                        res+=map.get(s.charAt(i));\n                    }\n                } else if (s.charAt(i)=='C') {\n                    if(s.charAt(i+1)=='D'){\n                        res+=400;\n                        i++;\n                    }else if(s.charAt(i+1)=='M'){\n                        res+=900;\n                        i++;\n                    }else {\n                        res+=map.get(s.charAt(i));\n                    }\n                }else {\n                    res+=map.get(s.charAt(i));\n                }\n            }else {\n                res+=map.get(s.charAt(i));\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## 🟡12. 整数转罗马数字\n\n> 罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n>\n> ```\n> 字符          数值\n> I             1\n> V             5\n> X             10\n> L             50\n> C             100\n> D             500\n> M             1000\n> ```\n>\n> 例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。\n>\n> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n>\n> - `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n> - `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。\n> - `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n>\n> 给你一个整数，将其转为罗马数字。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: num = 3\n> 输出: \"III\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: num = 4\n> 输出: \"IV\"\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: num = 9\n> 输出: \"IX\"\n> ```\n>\n> **示例 4:**\n>\n> ```\n> 输入: num = 58\n> 输出: \"LVIII\"\n> 解释: L = 50, V = 5, III = 3.\n> ```\n>\n> **示例 5:**\n>\n> ```\n> 输入: num = 1994\n> 输出: \"MCMXCIV\"\n> 解释: M = 1000, CM = 900, XC = 90, IV = 4.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 3999`\n>\n> Related Topics\n>\n> 哈希表\n>\n> 数学\n>\n> 字符串\n\n```java\nimport java.util.*;\n\nclass Solution {\n    public String intToRoman(int num) {\n        StringBuilder sb=new StringBuilder();\n        Map<Integer,String> map=new TreeMap<>();\n        map.put(1000,\"M\");\n        map.put(900,\"CM\");\n        map.put(500,\"D\");\n        map.put(400,\"CD\");\n        map.put(100,\"C\");\n        map.put(90,\"XC\");\n        map.put(50,\"L\");\n        map.put(40,\"XL\");\n        map.put(10,\"X\");\n        map.put(9,\"IX\");\n        map.put(5,\"V\");\n        map.put(4,\"IV\");\n        map.put(1,\"I\");\n        List<Integer> list= new ArrayList<>(map.keySet().stream().toList());\n        list.sort(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n        for (int a:list) {\n            for (int i = 0; i < num/a; i++) {\n                sb.append(map.get(a));\n            }\n            num-=(num/a)*a;\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n## 🔴273. 整数转换英文表示\n\n> \n\n## 🟡 165. 比较版本号 \n\n> 给你两个版本号 `version1` 和 `version2` ，请你比较它们。\n>\n> 版本号由一个或多个修订号组成，各修订号由一个 `'.'` 连接。每个修订号由 **多位数字** 组成，可能包含 **前导零** 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，`2.5.33` 和 `0.1` 都是有效的版本号。\n>\n> 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 。也就是说，修订号 `1` 和修订号 `001` **相等** 。如果版本号没有指定某个下标处的修订号，则该修订号视为 `0` 。例如，版本 `1.0` 小于版本 `1.1` ，因为它们下标为 `0` 的修订号相同，而下标为 `1` 的修订号分别为 `0` 和 `1` ，`0 < 1` 。\n>\n> 返回规则如下：\n>\n> - 如果 `*version1* > *version2*` 返回 `1`，\n> - 如果 `*version1* < *version2*` 返回 `-1`，\n> - 除此之外返回 `0`。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：version1 = \"1.01\", version2 = \"1.001\"\n> 输出：0\n> 解释：忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：version1 = \"1.0\", version2 = \"1.0.0\"\n> 输出：0\n> 解释：version1 没有指定下标为 2 的修订号，即视为 \"0\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：version1 = \"0.1\", version2 = \"1.1\"\n> 输出：-1\n> 解释：version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 < 1，所以 version1 < version2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= version1.length, version2.length <= 500`\n> - `version1` 和 `version2` 仅包含数字和 `'.'`\n> - `version1` 和 `version2` 都是 **有效版本号**\n> - `version1` 和 `version2` 的所有修订号都可以存储在 **32 位整数** 中\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\n```\n\n\n\n## 🟡481. 神奇字符串\n\n> 神奇字符串 `s` 仅由 `'1'` 和 `'2'` 组成，并需要遵守下面的规则：\n>\n> - 神奇字符串 s 的神奇之处在于，串联字符串中 `'1'` 和 `'2'` 的连续出现次数可以生成该字符串。\n>\n> `s` 的前几个元素是 `s = \"1221121221221121122……\"` 。如果将 `s` 中连续的若干 `1` 和 `2` 进行分组，可以得到 `\"1 22 11 2 1 22 1 22 11 2 11 22 ......\"` 。每组中 `1` 或者 `2` 的出现次数分别是 `\"1 2 2 1 1 2 1 2 2 1 2 2 ......\"` 。上面的出现次数正是 `s` 自身。\n>\n> 给你一个整数 `n` ，返回在神奇字符串 `s` 的前 `n` 个数字中 `1` 的数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 6\n> 输出：3\n> 解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 105`\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\n```\n\n\n\n# 子序列\n\n## 🟢392. 判断子序列 \n\n> 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。\n>\n> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n>\n> **进阶：**\n>\n> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n>\n> **致谢：**\n>\n> 特别感谢 [@pbrother ](https://leetcode.com/pbrother/)添加此问题并且创建所有测试用例。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abc\", t = \"ahbgdc\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"axc\", t = \"ahbgdc\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= s.length <= 100`\n> - `0 <= t.length <= 10^4`\n> - 两个字符串都只由小写字符组成。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n>\n> 动态规划\n\n```java\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int len=t.length();\n        int[]dp=new int[len+1];\n        int index=0;\n        for (int i = 1; i <=len; i++) {\n            if(index<s.length()&&t.charAt(i-1)==s.charAt(index)){\n                dp[i]=dp[i-1]+1;\n                index++;\n            }else {\n                dp[i]=dp[i-1];\n            }\n        }\n        return dp[len]==s.length();\n    }\n}\n```\n\n\n\n## 🟡524. 通过删除字母匹配到字典里最长单词\n\n> 给你一个字符串 `s` 和一个字符串数组 `dictionary` ，找出并返回 `dictionary` 中最长的字符串，该字符串可以通过删除 `s` 中的某些字符得到。\n>\n> 如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n> 输出：\"apple\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\n> 输出：\"a\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 1000`\n> - `1 <= dictionary.length <= 1000`\n> - `1 <= dictionary[i].length <= 1000`\n> - `s` 和 `dictionary[i]` 仅由小写英文字母组成\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public String findLongestWord(String s, List<String> dictionary) {\n        Queue<String>heap=new PriorityQueue<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                if(o1.length()!=o2.length()){\n                    return o2.length()-o1.length();\n                }else{\n                    return o1.compareTo(o2);\n                }\n            }\n        });\n        for (int i = 0; i < dictionary.size(); i++) {\n            if(isSubsequence(dictionary.get(i),s)){\n                heap.offer(dictionary.get(i));\n            }\n        }\n        return heap.isEmpty()?\"\":heap.poll();\n    }\n    boolean isSubsequence(String s, String t) {\n        int len=t.length();\n        int[]dp=new int[len+1];\n        int index=0;\n        for (int i = 1; i <=len; i++) {\n            if(index<s.length()&&t.charAt(i-1)==s.charAt(index)){\n                dp[i]=dp[i-1]+1;\n                index++;\n            }else {\n                dp[i]=dp[i-1];\n            }\n        }\n        return dp[len]==s.length();\n    }\n}\n```\n\n## 🟢 521. 最长特殊序列 Ⅰ \n\n> 给你两个字符串 `a` 和 `b`，请返回 *这两个字符串中 **最长的特殊序列*** 的长度。如果不存在，则返回 `-1` 。\n>\n> **「最长特殊序列」** 定义如下：该序列为 **某字符串独有的最长子序列（即不能是其他字符串的子序列）** 。\n>\n> 字符串 `s` 的子序列是在从 `s` 中删除任意数量的字符后可以获得的字符串。\n>\n> - 例如，`\"abc\"` 是 `\"aebdc\"` 的子序列，因为删除 `\"a***e***b***d\\***c\"` 中斜体加粗的字符可以得到 `\"abc\"` 。 `\"aebdc\"` 的子序列还包括 `\"aebdc\"` 、 `\"aeb\"` 和 `\"\"` (空字符串)。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: a = \"aba\", b = \"cdc\"\n> 输出: 3\n> 解释: 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：a = \"aaa\", b = \"bbb\"\n> 输出：3\n> 解释: 最长特殊序列是 \"aaa\" 和 \"bbb\" 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：a = \"aaa\", b = \"aaa\"\n> 输出：-1\n> 解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= a.length, b.length <= 100`\n> - `a` 和 `b` 由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public int findLUSlength(String a, String b) {\n        if(a.length()!=b.length()){\n            return a.length()>b.length()?a.length():b.length();\n        }else {\n            return a.equals(b)?-1:a.length();\n        }\n    }\n}\n```\n\n\n\n## 🟡522. 最长特殊序列 II\n\n> 给定字符串列表 `strs` ，返回其中 **最长的特殊序列** 的长度。如果最长特殊序列不存在，返回 `-1` 。\n>\n> **特殊序列** 定义如下：该序列为某字符串 **独有的子序列（即不能是其他字符串的子序列）**。\n>\n> `s` 的 **子序列**可以通过删去字符串 `s` 中的某些字符实现。\n>\n> - 例如，`\"abc\"` 是 `\"aebdc\"` 的子序列，因为您可以删除`\"aebdc\"`中的下划线字符来得到 `\"abc\"` 。`\"aebdc\"`的子序列还包括`\"aebdc\"`、 `\"aeb\"` 和 \"\" (空字符串)。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: strs = [\"aba\",\"cdc\",\"eae\"]\n> 输出: 3\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: strs = [\"aaa\",\"aaa\",\"aa\"]\n> 输出: -1\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `2 <= strs.length <= 50`\n> - `1 <= strs[i].length <= 10`\n> - `strs[i]` 只包含小写英文字母\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 字符串\n>\n> 排序\n\n```java\n```\n\n\n\n# 高精度运算\n\n## 🟢66. 加一 \n\n> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。\n>\n> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n>\n> 你可以假设除了整数 0 之外，这个整数不会以零开头。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：digits = [1,2,3]\n> 输出：[1,2,4]\n> 解释：输入数组表示数字 123。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：digits = [4,3,2,1]\n> 输出：[4,3,2,2]\n> 解释：输入数组表示数字 4321。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：digits = [0]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= digits.length <= 100`\n> - `0 <= digits[i] <= 9`\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int len=digits.length;\n        if(digits[len-1]!=9){\n            digits[len-1]++;\n            return digits;\n        }else {\n            int index=len-1;\n            while (index>=0&&digits[index]==9){\n                index--;\n            }\n            if(index==-1){\n                int[] res=new int[len+1];\n                res[0]=1;\n                for (int i = 1; i <= len; i++) {\n                    res[i]=0;\n                }\n                return res;\n            }else {\n                for (int i = index+1; i < len; i++) {\n                    digits[i]=0;\n                }\n                digits[index]++;\n                return digits;\n            }\n        }\n    }\n}\n```\n\n\n\n## 🟢67. 二进制求和\n\n> 给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入:a = \"11\", b = \"1\"\n> 输出：\"100\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：a = \"1010\", b = \"1011\"\n> 输出：\"10101\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= a.length, b.length <= 104`\n> - `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成\n> - 字符串如果不是 `\"0\"` ，就不含前导零\n>\n> Related Topics\n>\n> 位运算\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public String addBinary(String a, String b) {\n        int idxa=a.length()-1,idxb=b.length()-1;\n        int cout=0;\n        String res=\"\";\n        while (idxa>=0&&idxb>=0){\n            switch (a.charAt(idxa)+b.charAt(idxb)-'0'-'0'){\n                case 0:{\n                    if(cout==1){\n                        res+=\"1\";\n                        cout=0;\n                    }else {\n                        res+=\"0\";\n                    }\n                    break;\n                }\n                case 1:{\n                    if(cout==1){\n                        res+=\"0\";\n                        cout=1;\n                    }else {\n                        res+=\"1\";\n                    }\n                    break;\n                }\n                case 2:{\n                    if(cout==1){\n                        res+=\"1\";\n                    }else {\n                        res+=\"0\";\n                    }\n                    cout=1;\n                    break;\n                }\n            }\n            idxa--;\n            idxb--;\n        }\n        if(idxa>=0){\n            while (idxa>=0){\n                switch (a.charAt(idxa)+cout-'0'){\n                    case 0:{\n                        res+=\"0\";\n                        break;\n                    }\n                    case 1:{\n                        res+=\"1\";\n                        cout=0;\n                        break;\n                    }\n                    case 2:{\n                        res+=\"0\";\n                        cout=1;\n                        break;\n                    }\n                }\n                idxa--;\n            }\n        } else if (idxb>=0) {\n            while (idxb>=0){\n                switch (b.charAt(idxb)+cout-'0'){\n                    case 0:{\n                        res+=\"0\";\n                        break;\n                    }\n                    case 1:{\n                        res+=\"1\";\n                        cout=0;\n                        break;\n                    }\n                    case 2:{\n                        res+=\"0\";\n                        cout=1;\n                        break;\n                    }\n                }\n                idxb--;\n            }\n        }\n        if(cout==1){\n            res+=\"1\";\n        }\n        return new StringBuilder(res).reverse().toString();\n    }\n}\n```\n\n\n\n## 🟢415. 字符串相加 \n\n> 给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。\n>\n> 你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num1 = \"11\", num2 = \"123\"\n> 输出：\"134\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num1 = \"456\", num2 = \"77\"\n> 输出：\"533\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：num1 = \"0\", num2 = \"0\"\n> 输出：\"0\"\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= num1.length, num2.length <= 104`\n> - `num1` 和`num2` 都只包含数字 `0-9`\n> - `num1` 和`num2` 都不包含任何前导零\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        String res=\"\";\n        int idx1=num1.length()-1,idx2=num2.length()-1;\n        int cout=0;\n        while (idx1>=0&&idx2>=0){\n            int sum=num1.charAt(idx1)-'0'+num2.charAt(idx2)-'0'+cout;\n            if(sum>9){\n                sum-=10;\n                cout=1;\n            }else {\n                cout=0;\n            }\n            res+=(char)(sum+'0');\n            idx1--;\n            idx2--;\n        }\n        while (idx1>=0){\n            int sum=num1.charAt(idx1)-'0'+cout;\n            if(sum>9){\n                sum-=10;\n                cout=1;\n            }else {\n                cout=0;\n            }\n            res+=(char)(sum+'0');\n            idx1--;\n        }\n        while (idx2>=0){\n            int sum=num2.charAt(idx2)-'0'+cout;\n            if(sum>9){\n                sum-=10;\n                cout=1;\n            }else {\n                cout=0;\n            }\n            res+=(char)(sum+'0');\n            idx2--;\n        }\n        if(cout==1){\n            res+=\"1\";\n        }\n        return new StringBuilder(res).reverse().toString();\n    }\n}\n```\n\n\n\n## 🟡43. 字符串相乘 \n\n> 给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。\n>\n> **注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: num1 = \"2\", num2 = \"3\"\n> 输出: \"6\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: num1 = \"123\", num2 = \"456\"\n> 输出: \"56088\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num1.length, num2.length <= 200`\n> - `num1` 和 `num2` 只能由数字组成。\n> - `num1` 和 `num2` 都不包含任何前导零，除了数字0本身。\n>\n> Related Topics\n>\n> 数学\n>\n> 字符串\n>\n> 模拟\n\n```java\n```\n\n\n\n## 🟡306. 累加数\n\n> **累加数** 是一个字符串，组成它的数字可以形成累加序列。\n>\n> 一个有效的 **累加序列** 必须 **至少** 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。\n>\n> 给你一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是 **累加数** 。如果是，返回 `true` ；否则，返回 `false` 。\n>\n> **说明：**累加序列里的数，除数字 0 之外，**不会** 以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\"112358\"\n> 输出：true \n> 解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：\"199100199\"\n> 输出：true \n> 解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num.length <= 35`\n> - `num` 仅由数字（`0` - `9`）组成\n>\n> \n>\n> **进阶：**你计划如何处理由过大的整数输入导致的溢出?\n>\n> Related Topics\n>\n> 字符串\n>\n> 回溯\n\n```java\n```\n\n\n\n# 字符串变换\n\n## 🟢482. 密钥格式化\n\n> 给定一个许可密钥字符串 `s`，仅由字母、数字字符和破折号组成。字符串由 `n` 个破折号分成 `n + 1` 组。你也会得到一个整数 `k` 。\n>\n> 我们想要重新格式化字符串 `s`，使每一组包含 `k` 个字符，除了第一组，它可以比 `k` 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。\n>\n> 返回 *重新格式化的许可密钥* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：S = \"5F3Z-2e-9-w\", k = 4\n> 输出：\"5F3Z-2E9W\"\n> 解释：字符串 S 被分成了两个部分，每部分 4 个字符；\n>      注意，两个额外的破折号需要删掉。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：S = \"2-5g-3-J\", k = 2\n> 输出：\"2-5G-3J\"\n> 解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length <= 105`\n> - `s` 只包含字母、数字和破折号 `'-'`.\n> - `1 <= k <= 104`\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public String licenseKeyFormatting(String s, int k) {\n        String tokens=s.toUpperCase().replaceAll(\"-\",\"\");\n        StringBuilder sb=new StringBuilder();\n        for (int i = tokens.length()-1; i >=0; i--) {\n            sb.append(tokens.charAt(i));\n            if((tokens.length()-i)%k==0&&i!=0){\n                sb.append(\"-\");\n            }\n        }\n        return sb.reverse().toString();\n    }\n}\n```\n\n\n\n## 🟡6. Z 字形变换 \n\n> 将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。\n>\n> 比如输入字符串为 `\"PAYPALISHIRING\"` 行数为 `3` 时，排列如下：\n>\n> ```\n> P   A   H   N\n> A P L S I I G\n> Y   I   R\n> ```\n>\n> 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`\"PAHNAPLSIIGYIR\"`。\n>\n> 请你实现这个将字符串进行指定行数变换的函数：\n>\n> ```\n> string convert(string s, int numRows);\n> ```\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"PAYPALISHIRING\", numRows = 3\n> 输出：\"PAHNAPLSIIGYIR\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"PAYPALISHIRING\", numRows = 4\n> 输出：\"PINALSIGYAHRPI\"\n> 解释：\n> P     I    N\n> A   L S  I G\n> Y A   H R\n> P     I\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"A\", numRows = 1\n> 输出：\"A\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 1000`\n> - `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成\n> - `1 <= numRows <= 1000`\n>\n> Related Topics\n>\n> 字符串\n\n```java\n```\n\n\n\n## 🔴68. 文本左右对齐\n\n#  字符串匹配\n\n## 🟢28. 实现 strStr() \n\n## 🟡686. 重复叠加字符串匹配 \n\n## 🟢459. 重复的子字符串\n\n## 🔴214. 最短回文串\n\n## 🟢819. 最常见的单词\n\n#  中心拓展法\n\n## 🟡5. 最长回文子串\n\n## 🟡647. 回文子串\n\n# 字符串排序算法\n\n## 🟡75. 颜色分类\n\n## 🟡451. 根据字符出现频率排序\n\n## 🟡179. 最大数\n\n## 🟡937. 重新排列日志文件\n\n# 字符串压缩算法\n\n## Run-Length 编码：🟡443. 压缩字符串 \n\n## 哈夫曼编码：🔴297. 二叉树的序列化与反序列化\n\n# 字符串搜索算法\n\n## 🟡17. 电话号码的字母组合\n\n## 🟡22. 括号生成 \n\n## 🔴30. 串联所有单词的子串\n\n# 字符串编辑距离算法\n\n## 🟡583. 两个字符串的删除操作 \n\n## 🟡1143. 最长公共子序列\n\n# 正则表达式\n\n## 🔴10. 正则表达式匹配 \n\n## 🔴65. 有效数字\n\n\n\n# 其它\n\n## 693🟢LCR 122. 路径加密\n\n> 假定一段路径记作字符串 `path`，其中以 \"`.`\" 作为分隔符。现需将路径加密，加密方法为将 `path` 中的分隔符替换为空格 \"` `\"，请返回加密后的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：path = \"a.aef.qerf.bb\"\n> \n> 输出：\"a aef qerf bb\"\n> ```\n>\n> \n>\n> **限制：**\n>\n> ```\n> 0 <= path.length <= 10000\n> ```\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public String pathEncryption(String path) {\n        char [] ca=path.toCharArray();\n        for (int i = 0; i < path.length(); i++) {\n            if(ca[i]=='.'){\n                ca[i]=' ';\n            }\n        }\n        return String.valueOf(ca);\n    }\n}\n```\n\n## 715🟢LCR 182. 动态口令\n\n> 某公司门禁密码使用动态口令技术。初始密码为字符串 `password`，密码更新均遵循以下步骤：\n>\n> - 设定一个正整数目标值 `target`\n> - 将 `password` 前 `target` 个字符按原顺序移动至字符串末尾\n>\n> 请返回更新后的密码字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: password = \"s3cur1tyC0d3\", target = 4\n> 输出: \"r1tyC0d3s3cu\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: password = \"lrloseumgh\", target = 6\n> 输出: \"umghlrlose\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= target < password.length <= 10000`\n>\n> \n>\n> Related Topics\n>\n> 数学\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String dynamicPassword(String password, int target) {\n        StringBuilder res=new StringBuilder();\n        res.append(password.substring(target,password.length()));\n        res.append(password.substring(0,target));\n        return res.toString();\n    }\n}\n```\n\n\n\n## 726 🟢28.找出字符串中第一个匹配项的下标\n\n> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：haystack = \"sadbutsad\", needle = \"sad\"\n> 输出：0\n> 解释：\"sad\" 在下标 0 和 6 处匹配。\n> 第一个匹配项的下标是 0 ，所以返回 0 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：haystack = \"leetcode\", needle = \"leeto\"\n> 输出：-1\n> 解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= haystack.length, needle.length <= 104`\n> - `haystack` 和 `needle` 仅由小写英文字符组成\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n>\n> 字符串匹配\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int index=0;\n        while(index<=haystack.length()-needle.length()){\n            while(index<haystack.length()-needle.length()&&haystack.charAt(index)!=needle.charAt(0)){\n                index++;//index指向某一个匹配短字符串首字符的位置\n            }\n            int flag=1;\n            for (int i = 0; i < needle.length(); i++) {\n                if(haystack.charAt(index+i)!=needle.charAt(i)){\n                    flag=0;\n                    break;\n                }\n            }\n            if(flag==1){\n                return index;\n            }else{\n                index++;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n补充KMP知识：\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int[]next=next_arr(needle);\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i))\n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i))\n                j++;\n            if (j == needle.length())\n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    \n    int[]next_arr(String pat){//huo'qu\n        int len=pat.length();\n        int[]next=new int[len];\n        next[0]=0;\n        int j=0;\n        for (int i = 1; i < len; i++) {\n            while(j>0&&pat.charAt(j)!=pat.charAt(i)){\n                j=next[j-1];\n            }\n            if(pat.charAt(j)==pat.charAt(i)){\n                j++;\n            }\n            next[i]=j;\n       \n        return next;\n    }\n}\n```\n\n\n\n","categories":["algorithm learning"]},{"title":"Hashing","url":"/2023/09/03/algorithm-hashing/","content":"\n| 分类                     | 题号                            | 完成 |\n| ------------------------ | ------------------------------- | ---- |\n| 哈希表的查找、插入及删除 | 🟢706. 设计哈希映射              | ✅    |\n|                          | 🟢 217. 存在重复元素             | ✅    |\n|                          | 🟢349. 两个数组的交集            | ✅    |\n|                          | 🟡128. 最长连续序列              | ✅    |\n|                          | 🟢290. 单词规律                  | ✅    |\n|                          | 🟡532. 数组中的 k-diff 数对      | ✅    |\n|                          | 🟢 205. 同构字符串               | ✅    |\n|                          | 🟡138. 复制带随机指针的链表      |      |\n| 哈希表与索引             | 🟢1. 两数之和                    | ✅    |\n|                          | 🟢599. 两个列表的最小索引总和    | ✅    |\n|                          | 🟢219. 存在重复元素 II           | ✅    |\n| 哈希表与统计             | 🟢594. 最长和谐子序列            | ✅    |\n|                          | 🟢350. 两个数组的交集 II         | ✅    |\n|                          | 🟡 554. 砖墙                     | ✅    |\n|                          | 🟡609. 在系统中查找重复文件      | ✅    |\n|                          | 🟡454. 四数相加 II               | ✅    |\n| 哈希表与前缀和           | 🟡560. 和为 K 的子数组           | ✅    |\n|                          | 🟡523. 连续的子数组和            | ✅    |\n|                          | 🟡525. 连续数组                  |      |\n| 其他                     | 🟢242.有效的字母异位词           | ✅    |\n|                          | 🟢383.赎金信                     | ✅    |\n|                          | 🟡49.字母异位词分组              | ✅    |\n|                          | 🟡438.找到字符串中所有字母异位词 | ✅    |\n|                          | 🟢202. 快乐数                    | ✅    |\n|                          | 🟡15. 三数之和                   | ✅    |\n|                          | 🟡18. 四数之和                   | ✅    |\n\n#  哈希表的查找、插入及删除\n\n## 🟢706. 设计哈希映射\n\n> 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。\n>\n> 实现 `MyHashMap` 类：\n>\n> - `MyHashMap()` 用空映射初始化对象\n> - `void put(int key, int value)` 向 HashMap 插入一个键值对 `(key, value)` 。如果 `key` 已经存在于映射中，则更新其对应的值 `value` 。\n> - `int get(int key)` 返回特定的 `key` 所映射的 `value` ；如果映射中不包含 `key` 的映射，返回 `-1` 。\n> - `void remove(key)` 如果映射中存在 `key` 的映射，则移除 `key` 和它所对应的 `value` 。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> [\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n> [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n> 输出：\n> [null, null, null, 1, -1, null, 1, null, -1]\n> \n> 解释：\n> MyHashMap myHashMap = new MyHashMap();\n> myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]\n> myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]\n> myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]\n> myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]\n> myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）\n> myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]\n> myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]\n> myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= key, value <= 106`\n> - 最多调用 `104` 次 `put`、`get` 和 `remove` 方法\n>\n> Related Topics\n>\n> 设计\n>\n> 数组\n>\n> 哈希表\n>\n> 链表\n>\n> 哈希函数\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass MyHashMap {\n    List<Integer> keyList;\n    List<Integer>valueList;\n\n    public MyHashMap() {\n        this.keyList=new ArrayList<>();\n        this.valueList=new ArrayList<>();\n    }\n\n    public void put(int key, int value) {\n        if(!keyList.contains(key)){\n            this.keyList.add(key);\n            this.valueList.add(value);\n        }else {\n            int index=this.keyList.indexOf(key);\n            this.valueList.set(index,value);\n        }\n    }\n\n    public int get(int key) {\n        if(!keyList.contains(key)){\n            return -1;\n        }else {\n            int index=this.keyList.indexOf(key);\n            return this.valueList.get(index);\n        }\n    }\n\n    public void remove(int key) {\n        if(this.keyList.contains(key)){\n            int index=this.keyList.indexOf(key);\n            this.keyList.remove(index);\n            this.valueList.remove(index);\n        }\n    }\n}\n```\n\n- time:*O(1)*\n- space:*O(n)*\n\n## 🟢 217. 存在重复元素\n\n> 给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,1,1,3,3,4,3,2,4,2]\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(set.contains(nums[i])){\n                return true;\n            }\n            set.add(nums[i]);\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢349. 两个数组的交集 \n\n> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[9,4]\n> 解释：[4,9] 也是可通过的\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer>list=new ArrayList<>();\n        int[]hashtable=new int[10001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(hashtable[nums2[i]]>0){\n                hashtable[nums2[i]]=0;\n                list.add(nums2[i]);\n            }\n        }\n        int size= list.size();\n        int[]res=new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i]=list.get(i);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡128. 最长连续序列\n\n> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n>\n> 请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [100,4,200,1,3,2]\n> 输出：4\n> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,3,7,2,5,8,4,6,0,1]\n> 输出：9\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 并查集\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length==0){\n            return 0;\n        }\n        Arrays.sort(nums);\n        int res=1,cnt=1,last=nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if(nums[i]-last==1){\n                cnt++;\n            }else if(nums[i]==last) {\n                continue;\n            }else {\n                cnt=1;\n            }\n            res=Math.max(res,cnt);\n            last=nums[i];\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(1)*\n\n## 🟢290. 单词规律 \n\n> 给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。\n>\n> 这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。\n>\n> \n>\n> **示例1:**\n>\n> ```\n> 输入: pattern = \"abba\", s = \"dog cat cat dog\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入:pattern = \"abba\", s = \"dog cat cat fish\"\n> 输出: false\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: pattern = \"aaaa\", s = \"dog cat cat dog\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= pattern.length <= 300`\n> - `pattern` 只包含小写英文字母\n> - `1 <= s.length <= 3000`\n> - `s` 只包含小写英文字母和 `' '`\n> - `s` **不包含** 任何前导或尾随对空格\n> - `s` 中每个单词都被 **单个空格** 分隔\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String s) {\n        String[]splited=s.split(\"[ ]\");\n        List<String> list=new ArrayList<>();\n        for (int i = 0; i < splited.length; i++) {\n            if(splited[i]!=\"\"){\n                list.add(splited[i]);\n            }\n        }\n        if(pattern.length()!=list.size()){\n            return false;\n        }\n        Map<Character,String> map=new TreeMap<>();\n        for (int i = 0; i < pattern.length(); i++) {\n            if(map.containsKey(pattern.charAt(i))){\n                if(!map.get(pattern.charAt(i)).equals(list.get(i))){\n                    return false;\n                }\n            }else if(map.containsValue(list.get(i))){\n                return false;\n            }else {\n                map.put(pattern.charAt(i),list.get(i));\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡532. 数组中的 k-diff 数对\n\n> 给你一个整数数组 `nums` 和一个整数 `k`，请你在数组中找出 **不同的** k-diff 数对，并返回不同的 **k-diff 数对** 的数目。\n>\n> **k-diff** 数对定义为一个整数对 `(nums[i], nums[j])` ，并满足下述全部条件：\n>\n> - `0 <= i, j < nums.length`\n> - `i != j`\n> - `|nums[i] - nums[j]| == k`\n>\n> **注意**，`|val|` 表示 `val` 的绝对值。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3, 1, 4, 1, 5], k = 2\n> 输出：2\n> 解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n> 尽管数组中有两个 1 ，但我们只应返回不同的数对的数量。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1, 2, 3, 4, 5], k = 1\n> 输出：4\n> 解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1, 3, 1, 5, 4], k = 0\n> 输出：1\n> 解释：数组中只有一个 0-diff 数对，(1, 1) 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-107 <= nums[i] <= 107`\n> - `0 <= k <= 107`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        Arrays.sort(nums);\n        Set<String>set=new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if(nums[j]-nums[i]==k){\n                    set.add(nums[i]+\" \"+nums[j]);\n                }else if(nums[j]-nums[i]>k){\n                    break;\n                }\n            }\n        }\n        return set.size();\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n^2^)*\n\n```java\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        if(nums.length==1){\n            return 0;\n        }\n        Arrays.sort(nums);\n        int cnt=0;\n        int slow=0,fast=slow+1;\n        while (fast< nums.length){\n            if(slow== nums.length-1){\n                break;\n            }\n            int sub=nums[fast]-nums[slow];\n            if(sub==k){\n                cnt++;\n                slow++;\n                while (slow>0&&slow+1<nums.length&&nums[slow]==nums[slow-1]){//和之前的相同就前进\n                    slow++;\n                }\n                fast=slow+1;\n                while (fast+1<nums.length&&nums[fast+1]==nums[fast]){//和之后相同就前进\n                    fast++;\n                }\n            }else if(sub<k){\n                fast++;\n                while (fast+1<nums.length&&nums[fast+1]==nums[fast]){//和之后相同就前进\n                    fast++;\n                }\n            }else if(sub>k){\n                slow++;\n                while (slow+1<nums.length&&nums[slow+1]==nums[slow]){//和之后相同就前进\n                    slow++;\n                }\n                fast=slow+1;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(1)*\n\n## 🟢 205. 同构字符串\n\n> 给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。\n>\n> 如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。\n>\n> 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入：s = \"egg\", t = \"add\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"foo\", t = \"bar\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"paper\", t = \"title\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - `1 <= s.length <= 5 * 104`\n> - `t.length == s.length`\n> - `s` 和 `t` 由任意有效的 ASCII 字符组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if(s.length()!=t.length()){\n            return false;\n        }\n        Map<Character,Character>map=new TreeMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(map.containsKey(s.charAt(i))){\n                if(map.get(s.charAt(i))!=t.charAt(i)){\n                    return false;\n                }\n            } else if (map.containsValue(t.charAt(i))) {\n                return false;\n            }else{\n                map.put(s.charAt(i),t.charAt(i));\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡138. 复制带随机指针的链表\n\n> 给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n>\n> 构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。\n>\n> 例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。\n>\n> 返回复制链表的头节点。\n>\n> 用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n>\n> - `val`：一个表示 `Node.val` 的整数。\n> - `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。\n>\n> 你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)\n>\n> ```\n> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)\n>\n> ```\n> 输入：head = [[1,1],[2,1]]\n> 输出：[[1,1],[2,1]]\n> ```\n>\n> **示例 3：**\n>\n> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**\n>\n> ```\n> 输入：head = [[3,null],[3,0],[3,null]]\n> 输出：[[3,null],[3,0],[3,null]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= n <= 1000`\n> - `-104 <= Node.val <= 104`\n> - `Node.random` 为 `null` 或指向链表中的节点。\n>\n> \n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n\n```java\n```\n\n\n\n# 哈希表与索引\n\n## 🟢1. 两数之和 \n\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n>\n> 你可以按任意顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,4], target = 6\n> 输出：[1,2]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,3], target = 6\n> 输出：[0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 104`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n> - **只会存在一个有效答案**\n>\n> \n>\n> **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n       Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(map.containsKey(target-nums[i])&&map.get(target-nums[i])!=i){\n                return new int[]{i,map.get(target-nums[i])};\n            }\n            map.put(nums[i],i);\n        }\n        return null;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢599. 两个列表的最小索引总和 \n\n> 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。\n>\n> 你需要帮助他们用**最少的索引和**找出他们**共同喜爱的餐厅**。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n> 输出: [\"Shogun\"]\n> 解释: 他们唯一共同喜爱的餐厅是“Shogun”。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入:list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"KFC\", \"Shogun\", \"Burger King\"]\n> 输出: [\"Shogun\"]\n> 解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= list1.length, list2.length <= 1000`\n> - `1 <= list1[i].length, list2[i].length <= 30`\n> - `list1[i]` 和 `list2[i]` 由空格 `' '` 和英文字母组成。\n> - `list1` 的所有字符串都是 **唯一** 的。\n> - `list2` 中的所有字符串都是 **唯一** 的。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        Map<String,Integer> map=new HashMap<>();\n        Queue<String> heap=new PriorityQueue<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return map.get(o1)-map.get(o2);\n            }\n        });\n        for (int i = 0; i < list1.length; i++) {\n            map.put(list1[i],i);\n        }\n        for (int i = 0; i < list2.length; i++) {\n            if(map.containsKey(list2[i])){\n                map.put(list2[i],map.get(list2[i])+i);\n                heap.offer(list2[i]);\n            }\n        }\n        int min= map.get(heap.peek());\n        List<String>list=new ArrayList<>();\n        while (!heap.isEmpty()){\n            if(map.get(heap.peek())==min){\n                list.add(heap.poll());\n            }else {\n                break;\n            }\n        }\n        String[] res=new String[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            res[i]=list.get(i);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n log n)*\n- space:*O(n)*\n\n## 🟢219. 存在重复元素 II\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1], k = 3\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,0,1,1], k = 1\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,3,1,2,3], k = 2\n> 输出：false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n> - `0 <= k <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(map.containsKey(nums[i])&&i-map.get(nums[i])<=k){\n                return true;\n            }\n            map.put(nums[i],i);\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n#  哈希表与统计\n\n## 🟢594. 最长和谐子序列 \n\n> 和谐数组是指一个数组里元素的最大值和最小值之间的差别 **正好是 `1`** 。\n>\n> 现在，给你一个整数数组 `nums` ，请你在所有可能的子序列中找到最长的和谐子序列的长度。\n>\n> 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,2,2,5,2,3,7]\n> 输出：5\n> 解释：最长的和谐子序列是 [3,2,2,2,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4]\n> 输出：2\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,1,1,1]\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 2 * 104`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 计数\n>\n> 排序\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int findLHS(int[] nums) {\n        Map<Integer,Integer> map=new HashMap<>();\n        int max=0;\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\n        }\n        for (int key:map.keySet()) {\n            if(map.containsKey(key-1)){\n                max=Math.max(max,map.get(key)+ map.get(key-1));\n            }\n            if(map.containsKey(key+1)){\n                max=Math.max(max,map.get(key)+ map.get(key+1));\n            }\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢350. 两个数组的交集 II\n\n> 给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2,2]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[4,9]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> \n>\n> ***\\*进阶\\**：**\n>\n> - 如果给定的数组已经排好序呢？你将如何优化你的算法？\n> - 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？\n> - 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        List<Integer>list=new ArrayList<>();\n        int[]hashtable=new int[1001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(hashtable[nums2[i]]>0){\n                hashtable[nums2[i]]--;\n                list.add(nums2[i]);\n            }\n        }\n        int size= list.size();\n        int[]res=new int[size];\n        for (int i = 0; i < list.size(); i++) {\n            res[i]=list.get(i);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡 554. 砖墙\n\n> 你的面前有一堵矩形的、由 `n` 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。\n>\n> 你现在要画一条 **自顶向下** 的、穿过 **最少** 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。**你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。**\n>\n> 给你一个二维数组 `wall` ，该数组包含这堵墙的相关信息。其中，`wall[i]` 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 **穿过的砖块数量最少** ，并且返回 **穿过的砖块数量** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg)\n>\n> ```\n> 输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：wall = [[1],[1],[1]]\n> 输出：3\n> ```\n>\n> **提示：**\n>\n> - `n == wall.length`\n> - `1 <= n <= 104`\n> - `1 <= wall[i].length <= 104`\n> - `1 <= sum(wall[i].length) <= 2 * 104`\n> - 对于每一行 `i` ，`sum(wall[i])` 是相同的\n> - `1 <= wall[i][j] <= 231 - 1`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        int n=wall.size();\n        int num=0;\n        for (int i = 0; i < wall.get(0).size(); i++) {\n            num+=wall.get(0).get(i);\n        }\n        Map<Integer,Integer> map=new HashMap<>();\n        int max=0;\n        for (int i = 0; i < n; i++) {\n            int pos=0;\n            for (int j = 0; j < wall.get(i).size(); j++) {\n                int key=pos+wall.get(i).get(j);\n                if(key!=num){\n                    map.put(key,map.getOrDefault(key,0)+1);\n                    max=Math.max(max,map.get(key));\n                }\n                pos+=wall.get(i).get(j);\n            }\n        }\n        return n-max;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(arr_sum)*\n\n## 🟡609. 在系统中查找重复文件 \n\n> 给你一个目录信息列表 `paths` ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 **任意顺序** 返回。\n>\n> 一组重复的文件至少包括 **两个** 具有完全相同内容的文件。\n>\n> **输入** 列表中的单个目录信息字符串的格式如下：\n>\n> - `\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"`\n>\n> 这意味着，在目录 `root/d1/d2/.../dm` 下，有 `n` 个文件 ( `f1.txt`, `f2.txt` ... `fn.txt` ) 的内容分别是 ( `f1_content`, `f2_content` ... `fn_content` ) 。注意：`n >= 1` 且 `m >= 0` 。如果 `m = 0` ，则表示该目录是根目录。\n>\n> **输出** 是由 **重复文件路径组** 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：\n>\n> - `\"directory_path/file_name.txt\"`\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n> 输出：[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n> 输出：[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= paths.length <= 2 * 104`\n> - `1 <= paths[i].length <= 3000`\n> - `1 <= sum(paths[i].length) <= 5 * 105`\n> - `paths[i]` 由英文字母、数字、字符 `'/'`、`'.'`、`'('`、`')'` 和 `' '` 组成\n> - 你可以假设在同一目录中没有任何文件或目录共享相同的名称。\n> - 你可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用单个空格分隔。\n>\n> \n>\n> **进阶：**\n>\n> - 假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？\n> - 如果文件内容非常大（GB级别），您将如何修改您的解决方案？\n> - 如果每次只能读取 1 kb 的文件，您将如何修改解决方案？\n> - 修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？\n> - 如何确保您发现的重复文件不是误报？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public List<List<String>> findDuplicate(String[] paths) {\n        List<List<String>>res=new ArrayList<>();\n        Map<String,Integer> map=new HashMap<>();\n        List<String>new_paths=new ArrayList<>();\n        for (int i = 0; i < paths.length; i++) {\n            String[]splited=paths[i].split(\"[ ]\");\n            String pre=splited[0];\n            for (int j = 1; j < splited.length; j++) {\n                new_paths.add(pre+\"/\"+splited[j]);\n            }\n        }\n        for (int i = 0; i < new_paths.size(); i++) {\n            String key=new_paths.get(i).split(\"[()]\")[1];\n            if(!map.containsKey(key)){\n                map.put(key,map.size());\n                List<String>list=new ArrayList<>();\n                list.add(new_paths.get(i).split(\"[()]\")[0]);\n                res.add(list);\n            }else {\n                res.get(map.get(key)).add(new_paths.get(i).split(\"[()]\")[0]);\n            }\n        }\n        int index=0;\n        while (index<res.size()){\n            if(res.get(index).size()<2){\n                res.remove(index);\n            }else {\n                index++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n##  🟡454. 四数相加 II\n\n> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：\n>\n> - `0 <= i, j, k, l < n`\n> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n> 输出：2\n> 解释：\n> 两个元组如下：\n> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums1.length`\n> - `n == nums2.length`\n> - `n == nums3.length`\n> - `n == nums4.length`\n> - `1 <= n <= 200`\n> - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        Map<Integer,Integer> map=new HashMap<>();\n        int cnt=0;\n        for (int i = 0; i < nums1.length; i++) {\n            for (int j = 0; j < nums2.length; j++) {\n                int key=nums1[i]+nums2[j];\n                map.put(key,map.getOrDefault(key,0)+1);\n            }\n        }\n        for (int i = 0; i < nums3.length; i++) {\n            for (int j = 0; j < nums4.length; j++) {\n                int key=nums3[i]+nums4[j];\n                if(map.containsKey(-key)){\n                    cnt+=map.get(-key);\n                }\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n)*\n\n#  哈希表与前缀和\t\n\n## 🟡560. 和为 K 的子数组 \n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。\n>\n> 子数组是数组中元素的连续非空序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,1], k = 2\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3], k = 3\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 2 * 104`\n> - `-1000 <= nums[i] <= 1000`\n> - `-107 <= k <= 107`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 前缀和\n\n```java\nclass Solution {\n    public int subarraySum(int[] nums, int k) {\n        Map<Integer,Integer>map=new HashMap<>();\n        map.put(0,1);\n        int preSum=0;\n        int cnt=0;\n        for (int i = 0; i < nums.length; i++) {\n            preSum+=nums[i];\n            if(map.containsKey(preSum-k)){\n                cnt+=map.get(preSum-k);\n            }\n            map.put(preSum,map.getOrDefault(preSum,0)+1);\n        }\n        return cnt;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡523. 连续的子数组和 \n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n>\n> - 子数组大小 **至少为 2** ，且\n> - 子数组元素总和为 `k` 的倍数。\n>\n> 如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> 如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` 始终视为 `k` 的一个倍数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [23,2,4,6,7], k = 6\n> 输出：true\n> 解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [23,2,6,4,7], k = 6\n> 输出：true\n> 解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n> 42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [23,2,6,4,7], k = 13\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `0 <= nums[i] <= 109`\n> - `0 <= sum(nums[i]) <= 231 - 1`\n> - `1 <= k <= 231 - 1`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 数学\n>\n> 前缀和\n\n```java\nclass Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        map.put(0,-1);\n        int preSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            preSum += nums[i];\n            int key = preSum % k;\n            if (map.containsKey(key)) {\n                if (i - map.get(key) >= 2) {\n                    return true;\n                }\n                continue;\n            }\n            map.put(key,i);\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡525. 连续数组\n\n> 给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1]\n> 输出: 2\n> 说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0,1,0]\n> 输出: 2\n> 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `nums[i]` 不是 `0` 就是 `1`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 前缀和\n\n```java\n```\n\n# 其他\n\n## 🟢242.有效的字母异位词\n\n> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。\n>\n> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"anagram\", t = \"nagaram\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"rat\", t = \"car\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, t.length <= 5 * 104`\n> - `s` 和 `t` 仅包含小写字母\n>\n> \n>\n> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length()){\n            return false;\n        }\n        int[]hashtable=new int[26];      \n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[t.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtable[i]!=0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n##  🟢383.赎金信\n\n> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n>\n> 如果可以，返回 `true` ；否则返回 `false` 。\n>\n> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ransomNote = \"a\", magazine = \"b\"\n> 输出：false\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"ab\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"aab\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= ransomNote.length, magazine.length <= 105`\n> - `ransomNote` 和 `magazine` 由小写英文字母组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        if(ransomNote.length()>magazine.length()){\n            return false;\n        }\n        int[] hashtable =new int[26];\n        for (int i = 0; i < ransomNote.length(); i++) {\n            hashtable[ransomNote.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < magazine.length(); i++) {\n            hashtable[magazine.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtable[i]>0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡49.字母异位词分组\n\n> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n>\n> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n> 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: strs = [\"\"]\n> 输出: [[\"\"]]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: strs = [\"a\"]\n> 输出: [[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 104`\n> - `0 <= strs[i].length <= 100`\n> - `strs[i]` 仅包含小写字母\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String,List> res=new HashMap<>();\n        for (String s: strs) {\n            char[]ca= s.toCharArray();\n            Arrays.sort(ca);\n            String key=String.valueOf(ca);\n            if(!res.containsKey(key)){\n                res.put(key,new ArrayList<>());\n            }\n            res.get(key).add(s);\n        }\n        return new ArrayList(res.values());\n    }\n}\n```\n\n- time:*O(n·m·log·m)*\n- space:*O(n)*\n\n##  🟡438.找到字符串中所有字母异位词\n\n> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n>\n> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"cbaebabacd\", p = \"abc\"\n> 输出: [0,6]\n> 解释:\n> 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n> 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"abab\", p = \"ab\"\n> 输出: [0,1,2]\n> 解释:\n> 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n> 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n> 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, p.length <= 3 * 104`\n> - `s` 和 `p` 仅包含小写字母\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res=new ArrayList<Integer>();\n        if(s.length()<p.length()){\n            return res;\n        }\n        int []hashtable=new int[26];\n        for (int i = 0; i < p.length(); i++) {\n            hashtable[p.charAt(i)-'a']++;\n        }\n        int index=0;\n        while(index-p.length()<=s.length()){\n            int []temp=hashtable.clone();\n            for (int i = index; i < index+p.length()&&i<s.length(); i++) {\n                temp[s.charAt(i)-'a']--;\n            }\n            int flag=1;\n            for (int i = 0; i < 26; i++) {\n                if(temp[i]!=0){\n                    flag=0;\n                }\n            }\n            if(flag==1){\n                res.add(index);\n            }\n            index++;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢202. 快乐数\n\n> 编写一个算法来判断一个数 `n` 是不是快乐数。\n>\n> **「快乐数」** 定义为：\n>\n> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。\n> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。\n>\n> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 19\n> 输出：true\n> 解释：\n> 12 + 92 = 82\n> 82 + 22 = 68\n> 62 + 82 = 100\n> 12 + 02 + 02 = 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 2\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 231 - 1`\n>\n> Related Topics\n>\n> 哈希表\n>\n> 数学\n>\n> 双指针\n\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        if(n==1){\n            return true;\n        }\n        Set<Integer> set=new HashSet<>();\n        while(true){\n            int sum=0;\n            while(n>0){\n                sum+=(n%10)*(n%10);\n                n/=10;\n            }\n            if(sum==1){\n                return true;\n            }else if(set.contains(sum)){\n                return false;\n            }else{\n                set.add(sum);\n                n=sum;\n                sum=0;\n            }\n        }\n    }\n}\n```\n\n- time:*O(log n)*\n- space:*O(n)*\n\n##  🟡15. 三数之和\n\n> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n>\n> 你返回所有和为 `0` 且不重复的三元组。\n>\n> **注意：**答案中不可以包含重复的三元组。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-1,0,1,2,-1,-4]\n> 输出：[[-1,-1,2],[-1,0,1]]\n> 解释：\n> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\n> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\n> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n> 注意，输出的顺序和三元组的顺序并不重要。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,1]\n> 输出：[]\n> 解释：唯一可能的三元组和不为 0 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [0,0,0]\n> 输出：[[0,0,0]]\n> 解释：唯一可能的三元组和为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= nums.length <= 3000`\n> - `-105 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<String>set=new TreeSet<>();\n        List<List<Integer>>res=new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if(Arrays.binarySearch(nums,0-nums[i]-nums[j])>=0&&\n                        Arrays.binarySearch(nums,0-nums[i]-nums[j])!=i&&\n                        Arrays.binarySearch(nums,0-nums[i]-nums[j])!=j){\n                    int k=Arrays.binarySearch(nums,0-nums[i]-nums[j]);\n                    int[]arr_=new int[3];\n                    arr_[0]=nums[i];\n                    arr_[1]=nums[j];\n                    arr_[2]=nums[k];\n                    Arrays.sort(arr_);\n                    String key=arr_[0]+\"\"+arr_[1]+\"\"+arr_[2];\n                    if(!set.contains(key)){\n                        List<Integer> al=new ArrayList<>();\n                        set.add(key);\n                        al.add(arr_[0]);\n                        al.add(arr_[1]);\n                        al.add(arr_[2]);\n                        res.add(al);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^2^·log n)*\n- space:*O(n)*\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>>res=new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length-2; i++) {\n            while (i!=0&&i<nums.length&&nums[i]==nums[i-1]){\n                i++;\n            }\n            if(i==nums.length||nums[i]>0){\n                return res;\n            }\n            int left=i+1,right=nums.length-1;\n            while (left<right){\n                int sum=nums[i]+nums[left]+nums[right];\n                if(sum<0){\n                    left++;\n                }else if(sum>0){\n                    right--;\n                }else {\n                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));\n                    while (left+1<right&&nums[left+1]==nums[left]){\n                        left++;\n                    }\n                    while (right-1>left&&nums[right-1]==nums[right]){\n                        right--;\n                    }\n                    left++;\n                    right--;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(1)*\n\n## 🟡18. 四数之和\n\n> 给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：\n>\n> - `0 <= a, b, c, d < n`\n> - `a`、`b`、`c` 和 `d` **互不相同**\n> - `nums[a] + nums[b] + nums[c] + nums[d] == target`\n>\n> 你可以按 **任意顺序** 返回答案 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,0,-1,0,-2,2], target = 0\n> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,2,2,2,2], target = 8\n> 输出：[[2,2,2,2]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 200`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        int len= nums.length;\n        List<List<Integer>>res=new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < len; i++) {\n            if(nums[i]>0&&nums[i]>target){\n                return res;\n            }\n            while(i>0&&i<len&&nums[i]==nums[i-1]){\n                i++;\n            }\n            for (int j = i+1; j < len; j++) {\n                while(j>i+1&&j<len&&nums[j]==nums[j-1]){\n                    j++;\n                }\n                int left=j+1;\n                int right=len-1;\n                while(left<right){\n                    long sum=(long)nums[i]+nums[j]+nums[left]+nums[right];\n                    if(sum<target){\n                        left++;\n                    } else if (sum>target) {\n                        right--;\n                    }else{\n                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));\n                        while(left<right&&nums[left]==nums[left+1]){\n                            left++;\n                        }\n                        while(left<right&&nums[right]==nums[right-1]){\n                            right--;\n                        }\n                        left++;\n                        right--;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^3^)*\n- space:*O(1)*\n","categories":["algorithm learning"]},{"title":"Linked List","url":"/2023/09/02/algorithm-linkedlist/","content":"\n| 分类               | 题号                             | 完成 |\n| ------------------ | -------------------------------- | ---- |\n| 移除与插入链表元素 | 🟡707. 设计链表                   | ✅    |\n|                    | 🟢203. 移除链表元素               | ✅    |\n|                    | 🟡237. 删除链表中的节点           | ✅    |\n|                    | 🟡19. 删除链表的倒数第 N 个结点   | ✅    |\n|                    | 🟢83. 删除排序链表中的重复元素    | ✅    |\n|                    | 🟡82. 删除排序链表中的重复元素 II | ✅    |\n| 链表的遍历         | ☂️🟡430. 扁平化多级双向链表        | ✅    |\n|                    | 🟡114. 二叉树展开为链表           | ✅    |\n| 链表的旋转与反转   | 🟡61. 旋转链表                    | ✅    |\n|                    | 🟡24. 两两交换链表中的节点        | ✅    |\n|                    | 🟢206. 反转链表                   | ✅    |\n|                    | 🟡92. 反转链表 II                 | ✅    |\n|                    | 🔴25. K 个一组翻转链表            |      |\n| 链表高精度加法     | 🟡2. 两数相加                     | ✅    |\n|                    | 🟡445. 两数相加 II                | ✅    |\n| 链表的合并         | 🟢21. 合并两个有序链表            | ✅    |\n|                    | 🔴23. 合并K个升序链表             | ✅    |\n| 链表中的双指针技巧 | 🟡86. 分隔链表                    | ✅    |\n|                    | 🟡19. 删除链表的倒数第 N 个结点   | ✅    |\n|                    | 🟢141. 环形链表                   | ✅    |\n|                    | 🟡142. 环形链表 II                | ✅    |\n|                    | 🟢876. 链表的中间结点             | ✅    |\n|                    | 🟡143. 重排链表                   | ✅    |\n|                    | 🟢160. 相交链表                   | ✅    |\n\n# 移除与插入链表元素\n\n## 🟡707. 设计链表 \n\n> 你可以选择使用单链表或者双链表，设计并实现自己的链表。\n>\n> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。\n>\n> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。\n>\n> 实现 `MyLinkedList` 类：\n>\n> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。\n> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。\n> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\n> - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。\n> - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。\n> - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入\n> [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n> [[], [1], [3], [1, 2], [1], [1], [1]]\n> 输出\n> [null, null, null, null, 2, null, 3]\n> \n> 解释\n> MyLinkedList myLinkedList = new MyLinkedList();\n> myLinkedList.addAtHead(1);\n> myLinkedList.addAtTail(3);\n> myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3\n> myLinkedList.get(1);              // 返回 2\n> myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3\n> myLinkedList.get(1);              // 返回 3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= index, val <= 1000`\n> - 请不要使用内置的 LinkedList 库。\n> - 调用 `get`、`addAtHead`、`addAtTail`、`addAtIndex` 和 `deleteAtIndex` 的次数不超过 `2000` 。\n>\n> Related Topics\n>\n> 设计\n>\n> 链表\n\n```java\nclass ListNode{\n    int val;\n    ListNode next;\n    ListNode(int val){\n        this.val=val;\n    }\n}\nclass MyLinkedList {\n    ListNode head;\n    int size;\n\n    public MyLinkedList() {\n        this.head=null;\n        this.size=0;\n    }\n    \n    public int get(int index) {\n        if(index<0||index>=this.size){\n            return -1;\n        }else {\n            ListNode ptr=this.head;\n            int i=0;\n            while (i<index){//i指向index节点\n                ptr=ptr.next;\n                i++;\n            }\n            return ptr.val;\n        }\n    }\n\n    public void addAtHead(int val) {\n        ListNode node=new ListNode(val);\n        if(this.head!=null) {\n            node.next = this.head;\n        }\n        this.head=node;\n        this.size++;\n    }\n\n    public void addAtTail(int val) {\n        ListNode node=new ListNode(val);\n        if(this.head==null){\n            this.head=node;\n        }else {\n            ListNode ptr=this.head;\n            int i=0;\n            while (i<this.size-1){//i指向最后节点\n                ptr=ptr.next;\n                i++;\n            }\n            ptr.next=node;\n        }\n        this.size++;\n    }\n\n    public void addAtIndex(int index, int val) {\n        if(index>this.size||index<0){\n            return;\n        } else if(index==this.size){\n            addAtTail(val);\n        }else if(index==0){\n            addAtHead(val);\n        }else {\n            int i=0;\n            ListNode ptr=this.head;\n            while (i<index-1){//i指向index之前一个节点\n                ptr=ptr.next;\n                i++;\n            }\n            ListNode node=new ListNode(val);\n            node.next=ptr.next;\n            ptr.next=node;\n            this.size++;\n        }\n    }\n\n    public void deleteAtIndex(int index) {\n        if(index<0||index>=this.size){\n            return;\n        }else if(index==0){\n            this.head=this.head.next;\n            this.size--;\n        } else {\n            int i=0;\n            ListNode ptr=this.head;\n            while (i<index-1){//i指向index之前一个节点\n                ptr=ptr.next;\n                i++;\n            }\n            ptr.next=ptr.next.next;\n            this.size--;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n```java\nclass MyLinkedList {\n    int size;\n    ListNode head;\n\n    public MyLinkedList() {\n        size = 0;\n        head = new ListNode(0);\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n\n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        index = Math.max(0, index);\n        size++;\n        ListNode pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        ListNode toAdd = new ListNode(val);\n        toAdd.next = pred.next;\n        pred.next = toAdd;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        size--;\n        ListNode pred = head;\n        for (int i = 0; i < index; i++) {\n            pred = pred.next;\n        }\n        pred.next = pred.next.next;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    public ListNode(int val) {\n        this.val = val;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢203. 移除链表元素\n\n> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)\n>\n> ```\n> 输入：head = [1,2,6,3,4,5,6], val = 6\n> 输出：[1,2,3,4,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [], val = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [7,7,7,7], val = 7\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 列表中的节点数目在范围 `[0, 104]` 内\n> - `1 <= Node.val <= 50`\n> - `0 <= val <= 50`\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        while(head!=null&&head.val==val){\n            head=head.next;\n        }\n        ListNode p=head;\n        while(p!=null){\n            while(p.next!=null&&p.next.val==val){\n                p.next=p.next.next;\n            }\n            p=p.next;\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡237. 删除链表中的节点 \n\n> 有一个单链表的 `head`，我们想删除它其中的一个节点 `node`。\n>\n> 给你一个需要删除的节点 `node` 。你将 **无法访问** 第一个节点 `head`。\n>\n> 链表的所有值都是 **唯一的**，并且保证给定的节点 `node` 不是链表中的最后一个节点。\n>\n> 删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：\n>\n> - 给定节点的值不应该存在于链表中。\n> - 链表中的节点数应该减少 1。\n> - `node` 前面的所有值顺序相同。\n> - `node` 后面的所有值顺序相同。\n>\n> **自定义测试：**\n>\n> - 对于输入，你应该提供整个链表 `head` 和要给出的节点 `node`。`node` 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。\n> - 我们将构建链表，并将节点传递给你的函数。\n> - 输出将是调用你函数后的整个链表。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)\n>\n> ```\n> 输入：head = [4,5,1,9], node = 5\n> 输出：[4,1,9]\n> 解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)\n>\n> ```\n> 输入：head = [4,5,1,9], node = 1\n> 输出：[4,5,9]\n> 解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[2, 1000]`\n> - `-1000 <= Node.val <= 1000`\n> - 链表中每个节点的值都是 **唯一** 的\n> - 需要删除的节点 `node` 是 **链表中的节点** ，且 **不是末尾节点**\n>\n> Related Topics\n>\n> 链表\n\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val=node.next.val;\n        node.next=node.next.next;\n    }\n}\n```\n\n\n\n##  🟡19. 删除链表的倒数第 N 个结点 \n\n> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [1], n = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1,2], n = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中结点的数目为 `sz`\n> - `1 <= sz <= 30`\n> - `0 <= Node.val <= 100`\n> - `1 <= n <= sz`\n>\n> \n>\n> **进阶：**你能尝试使用一趟扫描实现吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head.next==null){\n            return null;\n        }\n        ListNode fast=head,slow=fast;\n        for (int i = 0; i < n; i++) {\n            fast=fast.next;\n        }\n        if(fast==null){\n            return head.next;\n        }else {\n            fast=fast.next;\n            while (fast!=null){\n                slow=slow.next;\n                fast=fast.next;\n            }\n            slow.next=slow.next.next;\n            return head;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢83. 删除排序链表中的重复元素 \n\n> 给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n>\n> ```\n> 输入：head = [1,1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n>\n> ```\n> 输入：head = [1,1,2,3,3]\n> 输出：[1,2,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n>\n> Related Topics\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode ptr = head;\n        while(ptr != null && ptr.next != null) {\n            if(ptr.val == ptr.next.val) {\n                ptr.next = ptr.next.next;\n            } else {\n                ptr = ptr.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡82. 删除排序链表中的重复元素 II\n\n> 给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,3,4,4,5]\n> 输出：[1,2,5]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n>\n> ```\n> 输入：head = [1,1,1,2,3]\n> 输出：[2,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            if (cur.next.val == cur.next.next.val) {\n                int x = cur.next.val;\n                while (cur.next != null && cur.next.val == x) {\n                    cur.next = cur.next.next;\n                }\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n#  链表的遍历\n\n## 🟡430. 扁平化多级双向链表 \n\n> 你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 **子指针** 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 **多层数据结构** 。\n>\n> 给定链表的头节点 head ，将链表 **扁平化** ，以便所有节点都出现在单层双链表中。让 `curr` 是一个带有子列表的节点。子列表中的节点应该出现在**扁平化列表**中的 `curr` **之后** 和 `curr.next` **之前** 。\n>\n> 返回 *扁平列表的 `head` 。列表中的节点必须将其 **所有** 子指针设置为 `null` 。*\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n> 输出：[1,2,3,7,8,11,12,9,10,4,5,6]\n> 解释：输入的多级列表如上图所示。\n> 扁平化后的链表如下图：\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg)\n>\n> ```\n> 输入：head = [1,2,null,3]\n> 输出：[1,3,2]\n> 解释：输入的多级列表如上图所示。\n> 扁平化后的链表如下图：\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> 说明：输入中可能存在空列表。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 节点数目不超过 `1000`\n> - `1 <= Node.val <= 105`\n>\n> \n>\n> **如何表示测试用例中的多级链表？**\n>\n> 以 **示例 1** 为例：\n>\n> ```\n>  1---2---3---4---5---6--NULL\n>          |\n>          7---8---9---10--NULL\n>              |\n>              11--12--NULL\n> ```\n>\n> 序列化其中的每一级之后：\n>\n> ```\n> [1,2,3,4,5,6,null]\n> [7,8,9,10,null]\n> [11,12,null]\n> ```\n>\n> 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。\n>\n> ```\n> [1,2,3,4,5,6,null]\n> [null,null,7,8,9,10,null]\n> [null,11,12,null]\n> ```\n>\n> 合并所有序列化结果，并去除末尾的 null 。\n>\n> ```\n> [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n> ```\n>\n> \n>\n> Related Topics\n>\n> 深度优先搜索\n>\n> 链表\n>\n> 双向链表\n\n递归法：\n\n```java\nclass Solution {\n    public Node flatten(Node head) {\n        dfs(head);\n        return head;\n    }\n    Node dfs(Node head) {\n        Node last = head;\n        while (head != null) {\n            if (head.child == null) {\n                last = head;\n                head = head.next;\n            } else {\n                Node tmp = head.next;\n                Node childLast = dfs(head.child);\n                head.next = head.child;\n                head.child.prev = head;\n                head.child = null;\n                if (childLast != null) {\n                    childLast.next = tmp;\n                }\n                if (tmp != null) {\n                    tmp.prev = childLast;\n                }\n                last = head;\n                head = childLast;\n            }\n        }\n        return last;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n迭代法：\n\n```java\nclass Solution {\n    public Node flatten(Node head) {\n        Node dummy = new Node(0);\n        dummy.next = head;\n        while (head != null) {\n            if (head.child != null) {\n                Node tmp = head.next;\n                Node child = head.child;\n                head.next = child;\n                child.prev = head;\n                head.child = null;\n                Node last = head;\n                while (last.next != null) {\n                    last = last.next;\n                }\n                last.next = tmp;\n                if (tmp != null) {\n                    tmp.prev = last;\n                }\n            }\n            head = head.next;\n        }\n        return dummy.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡114. 二叉树展开为链表\n\n> 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：\n>\n> - 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。\n> - 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)\n>\n> ```\n> 输入：root = [1,2,5,3,4,null,6]\n> 输出：[1,null,2,null,3,null,4,null,5,null,6]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [0]\n> 输出：[0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中结点数在范围 `[0, 2000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 深度优先搜索\n>\n> 链表\n>\n> 二叉树\n\n```java\nclass Solution {\n    public void flatten(TreeNode root) {\n        List<Integer>list=new ArrayList<>();\n        preOrder(root,list);\n        TreeNode ptr=root;\n        for (int i = 1; i < list.size(); i++) {\n            ptr.right=new TreeNode(list.get(i));\n            ptr.left=null;\n            ptr=ptr.right;\n        }\n    }\n    void preOrder(TreeNode root, List<Integer> list){\n        if(root==null){\n            return;\n        }\n        list.add(root.val);\n        preOrder(root.left,list);\n        preOrder(root.right,list);\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n#  链表的旋转与反转\n\n## 🟡61. 旋转链表 \n\n> 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], k = 2\n> 输出：[4,5,1,2,3]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\n>\n> ```\n> 输入：head = [0,1,2], k = 4\n> 输出：[2,0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目在范围 `[0, 500]` 内\n> - `-100 <= Node.val <= 100`\n> - `0 <= k <= 2 * 109`\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return null;\n        }\n        int cnt=0;\n        ListNode ptr=head;\n        while (ptr!=null){\n            cnt++;\n            ptr=ptr.next;\n        }\n        k%=cnt;\n        if(k==0){\n            return head;\n        }\n        ListNode fast=head,slow=fast;\n        for (int i = 0; i < cnt-k; i++) {\n            slow=fast;\n            fast=fast.next;\n        }\n        slow.next=null;\n        ptr=fast;\n        while (fast!=null){\n            slow=fast;\n            fast=fast.next;\n        }\n        slow.next=head;\n        return ptr;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡24. 两两交换链表中的节点\n\n> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4]\n> 输出：[2,1,4,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目在范围 `[0, 100]` 内\n> - `0 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode ptr = dummy;\n\n        while (head != null && head.next != null) {\n            ListNode p1 = head;\n            ListNode p2 = head.next;\n\n            ptr.next = p2;\n            p1.next = p2.next;\n            p2.next = p1;\n\n            ptr = p1;\n            head = p1.next;\n        }\n        return dummy.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢206. 反转链表 \n\n>  给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n>\n> ```\n> 输入：head = [1,2]\n> 输出：[2,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[0, 5000]`\n> - `-5000 <= Node.val <= 5000`\n>\n> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode fast=head,slow=fast;\n        ListNode res=new ListNode (0);//头插法\n        while(fast!=null){\n            fast=fast.next;\n            slow.next=res.next;\n            res.next=slow;\n            slow=fast;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡92. 反转链表 II \n\n> 给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], left = 2, right = 4\n> 输出：[1,4,3,2,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [5], left = 1, right = 1\n> 输出：[5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点数目为 `n`\n> - `1 <= n <= 500`\n> - `-500 <= Node.val <= 500`\n> - `1 <= left <= right <= n`\n>\n> \n>\n> **进阶：** 你可以使用一趟扫描完成反转吗？\n>\n> Related Topics\n>\n> 链表\n\n```java \nclass Solution {\n    ListNode ptr;\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        ListNode fast = head, slow = fast;\n        for (int i = 0; i < left - 1; i++) {\n            slow = fast;\n            fast = fast.next;\n        }\n        ListNode res=new ListNode(0);\n        if(left==1){\n            res.next=reverse(fast,right-left+1);\n        }else {\n            slow.next=reverse(fast,right-left+1);\n            res.next=head;\n        }\n        fast.next=ptr;\n        return res.next;\n    }\n\n    ListNode reverse(ListNode head, int len) {\n        ListNode fast = head, slow = fast;\n        ListNode res = new ListNode(0);//头插法\n        int cnt = 0;\n        while (fast != null && cnt < len) {\n            fast = fast.next;\n            slow.next = res.next;\n            res.next = slow;\n            slow = fast;\n            ptr=slow;\n            cnt++;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🔴25. K 个一组翻转链表\n\n#  链表高精度加法\n\n## 🟡2. 两数相加 \n\n> 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n>\n> 请你将两个数相加，并以相同形式返回一个表示和的链表。\n>\n> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)\n>\n> ```\n> 输入：l1 = [2,4,3], l2 = [5,6,4]\n> 输出：[7,0,8]\n> 解释：342 + 465 = 807.\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：l1 = [0], l2 = [0]\n> 输出：[0]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n> 输出：[8,9,9,9,0,0,0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 每个链表中的节点数在范围 `[1, 100]` 内\n> - `0 <= Node.val <= 9`\n> - 题目数据保证列表表示的数字不含前导零\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n>\n> 数学\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        int cout = 0;\n        ListNode ptr1 = l1, ptr2 = l2;\n        ListNode res = new ListNode(0);\n        ListNode ptr = res;\n        while (ptr1 != null && ptr2 != null) {\n            int sum = cout + ptr1.val + ptr2.val;\n            if (sum > 9) {\n                cout = 1;\n                sum -= 10;\n            } else {\n                cout = 0;\n            }\n            ptr.next = new ListNode(sum);\n            ptr = ptr.next;\n            ptr1 = ptr1.next;\n            ptr2 = ptr2.next;\n        }\n        ListNode rest = ptr1 != null ? ptr1 : ptr2;\n        while (rest != null) {\n            int sum = cout + rest.val;\n            if (sum > 9) {\n                cout = 1;\n                sum -= 10;\n            } else {\n                cout = 0;\n            }\n            ptr.next = new ListNode(sum);\n            ptr = ptr.next;\n            rest = rest.next;\n        }\n        if (cout == 1) {\n            ptr.next = new ListNode(1);\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n##  🟡445. 两数相加 II \n\n> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n>\n> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n>\n> \n>\n> **示例1：**\n>\n> ![img](https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png)\n>\n> ```\n> 输入：l1 = [7,2,4,3], l2 = [5,6,4]\n> 输出：[7,8,0,7]\n> ```\n>\n> **示例2：**\n>\n> ```\n> 输入：l1 = [2,4,3], l2 = [5,6,4]\n> 输出：[8,0,7]\n> ```\n>\n> **示例3：**\n>\n> ```\n> 输入：l1 = [0], l2 = [0]\n> 输出：[0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表的长度范围为` [1, 100]`\n> - `0 <= node.val <= 9`\n> - 输入数据保证链表代表的数字无前导 0\n>\n> \n>\n> **进阶：**如果输入链表不能翻转该如何解决？\n>\n> Related Topics\n>\n> 栈\n>\n> 链表\n>\n> 数学\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        l1=reverseList(l1);\n        l2=reverseList(l2);\n        int cout = 0;\n        ListNode ptr1 = l1, ptr2 = l2;\n        ListNode res = new ListNode(0);\n        ListNode ptr = res;\n        while (ptr1 != null && ptr2 != null) {\n            int sum = cout + ptr1.val + ptr2.val;\n            if (sum > 9) {\n                cout = 1;\n                sum -= 10;\n            } else {\n                cout = 0;\n            }\n            ptr.next = new ListNode(sum);\n            ptr = ptr.next;\n            ptr1 = ptr1.next;\n            ptr2 = ptr2.next;\n        }\n        ListNode rest = ptr1 != null ? ptr1 : ptr2;\n        while (rest != null) {\n            int sum = cout + rest.val;\n            if (sum > 9) {\n                cout = 1;\n                sum -= 10;\n            } else {\n                cout = 0;\n            }\n            ptr.next = new ListNode(sum);\n            ptr = ptr.next;\n            rest = rest.next;\n        }\n        if (cout == 1) {\n            ptr.next = new ListNode(1);\n        }\n        return reverseList(res.next);\n    }\n\n    ListNode reverseList(ListNode head) {\n        ListNode fast = head, slow = fast;\n        ListNode res = new ListNode(0);//头插法\n        while (fast != null) {\n            fast = fast.next;\n            slow.next = res.next;\n            res.next = slow;\n            slow = fast;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n#  链表的合并\n\n## 🟢21. 合并两个有序链表 \n\n> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n>\n> ```\n> 输入：l1 = [1,2,4], l2 = [1,3,4]\n> 输出：[1,1,2,3,4,4]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：l1 = [], l2 = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：l1 = [], l2 = [0]\n> 输出：[0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 两个链表的节点数目范围是 `[0, 50]`\n> - `-100 <= Node.val <= 100`\n> - `l1` 和 `l2` 均按 **非递减顺序** 排列\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode res=new ListNode(0);\n        ListNode ptr=res;\n        ListNode ptr1=list1,ptr2=list2;\n        while (ptr1!=null&&ptr2!=null){\n            if(ptr1.val<ptr2.val){\n                ptr.next=ptr1;\n                ptr1=ptr1.next;\n            }else {\n                ptr.next=ptr2;\n                ptr2=ptr2.next;\n            }\n            ptr=ptr.next;\n        }\n        ptr.next=ptr1!=null?ptr1:ptr2;\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🔴23. 合并K个升序链表\n\n> 给你一个链表数组，每个链表都已经按升序排列。\n>\n> 请你将所有链表合并到一个升序链表中，返回合并后的链表。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：lists = [[1,4,5],[1,3,4],[2,6]]\n> 输出：[1,1,2,3,4,4,5,6]\n> 解释：链表数组如下：\n> [\n>   1->4->5,\n>   1->3->4,\n>   2->6\n> ]\n> 将它们合并到一个有序链表中得到。\n> 1->1->2->3->4->4->5->6\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：lists = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：lists = [[]]\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `k == lists.length`\n> - `0 <= k <= 10^4`\n> - `0 <= lists[i].length <= 500`\n> - `-10^4 <= lists[i][j] <= 10^4`\n> - `lists[i]` 按 **升序** 排列\n> - `lists[i].length` 的总和不超过 `10^4`\n>\n> Related Topics\n>\n> 链表\n>\n> 分治\n>\n> 堆（优先队列）\n>\n> 归并排序\n\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        int len= lists.length;\n        if(len==0){\n            return null;\n        }\n        return biaryMerge(lists,0,len-1);\n    }\n    ListNode biaryMerge(ListNode[] lists,int i,int j){\n        if(i>j){\n            return null;\n        } else if (i==j) {\n            return lists[i];\n        }\n        int mid=(i+j)/2;\n        return merge(biaryMerge(lists,i,mid),biaryMerge(lists,mid+1,j));\n    }\n    ListNode merge(ListNode l1, ListNode l2) {\n        ListNode res = new ListNode(0);\n        ListNode p = res;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                p.next = l1;\n                l1 = l1.next;\n            } else {\n                p.next = l2;\n                l2 = l2.next;\n            }\n            p = p.next;\n        }\n        if (l1 != null) {\n            p.next = l1;\n        }\n        if (l2 != null) {\n            p.next = l2;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(nlogn)*\n- space:*O(n)*\n\n#  链表中的双指针技巧\n\n## 🟡86. 分隔链表 \n\n> 给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。\n>\n> 你应当 **保留** 两个分区中每个节点的初始相对位置。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)\n>\n> ```\n> 输入：head = [1,4,3,2,5,2], x = 3\n> 输出：[1,2,2,4,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [2,1], x = 2\n> 输出：[1,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目在范围 `[0, 200]` 内\n> - `-100 <= Node.val <= 100`\n> - `-200 <= x <= 200`\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode beforeHead = new ListNode(0);\n        ListNode afterHead = new ListNode(0);\n        ListNode before = beforeHead;\n        ListNode after = afterHead;\n        while (head != null) {\n            if (head.val < x) {\n                before.next = new ListNode(head.val);\n                before = before.next;\n            } else {\n                after.next = new ListNode(head.val);\n                after = after.next;\n            }\n            head = head.next;\n        }\n        before.next = afterHead.next;\n        return beforeHead.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡19. 删除链表的倒数第 N 个结点 \n\n> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [1], n = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1,2], n = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中结点的数目为 `sz`\n> - `1 <= sz <= 30`\n> - `0 <= Node.val <= 100`\n> - `1 <= n <= sz`\n>\n> \n>\n> **进阶：**你能尝试使用一趟扫描实现吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head.next==null){\n            return null;\n        }\n        ListNode fast=head,slow=fast;\n        for (int i = 0; i < n; i++) {\n            fast=fast.next;\n        }\n        if(fast==null){\n            return head.next;\n        }else {\n            fast=fast.next;\n            while (fast!=null){\n                slow=slow.next;\n                fast=fast.next;\n            }\n            slow.next=slow.next.next;\n            return head;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢141. 环形链表 \n\n> 给你一个链表的头节点 `head` ，判断链表中是否有环。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。\n>\n> *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)\n>\n> ```\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：true\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> ```\n> 输入：head = [1,2], pos = 0\n> 输出：true\n> 解释：链表中有一个环，其尾部连接到第一个节点。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> ```\n> 输入：head = [1], pos = -1\n> 输出：false\n> 解释：链表中没有环。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[0, 104]`\n> - `-105 <= Node.val <= 105`\n> - `pos` 为 `-1` 或者链表中的一个 **有效索引** 。\n>\n> \n>\n> **进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡142. 环形链表 II\n\n> 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n>\n> **不允许修改** 链表。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>\n> ```\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> ```\n> 输入：head = [1,2], pos = 0\n> 输出：返回索引为 0 的链表节点\n> 解释：链表中有一个环，其尾部连接到第一个节点。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> ```\n> 输入：head = [1], pos = -1\n> 输出：返回 null\n> 解释：链表中没有环。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围在范围 `[0, 104]` 内\n> - `-105 <= Node.val <= 105`\n> - `pos` 的值为 `-1` 或者链表中的一个有效索引\n>\n> \n>\n> **进阶：**你是否可以使用 `O(1)` 空间解决此题？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n##  🟢876. 链表的中间结点 \n\n> 给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。\n>\n> 如果有两个中间结点，则返回第二个中间结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[3,4,5]\n> 解释：链表只有一个中间结点，值为 3 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5,6]\n> 输出：[4,5,6]\n> 解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表的结点数范围是 `[1, 100]`\n> - `1 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast=head,slow=head;\n        while (fast.next!=null){\n            slow=slow.next;\n            if(fast.next.next!=null){\n                fast=fast.next.next;\n            }else {\n                break;\n            }\n        }\n        return slow;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n##  🟡143. 重排链表 \n\n> 给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：\n>\n> ```\n> L0 → L1 → … → Ln - 1 → Ln\n> ```\n>\n> 请将其重新排列后变为：\n>\n> ```\n> L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n> ```\n>\n> 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)\n>\n> ```\n> 输入：head = [1,2,3,4]\n> 输出：[1,4,2,3]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://pic.leetcode-cn.com/1626420320-YUiulT-image.png)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[1,5,2,4,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表的长度范围为 `[1, 5 * 104]`\n> - `1 <= node.val <= 1000`\n>\n> Related Topics\n>\n> 栈\n>\n> 递归\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) {\n            return;\n        }\n        // Step 1: Find the middle node of the linked list\n        ListNode slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        // Step 2: Reverse the second half of the linked list\n        ListNode secondHalf = reverseList(slow.next);\n        slow.next = null; // Break the list into two halves\n        // Step 3: Merge the first half and the reversed second half alternatively\n        ListNode p1 = head;\n        ListNode p2 = secondHalf;\n        while (p1 != null && p2 != null) {\n            ListNode temp1 = p1.next;\n            ListNode temp2 = p2.next;\n            p1.next = p2;\n            p2.next = temp1;\n            p1 = temp1;\n            p2 = temp2;\n        }\n    }\n    ListNode reverseList(ListNode head) {\n        ListNode fast = head, slow = fast;\n        ListNode res = new ListNode(0);//头插法\n        while (fast != null) {\n            fast = fast.next;\n            slow.next = res.next;\n            res.next = slow;\n            slow = fast;\n        }\n        return res.next;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢160. 相交链表\n\n> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n>\n> 图示两个链表在节点 `c1` 开始相交**：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n>\n> 题目数据 **保证** 整个链式结构中不存在环。\n>\n> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n>\n> **自定义评测：**\n>\n> **评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：\n>\n> - `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`\n> - `listA` - 第一个链表\n> - `listB` - 第二个链表\n> - `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数\n> - `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数\n>\n> 评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。\n>\n> \n>\n> **示例 1：**\n>\n> [![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n>\n> ```\n> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n> 输出：Intersected at '8'\n> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n> — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n> ```\n>\n> \n>\n> **示例 2：**\n>\n> [![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n>\n> ```\n> 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n> 输出：Intersected at '2'\n> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n> 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n> ```\n>\n> **示例 3：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n>\n> ```\n> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n> 输出：null\n> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n> 这两个链表不相交，因此返回 null 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `listA` 中节点数目为 `m`\n> - `listB` 中节点数目为 `n`\n> - `1 <= m, n <= 3 * 104`\n> - `1 <= Node.val <= 105`\n> - `0 <= skipA <= m`\n> - `0 <= skipB <= n`\n> - 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`\n> - 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`\n>\n> \n>\n> **进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA, B = headB;\n        while (A != B) {\n            A = A != null ? A.next : headB;\n            B = B != null ? B.next : headA;\n        }\n        return A;\n    }\n}\n```\n\n- time:*O(m + n)*\n- sapce:*O(1)*\n\n","categories":["algorithm learning"]},{"title":"Array","url":"/2023/09/01/algorithm-array/","content":"\n| 类型                 | 题号                                           | 完成 |\n| -------------------- | ---------------------------------------------- | ---- |\n| 数组的改变、移动     | 🟡453. 最小移动次数使数组元素相等               | ✅    |\n|                      | 🟡665. 非递减数列                               | ✅    |\n|                      | 🟢283. 移动零                                   | ✅    |\n| 数组的旋转           | 🟡189. 旋转数组                                 | ✅    |\n|                      | 🟡396. 旋转函数                                 | ✅    |\n| 统计数组中的元素     | 🟢645. 错误的集合                               | ✅    |\n|                      | 🟢697. 数组的度                                 | ✅    |\n|                      | 🟢448. 找到所有数组中消失的数字                 | ✅    |\n|                      | 🟡442. 数组中重复的数据                         | ✅    |\n|                      | 🔴41. 缺失的第一个正数                          | ✅    |\n| 数组的遍历           | 🟢485. 最大连续1的个数                          | ✅    |\n|                      | 🟢495. 提莫攻击                                 | ✅    |\n|                      | 🟢414. 第三大的数                               | ✅    |\n|                      | 🟢628. 三个数的最大乘积                         | ✅    |\n| 二维数组及滚动数组   | 🟢118. 杨辉三角                                 | ✅    |\n|                      | 🟢119. 杨辉三角 II                              | ✅    |\n|                      | 🟢661. 图片平滑器                               | ✅    |\n|                      | 🟢598. 范围求和 II                              | ✅    |\n|                      | 🟡419. 甲板上的战舰                             | ✅    |\n| 特定顺序遍历二维数组 | 🟡54. 螺旋矩阵                                  | ✅    |\n|                      | 🟡 59. 螺旋矩阵 II                              | ✅    |\n|                      | 🟡498. 对角线遍历                               | ✅    |\n| 二维数组变换         | 🟢566. 重塑矩阵                                 | ✅    |\n|                      | ☂️🟡48. 旋转图像                                 | ✅    |\n|                      | 🟡73. 矩阵置零                                  | ✅    |\n|                      | 🟡289. 生命游戏                                 | ✅    |\n| 前缀和数组           | 🟢303. 区域和检索 - 数组不可变                  | ✅    |\n|                      | 🟡304. 二维区域和检索 - 矩阵不可变              | ✅    |\n|                      | 🟡238. 除自身以外数组的乘积                     | ✅    |\n| 其它                 | 🟢704.二分查找                                  | ✅    |\n|                      | 🟢35.搜索插入位置                               | ✅    |\n|                      | 🟡34.在排序数组中查找元素的第一个和最后一个位置 | ✅    |\n|                      | 🟢69.x 的平方根                                 | ✅    |\n|                      | 🟢367.有效的完全平方数                          | ✅    |\n|                      | 🟢27.移除元素                                   | ✅    |\n|                      | 🟢26.删除排序数组中的重复项                     | ✅    |\n|                      | 🟢844.比较含退格的字符串                        | ✅    |\n|                      | 🟢977.有序数组的平方                            | ✅    |\n|                      | 🟡209.长度最小的子数组                          | ✅    |\n|                      | 🟡904.水果成篮                                  | ✅    |\n|                      | 🔴76.最小覆盖子串变、移动                       |      |\n\n\n\n## 🟡453. 最小移动次数使数组元素相等 \n\n> 给你一个长度为 `n` 的整数数组，每次操作将会使 `n - 1` 个元素增加 `1` 。返回让数组所有元素相等的最小操作次数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：3\n> 解释：\n> 只需要3次操作（注意每次操作会增加两个元素的值）：\n> [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,1,1]\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n> - 答案保证符合 **32-bit** 整数\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int minMoves(int[] nums) {\n        int len= nums.length;\n        int res=0;\n        int min= Arrays.stream(nums).min().getAsInt();\n        for (int i = 0; i < len; i++) {\n            res+=nums[i]-min;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n##  🟡665. 非递减数列 \n\n> 给你一个长度为 `n` 的整数数组 `nums` ，请你判断在 **最多** 改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。\n>\n> 我们是这样定义一个非递减数列的： 对于数组中任意的 `i` `(0 <= i <= n-2)`，总满足 `nums[i] <= nums[i + 1]`。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [4,2,3]\n> 输出: true\n> 解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [4,2,1]\n> 输出: false\n> 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 104`\n> - `-105 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n\n```java\nclass Solution {\n    public boolean checkPossibility(int[] nums) {\n        int cnt=0,len= nums.length;\n        for (int i = 1; i < len; i++) {\n            if(nums[i]-nums[i-1]<0){\n                if (i == 1 || nums[i] >= nums[i - 2]) {\n                    nums[i - 1] = nums[i];\n                } else {\n                    nums[i] = nums[i - 1]; \n                }\n                cnt++;\n            }\n            if(cnt==2){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n##  🟢283. 移动零\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len= nums.length;\n        int i=0,j=1;\n        while (i<len){\n            while (i<len&&nums[i]!=0){\n                i++;\n            }\n            if(i>=len){\n                break;\n            }\n            j=i+1;\n            while (j<len&&nums[j]==0){\n                j++;\n            }\n            if(j>=len){\n                break;\n            }\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n            i++;\n            j++;\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n# 数组的旋转\n\n## 🟡189. 旋转数组 \n\n>给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。\n>\n>\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [1,2,3,4,5,6,7], k = 3\n>输出: [5,6,7,1,2,3,4]\n>解释:\n>向右轮转 1 步: [7,1,2,3,4,5,6]\n>向右轮转 2 步: [6,7,1,2,3,4,5]\n>向右轮转 3 步: [5,6,7,1,2,3,4]\n>```\n>\n>**示例 2:**\n>\n>```\n>输入：nums = [-1,-100,3,99], k = 2\n>输出：[3,99,-1,-100]\n>解释: \n>向右轮转 1 步: [99,-1,-100,3]\n>向右轮转 2 步: [3,99,-1,-100]\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= nums.length <= 105`\n>- `-231 <= nums[i] <= 231 - 1`\n>- `0 <= k <= 105`\n>\n>\n>\n>**进阶：**\n>\n>- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。\n>- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？\n>\n>Related Topics\n>\n>数组\n>\n>数学\n>\n>双指针\n\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        int len= nums.length;\n        k%=len;\n        int []arr=new int[k];\n        for (int i = 0; i < k; i++) {\n            arr[i]=nums[len-k+i];\n        }\n        for (int i = len-k-1; i >=0; i--) {//3-0\n            nums[k+i]=nums[i];\n        }\n        for (int i = 0; i < k; i++) {\n            nums[i]=arr[i];\n        }\n    }\n}\n```\n\n- time:*O(n+k)*\n- space:*O(k)*\n\n## 🟡396. 旋转函数\n\n> 给定一个长度为 `n` 的整数数组 `nums` 。\n>\n> 假设 `arrk` 是数组 `nums` 顺时针旋转 `k` 个位置后的数组，我们定义 `nums` 的 **旋转函数** `F` 为：\n>\n> - `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]`\n>\n> 返回 *`F(0), F(1), ..., F(n-1)`中的最大值* 。\n>\n> 生成的测试用例让答案符合 **32 位** 整数。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [4,3,2,6]\n> 输出: 26\n> 解释:\n> F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n> F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n> F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n> F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n> 所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [100]\n> 输出: 0\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `n == nums.length`\n> - `1 <= n <= 105`\n> - `-100 <= nums[i] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int maxRotateFunction(int[] nums) {\n        int len= nums.length;\n        int res=Integer.MIN_VALUE;\n        int arr_sum= Arrays.stream(nums).sum();\n        int sum=0;\n        for (int i = 0; i < len; i++) {\n            sum+=i*nums[i];\n        }\n        res=Math.max(res,sum);\n        for (int i = len-1; i >0; i--) {\n            sum+=arr_sum-nums[i]*len;\n            res=Math.max(res,sum);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n#  统计数组中的元素\n\n## 🟢645. 错误的集合 \n\n> 集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。\n>\n> 给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。\n>\n> 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,2,4]\n> 输出：[2,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,1]\n> 输出：[1,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 104`\n> - `1 <= nums[i] <= 104`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 哈希表\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] findErrorNums(int[] nums) {\n        int len= nums.length;\n        Set<Integer>set=new HashSet<>();\n        int[]res=new int[2];\n        for (int i = 0; i < len; i++) {\n            if(set.contains(nums[i])){\n                res[0]=nums[i];\n            }\n            set.add(nums[i]);\n        }\n        for (int i = 0; i < len; i++) {\n            if(!set.contains(i+1)){\n                res[1]=i+1;\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢697. 数组的度 \n\n> 给定一个非空且只包含非负数的整数数组 `nums`，数组的 **度** 的定义是指数组里任一元素出现频数的最大值。\n>\n> 你的任务是在 `nums` 中找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,2,3,1]\n> 输出：2\n> 解释：\n> 输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。\n> 连续子数组里面拥有相同度的有如下所示：\n> [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\n> 最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,2,3,1,4,2]\n> 输出：6\n> 解释：\n> 数组的度是 3 ，因为元素 2 重复出现 3 次。\n> 所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `nums.length` 在 `1` 到 `50,000` 范围内。\n> - `nums[i]` 是一个在 `0` 到 `49,999` 范围内的整数。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int findShortestSubArray(int[] nums) {\n        int len= nums.length;\n        Map<Integer,Integer>map=new HashMap<>();\n        int max=0;\n        for (int i = 0; i < len; i++) {\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1 );\n            max=Math.max(max,map.get(nums[i]));\n        }\n        int res=Integer.MAX_VALUE;\n        for (Map.Entry entry: map.entrySet()) {\n            if((int)entry.getValue()==max){\n                res=Math.min(res,length(nums,(int)entry.getKey()));\n            }\n        }\n        return res;\n    }\n    int length(int[]nums,int k){\n        int len= nums.length;\n        int start=0,end=len-1;\n        for (int i = 0; i < len; i++) {\n            if(nums[i]==k){\n                start=i;\n                break;\n            }\n        }\n        for (int i = len-1; i >=0; i--) {\n            if(nums[i]==k){\n                end=i;\n                break;\n            }\n        }\n        return end-start+1;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟢448. 找到所有数组中消失的数字 \n\n> 给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[5,6]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,1]\n> 输出：[2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 105`\n> - `1 <= nums[i] <= n`\n>\n> **进阶：**你能在不使用额外空间且时间复杂度为 `O(n)` 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        int len= nums.length;\n        List<Integer>res=new ArrayList<>();\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < len; i++) {\n            set.add(nums[i]);\n        }\n        for (int i = 0; i < len; i++) {\n            if(!set.contains(i+1)){\n                res.add(i+1);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡442. 数组中重复的数据 \n\n> 给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **一次** 或 **两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。\n>\n> 你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间的算法解决此问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[2,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：[1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums.length`\n> - `1 <= n <= 105`\n> - `1 <= nums[i] <= n`\n> - `nums` 中的每个元素出现 **一次** 或 **两次**\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        int len= nums.length;\n        Set<Integer>set=new HashSet<>();\n        List<Integer>list=new ArrayList<>();\n        for (int i = 0; i < len; i++) {\n            if(set.contains(nums[i])){\n                list.add(nums[i]);\n            }\n            set.add(nums[i]);\n        }\n        return list;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n##  🔴41. 缺失的第一个正数\n\n> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。\n>\n> 请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,0]\n> 输出：3\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,4,-1,1]\n> 输出：2\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [7,8,9,11,12]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 5 * 105`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        int len= nums.length;\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < len; i++) {\n            set.add(nums[i]);\n        }\n        int res=-1;\n        for (int i = 0; i < len; i++) {\n            if(!set.contains(i+1)){\n                res=i+1;\n                break;\n            }\n        }\n        if(res==-1){\n            return len+1;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n#  数组的遍历\n\n## 🟢485. 最大连续1的个数 \n\n> 给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,0,1,1,1]\n> 输出：3\n> 解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：nums = [1,0,1,1,0,1]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `nums[i]` 不是 `0` 就是 `1`.\n>\n> Related Topics\n>\n> 数组\n\n```java\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int cnt=0,max=0;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]==1){\n                cnt++;\n            }else{\n                cnt=0;\n            }\n            max=Math.max(max,cnt);\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢495. 提莫攻击 \n\n> 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。\n>\n> 当提莫攻击艾希，艾希的中毒状态正好持续 `duration` 秒。\n>\n> 正式地讲，提莫在 `t` 发起攻击意味着艾希在时间区间 `[t, t + duration - 1]`（含 `t` 和 `t + duration - 1`）处于中毒状态。如果提莫在中毒影响结束 **前** 再次攻击，中毒状态计时器将会 **重置** ，在新的攻击之后，中毒影响将会在 `duration` 秒后结束。\n>\n> 给你一个 **非递减** 的整数数组 `timeSeries` ，其中 `timeSeries[i]` 表示提莫在 `timeSeries[i]` 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 `duration` 。\n>\n> 返回艾希处于中毒状态的 **总** 秒数。\n>\n> **示例 1：**\n>\n> ```\n> 输入：timeSeries = [1,4], duration = 2\n> 输出：4\n> 解释：提莫攻击对艾希的影响如下：\n> - 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n> - 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n> 艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：timeSeries = [1,2], duration = 2\n> 输出：3\n> 解释：提莫攻击对艾希的影响如下：\n> - 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n> - 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n> 艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= timeSeries.length <= 104`\n> - `0 <= timeSeries[i], duration <= 107`\n> - `timeSeries` 按 **非递减** 顺序排列\n>\n> Related Topics\n>\n> 数组\n>\n> 模拟\n\n```java\nclass Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        int len=timeSeries.length;\n        int res=duration;\n        for (int i = 1; i < len; i++) {\n            res+=Math.min(duration,timeSeries[i]-timeSeries[i-1]);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢414. 第三大的数\n\n> 给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：[3, 2, 1]\n> 输出：1\n> 解释：第三大的数是 1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：[1, 2]\n> 输出：2\n> 解释：第三大的数不存在, 所以返回最大的数 2 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：[2, 2, 3, 1]\n> 输出：1\n> 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。\n> 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能设计一个时间复杂度 `O(n)` 的解决方案吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 排序\n\n```java\nclass Solution {\n    public int thirdMax(int[] nums) {\n        int len= nums.length;\n        int res=0,flag=0;\n        Arrays.sort(nums);\n        int max=nums[len-1];\n        int cnt=3;\n        for (int i = len-2; i >= 0 ; i--) {\n            if(cnt>=1&&nums[i]!=nums[i+1]){\n                cnt--;\n            }\n            if(cnt==1){\n                flag=1;\n                res=nums[i];\n                break;\n            }\n        }\n        return flag==1?res:max;\n    }\n}\n```\n\n- time:*O(nlogn)*\n- space:*O(1)*\n\n```java\nclass Solution {\n    public int thirdMax(int[] nums) {\n        if(nums.length==1){\n            return nums[0];\n        } else if (nums.length==2) {\n            return Math.max(nums[0],nums[1]);\n        }else {\n            int first=Integer.MIN_VALUE;\n            int second=Integer.MIN_VALUE;\n            int third=Integer.MIN_VALUE;\n            int min=Integer.MAX_VALUE;\n            for (int i = 0; i < nums.length; i++) {\n                if(nums[i]>first){\n                    third=second;\n                    second=first;\n                    first=nums[i];\n                } else if (nums[i]>second&&nums[i]!=first) {\n                    third=second;\n                    second=nums[i];\n                }else if(nums[i]>third&&nums[i]!=second&&nums[i]!=first){\n                    third=nums[i];\n                }\n                min=Math.min(min,nums[i]);\n            }\n            if(third==Integer.MIN_VALUE&& min!=Integer.MIN_VALUE||\n                    second==Integer.MIN_VALUE&&min==Integer.MIN_VALUE){\n                return first;\n            }else {\n                return third;\n            }\n        }\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟢628. 三个数的最大乘积\n\n> 给你一个整型数组 `nums` ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：6\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4]\n> 输出：24\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [-1,-2,-3]\n> 输出：-6\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= nums.length <= 104`\n> - `-1000 <= nums[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n>\n> 排序\n\n```java\nclass Solution {\n    public int maximumProduct(int[] nums) {\n        int len= nums.length;\n        Arrays.sort(nums);\n        return Math.max(nums[0]*nums[1]*nums[len-1], nums[len-3]*nums[len-2]*nums[len-1]);\n    }\n}\n```\n\n- time:*O(nlogn)*\n- space:*O(1)*\n\n# 二维数组及滚动数组\n\n## 🟢118. 杨辉三角 \n\n> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。\n>\n> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n>\n> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: numRows = 5\n> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: numRows = 1\n> 输出: [[1]]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= numRows <= 30`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>>res=new ArrayList<>();\n        res.add(new ArrayList<>(Arrays.asList(1)));\n        for (int i = 1; i < numRows; i++) {\n            List<Integer>list=new ArrayList<>(i+1);\n            list.add(1);\n            for (int j = 1; j < i; j++) {\n                list.add(res.get(i-1).get(j-1)+res.get(i-1).get(j));\n            }\n            list.add(1);\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n^2^)*\n\n## 🟢119. 杨辉三角 II \n\n> 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。\n>\n> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n>\n> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: rowIndex = 3\n> 输出: [1,3,3,1]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: rowIndex = 0\n> 输出: [1]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: rowIndex = 1\n> 输出: [1,1]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `0 <= rowIndex <= 33`\n>\n> \n>\n> **进阶：**\n>\n> 你可以优化你的算法到 `*O*(*rowIndex*)` 空间复杂度吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<List<Integer>>res=new ArrayList<>();\n        res.add(new ArrayList<>(Arrays.asList(1)));\n        for (int i = 1; i <= rowIndex; i++) {\n            List<Integer>list=new ArrayList<>(i+1);\n            list.add(1);\n            for (int j = 1; j < i; j++) {\n                list.add(res.get(i-1).get(j-1)+res.get(i-1).get(j));\n            }\n            list.add(1);\n            res.add(list);\n        }\n        return res.get(rowIndex);\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n^2^)*\n\n## 🟢661. 图片平滑器 \n\n> **图像平滑器** 是大小为 `3 x 3` 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。\n>\n> 每个单元格的 **平均灰度** 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。\n>\n> 如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。\n>\n> ![img](https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg)\n>\n> 给你一个表示图像灰度的 `m x n` 整数矩阵 `img` ，返回对图像的每个单元格平滑处理后的图像 。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg)\n>\n> ```\n> 输入:img = [[1,1,1],[1,0,1],[1,1,1]]\n> 输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]\n> 解释:\n> 对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n> 对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n> 对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg)\n>\n> ```\n> 输入: img = [[100,200,100],[200,50,200],[100,200,100]]\n> 输出: [[137,141,137],[141,138,141],[137,141,137]]\n> 解释:\n> 对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n> 对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n> 对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `m == img.length`\n> - `n == img[i].length`\n> - `1 <= m, n <= 200`\n> - `0 <= img[i][j] <= 255`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n\n```java\nclass Solution {\n    public int[][] imageSmoother(int[][] img) {\n        int n=img.length,m=img[0].length;\n        int[][]res=new int[n][m];\n        if(n==1&&m==1){\n            return img;\n        } else if (n==1) {\n            for (int i = 0; i < m; i++) {\n                if(i==0){\n                    res[0][i]=(img[0][0]+img[0][1])/2;\n                } else if (i==m-1) {\n                    res[0][i]=(img[0][m-1]+img[0][m-2])/2;\n                }else {\n                    res[0][i]=(img[0][i-1]+img[0][i]+img[0][i+1])/3;\n                }\n            }\n        } else if (m==1) {\n            for (int i = 0; i < n; i++) {\n                if(i==0){\n                    res[i][0]=(img[0][0]+img[1][0])/2;\n                } else if (i==n-1) {\n                    res[i][0]=(img[n-1][0]+img[n-2][0])/2;\n                }else {\n                    res[i][0]=(img[i-1][0]+img[i][0]+img[i+1][0])/3;\n                }\n            }\n        }else {\n            int[][]new_img=new int[n+2][m+2];\n            for (int i = 1; i < n+1; i++) {\n                for (int j = 1; j < m+1; j++) {\n                    new_img[i][j]=img[i-1][j-1];\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    int sum=0;\n                    for (int k = i-1; k <= i+1; k++) {\n                        for (int l = j-1; l <= j+1; l++) {\n                            sum+=new_img[k+1][l+1];\n                        }\n                    }\n                    if(i==0&&j==0||i==0&&j==m-1||i==n-1&&j==0||i==n-1&&j==m-1){\n                        res[i][j]=sum/4;\n                    } else if (i==0||j==0||i==n-1||j==m-1) {\n                        res[i][j]=sum/6;\n                    }else{\n                        res[i][j]=sum/9;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n```java\nclass Solution {\n    public int[][] imageSmoother(int[][] img) {\n        int n=img.length;\n        int m=img[0].length;\n        int[][]preSum=new int[n+1][m+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                preSum[i+1][j+1]=preSum[i + 1][j] + preSum[i][j + 1] - preSum[i][j] + img[i][j];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int row1=i-1<0?0:i-1;\n                int col1=j-1<0?0:j-1;\n                int row2=i+1>=n?n-1:i+1;\n                int col2=j+1>=m?m-1:j+1;\n                int num=(row2-row1+1)*(col2-col1+1);\n                img[i][j]=preSum[row2+1][col2+1]+preSum[row1][col1]-preSum[row2+1][col1]-preSum[row1][col2+1];\n                img[i][j]/=num;\n            }\n        }\n        return img;\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n##  🟢598. 范围求和 II \n\n> 给你一个 `m x n` 的矩阵 `M` 和一个操作数组 `op` 。矩阵初始化时所有的单元格都为 `0` 。`ops[i] = [ai, bi]` 意味着当所有的 `0 <= x < ai` 和 `0 <= y < bi` 时， `M[x][y]` 应该加 1。\n>\n> 在 *执行完所有操作后* ，计算并返回 *矩阵中最大整数的个数* 。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/02/ex1.jpg)\n>\n> ```\n> 输入: m = 3, n = 3，ops = [[2,2],[3,3]]\n> 输出: 4\n> 解释: M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n> 输出: 4\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: m = 3, n = 3, ops = []\n> 输出: 9\n> ```\n>\n> \n>\n> **提示:**\n>\n> \n>\n> - `1 <= m, n <= 4 * 104`\n> - `0 <= ops.length <= 104`\n> - `ops[i].length == 2`\n> - `1 <= ai <= m`\n> - `1 <= bi <= n`\n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int maxCount(int m, int n, int[][] ops) {\n        int min1=m,min2=n;\n        for (int i = 0; i < ops.length; i++) {\n            min1=Math.min(min1,ops[i][0]);\n            min2=Math.min(min2,ops[i][1]);\n        }\n        return min1*min2;\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(1)*\n\n## 🟡419. 甲板上的战舰\n\n> 给你一个大小为 `m x n` 的矩阵 `board` 表示甲板，其中，每个单元格可以是一艘战舰 `'X'` 或者是一个空位 `'.'` ，返回在甲板 `board` 上放置的 **战舰** 的数量。\n>\n> **战舰** 只能水平或者垂直放置在 `board` 上。换句话说，战舰只能按 `1 x k`（`1` 行，`k` 列）或 `k x 1`（`k` 行，`1` 列）的形状建造，其中 `k` 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg)\n>\n> ```\n> 输入：board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：board = [[\".\"]]\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == board.length`\n> - `n == board[i].length`\n> - `1 <= m, n <= 200`\n> - `board[i][j]` 是 `'.'` 或 `'X'`\n>\n> \n>\n> **进阶：**你可以实现一次扫描算法，并只使用 `O(1)` 额外空间，并且不修改 `board` 的值来解决这个问题吗？\n>\n> Related Topics\n>\n> 深度优先搜索\n>\n> 数组\n>\n> 矩阵\n\n```java\nclass Solution {\n    int[][]direction=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\n    boolean[][]visited;\n    int n,m;\n    public int countBattleships(char[][] board) {\n        int res=0;\n        n=board.length;\n        m=board[0].length;\n        visited=new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&board[i][j]=='X'){\n                    res++;\n                    dfs(board,i,j);\n                }\n            }\n        }\n        return res;\n    }\n    void dfs(char[][] board,int i,int j){\n        if(visited[i][j]==true||board[i][j]=='.'){\n            return;\n        }\n        visited[i][j]=true;\n        for (int k = 0; k < 4; k++) {\n            int x=i+direction[k][0];\n            int y=j+direction[k][1];\n            if(x<0||x>= n||y<0||y>=m){\n                continue;\n            }\n            dfs(board,x,y);\n        }\n    }\n}\n```\n\n- time:*O(n·m·4^(n·m)^)*\n- space:*O(n·m)*\n\n# 特定顺序遍历二维数组\n\n## 🟡54. 螺旋矩阵 \n\n> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[1,2,3,6,9,8,7,4,5]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= m, n <= 10`\n> - `-100 <= matrix[i][j] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    int[][]directions=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n= matrix.length;\n        int m=matrix[0].length;\n        boolean[][]visited=new boolean[n][m];\n        List<Integer>res=new ArrayList<>();\n        int cnt=m*n;\n        int i=0,j=0,state=0;\n        while (cnt>0){\n            res.add(matrix[i][j]);\n            visited[i][j]=true;\n            if(state==0&&(j==m-1||visited[i][j+1])) {\n                state=1;\n            } else if (state==1&&(i==n-1||visited[i+1][j])) {\n                state=2;\n            }else if (state==2&&(j==0||visited[i][j-1])) {\n                state = 3;\n            }else if(state==3&&(i==0||visited[i-1][j])) {\n                state=0;\n            }\n            i+=directions[state][0];\n            j+=directions[state][1];\n            cnt--;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n## 🟡 59. 螺旋矩阵 II \n\n> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n>\n> ```\n> 输入：n = 3\n> 输出：[[1,2,3],[8,9,4],[7,6,5]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1\n> 输出：[[1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 20`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n       int[][]res=new int[n][n];\n       boolean[][]visited=new boolean[n][n];\n       int[][]directions=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n       int cnt=1;\n       int i=0,j=0,state=0;\n       while (cnt<=n*n){\n           res[i][j]=cnt;\n           visited[i][j]=true;\n           if(state==0&&(j==n-1||visited[i][j+1])) {\n               state=1;\n           } else if (state==1&&(i==n-1||visited[i+1][j])) {\n               state=2;\n           }else if (state==2&&(j==0||visited[i][j-1])) {\n               state = 3;\n           }else if(state==3&&(i==0||visited[i-1][j])) {\n               state=0;\n           }\n           i+=directions[state][0];\n           j+=directions[state][1];\n           cnt++;\n       }\n       return res;\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(n^2^)*\n\n## 🟡498. 对角线遍历\n\n> 给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)\n>\n> ```\n> 输入：mat = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[1,2,4,7,5,3,6,8,9]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：mat = [[1,2],[3,4]]\n> 输出：[1,2,3,4]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == mat.length`\n> - `n == mat[i].length`\n> - `1 <= m, n <= 104`\n> - `1 <= m * n <= 104`\n> - `-105 <= mat[i][j] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    public int[] findDiagonalOrder(int[][] mat) {\n        int n= mat.length;\n        int m=mat[0].length;\n        int cnt=n*m,i=0,j=0;\n        int[]res=new int[cnt];\n        int state=m>1?1:3;\n        while (cnt>0){\n            res[n*m-cnt]=mat[i][j];\n            switch (state){\n                case 1:{//→\n                    j++;\n                    if(n==1){\n                        state=1;\n                        break;\n                    }\n                    if(i==0){\n                        state=2;\n                    }else if(i==n-1){\n                        state=4;\n                    }\n                    break;\n                }\n                case 2:{//↙\n                    i++;\n                    j--;\n                    if(i==n-1){\n                        state=1;\n                    }else if(j==0){\n                        state=3;\n                    }\n                    break;\n                }\n                case 3:{//↓\n                    i++;\n                    if(m==1){\n                        state=3;\n                        break;\n                    }\n                    if(j==0){\n                        state=4;\n                    }else if(j==m-1){\n                        state=2;\n                    }\n                    break;\n                }\n                case 4:{//↗\n                    i--;\n                    j++;\n                    if(j==m-1){\n                        state=3;\n                    } else if (i==0) {\n                        state=1;\n                    }\n                    break;\n                }\n\n            }\n            cnt--;\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n#  二维数组变换\n\n## 🟢566. 重塑矩阵 \n\n> 在 MATLAB 中，有一个非常有用的函数 `reshape` ，它可以将一个 `m x n` 矩阵重塑为另一个大小不同（`r x c`）的新矩阵，但保留其原始数据。\n>\n> 给你一个由二维数组 `mat` 表示的 `m x n` 矩阵，以及两个正整数 `r` 和 `c` ，分别表示想要的重构的矩阵的行数和列数。\n>\n> 重构后的矩阵需要将原始矩阵的所有元素以相同的 **行遍历顺序** 填充。\n>\n> 如果具有给定参数的 `reshape` 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg)\n>\n> ```\n> 输入：mat = [[1,2],[3,4]], r = 1, c = 4\n> 输出：[[1,2,3,4]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg)\n>\n> ```\n> 输入：mat = [[1,2],[3,4]], r = 2, c = 4\n> 输出：[[1,2],[3,4]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == mat.length`\n> - `n == mat[i].length`\n> - `1 <= m, n <= 100`\n> - `-1000 <= mat[i][j] <= 1000`\n> - `1 <= r, c <= 300`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n        int n= mat.length;\n        int m=mat[0].length;\n        if(r*c!=n*m){\n            return mat;\n        }\n        List<Integer>list=new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                list.add(mat[i][j]);\n            }\n        }\n        int index=0;\n        int[][]res=new int[r][c];\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                res[i][j]= list.get(index++);\n            }\n        }\n        return res;\n    }\n}\n```\n\n- time:*O(n·m+r·c)*\n- space:*O(n·m)*\n\n## 🟡48. 旋转图像\n\n> 给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n>\n> 你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[[7,4,1],[8,5,2],[9,6,3]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n>\n> ```\n> 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n> 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == matrix.length == matrix[i].length`\n> - `1 <= n <= 20`\n> - `-1000 <= matrix[i][j] <= 1000`\n>\n> \n>\n> Related Topics\n>\n> 数组\n>\n> 数学\n>\n> 矩阵\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i < n / 2; i++) {\n            for (int j = 0; j < (n + 1) / 2; j++) {\n                int tmp = matrix[i][j];\n                matrix[i][j] = matrix[n - 1 - j][i];\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\n                matrix[j][n - 1 - i] = tmp;\n            }\n        }\n    }\n}\n```\n\n- time:*O(n^2^)*\n- space:*O(1)*\n\n## 🟡73. 矩阵置零 \n\n> 给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)\n>\n> ```\n> 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n> 输出：[[1,0,1],[0,0,0],[1,0,1]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)\n>\n> ```\n> 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n> 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[0].length`\n> - `1 <= m, n <= 200`\n> - `-231 <= matrix[i][j] <= 231 - 1`\n>\n> \n>\n> **进阶：**\n>\n> - 一个直观的解决方案是使用 `O(*m**n*)` 的额外空间，但这并不是一个好的解决方案。\n> - 一个简单的改进方案是使用 `O(*m* + *n*)` 的额外空间，但这仍然不是最好的解决方案。\n> - 你能想出一个仅使用常量空间的解决方案吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 矩阵\n\n```java\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int n= matrix.length;\n        int m=matrix[0].length;\n        int[][]temp=new int[n][m];\n        for (int i = 0; i < n; i++) {\n            temp[i]=matrix[i].clone();\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(temp[i][j]==0){\n                    for (int k = 0; k < n; k++) {\n                        matrix[k][j]=0;\n                    }\n                    for (int k = 0; k < m; k++) {\n                        matrix[i][k]=0;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n- time:*O(n·m·(n+m))*\n- space:*O(n·m)*\n\n## 🟡289. 生命游戏\n\n> 根据 [百度百科](https://baike.baidu.com/item/生命游戏/2926434?fr=aladdin) ， **生命游戏** ，简称为 **生命** ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n>\n> 给定一个包含 `m × n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： `1` 即为 **活细胞** （live），或 `0` 即为 **死细胞** （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n>\n> 1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；\n> 2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；\n> 3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；\n> 4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；\n>\n> 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 `m x n` 网格面板 `board` 的当前状态，返回下一个状态。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg)\n>\n> ```\n> 输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n> 输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg)\n>\n> ```\n> 输入：board = [[1,1],[1,0]]\n> 输出：[[1,1],[1,1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == board.length`\n> - `n == board[i].length`\n> - `1 <= m, n <= 25`\n> - `board[i][j]` 为 `0` 或 `1`\n>\n> \n>\n> **进阶：**\n>\n> - 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。\n> - 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    public void gameOfLife(int[][] board) {\n        int n= board.length;\n        int m=board[0].length;\n        int[][]temp=new int[n+2][m+2];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                temp[i][j]=board[i-1][j-1];\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                int cnt=0;\n                for (int k = i-1; k <= i+1; k++) {\n                    for (int l = j-1; l <= j+1; l++) {\n                        if(!(k==i&&l==j)){\n                            cnt+=temp[k][l];\n                        }\n                    }\n                }\n                if(temp[i][j]==1){\n                    if(cnt<2||cnt>3){\n                        board[i-1][j-1]=0;\n                    }\n                }else{\n                    if(cnt==3){\n                        board[i-1][j-1]=1;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n#  前缀和数组\n\n## 🟢303. 区域和检索 - 数组不可变 \n\n> 给定一个整数数组 `nums`，处理以下类型的多个查询:\n>\n> 1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`\n>\n> 实现 `NumArray` 类：\n>\n> - `NumArray(int[] nums)` 使用数组 `nums` 初始化对象\n> - `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n> [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n> 输出：\n> [null, 1, -1, -3]\n> \n> 解释：\n> NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\n> numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)\n> numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) \n> numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-105 <= nums[i] <= 105`\n> - `0 <= i <= j < nums.length`\n> - 最多调用 `104` 次 `sumRange` 方法\n>\n> Related Topics\n>\n> 设计\n>\n> 数组\n>\n> 前缀和\n\n```java\nclass NumArray {\n\n    int[]arr;\n\n    public NumArray(int[] nums) {\n        this.arr=nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum=0;\n        for (int i = left; i <= right; i++) {\n            sum+=this.arr[i];\n        }\n        return sum;\n    }\n}\n```\n\n- time:*O(right-left)*\n- space:*O(1)*\n\n```java\nclass NumArray {\n    int[]preSum;\n    public NumArray(int[] nums) {\n        int len= nums.length;\n        this.preSum=new int[len+1];\n        for (int i = 0; i < len; i++) {\n            this.preSum[i+1]=preSum[i]+nums[i];\n        }\n    }\n    \n    public int sumRange(int left, int right) {\n        return this.preSum[right+1]-this.preSum[left];\n    }\n}\n```\n\n- time:*O(n)*\n- space:*O(n)*\n\n## 🟡304. 二维区域和检索 - 矩阵不可变 \n\n> 给定一个二维矩阵 `matrix`，以下类型的多个请求：\n>\n> - 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 `(row1, col1)` ，**右下角** 为 `(row2, col2)` 。\n>\n> 实现 `NumMatrix` 类：\n>\n> - `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化\n> - `int sumRegion(int row1, int col1, int row2, int col2)` 返回 **左上角** `(row1, col1)` 、**右下角** `(row2, col2)` 所描述的子矩阵的元素 **总和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png)\n>\n> ```\n> 输入: \n> [\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n> [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n> 输出: \n> [null, 8, 11, 12]\n> \n> 解释:\n> NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);\n> numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\n> numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\n> numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= m, n <= 200`\n> - `-105 <= matrix[i][j] <= 105`\n> - `0 <= row1 <= row2 < m`\n> - `0 <= col1 <= col2 < n`\n> - 最多调用 `104` 次 `sumRegion` 方法\n>\n> Related Topics\n>\n> 设计\n>\n> 数组\n>\n> 矩阵\n>\n> 前缀和\n\n```java\nclass NumMatrix {\n    int[][] matrix;\n    public NumMatrix(int[][] matrix) {\n        this.matrix=matrix;\n    }    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        int sum=0;\n        for (int i = row1; i <= row2 ; i++) {\n            for (int j = col1; j <= col2; j++) {\n                sum+=this.matrix[i][j];\n            }\n        }\n        return sum;\n    }\n}\n```\n\n- time:*O((row2-row1)·(col2-col1))*\n- space:*O(1)*\n\n```java\nclass NumMatrix {\n    int[][]preSum;\n    public NumMatrix(int[][] matrix) {\n        int n=matrix.length,m=matrix[0].length;\n        this.preSum=new int[n+1][m+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                this.preSum[i+1][j+1]=this.preSum[i + 1][j] + this.preSum[i][j + 1] - this.preSum[i][j] + matrix[i][j];\n            }\n        }\n    }\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return this.preSum[row2+1][col2+1]+this.preSum[row1][col1]-\n                this.preSum[row1][col2+1]-this.preSum[row2+1][col1];\n    }\n}\n```\n\n- time:*O(n·m)*\n- space:*O(n·m)*\n\n##  🟡238. 除自身以外数组的乘积\n\n> 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。\n>\n> 题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。\n>\n> 请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [1,2,3,4]\n> 输出: [24,12,8,6]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [-1,1,0,-3,3]\n> 输出: [0,0,9,0,0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 105`\n> - `-30 <= nums[i] <= 30`\n> - **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内\n>\n> \n>\n> **进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）\n>\n> Related Topics\n>\n> 数组\n>\n> 前缀和\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int len= nums.length;\n        int[]res=new int[len];\n        int mut=1,cnt_0=0;\n        for (int i = 0; i < len; i++) {\n            if(nums[i]!=0){\n                mut*=nums[i];\n            }else {\n                cnt_0++;\n            }\n        }\n        if(cnt_0==0){\n            Arrays.fill(res,mut);\n            for (int i = 0; i < len; i++) {\n                res[i]=mut/nums[i];\n            }\n\n        } else if (cnt_0==1) {\n            for (int i = 0; i < len; i++) {\n                if(nums[i]==0){\n                       res[i]=mut;\n                }\n            }\n        } \n        return res;\n    }\n}\n```\n\n- time:*O(nlogn)*\n- space:*O(n)*\n\n# 其它\n\n\n\n## 🟢704.二分查找\n\n>给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [-1,0,3,5,9,12], target = 9\n>输出: 4\n>解释: 9 出现在 nums 中并且下标为 4\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: nums = [-1,0,3,5,9,12], target = 2\n>输出: -1\n>解释: 2 不存在 nums 中因此返回 -1\n>```\n>\n>\n>\n>**提示：**\n>\n>1. 你可以假设 `nums` 中的所有元素是不重复的。\n>2. `n` 将在 `[1, 10000]`之间。\n>3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len=nums.length;\n        int l=0,r=len-1;\n        while(l<=r){\n            //int mid=(l+r)>>1; 改进成下面↓,可以防止溢出.\n            int mid=l+((r-l)>>1);\n            if(target<nums[mid]){\n                r=mid-1;\n            }else if(target>nums[mid]){\n                l=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(1)*\n\n## 🟢35.搜索插入位置 \n\n>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n>\n>请必须使用时间复杂度为 `O(log n)` 的算法。\n>\n>\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 5\n>输出: 2\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 2\n>输出: 1\n>```\n>\n>**示例 3:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 7\n>输出: 4\n>```\n>\n>\n>\n>**提示:**\n>\n>- `1 <= nums.length <= 104`\n>- `-104 <= nums[i] <= 104`\n>- `nums` 为 **无重复元素** 的 **升序** 排列数组\n>- `-104 <= target <= 104`\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n\n        int len=nums.length;\n        int l=0, r=len-1;\n\n        while(l<=r){\n            int mid=l+((r-l)>>1);\n            if(target<nums[mid]){\n                r=mid-1;\n            }else if(target>nums[mid]){\n                l=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return l;//此时l代表元素在数组中的左边缘.如果元素有重复,则是第一次出现的位置.\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(1)*\n\n## 🟡34.在排序数组中查找元素的第一个和最后一个位置 \n\n>\n>\n>给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n>\n>如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n>\n>你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [5,7,7,8,8,10], target = 8\n>输出：[3,4]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [5,7,7,8,8,10], target = 6\n>输出：[-1,-1]\n>```\n>\n>**示例 3：**\n>\n>```\n>输入：nums = [], target = 0\n>输出：[-1,-1]\n>```\n>\n>\n>\n>**提示：**\n>\n>- `0 <= nums.length <= 105`\n>- `-109 <= nums[i] <= 109`\n>- `nums` 是一个非递减数组\n>- `-109 <= target <= 109`\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int len= nums.length;\n        int l=0,r=len-1;\n        int mid=0;\n        int[]ans={-1,-1};\n\n        if(len==0){\n            return ans;\n        }\n\t\t//以下是寻找元素在数组中第一次出现的位置\n        while(l<r){\n            mid=l+((r-l)>>1);\n            if(target<=nums[mid]){\n                r=mid;\n            }else{\n                l=mid+1;\n            }\n\n        }\n        if(target==nums[l]){\n            ans[0]=l;\n        }else{//元素不存在\n            return ans;\n        }\n        \n\t\t//以下是寻找元素在数组中最后一次出现的位置\t\n        l=0;\n        r=len-1;\n        while(l<r){\n            mid=l+((r-l+1)>>1);//找右边缘需要加一\n            if(target>=nums[mid]){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        ans[1]=r;\n\n        return ans;\n\n    }\n}\n```\n\n- time:*O(n log n)*\n\n- space:*O(1)*\n\n## 🟢69.x 的平方根\n\n> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。\n>\n> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**\n>\n> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 4\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = 8\n> 输出：2\n> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= x <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n首答超时\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l=0,r=x;\n        while(l<r){\n            int mid=l+((r-l)>>1);\n            if(x<=mid*mid){\n                r=mid;\n            }else{\n                l=mid+1;\n            }\n        }\n        if(l*l==x){\n            return l;\n        }\n        return l-1;\n    }\n}\n```\n\n接着看了别人题解，发现下面错误:：\n\n1. 根据数学理论，应当寻找右边界，而不是之前认为的左边界\n2. **if(x <= mid*mid)**可能导致乘法运算溢出，故改成**if(x/mid <= mid)**\n3. 需要考虑x=0和x=1的特殊情况\n\n```Java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==0||x==1){\n            return x;\n        }\n        int l=1,r=x-1,mid=0;\n        while(l<r){\n            mid=l+((r-l+1)>>1);\n            if(x/mid>=mid){//❗防止乘法运算溢出\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(1)*\n\n## 🟢367.有效的完全平方数\n\n> 给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。\n>\n> **完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n>\n> 不能使用任何内置的库函数，如 `sqrt` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 16\n> 输出：true\n> 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 14\n> 输出：false\n> 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n```Java\n    public boolean isPerfectSquare(int num) {\n        if(num==1)return true;\n        int l=1,r=num;\n        while(l<r){\n            int mid=l+((r-l+1)>>1);\n            if(num/mid>=mid){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r*r==num;\n    }\n}\n```\n\n- time:*O(nlogn)*\n\n- space:*O(1)*\n\n## 🟢27.移除元素 \n\n>给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n>不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n>\n>\n>\n>**说明:**\n>\n>为什么返回数值是整数，但输出的答案是数组呢?\n>\n>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n>你可以想象内部操作如下:\n>\n>```\n>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n>int len = removeElement(nums, val);\n>\n>// 在函数里修改输入数组对于调用者是可见的。\n>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n>for (int i = 0; i < len; i++) {\n>print(nums[i]);\n>}\n>```\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [3,2,2,3], val = 3\n>输出：2, nums = [2,2]\n>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [0,1,2,2,3,0,4,2], val = 2\n>输出：5, nums = [0,1,4,0,3]\n>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n>```\n>\n>\n>\n>**提示：**\n>\n>- `0 <= nums.length <= 100`\n>- `0 <= nums[i] <= 50`\n>- `0 <= val <= 100`\n>\n>Related Topics\n>\n>数组\n>\n>双指针\n\n```Java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int len=nums.length;\n        int pre=0,last=len-1;\n        while(last>=0&&nums[last]==val){//寻找从后往前数的第一个可以替换的位置\n            last--;\n        }\n        while(pre<last){\n            if(nums[pre]==val){\n                int temp=nums[pre];\n                nums[pre]=nums[last];\n                nums[last]=temp;\n                while(last>=pre&&nums[last]==val){//再次寻找从后往前数的第一个可以替换的位置\n                    last--;\n                }\n            }\n            pre++;\n        }\n        return last+1;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n## 🟢26.删除排序数组中的重复项\n\n> 给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。\n>\n> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：\n>\n> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。\n> - 返回 `k` 。\n>\n> **判题标准:**\n>\n> 系统会用下面的代码来测试你的题解:\n>\n> ```\n> int[] nums = [...]; // 输入数组\n> int[] expectedNums = [...]; // 长度正确的期望答案\n> \n> int k = removeDuplicates(nums); // 调用\n> \n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n> ```\n>\n> 如果所有断言都通过，那么您的题解将被 **通过**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2,_]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **升序** 排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```Java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len=nums.length;\n        if(len==1)return 1;\n        int a=0,b=a+1;\n\n        while(b<len&&nums[b]==nums[a]){//b指向第一个和a指向的元素不同的元素\n            b++;\n        }\n\n        while(a+1<len&&b<len){\n            nums[a+1]=nums[b];\n            a++;\n            while(b<len&&nums[b]==nums[a]){//b指向下一个和a指向的元素不同的元素\n                b++;\n            }\n        }\n        return a+1;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n##  🟢844.比较含退格的字符串\n\n> 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。\n>\n> **注意：**如果对空文本输入退格字符，文本继续为空。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ab#c\", t = \"ad#c\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"ac\"。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"ab##\", t = \"c#d#\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"\"。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a#c\", t = \"b\"\n> 输出：false\n> 解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length, t.length <= 200`\n> - `s` 和 `t` 只含有小写字母以及字符 `'#'`\n>\n> \n>\n> **进阶：**\n>\n> - 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 双指针\n>\n> 字符串\n>\n> 模拟\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String s, String t) {\n        int len_s=s.length(),len_t=t.length();\n        Stack<Character> S=new Stack<Character>();\n        Stack<Character> T=new Stack<Character>();\n        int index_s=0;\n        while(index_s<len_s){\n            if(s.charAt(index_s)!='#'){\n                S.push(s.charAt(index_s));\n            }else if(!S.empty()){\n                S.pop();\n            }\n            index_s++;\n        }\n\n        int index_t=0;\n        while(index_t<len_t){\n            if(t.charAt(index_t)!='#'){\n                T.push(t.charAt(index_t));\n            }else if(!T.empty()){\n                T.pop();\n            }\n            index_t++;\n        }\n        return S.equals(T);\n    }\n}\n```\n\n- time:*O(n+m)*\n\n- space:*O(n+m)*\n\n## 🟢977.有序数组的平方 \n\n>给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [-4,-1,0,3,10]\n>输出：[0,1,9,16,100]\n>解释：平方后，数组变为 [16,1,0,9,100]\n>排序后，数组变为 [0,1,9,16,100]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [-7,-3,2,3,11]\n>输出：[4,9,9,49,121]\n>```\n>\n>**提示：**\n>\n>- `1 <= nums.length <= 104`\n>- `-104 <= nums[i] <= 104`\n>- `nums` 已按 **非递减顺序** 排序\n>\n>**进阶：**\n>\n>- 请你设计时间复杂度为 `O(n)` 的算法解决本问题\n>\n>Related Topics\n>\n>数组\n>\n>双指针\n>\n>排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int len=nums.length;\n        int[]ans=new int[len];//创建定长的新数组\n        int index=len-1;\n        int l=0,r=len-1;\n        while(index>=0){\n            if(nums[l]*nums[l]>=nums[r]*nums[r]){\n                ans[index]=nums[l]*nums[l];\n                l++;\n            }else{\n                ans[index]=nums[r]*nums[r];\n                r--;\n            }\n            index--;\n        }\n        return ans;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(n)*\n\n## 🟡209.长度最小的子数组 \n\n>给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**\n>\n>找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n>\n>**示例 1：**\n>\n>```\n>输入：target = 7, nums = [2,3,1,2,4,3]\n>输出：2\n>解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：target = 4, nums = [1,4,4]\n>输出：1\n>```\n>\n>**示例 3：**\n>\n>```\n>输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n>输出：0\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= target <= 109`\n>- `1 <= nums.length <= 105`\n>- `1 <= nums[i] <= 105`\n>\n>\n>\n>**进阶：**\n>\n>- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n>\n>前缀和\n>\n>滑动窗口\n\n第一次使用滑动窗口\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int len=nums.length;\n        int i=0;\n        int sum=0;\n        int ans= Integer.MAX_VALUE;\n        for(int j=0;j<len;j++){\n            sum+=nums[j];\n            while(sum>=target){\n                ans=Math.min(ans,j-i+1);\n                sum-=nums[i];\n                i++;\n            }\n        }\n        return ans==Integer.MAX_VALUE?0:ans;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n##  🟡904.水果成篮\n\n> 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。\n>\n> 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n>\n> - 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。\n> - 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n> - 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n>\n> 给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：fruits = [1,2,1]\n> 输出：3\n> 解释：可以采摘全部 3 棵树。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：fruits = [0,1,2,2]\n> 输出：3\n> 解释：可以采摘 [1,2,2] 这三棵树。\n> 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：fruits = [1,2,3,2,2]\n> 输出：4\n> 解释：可以采摘 [2,3,2,2] 这四棵树。\n> 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n> 输出：5\n> 解释：可以采摘 [1,2,1,1,2] 这五棵树。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= fruits.length <= 105`\n> - `0 <= fruits[i] < fruits.length`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int totalFruit(int[] fruits) {\n        int len=fruits.length;\n        if(len<=2){\n            return len;\n        }\n        int index=0,cnt=0,max=0;\n        int i=0,j=i+1;\n        while(j<len&&fruits[j]==fruits[i]){\n            j++;\n        }\n        while(index<len){\n            if(fruits[index]==fruits[i]||fruits[index]==fruits[j]){\n                cnt++;\n            }else{\n                i=j;\n                j=i+1;\n                while(j<len&&fruits[j]==fruits[i]){\n                    j++;\n                }\n                cnt=1;\n                index=i;\n            }\n            max=Math.max(max,cnt);\n            index++;\n        }\n        return max;\n    }\n}\n```\n\n- time:*O(n)*\n\n- space:*O(1)*\n\n## 🔴76.最小覆盖子串\n\n> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n>\n> \n>\n> **注意：**\n>\n> - 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。\n> - 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n> 输出：\"BANC\"\n> 解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"a\", t = \"a\"\n> 输出：\"a\"\n> 解释：整个字符串 s 是最小覆盖子串。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"a\", t = \"aa\"\n> 输出: \"\"\n> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n> 因此没有符合条件的子字符串，返回空字符串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == s.length`\n> - `n == t.length`\n> - `1 <= m, n <= 105`\n> - `s` 和 `t` 由英文字母组成\n>\n> \n>\n> **进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n","categories":["algorithm learning"]}]