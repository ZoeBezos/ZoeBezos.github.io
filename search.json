[{"title":"简历","url":"/2023/06/12/6-12-resume-cn/","content":"\n巴拉巴案例\n","tags":["resume"],"categories":["resume"]},{"title":"Book List","url":"/2023/06/09/6-9-book-list/","content":"\n\n\n# 小说\n\n- [ ] 三体\n- [ ] 白鹿原\n- [ ] 使女的故事\n- [ ] 美丽新世界\n- [ ] 1984\n\n\n\n# 传记\n\n- [ ] 巴菲特传\n- [ ] 稻盛和夫自传\n- [ ] 钱钟书传\n- [ ] 成为波伏娃\n- [ ] 苏格拉底传\n\n# 逻辑类\n\n- [ ] 我为什么不结婚\n- [ ] 厌女\n- [ ] 君主论\n- [ ] \n\n# 医学健康类\n\n- [ ] 护照\n- [ ] 施瓦辛格健身全书\n- [ ] 皮肤的秘密\n\n# 人类/心理/社会类\n\n- [ ] 心理学与生活\n- [ ] 跨越边界的社区\n- [ ] 乌合之众\n- [ ] 人性心理学\n- [ ] 乡土中国\n\n# 法律类\n\n- [ ] 刑法学讲义\n- [ ] 洞学奇案\n\n# 财经类\n\n- [ ] 经济学原理\n- [ ] 货币金融学\n- [ ] 聪明的投资者\n\n# 计算机发展史\n\n- [ ] 浪潮之巅\n\n# 历史类\n\n- [ ] 明朝那些事\n- [ ] 中国通史\n- [ ] 全球通史\n- [ ] 极简宇宙史\n\n# 哲学\n\n- [ ] 大问题 简明哲学导论\n- [ ] 理想国\n- [ ] 沉思录\n- [ ] 哲学的历程\n- [ ] 认识你自己\n- [ ] 纯粹理性批判\n- [ ] 存在与虚无\n- [ ] 逻辑与哲学\n- [ ] 你的第一本哲学书\n\n# 艺术\n\n- [ ] 艺术与生活\n\n# 设计\n\n- [ ] 给大家看的设计书\n\n# 摄影\n\n- [ ] 美国纽约摄影学院摄影教材\n\n# 电影\n\n- [ ] 认识电影\n\n# 传播学\n\n- [ ] 舆论\n\n# 考古\n\n- [ ] 考古学与史前文明\n\n# 生物学\n\n- [ ] 所罗门王的指环\n\n# 死亡\n\n- [ ] 安乐死现场\n\n# 俄罗斯文学\n\n- [ ] 白夜\n- [ ] 罪与罚\n- [ ] 白痴\n- [ ] 卡拉马佐夫兄弟\n- [ ] 少年\n- [ ] 群魔\n- [ ] 地下室手记\n\n# 人生意义\n\n- [ ] 编周记\n\n# 两性婚姻\n\n- [ ] 爱的艺术\n\n# 情绪管理\n\n- [ ] 伯恩斯新情绪疗法\n\n# 自然\n\n- [ ] 看不见的自然\n\n# 宗教\n\n- [ ] 佛教的见地和修道\n\n","tags":["hobby"],"categories":["reading"]},{"title":"创建新的Hexo-Blog主题构想","url":"/2023/05/19/5-19-博客主题构想/","content":"\n- <span id=\"head1\"> HOME</span>\n\n![img.png](5-19-博客主题构想/img.png)\n\n- 可以到达六个模块\n- 左上角可以转换四种语言\n- xxxxxxxxxx class Solution{​ public:    vector<int> sortedSquares(vector<int>& nums){        int len = nums.size();        vector<int>ans(len);​        int l=0;        int r=len-1;        int idx=len-1;​        while(idx>=0){            if(nums[l]*nums[l]>nums[r]*nums[r]){                ans[idx]=nums[l]*nums[l];                l++;            }else{                ans[idx]=nums[r]*nums[r];                r--;            }            idx--;        }​        return ans;    }​};​c++\n\n# <span id=\"head2\"> BLOG</span>\n\n![img_1.png](5-19-博客主题构想/img_1.png)\n\n- 左部：按照类别和目录归纳，左上角是BLOG首页\n- 中部：博客内容，左上角是类别，右上角是修改时间，底部是评论区\n- 右部：文章toc，右上角是HOME页链接\n\n# <span id=\"head3\"> RESUME</span>\n\n![img_2.png](5-19-博客主题构想/img_2.png)\n\n- 左部：左上角是RESUME首页，左下角转换四种语言\n- 中部：简历\n- 右部：简历toc，右上角是HOME页链接\n\n# <span id=\"head4\"> HOBBY</span>\n\n![img_3.png](5-19-博客主题构想/img_3.png)\n\n- 左部：按照类别和目录归纳，左上角是HOBBY首页\n- 中部：内容，左上角是类别，右上角是时间戳\n- 右部：内容toc，右上角是HOME页链接\n\n# <span id=\"head5\"> DIARY</span>\n\n![img_4.png](5-19-博客主题构想/img_4.png)\n\n- 左部：日期+题目，左上角是DIARY首页\n- 中部：内容，左上角是今日心情、新日天气，右上角是时间戳\n- 右部：本月心情记录，本月天气记录，右上角是HOME页链接\n\n# <span id=\"head6\"> REVIEW</span>\n![img_5.png](5-19-博客主题构想/img_5.png)\n\n\n- 左部：年、月、日归纳，点击年有年复盘，点击月有月复盘，点击日是日复盘，左上角是REVIEW首页\n- 中部：\n  - 日复盘：按日复盘，左上角是第几周周几，右上角是时间戳\n  - 月复盘：按月复盘，左上角是几月，右上角是时间戳\n  - 年复盘：按年复盘，左上角是几年，右上角是时间戳\n- 右部：在日历上，按照周次和周几复盘，点击第几周是周复盘，右上角是HOME页链接\n\n# <span id=\"head7\"> PREVIEW</span>\n\n![img_6.png](5-19-博客主题构想/img_6.png)\n\n- 左部：按照规划类型归纳，左上角是PREVIEW首页\n- 中部：\n- 右部：内容toc，右上角是HOME页链接\n\n","tags":["hobby","private"],"categories":["thoughts"]},{"title":"Array 3:Squares of a Sorted Array","url":"/2023/05/14/5-14-array-3-squares-of-a-sorted-array/","content":"# <span id=\"head1\">[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)</span>\n\n![977](5-14-array-3-squares-of-a-sorted-array/img.png)\n\n## <span id=\"head2\"> NOTE</span>\n\n原本自己读完题想着要先挨个平方完，然后快排（没错本人就是这么垃圾:sob:）这样的话，是复杂度是O(n+nlogn)，\n绝对超过了O(n)。之后看到了提示说用双指针，就恍然大悟：①遍历数组找到正负分界点②从这个点向两端依次确定\n最小值，直到有一侧达到尽头③处理剩下的数组。写完之后，发现卡哥的思路：从数组两端向中间聚拢，以此确定最大值，\n这样省了找分界点和处理剩下元素的时间，respect！！\n\n## <span id=\"head3\">c++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> ans(nums.size());\n        int FLAG=1;\n        int r=0;\n        while(nums[r]<0){\n            r++;\n            if(r>=nums.size())break;\n        }\n        int l=r-1;\n        if(l<0||r>=nums.size())FLAG=0;\n        int idx=0;\n        while(FLAG&&idx<nums.size()){\n            if(nums[l]*(-1)<nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l--;\n                if(l<0)FLAG=0;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r++;\n                if(r>=nums.size())FLAG=0;\n            }\n            idx++;\n        }\n\n        if(FLAG==0){\n            if(l<0){//剩下右边\n                while(idx<nums.size()&&r<nums.size()){\n                    ans[idx]=nums[r]*nums[r];\n                    idx++;\n                    r++;\n                }\n            }else{\n                 while(idx<nums.size()&&l>=0){\n                    ans[idx]=nums[l]*nums[l];\n                    idx++;\n                    l--;\n                }\n            }\n        }\n\n        return ans;\n\n    }\n};\n\n```\n## <span id=\"head4\">java solution</span>\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        \n        int len=nums.length;\n        int[]ans=new int[len];\n        int FLAG=1;\n\n        int r=0;\n        while(nums[r]<0){\n            r++;\n            if(r>=len){\n                FLAG=0;\n                break;\n            }\n        }\n\n        int l=r-1;\n        if(l<0) FLAG=0;\n\n        int idx=0;\n        while(FLAG==1&&idx<len){\n\n            if(nums[l]*(-1)<nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l--;\n                if(l<0)FLAG=0;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r++;\n                if(r>=len)FLAG=0;\n            }\n\n            idx++;\n        }\n\n        if(FLAG==0){\n            if(l<0){//只剩右边\n\n                while(idx<len&&r<len){\n                    ans[idx]=nums[r]*nums[r];\n                    idx++;\n                    r++;\n                }\n                \n            }else{\n                while(idx<len&&l>=0){\n                    ans[idx]=nums[l]*nums[l];\n                    idx++;\n                    l--;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## <span id=\"head5\">improved solution</span>\n\n显然代码短了很多\n\n```c++\nclass Solution{\n\n public:\n\n    vector<int> sortedSquares(vector<int>& nums){\n        int len = nums.size();\n        vector<int>ans(len);\n\n        int l=0;\n        int r=len-1;\n        int idx=len-1;\n\n        while(idx>=0){\n            if(nums[l]*nums[l]>nums[r]*nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l++;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r--;\n            }\n            idx--;\n        }\n\n        return ans;\n    }\n\n};\n\n```","tags":["blog"],"categories":["algorithm-training"]},{"title":"Array 2:Remove Element","url":"/2023/05/11/5-11-array-2-remove-element/","content":"\n\n\n# <span id=\"head1\">[27. 移除元素](https://leetcode.cn/problems/remove-element/)</span>\n\n![27](5-11-array-2-remove-element/1.png)\n\n## <span id=\"head2\">C++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n\n       int cur_index =0;\n       int length=nums.size();\n       int last_index=length-1;\n\n       if(length==1&&nums[0]==val)return 0;\n\n       while(cur_index<length){\n           if(nums[cur_index]==val){\n               while(nums[last_index]==val){\n                   length--;\n                   if(length==0)return 0;\n                    last_index=length-1;\n                    \n               }\n               if(cur_index<last_index){\n                    int t=nums[last_index];\n                    nums[last_index]=nums[cur_index];\n                    nums[cur_index]=t;\n               }\n               \n           }\n           cur_index++;\n       }\n         \n\t\treturn length;\n    }\n};\n```\n\n## <span id=\"head3\">Java solution</span>\n\n```java\n    class Solution {\n    public int removeElement(int[] nums, int val) {\n      \n      int cur=0;\n      int length=nums.length;\n      int last=length-1;\n\n      if(length==0)return 0;\n\n      while(cur<length){\n\n          if(nums[cur]==val){\n\n              while(nums[last]==val){\n                    length--;\n                    if(length==0)return 0;\n                    last=length-1;\n              }\n              if(cur<last){\n                  int t=nums[cur];\n                  nums[cur]=nums[last];\n                  nums[last]=t;\n              }\n          }\n          cur++;\n      }\n\n        return length;\n    }\n\n}\n```\n\n#  <span id=\"head1\">[26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)</span>\n\n![26](5-11-array-2-remove-element/2.png)\n\n## <span id=\"head5\">C++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int cur=0;\n        int next=cur+1;\n\n        if(nums.size()==1)return 1;\n\n        while(cur<=nums.size()-1){\n\n            while(next<nums.size()&&nums[next]==nums[cur])next++;\n            cur++;\n            if(cur>=nums.size()||next>=nums.size())break;\n\n            nums[cur]=nums[next];\n            \n            \n        }\n        return cur;\n    }\n    \n};\n```\n\n## <span id=\"head6\">Java solution</span>\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int cur=0;\n        int next=cur+1;\n\n        if(nums.length==1)return 1;\n\n        while(cur<=nums.length-1){\n           \n            while(next<nums.length&&nums[next]==nums[cur])next++;\n            cur++;\n            if(cur==nums.length||next==nums.length)break;\n            nums[cur]=nums[next];\n\n        }\n\n        return cur;\n    }\n}\n```","tags":["blog"],"categories":["algorithm-training"]}]