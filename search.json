[{"title":"2. List","url":"/2023/09/13/23-9-13-algorithm-list/","content":"\n|      | 是否完成 | 难度 | 题号                                                         | 标签 |\n| ---- | :------: | :--: | ------------------------------------------------------------ | :--- |\n| 1    |          |  🟢   | [<span id=\"head1\"> 203.移除链表元素</span>](#head1)          |      |\n| 2    |          |  🟡   | [<span id=\"head2\">707.设计链表 </span>](#head2)              |      |\n| 3    |          |  🟢   | [<span id=\"head3\">206.反转链表 </span>](#head3)              |      |\n| 4    |          |  🟡   | [<span id=\"head4\">24. 两两交换链表中的节点</span>](#head4)   |      |\n| 5    |          |  🟡   | [<span id=\"head5\"> 19.删除链表的倒数第N个节点</span>](#head5) |      |\n| 6    |          |  🟢   | [<span id=\"head6\">160.链表相交 </span>](#head6)              |      |\n| 7    |          |  🟡   | [<span id=\"head7\">142.环形链表II</span>](#head7)             |      |\n\n# 🟢  [<span id=\"head1\"> 203.移除链表元素</span>](#head1)\n\n# 🟡  [<span id=\"head2\">707.设计链表 </span>](#head2)\n\n# 🟢  [<span id=\"head3\">206.反转链表 </span>](#head3)\n\n# 🟡  [<span id=\"head4\">24. 两两交换链表中的节点</span>](#head4)\n\n# 🟡  [<span id=\"head5\"> 19.删除链表的倒数第N个节点</span>](#head5)\n\n# 🟢  [<span id=\"head6\">160.链表相交 </span>](#head6)\n\n# 🟡  [<span id=\"head7\">142.环形链表II</span>](#head7)\n","tags":["private"],"categories":["algorithm"]},{"title":"1. Array","url":"/2023/08/27/23-8-27-algorithm-array/","content":"\n\n\n|      | 是否完成 | 难度 | 题号                                                      | 标签                 |\n| ---- | :------: | :--: | --------------------------------------------------------- | :------------------- |\n| 1    |    ✅     |  🟢   | [[704]二分查找](#head1)                                   | 二分法               |\n| 2    |    ✅     |  🟢   | [[35]搜索插入位置 ](#head2)                               | 二分法 左边缘        |\n| 3    |    ✅     |  🟡   | [[34]在排序数组中查找元素的第一个和最后一个位置 ](#head3) | 二分法 左边缘 右边缘 |\n| 4    |    ✅     |  🟢   | [[69]x 的平方根](#head4)                                  | 二分法 右边界 数学   |\n| 5    |    ✅     |  🟢   | [[367]有效的完全平方数](#head5)                           | 二分法 右边界 数学   |\n| 6    |    ✅     |  🟢   | [[27]移除元素 ](#head6)                                   | 双指针               |\n| 7    |    ✅     |  🟢   | [[26]删除排序数组中的重复项](#head7)                      | 双指针               |\n| 8    |    ✅     |  🟢   | [[283]移动零](#head8)                                     | 双指针               |\n| 9    |    ✅     |  🟢   | [[844]比较含退格的字符串](#head9)                         | 栈 (双指针)          |\n| 10   |    ✅     |  🟢   | [[977]有序数组的平方 ](#head10)                           | 双指针               |\n| 11   |    ✅     |  🟡   | [[209]长度最小的子数组 ](#head11)                         | 滑动窗口 (队列)      |\n| 12   |    ✅     |  🟡   | [[904]水果成篮](#head12)                                  | 滑动窗口             |\n| 13   |          |  🟠   | [[76]最小覆盖子串](#head13)                               |                      |\n| 14   |    ✅     |  🟡   | [[59]螺旋矩阵II ](#head14)                                | 模拟                 |\n| 15   |    ✅     |  🟡   | [[54]螺旋矩阵](#head15)                                   | 模拟                 |\n\n\n\n# <span id=\"head1\"> 🟢[704]二分查找</span>a\n\n>给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [-1,0,3,5,9,12], target = 9\n>输出: 4\n>解释: 9 出现在 nums 中并且下标为 4\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: nums = [-1,0,3,5,9,12], target = 2\n>输出: -1\n>解释: 2 不存在 nums 中因此返回 -1\n>```\n>\n>\n>\n>**提示：**\n>\n>1. 你可以假设 `nums` 中的所有元素是不重复的。\n>2. `n` 将在 `[1, 10000]`之间。\n>3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n\n        int len=nums.length;\n        int l=0,r=len-1;\n\n        while(l<=r){\n            //int mid=(l+r)>>1; 改进成下面↓,可以防止溢出.\n            int mid=l+((r-l)>>1);\n\n            if(target<nums[mid]){\n                r=mid-1;\n            }else if(target>nums[mid]){\n                l=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n\n\n# <span id=\"head2\">🟢[35]搜索插入位置 </span>\n\n>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n>\n>请必须使用时间复杂度为 `O(log n)` 的算法。\n>\n>\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 5\n>输出: 2\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 2\n>输出: 1\n>```\n>\n>**示例 3:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 7\n>输出: 4\n>```\n>\n>\n>\n>**提示:**\n>\n>- `1 <= nums.length <= 104`\n>- `-104 <= nums[i] <= 104`\n>- `nums` 为 **无重复元素** 的 **升序** 排列数组\n>- `-104 <= target <= 104`\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n\n        int len=nums.length;\n        int l=0, r=len-1;\n\n        while(l<=r){\n            int mid=l+((r-l)>>1);\n            if(target<nums[mid]){\n                r=mid-1;\n            }else if(target>nums[mid]){\n                l=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return l;//此时l代表元素在数组中的左边缘.如果元素有重复,则是第一次出现的位置.\n    }\n}\n```\n\n\n\n# <span id=\"head3\">🟡[34]在排序数组中查找元素的第一个和最后一个位置 </span>\n\n>\n>\n>给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n>\n>如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n>\n>你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [5,7,7,8,8,10], target = 8\n>输出：[3,4]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [5,7,7,8,8,10], target = 6\n>输出：[-1,-1]\n>```\n>\n>**示例 3：**\n>\n>```\n>输入：nums = [], target = 0\n>输出：[-1,-1]\n>```\n>\n>\n>\n>**提示：**\n>\n>- `0 <= nums.length <= 105`\n>- `-109 <= nums[i] <= 109`\n>- `nums` 是一个非递减数组\n>- `-109 <= target <= 109`\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n\n        int len= nums.length;\n        int l=0,r=len-1;\n        int mid=0;\n        int[]ans={-1,-1};\n\n        if(len==0){\n            return ans;\n        }\n\t\t//以下是寻找元素在数组中第一次出现的位置\n        while(l<r){\n            mid=l+((r-l)>>1);\n            if(target<=nums[mid]){\n                r=mid;\n            }else{\n                l=mid+1;\n            }\n\n        }\n        if(target==nums[l]){\n            ans[0]=l;\n        }else{//元素不存在\n            return ans;\n        }\n        \n\t\t//以下是寻找元素在数组中最后一次出现的位置\t\n        l=0;\n        r=len-1;\n        while(l<r){\n            mid=l+((r-l+1)>>1);//找右边缘需要加一\n            if(target>=nums[mid]){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        ans[1]=r;\n\n        return ans;\n\n    }\n}\n```\n\n\n\n# <span id=\"head4\">🟢[69]x 的平方根</span>\n\n> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。\n>\n> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**\n>\n> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 4\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = 8\n> 输出：2\n> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= x <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n第一次想到了,用二分查找,但是感觉比较一维线性(?),果不其然遇到2147395599超时了.\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l=0,r=x;\n        while(l<r){\n            int mid=l+((r-l)>>1);\n            if(x<=mid*mid){\n                r=mid;\n            }else{\n                l=mid+1;\n            }\n        }\n        if(l*l==x){\n            return l;\n        }\n        return l-1;\n    }\n}\n```\n\n接着看了别人题解,发现下面错误:\n\n1. 根据数学理论,应当寻找右边界,而不是之前认为的左边界\n2. **if(x<=mid*mid)**可能导致乘法运算溢出,故改成**if(x/mid<=mid)**\n3. 需要考虑x=0和x=1的特殊情况\n\n```Java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==0||x==1){\n            return x;\n        }\n        int l=1,r=x-1,mid=0;\n        while(l<r){\n            mid=l+((r-l+1)>>1);\n            if(x/mid>=mid){//❗防止乘法运算溢出\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r;\n    }\n}\n```\n\n\n\n# <span id=\"head5\"> 🟢[367]有效的完全平方数</span>\n\n> 给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。\n>\n> **完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n>\n> 不能使用任何内置的库函数，如 `sqrt` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 16\n> 输出：true\n> 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 14\n> 输出：false\n> 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n```Java\n    public boolean isPerfectSquare(int num) {\n        if(num==1)return true;\n        int l=1,r=num;\n        while(l<r){\n            int mid=l+((r-l+1)>>1);\n            if(num/mid>=mid){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r*r==num;\n    }\n}\n```\n\n\n\n# <span id=\"head6\">🟢[27]移除元素 </span>\n\n>给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n>不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n>\n>\n>\n>**说明:**\n>\n>为什么返回数值是整数，但输出的答案是数组呢?\n>\n>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n>你可以想象内部操作如下:\n>\n>```\n>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n>int len = removeElement(nums, val);\n>\n>// 在函数里修改输入数组对于调用者是可见的。\n>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n>for (int i = 0; i < len; i++) {\n>print(nums[i]);\n>}\n>```\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [3,2,2,3], val = 3\n>输出：2, nums = [2,2]\n>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [0,1,2,2,3,0,4,2], val = 2\n>输出：5, nums = [0,1,4,0,3]\n>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n>```\n>\n>\n>\n>**提示：**\n>\n>- `0 <= nums.length <= 100`\n>- `0 <= nums[i] <= 50`\n>- `0 <= val <= 100`\n>\n>Related Topics\n>\n>数组\n>\n>双指针\n\n```Java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int len=nums.length;\n        int pre=0,last=len-1;\n        while(last>=0&&nums[last]==val){//寻找从后往前数的第一个可以替换的位置\n            last--;\n        }\n        while(pre<last){\n            if(nums[pre]==val){\n                int temp=nums[pre];\n                nums[pre]=nums[last];\n                nums[last]=temp;\n                while(last>=pre&&nums[last]==val){//再次寻找从后往前数的第一个可以替换的位置\n                    last--;\n                }\n            }\n            pre++;\n        }\n        return last+1;\n    }\n}\n```\n\n# <span id=\"head7\">🟢[26]删除排序数组中的重复项</span>\n\n> 给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。\n>\n> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：\n>\n> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。\n> - 返回 `k` 。\n>\n> **判题标准:**\n>\n> 系统会用下面的代码来测试你的题解:\n>\n> ```\n> int[] nums = [...]; // 输入数组\n> int[] expectedNums = [...]; // 长度正确的期望答案\n> \n> int k = removeDuplicates(nums); // 调用\n> \n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n> ```\n>\n> 如果所有断言都通过，那么您的题解将被 **通过**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2,_]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **升序** 排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```Java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len=nums.length;\n        if(len==1)return 1;\n        int a=0,b=a+1;\n\n        while(b<len&&nums[b]==nums[a]){//b指向第一个和a指向的元素不同的元素\n            b++;\n        }\n\n        while(a+1<len&&b<len){\n            nums[a+1]=nums[b];\n            a++;\n            while(b<len&&nums[b]==nums[a]){//b指向下一个和a指向的元素不同的元素\n                b++;\n            }\n        }\n        return a+1;\n    }\n}\n```\n\n\n\n# <span id=\"head8\"> 🟢[283]移动零</span>\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len= nums.length;\n        int a=0;\n        while(a<len&&nums[a]!=0){//a指向第一个零元素\n            a++;\n        }\n        int b=a+1;\n        while(b<len&&nums[b]==0){//b指向第一个非零元素\n            b++;\n        }\n        while(a<len&b<len){\n            int temp=nums[a];\n            nums[a]=nums[b];\n            nums[b]=temp;\n            while(a<len&&nums[a]!=0){//a指向下一个零元素\n                a++;\n            }\n            b=a+1;\n            while(b<len&&nums[b]==0){//b指向下一个非零元素\n                b++;\n            }\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head9\"> 🟢[844]比较含退格的字符串</span>\n\n> 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。\n>\n> **注意：**如果对空文本输入退格字符，文本继续为空。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ab#c\", t = \"ad#c\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"ac\"。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"ab##\", t = \"c#d#\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"\"。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a#c\", t = \"b\"\n> 输出：false\n> 解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length, t.length <= 200`\n> - `s` 和 `t` 只含有小写字母以及字符 `'#'`\n>\n> \n>\n> **进阶：**\n>\n> - 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 双指针\n>\n> 字符串\n>\n> 模拟\n\n这道题首先想到了用栈,但是既然在训练双指针,还是用双指针做一遍吧.\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String s, String t) {\n        int len_s=s.length(),len_t=t.length();\n        Stack<Character> S=new Stack<Character>();//这里注意尖括号里面是Character,不是char\n        Stack<Character> T=new Stack<Character>();\n\n        int index_s=0;\n        while(index_s<len_s){\n            if(s.charAt(index_s)!='#'){\n                S.push(s.charAt(index_s));\n            }else if(!S.empty()){\n                S.pop();\n            }\n            index_s++;\n        }\n\n        int index_t=0;\n        while(index_t<len_t){\n            if(t.charAt(index_t)!='#'){\n                T.push(t.charAt(index_t));\n            }else if(!T.empty()){\n                T.pop();\n            }\n            index_t++;\n        }\n        return S.equals(T);\n    }\n}\n```\n\n\n\n# <span id=\"head10\">🟢[977]有序数组的平方 </span>\n\n>给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [-4,-1,0,3,10]\n>输出：[0,1,9,16,100]\n>解释：平方后，数组变为 [16,1,0,9,100]\n>排序后，数组变为 [0,1,9,16,100]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [-7,-3,2,3,11]\n>输出：[4,9,9,49,121]\n>```\n>\n>**提示：**\n>\n>- `1 <= nums.length <= 104`\n>- `-104 <= nums[i] <= 104`\n>- `nums` 已按 **非递减顺序** 排序\n>\n>**进阶：**\n>\n>- 请你设计时间复杂度为 `O(n)` 的算法解决本问题\n>\n>Related Topics\n>\n>数组\n>\n>双指针\n>\n>排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n\n        int len=nums.length;\n        int[]ans=new int[len];//创建定长的新数组\n        int index=len-1;\n        int l=0,r=len-1;\n        while(index>=0){\n            if(nums[l]*nums[l]>=nums[r]*nums[r]){\n                ans[index]=nums[l]*nums[l];\n                l++;\n            }else{\n                ans[index]=nums[r]*nums[r];\n                r--;\n            }\n            index--;\n        }\n        return ans;\n    }\n}\n```\n\n\n\n# <span id=\"head11\">🟡[209]长度最小的子数组 </span>\n\n>给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**\n>\n>找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n>\n>**示例 1：**\n>\n>```\n>输入：target = 7, nums = [2,3,1,2,4,3]\n>输出：2\n>解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：target = 4, nums = [1,4,4]\n>输出：1\n>```\n>\n>**示例 3：**\n>\n>```\n>输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n>输出：0\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= target <= 109`\n>- `1 <= nums.length <= 105`\n>- `1 <= nums[i] <= 105`\n>\n>\n>\n>**进阶：**\n>\n>- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n>\n>前缀和\n>\n>滑动窗口\n\n暴力解法,也许可以骗一点分.🙃\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int len=nums.length;\n        int ans=100001,sum=0;\n        for(int i=0;i<len;i++){\n            int sum_=0;\n            for(int j=i;j<len&&sum_<target;j++){\n                sum_+=nums[j];\n                if(sum_>=target&&(j-i+1)<=ans){\n                    ans=j-i+1;\n                    sum=sum_;\n                }\n            }\n        }\n        if(ans!=100001){\n            return ans;\n        }else{\n            return 0;\n        }\n    }\n}\n```\n\n第一次使用滑动窗口\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int len=nums.length;\n        int i=0;\n        int sum=0;\n        int ans= Integer.MAX_VALUE;\n        for(int j=0;j<len;j++){\n            sum+=nums[j];\n            while(sum>=target){\n                ans=Math.min(ans,j-i+1);\n                sum-=nums[i];\n                i++;\n            }\n        }\n        return ans==Integer.MAX_VALUE?0:ans;\n    }\n}\n```\n\n\n\n# <span id=\"head12\"> 🟡[904]水果成篮</span>\n\n> 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。\n>\n> 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n>\n> - 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。\n> - 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n> - 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n>\n> 给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：fruits = [1,2,1]\n> 输出：3\n> 解释：可以采摘全部 3 棵树。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：fruits = [0,1,2,2]\n> 输出：3\n> 解释：可以采摘 [1,2,2] 这三棵树。\n> 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：fruits = [1,2,3,2,2]\n> 输出：4\n> 解释：可以采摘 [2,3,2,2] 这四棵树。\n> 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n> 输出：5\n> 解释：可以采摘 [1,2,1,1,2] 这五棵树。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= fruits.length <= 105`\n> - `0 <= fruits[i] < fruits.length`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int totalFruit(int[] fruits) {\n        int len=fruits.length;\n        if(len<=2){\n            return len;\n        }\n        int index=0,cnt=0,max=0;\n        int i=0,j=i+1;\n        while(j<len&&fruits[j]==fruits[i]){\n            j++;\n        }\n        while(index<len){\n            if(fruits[index]==fruits[i]||fruits[index]==fruits[j]){\n                cnt++;\n            }else{\n                i=j;\n                j=i+1;\n                while(j<len&&fruits[j]==fruits[i]){\n                    j++;\n                }\n                cnt=1;\n                index=i;\n            }\n            max=Math.max(max,cnt);\n            index++;\n        }\n        return max;\n    }\n}\n```\n\n\n\n# <span id=\"head13\"> 🟠[76]最小覆盖子串</span>\n\n> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n>\n> \n>\n> **注意：**\n>\n> - 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。\n> - 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n> 输出：\"BANC\"\n> 解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"a\", t = \"a\"\n> 输出：\"a\"\n> 解释：整个字符串 s 是最小覆盖子串。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"a\", t = \"aa\"\n> 输出: \"\"\n> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n> 因此没有符合条件的子字符串，返回空字符串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == s.length`\n> - `n == t.length`\n> - `1 <= m, n <= 105`\n> - `s` 和 `t` 由英文字母组成\n>\n> \n>\n> **进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n# <span id=\"head14\">🟡[59]螺旋矩阵II </span>\n\n>给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。\n>\n>\n>\n>**示例 1：**\n>\n>![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n>\n>```\n>输入：n = 3\n>输出：[[1,2,3],[8,9,4],[7,6,5]]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：n = 1\n>输出：[[1]]\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= n <= 20`\n>\n>Related Topics\n>\n>数组\n>\n>矩阵\n>\n>模拟\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int [][]matrix=new int[n][n];\n        int cnt=1;\n        int i=0,j=-1;\n        while(cnt<=n){\n            matrix[i][++j]=cnt++;//👉\n        }\n        int len=n-1;\n        while(cnt<=n*n){\n            for (int k = 1; k <= len; k++) {\n                matrix[++i][j]=cnt++;//👇\n            }\n            for (int k = 1; k <= len; k++) {\n                matrix[i][--j]=cnt++;//👈\n            }\n            len--;\n            if(len>0){\n                for (int k = 1; k <= len; k++) {\n                    matrix[--i][j]=cnt++;//👆\n                }\n                for (int k = 1; k <= len; k++) {\n                    matrix[i][++j]=cnt++;//👉\n                }\n                len--;\n            }\n        }\n        return matrix;\n    }\n}\n```\n\n\n\n# <span id=\"head15\"> 🟡[54]螺旋矩阵</span>\n\n> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[1,2,3,6,9,8,7,4,5]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= m, n <= 10`\n> - `-100 <= matrix[i][j] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n=matrix.length;\n        int m=matrix[0].length;\n        List<Integer> res=new ArrayList<>();\n        int i=0,j=-1;\n        while(j<m-1){\n            res.add(matrix[i][++j]);   //👉\n        }\n        while(n*m>0){\n\n            n--;\n            for (int k = 0; k <n; k++) {\n                res.add(matrix[++i][j]);//👇\n            }\n\n            m--;\n            if(n*m>0){\n                for (int k = 0; k < m; k++) {\n                    res.add(matrix[i][--j]);//👈\n                }\n            }\n\n            n--;\n            if(n*m>0){\n                for (int k = 0; k < n; k++) {\n                    res.add(matrix[--i][j]);//👆\n                }\n            }\n\n            m--;\n            if(n*m>0){\n                for (int k = 0; k < m; k++) {\n                    res.add(matrix[i][++j]);//👉\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n","tags":["private"],"categories":["algorithm"]},{"title":"list","url":"/2023/08/27/list/","content":"\n[toc]\n\n# 代码随想录算法训练营14期\n\n当前任务：\n\n​                ● day 1 任务以及具体安排：[第一章 数组part01](https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY)\n\n​                ● day 2 任务以及具体安排：[day 2 第一章数组](https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG)  \n\n​                ● day 3 任务以及具体安排：[day 3 第二章 链表](https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6) \n\n​                ● day 4 任务以及具体安排：[day 4 第二章 链表](https://docs.qq.com/doc/DUFNjYUxYRHRVWklp)\n\n​                ● day 5 周日休息\n\n​                ● day 6 任务以及具体安排：[day 6 第三章 哈希表](https://docs.qq.com/doc/DUEtFSGdreWRuR2p4) \n\n​                ● day 7 任务以及具体安排：[day 7 第三章 哈希表](https://docs.qq.com/doc/DUElCb1NyTVpXa0Jj) \n\n​                ● day 8 任务以及具体安排：[day 8 第四章 字符串](https://docs.qq.com/doc/DUGdsY2JFaFhDRVZH)\n\n​                ● day 9 任务以及具体安排：[day 9 第四章 字符串](https://docs.qq.com/doc/DUHVXSnZNaXpVUHN4) \n\n​                ● day 10 任务以及具体安排：[day 10第五章 栈与队列](https://docs.qq.com/doc/DUElqeHh3cndDbW1Q) \n\n​                ● day 11 任务以及具体安排：[day 11 第五章 栈与队列](https://docs.qq.com/doc/DUHh6UE5hUUZOZUd0) \n\n​                ● day 12 周日休息\n\n​                ● day 13 任务以及具体安排：[day 13 第五章 栈与队列](https://docs.qq.com/doc/DUHNpa3F4b2dMUWJ3) \n\n​                ● day 14 任务以及具体安排：[day 14 第六章二叉树](https://docs.qq.com/doc/DUHRtdXZZSWFkeGdE) \n\n​                ● day 15 任务以及具体安排：[day 15 第六章二叉树](https://docs.qq.com/doc/DUHN0ZVJuRmVYeWNv) \n\n​                ● day 16 任务以及具体安排：[day 16 第六章二叉树](https://docs.qq.com/doc/DUHBQRm1aSWR4T2NK) \n\n​                ● day 17 任务以及具体安排：[day 17 第六章二叉树](https://docs.qq.com/doc/DUFpXY3hBZkpabWFY) \n\n​                ● day 18 任务以及具体安排：[day 18 第六章 二叉树](https://docs.qq.com/doc/DUFFiVHl3YVlReVlr) \n\n​                ● day 19 周日休息\n\n​                ● day 20 任务以及具体安排：[day 20 第六章 二叉树](https://docs.qq.com/doc/DUGFRU2V6Z1F4alBH)  \n\n​                ● day 21 任务以及具体安排：[day 21 第六章 二叉树](https://docs.qq.com/doc/DUHl2SGNvZmxqZm1X) \n\n​                ● day 22 任务以及具体安排：[day 22 第六章 二叉树](https://docs.qq.com/doc/DUHplVUp5YnN1bnBL)  \n\n​                ● day 23 任务以及具体安排：[day 23 第六章 二叉树](https://docs.qq.com/doc/DUFBUQmxpQU1pa29C) \n\n​                ● day 24 任务以及具体安排：[24 第七章 回溯算法](https://docs.qq.com/doc/DUEhsb0pUUm1WT2NP)  \n\n​                ● day 25 任务以及具体安排：[25 第七章 回溯算法](https://docs.qq.com/doc/DUExTYXVzU1BiU2Zl) \n\n​                ● day 26 休息\n\n​                ● day 27 任务以及具体安排：[27 第七章 回溯算法](https://docs.qq.com/doc/DUElpbnNUR3hIbXlY) \n\n​                ● day 28 任务以及具体安排：[28 第七章 回溯算法](https://docs.qq.com/doc/DUG1yVHdlWEdNYlhZ)\n\n​                ● day 29 任务以及具体安排：[29 第七章 回溯算法](https://docs.qq.com/doc/DUHZYbWhwSHRCRmp3)\n\n​                ● day 30 任务以及具体安排：[30 第七章 回溯算法](https://docs.qq.com/doc/DUEdTVVhxbnJiY3BR) \n\n​                ● day 31 任务以及具体安排：[31第八章 贪心算法](https://docs.qq.com/doc/DUG1PQ1ZZY2xXY1ly) \n\n​                ● day 32 任务以及具体安排：[32 第八章 贪心算法](https://docs.qq.com/doc/DUGFEdGFWeVhleFF1) \n\n​                ● day 33 周日休息 \n\n​                ● day 34 任务以及具体安排：[34 第八章 贪心算法](https://docs.qq.com/doc/DUEh5WFVlQkp1U0p4)  \n\n​                ● day 35 任务以及具体安排：[35 第八章 贪心算法](https://docs.qq.com/doc/DUFRWc3BGRHFXZ1pO)  \n\n​                ● day 36 任务以及具体安排：[36 第八章 贪心算法](https://docs.qq.com/doc/DUERGbnhhRkFRVENZ) \n\n​                ● day 37 任务以及具体安排：[37 第八章 贪心算法](https://docs.qq.com/doc/DUFVRd3p5SHFMSExQ)  \n\n​                ● day 38 任务以及具体安排：[38 第九章 动态规划](https://docs.qq.com/doc/DUGNUdVpoT0VJR01l) \n\n​                ● day 39 任务以及具体安排：[39 第八章 动态规划](https://docs.qq.com/doc/DUE55cVJ5WkNoREhS) \n\n​                ● day 40 周日休息\n\n​                ● day 41 任务以及具体安排：[41 第八章 动态规划](https://docs.qq.com/doc/DUFhIUXRFYnVGUkFp) \n\n​                ● day 42 任务以及具体安排：[42 第八章 动态规划](https://docs.qq.com/doc/DUGdkaEl5dFN1QnBl) \n\n​                ● day 43 任务以及具体安排：[43第八章 动态规划](https://docs.qq.com/doc/DUEVMRHZOemN5S2Vm) \n\n​                ● day 44 任务以及具体安排：[44 第八章 动态规划](https://docs.qq.com/doc/DUHBSRVRUc0Vsck1z) \n\n​                ● day 45 任务以及具体安排：[45 第八章 动态规划](https://docs.qq.com/doc/DUFVEbWRyZlpjaGty)\n\n​                ● day 46 任务以及具体安排：[46 第八章 动态规划](https://docs.qq.com/doc/DUHhuT2RTTEtBeGhX) \n\n​                ● day 47 周日休息\n\n​                ● day 48 任务以及具体安排：[48 第八章 动态规划](https://docs.qq.com/doc/DUGd5ZkNZS1NsYkFk) \n\n​                ● day 49 任务以及具体安排：[49 第八章 动态规划](https://docs.qq.com/doc/DUFhzV29ZSEtFVkto)  \n\n​                ● day 50 任务以及具体安排：[50 第八章 动态规划](https://docs.qq.com/doc/DUEtsRGRXT2F2Y0FR) \n\n​                ● day 51 任务以及具体安排：[51 第八章 动态规划](https://docs.qq.com/doc/DUGt6dWVUUFhHUlpH) \n\n​                ● day 52 任务以及具体安排：[52 第八章 动态规划](https://docs.qq.com/doc/DUFJzanBWVXNVWW1N) \n\n​                ● day 53 任务以及具体安排：[53 第八章 动态规划](https://docs.qq.com/doc/DUEVBcnBldHBKWk12)\n\n​                ● day 54 周日休息\n\n​                ● day 55 任务以及具体安排：[55 第八章 动态规划](https://docs.qq.com/doc/DUGtwYWlEZVZSVXdF) \n\n​                ● day 56 任务以及具体安排：[56 第八章 动态规划](https://docs.qq.com/doc/DUEdhTmx4SW9OcVJo)  \n\n​                ● day 57 任务以及具体安排：[57 第八章 动态规划](https://docs.qq.com/doc/DUHNxR2VUZURGb3NN)  \n\n​                ● day 58 任务以及具体安排：[58 第九章 单调栈](https://docs.qq.com/doc/DUEJTT1BoS29NTGRD)  \n\n​                ● day 59 任务以及具体安排：[59 第九章 单调栈](https://docs.qq.com/doc/DUHhnTHZUSGpHZ0Z2)\n\n​                ● day 60 任务以及具体安排：[60 第十章 单调栈](https://docs.qq.com/doc/DUFJEbG5uTHV2a1hC)\n\n# 1 数组 part01\n\n 今日任务\n\n 数组理论基础 \n\n文章链接：[https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/数组理论基础.html)\n\n题目建议： 了解一下数组基础，以及数组的内存空间地址，数组也没那么简单。\n\n## 704. 二分查找\n\n题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。\n\n先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。\n\n题目链接：https://leetcode.cn/problems/binary-search/\n\n文章讲解：[https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html](https://programmercarl.com/0704.二分查找.html)\n\n视频讲解：https://www.bilibili.com/video/BV1fA4y1o715\n\n##  27. 移除元素\n\n题目建议： 暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。 \n\n题目链接：https://leetcode.cn/problems/remove-element/ \n\n文章讲解：[https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0027.移除元素.html)\n\n视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP \n\n\n\n# 2 数组 part02\n\n977.有序数组的平方 ，209.长度最小的子数组 ，59.螺旋矩阵II ，总结 \n\n建议大家先独立做题，然后看视频讲解，然后看文章讲解，然后在重新做一遍题，把题目AC，最后整理成今日当天的博客\n\n拓展题目可以先不做\n\n 详细布置\n\n##  977.有序数组的平方 \n\n题目建议： 本题关键在于理解双指针思想 \n\n题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/\n\n文章讲解：[https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html](https://programmercarl.com/0977.有序数组的平方.html)\n\n视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep \n\n##  209.长度最小的子数组\n\n题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。 拓展题目可以先不做。 \n\n题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/\n\n文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html](https://programmercarl.com/0209.长度最小的子数组.html)\n\n视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE\n\n##  59.螺旋矩阵II\n\n题目建议： 本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 \n\n题目链接：https://leetcode.cn/problems/spiral-matrix-ii/\n\n文章讲解：[https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html](https://programmercarl.com/0059.螺旋矩阵II.html)\n\n视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/\n\n 总结 \n\n题目建议：希望大家 也做一个自己 对数组专题的总结\n\n文章链接：[https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/数组总结篇.html) \n\n# 3 链表 part01\n\n​                ● 链表理论基础 \n\n​                ● 203.移除链表元素 \n\n​                ● 707.设计链表 \n\n​                ● 206.反转链表 \n\n 详细布置 \n\n 链表理论基础 \n\n建议：了解一下链接基础，以及链表和数组的区别 \n\n文章链接：[https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/链表理论基础.html)\n\n##  203.移除链表元素 \n\n建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。\n\n题目链接/文章讲解/视频讲解：：[https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0203.移除链表元素.html)\n\n##  707.设计链表 \n\n建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html](https://programmercarl.com/0707.设计链表.html)\n\n##  206.反转链表 \n\n建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html](https://programmercarl.com/0206.翻转链表.html) \n\n# 4 链表 part02 \n\n今日任务 \n\n​                ● 24. 两两交换链表中的节点 \n\n​                ● 19.删除链表的倒数第N个节点 \n\n​                ● 面试题 02.07. 链表相交 \n\n​                ● 142.环形链表II \n\n​                ● 总结\n\n 详细布置 \n\n##  24. 两两交换链表中的节点 \n\n用虚拟头结点，这样会方便很多。 \n\n本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。\n\n题目链接/文章讲解/视频讲解： [https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html](https://programmercarl.com/0024.两两交换链表中的节点.html)\n\n##  19.删除链表的倒数第N个节点 \n\n双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html](https://programmercarl.com/0019.删除链表的倒数第N个节点.html)\n\n##  面试题 02.07. 链表相交 \n\n本题没有视频讲解，大家注意 数值相同，不代表指针相同。\n\n题目链接/文章讲解：[https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html](https://programmercarl.com/面试题02.07.链表相交.html)\n\n##  142.环形链表II \n\n算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html](https://programmercarl.com/0142.环形链表II.html)\n\n# 5 哈希表 part01\n\n 今日任务 \n\n​                ● 哈希表理论基础 \n\n​                ● 242.有效的字母异位词 \n\n​                ● 349. 两个数组的交集 \n\n​                ● 202. 快乐数\n\n​                ● 1. 两数之和  \n\n 详细布置 \n\n 哈希表理论基础 \n\n建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。 \n\n什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 这句话很重要，大家在做哈希表题目都要思考这句话。 \n\n文章讲解：[https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/哈希表理论基础.html)  \n\n##  242.有效的字母异位词 \n\n建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。 \n\n题目链接/文章讲解/视频讲解： [https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html](https://programmercarl.com/0242.有效的字母异位词.html)  \n\n##  349. 两个数组的交集 \n\n建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 <= nums1[i], nums2[i] <= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html](https://programmercarl.com/0349.两个数组的交集.html)  \n\n##  202. 快乐数 \n\n建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子 \n\n题目链接/文章讲解：[https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html](https://programmercarl.com/0202.快乐数.html)  \n\n##  1. 两数之和 \n\n建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。 \n\n建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0001.两数之和.html) \n\n# 6 哈希表 part02\n\n 今日任务 \n\n​                ● 454.四数相加II \n\n​                ● 383. 赎金信 \n\n​                ● 15. 三数之和 \n\n​                ● 18. 四数之和 \n\n​                ● 总结 \n\n 详细布置 \n\n##  454.四数相加II \n\n建议：本题是 使用map 巧妙解决的问题，好好体会一下 哈希法 如何提高程序执行效率，降低时间复杂度，当然使用哈希法 会提高空间复杂度，但一般来说我们都是舍空间 换时间， 工业开发也是这样。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html](https://programmercarl.com/0454.四数相加II.html)  \n\n##  383. 赎金信 \n\n建议：本题 和 242.有效的字母异位词 是一个思路 ，算是拓展题 \n\n题目链接/文章讲解：[https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html](https://programmercarl.com/0383.赎金信.html) \n\n##  15. 三数之和 \n\n建议：本题虽然和 两数之和 很像，也能用哈希法，但用哈希法会很麻烦，双指针法才是正解，可以先看视频理解一下 双指针法的思路，文章中讲解的，没问题 哈希法很麻烦。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0015.三数之和.html) \n\n##  18. 四数之和 \n\n建议： 要比较一下，本题和 454.四数相加II 的区别，为什么 454.四数相加II 会简单很多，这个想明白了，对本题理解就深刻了。 本题 思路整体和 三数之和一样的，都是双指针，但写的时候 有很多小细节，需要注意，建议先看视频。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0018.四数之和.html) \n\n# 7 字符串 part01\n\n 今日任务 \n\n​                ● 344.反转字符串\n\n​                ● 541. 反转字符串II\n\n​                ● 剑指Offer 05.替换空格\n\n​                ● 151.翻转字符串里的单词\n\n​                ● 剑指Offer58-II.左旋转字符串\n\n 详细布置 \n\n##  344.反转字符串 \n\n建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html](https://programmercarl.com/0344.反转字符串.html)  \n\n##  541. 反转字符串II\n\n建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html](https://programmercarl.com/0541.反转字符串II.html)  \n\n##  剑指Offer 05.替换空格 \n\n建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。\n\n题目链接/文章讲解：[https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html](https://programmercarl.com/剑指Offer05.替换空格.html)  \n\n##  151.翻转字符串里的单词 \n\n建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html](https://programmercarl.com/0151.翻转字符串里的单词.html)  \n\n##  剑指Offer58-II.左旋转字符串 \n\n建议：题解中的解法如果没接触过的话，应该会想不到\n\n题目链接/文章讲解：[https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html](https://programmercarl.com/剑指Offer58-II.左旋转字符串.html)  \n\n# 8 字符串 part02\n\n今日任务 \n\n​                ● 28. 实现 strStr()\n\n​                ● 459.重复的子字符串\n\n​                ● 字符串总结 \n\n​                ● 双指针回顾 \n\n 详细布置 \n\n## 28. 实现 strStr() （本题可以跳过）\n\n因为KMP算法很难，大家别奢求 一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会 好懂很多。\n\n或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。\n\n因为大家 算法能力还没到，细扣 很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有 算法基础和思维了，在看多看几遍视频，慢慢就理解了。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html](https://programmercarl.com/0028.实现strStr.html) \n\n##  459.重复的子字符串 （本题可以跳过）\n\n本题算是KMP算法的一个应用，不过 对KMP了解不够熟练的话，理解本题就难很多。 \n\n我的建议是 KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html](https://programmercarl.com/0459.重复的子字符串.html) \n\n字符串总结 \n\n比较简单，大家读一遍就行 \n\n题目链接/文章讲解：[https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html](https://programmercarl.com/字符串总结.html) \n\n 双指针回顾 \n\n此时我们已经做过10到双指针的题目了，来一起回顾一下，大家自己也总结一下双指针的心得 \n\n文章讲解：[https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html](https://programmercarl.com/双指针总结.html) \n\n# 9 栈与队列 part01\n\n今日任务：\n\n​                ● 理论基础\n\n​                ● 232.用栈实现队列\n\n​                ● 225. 用队列实现栈\n\n理论基础 \n\n了解一下 栈与队列的内部实现机智，文中是以C++为例讲解的。 \n\n文章讲解：[https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/栈与队列理论基础.html)   \n\n##  232.用栈实现队列 \n\n大家可以先看视频，了解一下模拟的过程，然后写代码会轻松很多。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html](https://programmercarl.com/0232.用栈实现队列.html)   \n\n##  225. 用队列实现栈 \n\n可以大家惯性思维，以为还要两个队列来模拟栈，其实只用一个队列就可以模拟栈了。 \n\n建议大家掌握一个队列的方法，更简单一些，可以先看视频讲解\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html](https://programmercarl.com/0225.用队列实现栈.html)  \n\n# 10 栈与队列 part02\n\n今日内容： \n\n​                ● 20. 有效的括号\n\n​                ● 1047. 删除字符串中的所有相邻重复项\n\n​                ● 150. 逆波兰表达式求值\n\n 详细布置 \n\n##  20. 有效的括号 \n\n讲完了栈实现队列，队列实现栈，接下来就是栈的经典应用了。 \n\n大家先自己思考一下 有哪些不匹配的场景，在看视频 我讲的都有哪些场景，落实到代码其实就容易很多了。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html](https://programmercarl.com/0020.有效的括号.html)  \n\n##  1047. 删除字符串中的所有相邻重复项 \n\n栈的经典应用。 \n\n要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html](https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html)  \n\n##  150. 逆波兰表达式求值 \n\n本题不难，但第一次做的话，会很难想到，所以先看视频，了解思路再去做题 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html](https://programmercarl.com/0150.逆波兰表达式求值.html)  \n\n# 11 栈与队列 part03\n\n 今日内容： \n\n​                ● 239. 滑动窗口最大值\n\n​                ● 347.前 K 个高频元素\n\n​                ● 总结\n\n 详细布置 \n\n##  239. 滑动窗口最大值 （一刷至少需要理解思路）\n\n之前讲的都是栈的应用，这次该是队列的应用了。\n\n本题算比较有难度的，需要自己去构造单调队列，建议先看视频来理解。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html](https://programmercarl.com/0239.滑动窗口最大值.html) \n\n##  347.前 K 个高频元素 （一刷至少需要理解思路）\n\n大/小顶堆的应用， 在C++中就是优先级队列 \n\n本题是 大数据中取前k值 的经典思路，了解想法之后，不算难。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0347.前K个高频元素.html)  \n\n 总结 \n\n栈与队列做一个总结吧，加油\n\n[https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html](https://programmercarl.com/栈与队列总结.html)  \n\n# 12 二叉树 part01\n\n今日内容： \n\n​                ● 理论基础\n\n​                ● 递归遍历 \n\n​                ● 迭代遍历\n\n​                ● 统一迭代\n\n 详细布置 \n\n 理论基础 \n\n需要了解 二叉树的种类，存储方式，遍历方式 以及二叉树的定义 \n\n文章讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/二叉树理论基础.html)  \n\n##  递归遍历 （必须掌握）\n\n二叉树的三种递归遍历掌握其规律后，其实很简单 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html](https://programmercarl.com/二叉树的递归遍历.html)  \n\n##  迭代遍历 （基础不好的录友，迭代法可以放过）\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html](https://programmercarl.com/二叉树的迭代遍历.html)  \n\n##  统一迭代  （基础不好的录友，迭代法可以放过）\n\n这是统一迭代法的写法， 如果学有余力，可以掌握一下\n\n题目链接/文章讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html](https://programmercarl.com/二叉树的统一迭代法.html)  \n\n# 13 二叉树 part02\n\n今日内容： \n\n​                ● 层序遍历 10 \n\n​                ● 226.翻转二叉树 \n\n​                ● 101.对称二叉树 2  \n\n 详细布置 \n\n##  层序历 \n\n看完本篇可以一口气刷十道题，试一试， 层序遍历并不难，大家可以很快刷了十道题。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html](https://programmercarl.com/0102.二叉树的层序遍历.html)\n\n##  226.翻转二叉树 （优先掌握递归） \n\n这道题目 一些做过的同学 理解的也不够深入，建议大家先看我的视频讲解，无论做过没做过，都会有很大收获。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0226.翻转二叉树.html) \n\n##  101. 对称二叉树 （优先掌握递归） \n\n先看视频讲解，会更容易一些。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0101.对称二叉树.html)  \n\n\n\n# 14 二叉树 part03\n\n今日内容： \n\n​                ● 104.二叉树的最大深度 559.n叉树的最大深度\n\n​                ● 111.二叉树的最小深度\n\n​                ● 222.完全二叉树的节点个数\n\n迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。\n\n 详细布置 \n\n##  104.二叉树的最大深度 （优先掌握递归）\n\n什么是深度，什么是高度，如何求深度，如何求高度，这里有关系到二叉树的遍历方式。\n\n大家 要先看视频讲解，就知道以上我说的内容了，很多录友刷过这道题，但理解的还不够。\n\n题目链接/文章讲解/视频讲解： [https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html](https://programmercarl.com/0104.二叉树的最大深度.html)  \n\n##  111.二叉树的最小深度 （优先掌握递归）\n\n先看视频讲解，和最大深度 看似差不多，其实 差距还挺大，有坑。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html](https://programmercarl.com/0111.二叉树的最小深度.html) \n\n##  222.完全二叉树的节点个数（优先掌握递归）\n\n需要了解，普通二叉树 怎么求，完全二叉树又怎么求\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html](https://programmercarl.com/0222.完全二叉树的节点个数.html)  \n\n# 15  二叉树 part04\n\n今日内容： \n\n​                ● 110.平衡二叉树 \n\n​                ● 257. 二叉树的所有路径 \n\n​                ● 404.左叶子之和 \n\n 详细布置 \n\n迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。\n\n##  110.平衡二叉树 （优先掌握递归）\n\n再一次涉及到，什么是高度，什么是深度，可以巩固一下。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0110.平衡二叉树.html)  \n\n##  257. 二叉树的所有路径 （优先掌握递归） \n\n这是大家第一次接触到回溯的过程， 我在视频里重点讲解了 本题为什么要有回溯，已经回溯的过程。 \n\n如果对回溯 似懂非懂，没关系， 可以先有个印象。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html](https://programmercarl.com/0257.二叉树的所有路径.html) \n\n##  404.左叶子之和 （优先掌握递归）\n\n其实本题有点文字游戏，搞清楚什么是左叶子，剩下的就是二叉树的基本操作。 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0404.左叶子之和.html)  \n\n# 16 二叉树 part05\n\n  今日内容 \n\n​                ● 513.找树左下角的值\n\n​                ● 112. 路径总和 113.路径总和ii\n\n​                ● 106.从中序与后序遍历序列构造二叉树 105.从前序与中序遍历序列构造二叉树\n\n 详细布置 \n\n##  找树左下角的值 \n\n本地递归偏难，反而迭代简单属于模板题， 两种方法掌握一下 \n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html](https://programmercarl.com/0513.找树左下角的值.html)  \n\n##  路径总和 \n\n本题 又一次设计要回溯的过程，而且回溯的过程隐藏的还挺深，建议先看视频来理解 \n\n\\112. 路径总和，和 113. 路径总和ii 一起做了。 优先掌握递归法。\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html](https://programmercarl.com/0112.路径总和.html)  \n\n##  从中序与后序遍历序列构造二叉树 \n\n本题算是比较难的二叉树题目了，大家先看视频来理解。 \n\n106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树 一起做，思路一样的\n\n题目链接/文章讲解/视频讲解：[https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html) \n\n# 17 二叉树 part06\n\n今日内容 \n\n​                ● 654.最大二叉树 \n\n​                ● 617.合并二叉树 \n\n​                ● 700.二叉搜索树中的搜索 \n\n​                ● 98.验证二叉搜索树 \n\n 详细布置 \n\n##  654.最大二叉树 \n\n又是构造二叉树，昨天大家刚刚做完 中序后序确定二叉树，今天做这个 应该会容易一些， 先看视频，好好体会一下 为什么构造二叉树都是 前序遍历 \n\n题目链接/文章讲解：[https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0654.最大二叉树.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1MG411G7ox  \n\n##  617.合并二叉树 \n\n这次是一起操作两个二叉树了， 估计大家也没一起操作过两个二叉树，也不知道该如何一起操作，可以看视频先理解一下。 优先掌握递归。\n\n题目链接/文章讲解：[https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0617.合并二叉树.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1m14y1Y7JK  \n\n##  700.二叉搜索树中的搜索 \n\n递归和迭代 都可以掌握以下，因为本题比较简单， 了解一下 二叉搜索树的特性\n\n题目链接/文章讲解: [https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html](https://programmercarl.com/0700.二叉搜索树中的搜索.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1wG411g7sF   \n\n##  98.验证二叉搜索树 \n\n遇到 搜索树，一定想着中序遍历，这样才能利用上特性。 \n\n但本题是有陷阱的，可以自己先做一做，然后在看题解，看看自己是不是掉陷阱里了。这样理解的更深刻。\n\n题目链接/文章讲解：[https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html](https://programmercarl.com/0098.验证二叉搜索树.html) \n\n视频讲解：https://www.bilibili.com/video/BV18P411n7Q4  \n\n# 18 二叉树 part07\n\n今日内容 \n\n​                ● 530.二叉搜索树的最小绝对差 \n\n​                ● 501.二叉搜索树中的众数 \n\n​                ● 236. 二叉树的最近公共祖先 \n\n 详细布置 \n\n##  530.二叉搜索树的最小绝对差 \n\n需要领悟一下二叉树遍历上双指针操作，优先掌握递归 \n\n题目链接/文章讲解：[https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html](https://programmercarl.com/0530.二叉搜索树的最小绝对差.html) \n\n视频讲解：https://www.bilibili.com/video/BV1DD4y11779 \n\n##  501.二叉搜索树中的众数 \n\n和 530差不多双指针思路，不过 这里涉及到一个很巧妙的代码技巧。\n\n可以先自己做做看，然后看我的视频讲解。\n\n[https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html](https://programmercarl.com/0501.二叉搜索树中的众数.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1fD4y117gp  \n\n##  236. 二叉树的最近公共祖先 \n\n本题其实是比较难的，可以先看我的视频讲解 \n\n[https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html](https://programmercarl.com/0236.二叉树的最近公共祖先.html) \n\n视频讲解：https://www.bilibili.com/video/BV1jd4y1B7E2   \n\n# 19 二叉树 part08\n\n今日内容： \n\n​                ● 235. 二叉搜索树的最近公共祖先 \n\n​                ● 701.二叉搜索树中的插入操作 \n\n​                ● 450.删除二叉搜索树中的节点 \n\n 详细布置 \n\n##  235. 二叉搜索树的最近公共祖先 \n\n相对于 二叉树的最近公共祖先 本题就简单一些了，因为 可以利用二叉搜索树的特性。 \n\n题目链接/文章讲解：[https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html](https://programmercarl.com/0235.二叉搜索树的最近公共祖先.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1Zt4y1F7ww  \n\n##  701.二叉搜索树中的插入操作 \n\n本题比想象中的简单，大家可以先自己想一想应该怎么做，然后看视频讲解，就发现 本题为什么比较简单了。\n\n题目链接/文章讲解：[https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html](https://programmercarl.com/0701.二叉搜索树中的插入操作.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1Et4y1c78Y  \n\n##  450.删除二叉搜索树中的节点 \n\n相对于 插入操作，本题就有难度了，涉及到改树的结构 \n\n题目链接/文章讲解：[https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html](https://programmercarl.com/0450.删除二叉搜索树中的节点.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1tP41177us  \n\n# 20 二叉树 part09\n\n 今日内容：\n\n​                ● 669. 修剪二叉搜索树 \n\n​                ● 108.将有序数组转换为二叉搜索树 \n\n​                ● 538.把二叉搜索树转换为累加树 \n\n​                ● 总结篇 \n\n 详细布置 \n\n##  669. 修剪二叉搜索树 \n\n这道题目比较难，比 添加增加和删除节点难的多，建议先看视频理解。\n\n题目链接/文章讲解： [https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html](https://programmercarl.com/0669.修剪二叉搜索树.html)  \n\n视频讲解： https://www.bilibili.com/video/BV17P41177ud  \n\n##  108.将有序数组转换为二叉搜索树 \n\n本题就简单一些，可以尝试先自己做做。\n\n[https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html](https://programmercarl.com/0108.将有序数组转换为二叉搜索树.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1uR4y1X7qL  \n\n##  538.把二叉搜索树转换为累加树 \n\n本题也不难，在 求二叉搜索树的最小绝对差 和 众数 那两道题目 都讲过了 双指针法，思路是一样的。\n\n[https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html](https://programmercarl.com/0538.把二叉搜索树转换为累加树.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1d44y1f7wP\n\n 总结篇 \n\n好了，二叉树大家就这样刷完了，做一个总结吧\n\n[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/二叉树总结篇.html)   \n\n\n\n# 21 回溯算法 part01\n\n今日内容：\n\n​                ● 理论基础 \n\n​                ● 77. 组合 \n\n 详细布置 \n\n 理论基础 \n\n其实在讲解二叉树的时候，就给大家介绍过回溯，这次正式开启回溯算法，大家可以先看视频，对回溯算法有一个整体的了解。\n\n题目链接/文章讲解：[https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/回溯算法理论基础.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1cy4y167mM  \n\n##  77. 组合 \n\n对着 在 回溯算法理论基础 给出的 代码模板，来做本题组合问题，大家就会发现 写回溯算法套路。\n\n在回溯算法解决实际问题的过程中，大家会有各种疑问，先看视频介绍，基本可以解决大家的疑惑。\n\n本题关于剪枝操作是大家要理解的重点，因为后面很多回溯算法解决的题目，都是这个剪枝套路。 \n\n题目链接/文章讲解：[https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html](https://programmercarl.com/0077.组合.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1ti4y1L7cv \n\n剪枝操作：https://www.bilibili.com/video/BV1wi4y157er   \n\nhttps://docs.qq.com/doc/DUFBUQmxpQU1pa29C) \n\n# 22 回溯算法 part02\n\n今日内容： \n\n​                ● 216.组合总和III\n\n​                ● 17.电话号码的字母组合\n\n 详细布置 \n\n##  216.组合总和III \n\n如果把 组合问题理解了，本题就容易一些了。 \n\n题目链接/文章讲解：[https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html](https://programmercarl.com/0216.组合总和III.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1wg411873x\n\n##  17.电话号码的字母组合 \n\n本题大家刚开始做会有点难度，先自己思考20min，没思路就直接看题解。 \n\n题目链接/文章讲解：[https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html](https://programmercarl.com/0017.电话号码的字母组合.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1yV4y1V7Ug\n\n# 23 回溯算法 part03\n\n​                ● 39. 组合总和\n\n​                ● 40.组合总和II\n\n​                ● 131.分割回文串\n\n 详细布置 \n\n##  39. 组合总和 \n\n本题是 集合里元素可以用无数次，那么和组合问题的差别 其实仅在于 startIndex上的控制\n\n题目链接/文章讲解：[https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html](https://programmercarl.com/0039.组合总和.html) \n\n视频讲解：https://www.bilibili.com/video/BV1KT4y1M7HJ  \n\n##  40.组合总和II \n\n本题开始涉及到一个问题了：去重。\n\n注意题目中给我们 集合是有重复元素的，那么求出来的 组合有可能重复，但题目要求不能有重复组合。 \n\n题目链接/文章讲解：[https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html](https://programmercarl.com/0040.组合总和II.html)   \n\n视频讲解：https://www.bilibili.com/video/BV12V4y1V73A\n\n##  131.分割回文串 \n\n本题较难，大家先看视频来理解 分割问题，明天还会有一道分割问题，先打打基础。 \n\n[https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html](https://programmercarl.com/0131.分割回文串.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1c54y1e7k6  \n\n# 24 回溯算法 04\n\n​                ● 93.复原IP地址 \n\n​                ● 78.子集 \n\n​                ● 90.子集II \n\n 详细布置 \n\n##  93.复原IP地址 \n\n本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了 \n\n题目链接/文章讲解：[https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html](https://programmercarl.com/0093.复原IP地址.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1XP4y1U73i/\n\n##  78.子集 \n\n子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。 \n\n题目链接/文章讲解：[https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html](https://programmercarl.com/0078.子集.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1U84y1q7Ci \n\n##  90.子集II \n\n大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。 \n\n题目链接/文章讲解：[https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html](https://programmercarl.com/0090.子集II.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1vm4y1F71J\n\n# 25 回溯算法 part05\n\n\\* 491.递增子序列\n\n\\* 46.全排列\n\n\\* 47.全排列 II\n\n详细布置 \n\n## 491.递增子序列 \n\n本题和大家刚做过的 90.子集II 非常像，但又很不一样，很容易掉坑里。 \n\n[https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0491.递增子序列.html) \n\n视频讲解：https://www.bilibili.com/video/BV1EG4y1h78v  \n\n## 46.全排列 \n\n本题重点感受一下，排列问题 与 组合问题，组合总和，子集问题的区别。 为什么排列问题不用 startIndex \n\n[https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html](https://programmercarl.com/0046.全排列.html)   \n\n视频讲解：https://www.bilibili.com/video/BV19v4y1S79W  \n\n## 47.全排列 II \n\n本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合，可以先自己做一下，然后重点看一下 文章中 我讲的拓展内容。 used[i - 1] == true 也行，used[i - 1] == false 也行 \n\n[https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html](https://programmercarl.com/0047.全排列II.html)     \n\n视频讲解：https://www.bilibili.com/video/BV1R84y1i7Tm\n\n# 26 回溯算法 part06\n\n​                ● 332.重新安排行程 \n\n​                ● 51. N皇后 \n\n​                ● 37. 解数独 \n\n​                ● 总结 \n\n详细布置 \n\n今天这三道题都非常难，那么这么难的题，为啥一天做三道？ \n\n因为 一刷 也不求大家能把这么难的问题解决，所以 大家一刷的时候，就了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。 \n\n大家今天的任务，其实是 对回溯算法章节做一个总结就行。 \n\n重点是看 回溯算法总结篇：\n\n[https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html](https://programmercarl.com/回溯总结.html)  \n\n## 332.重新安排行程（可跳过） \n\n[https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html](https://programmercarl.com/0332.重新安排行程.html)  \n\n## 51. N皇后（可跳过） \n\n[https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html](https://programmercarl.com/0051.N皇后.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1Rd4y1c7Bq \n\n## 37. 解数独（可跳过） \n\n[https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html](https://programmercarl.com/0037.解数独.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1TW4y1471V\n\n## 总结 \n\n[https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html](https://programmercarl.com/回溯总结.html) \n\n# 27 贪心算法 part01\n\n​                ● 理论基础 \n\n​                ● 455.分发饼干 \n\n​                ● 376. 摆动序列 \n\n​                ● 53. 最大子序和 \n\n贪心算法其实就是没有什么规律可言，所以大家了解贪心算法 就了解它没有规律的本质就够了。 \n\n不用花心思去研究其规律， 没有思路就立刻看题解。\n\n基本贪心的题目 有两个极端，要不就是特简单，要不就是死活想不出来。 \n\n学完贪心之后再去看动态规划，就会了解贪心和动规的区别。\n\n详细布置 \n\n理论基础 \n\n[https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/贪心算法理论基础.html)  \n\n## 455.分发饼干 \n\n[https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html](https://programmercarl.com/0455.分发饼干.html)  \n\n## 376. 摆动序列 \n\n[https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0376.摆动序列.html)  \n\n## 53. 最大子序和 \n\n[https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html](https://programmercarl.com/0053.最大子序和.html)  \n\nhttps://docs.qq.com/doc/DUEdTVVhxbnJiY3BR) \n\n# 28 贪心算法 part02\n\n​                ● 122.买卖股票的最佳时机II \n\n​                ● 55. 跳跃游戏 \n\n​                ● 45.跳跃游戏II \n\n 详细布置 \n\n##  122.买卖股票的最佳时机II \n\n本题解法很巧妙，大家可以看题思考一下，在看题解。 \n\n[https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html](https://programmercarl.com/0122.买卖股票的最佳时机II.html)  \n\n##  55. 跳跃游戏 \n\n本题如果没接触过，很难想到，所以不要自己憋时间太久，读题思考一会，没思路立刻看题解 \n\n[https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html](https://programmercarl.com/0055.跳跃游戏.html)  \n\n##  45.跳跃游戏II \n\n本题同样不容易想出来。贪心就是这样，有的时候 会感觉简单到离谱，有时候，难的不行，主要是不容易想到。\n\n[https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html](https://programmercarl.com/0045.跳跃游戏II.html)    \n\n# 29 贪心算法 part03\n\n​                ● 1005.K次取反后最大化的数组和 \n\n​                ● 134. 加油站\n\n​                ● 135. 分发糖果 \n\n 详细布置 \n\n##  1005.K次取反后最大化的数组和 \n\n本题简单一些，估计大家不用想着贪心 ，用自己直觉也会有思路。 \n\n[https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html](https://programmercarl.com/1005.K次取反后最大化的数组和.html)  \n\n##  134. 加油站 \n\n本题有点难度，不太好想，推荐大家熟悉一下方法二 \n\n[https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html](https://programmercarl.com/0134.加油站.html)  \n\n## 135.分发糖果 \n\n本题涉及到一个思想，就是想处理好一边再处理另一边，不要两边想着一起兼顾，后面还会有题目用到这个思路 \n\n[https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html](https://programmercarl.com/0135.分发糖果.html)  \n\n# 30 贪心算法 part04\n\n​                ● 860.柠檬水找零 \n\n​                ● 406.根据身高重建队列 \n\n​                ● 452. 用最少数量的箭引爆气球 \n\n 详细布置 \n\n##  860.柠檬水找零 \n\n本题看上好像挺难，其实挺简单的，大家先尝试自己做一做。\n\n[https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html](https://programmercarl.com/0860.柠檬水找零.html)  \n\n##  406.根据身高重建队列 \n\n本题有点难度，和分发糖果类似，不要两头兼顾，处理好一边再处理另一边。 \n\n[https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html](https://programmercarl.com/0406.根据身高重建队列.html)  \n\n##  452. 用最少数量的箭引爆气球 \n\n本题是一道 重叠区间的题目，好好做一做，因为明天三道题目，都是 重叠区间。 \n\n[https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html](https://programmercarl.com/0452.用最少数量的箭引爆气球.html)  \n\nhttps://docs.qq.com/doc/DUEh5WFVlQkp1U0p4) \n\n# 31 贪心算法 part05\n\n 详细布置 \n\n今天的三道题目，都算是 重叠区间 问题，大家可以好好感受一下。 都属于那种看起来好复杂，但一看贪心解法，惊呼：这么巧妙！ \n\n还是属于那种，做过了也就会了，没做过就很难想出来。\n\n不过大家把如下三题做了之后， 重叠区间 基本上差不多了\n\n##  435. 无重叠区间 \n\nhttps://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html  \n\n##  763.划分字母区间 \n\nhttps://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html  \n\n##  56. 合并区间 \n\n本题相对来说就比较难了。\n\nhttps://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html  \n\n# 32 贪心算法 part06\n\n​                ● 738.单调递增的数字 \n\n​                ● 968.监控二叉树 \n\n​                ● 总结 \n\n 详细布置 \n\n##  738.单调递增的数字 \n\n[https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html](https://programmercarl.com/0738.单调递增的数字.html)  \n\n##  968.监控二叉树 （可以跳过）\n\n本题是贪心和二叉树的一个结合，比较难，一刷大家就跳过吧。 \n\n[https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0968.监控二叉树.html)  \n\n 总结 \n\n可以看看贪心算法的总结，贪心本来就没啥规律，能写出个总结篇真的不容易了。 \n\n[https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/贪心算法总结篇.html) \n\n# 33 动态规划 part01\n\n​                ● 理论基础 \n\n​                ● 509. 斐波那契数 \n\n​                ● 70. 爬楼梯 \n\n​                ● 746. 使用最小花费爬楼梯 \n\n 详细布置 \n\n今天正式开始动态规划！\n\n 理论基础 \n\n无论大家之前对动态规划学到什么程度，一定要先看 我讲的 动态规划理论基础。 \n\n如果没做过动态规划的题目，看我讲的理论基础，会有感觉 是不是简单题想复杂了？ \n\n其实并没有，我讲的理论基础内容，在动规章节所有题目都有运用，所以很重要！ \n\n如果做过动态规划题目的录友，看我的理论基础 就会感同身受了。\n\n[https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/动态规划理论基础.html) \n\n视频：https://www.bilibili.com/video/BV13Q4y197Wg  \n\n##  509. 斐波那契数 \n\n很简单的动规入门题，但简单题使用来掌握方法论的，还是要有动规五部曲来分析。\n\n[https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html](https://programmercarl.com/0509.斐波那契数.html)  \n\n视频：https://www.bilibili.com/video/BV1f5411K7mo  \n\n## 70.爬楼梯  \n\n本题大家先自己想一想， 之后会发现，和 斐波那契数 有点关系。\n\n[https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html](https://programmercarl.com/0070.爬楼梯.html)  \n\n视频：https://www.bilibili.com/video/BV17h411h7UH  \n\n## 745.使用最小花费爬楼梯 \n\n这道题目力扣改了题目描述了，现在的题目描述清晰很多，相当于明确说 第一步是不用花费的。 \n\n更改题目描述之后，相当于是 文章中 「拓展」的解法 \n\n[https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html](https://programmercarl.com/0746.使用最小花费爬楼梯.html)   \n\n视频讲解：https://www.bilibili.com/video/BV16G411c7yZ \n\n# 34 动态规划part02\n\n​                ● 62.不同路径 \n\n​                ● 63. 不同路径 II \n\n今天开始逐渐有 dp的感觉了，题目不多，就两个 不同路径，可以好好研究一下\n\n 详细布置 \n\n##  62.不同路径 \n\n本题大家掌握动态规划的方法就可以。 数论方法 有点非主流，很难想到。 \n\n[https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html](https://programmercarl.com/0062.不同路径.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1ve4y1x7Eu\n\n## 63.不同路径 II \n\n[https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.htmlhttps://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html](https://programmercarl.com/0063.不同路径II.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1Ld4y1k7c6 \n\n# 35 动态规划part03\n\n​                ● 343. 整数拆分 \n\n​                ● 96.不同的二叉搜索树 \n\n 详细布置 \n\n今天两题都挺有难度，建议大家思考一下没思路，直接看题解，第一次做，硬想很难想出来。\n\n##  343. 整数拆分 \n\n[https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html](https://programmercarl.com/0343.整数拆分.html)   \n\n视频讲解：https://www.bilibili.com/video/BV1Mg411q7YJ\n\n##  96.不同的二叉搜索树 \n\n[https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html](https://programmercarl.com/0096.不同的二叉搜索树.html)   \n\n视屏讲解：https://www.bilibili.com/video/BV1eK411o7QA \n\n# 36 动态规划part04\n\n​                ● 01背包问题，你该了解这些！ \n\n​                ● 01背包问题，你该了解这些！ 滚动数组 \n\n​                ● 416. 分割等和子集 \n\n正式开始背包问题，背包问题还是挺难的，虽然大家可能看了很多背包问题模板代码，感觉挺简单，但基本理解的都不够深入。 \n\n如果是直接从来没听过背包问题，可以先看文字讲解慢慢了解 这是干什么的。\n\n如果做过背包类问题，可以先看视频，很多内容，是自己平时没有考虑到位的。 \n\n背包问题，力扣上没有原题，大家先了解理论，今天就安排一道具体题目。 \n\n 详细布置 \n\n##  01背包问题 二维 \n\n[https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html](https://programmercarl.com/背包理论基础01背包-1.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1cg411g7Y6  \n\n##  01背包问题 一维 \n\n[https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html](https://programmercarl.com/背包理论基础01背包-2.html)  \n\n视频讲解：https://www.bilibili.com/video/BV1BU4y177kY  \n\n## 416. 分割等和子集 \n\n本题是 01背包的应用类题目\n\n[https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html](https://programmercarl.com/0416.分割等和子集.html)    \n\n视频讲解：https://www.bilibili.com/video/BV1rt4y1N7jE\n\n# 37 动态规划 part05\n\n​                ● 1049. 最后一块石头的重量 II \n\n​                ● 494. 目标和 \n\n​                ● 474.一和零 \n\n 详细布置 \n\n## 1049. 最后一块石头的重量 II \n\n本题就和 昨天的 416. 分割等和子集 很像了，可以尝试先自己思考做一做。 \n\n视频讲解：https://www.bilibili.com/video/BV14M411C7oV \n\n[https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html](https://programmercarl.com/1049.最后一块石头的重量II.html)  \n\n##  494. 目标和 \n\n大家重点理解 递推公式：dp[j] += dp[j - nums[i]]，这个公式后面的提问 我们还会用到。 \n\n视频讲解：https://www.bilibili.com/video/BV1o8411j73x\n\n[https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html](https://programmercarl.com/0494.目标和.html)  \n\n##  474.一和零 \n\n通过这道题目，大家先粗略了解， 01背包，完全背包，多重背包的区别，不过不用细扣，因为后面 对于 完全背包，多重背包 还有单独讲解。\n\n视频讲解：https://www.bilibili.com/video/BV1rW4y1x7ZQ \n\n[https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html](https://programmercarl.com/0474.一和零.html)  \n\n# 38 动态规划part06\n\n​                ● 完全背包\n\n​                ● 518. 零钱兑换 II \n\n​                ● 377. 组合总和 Ⅳ \n\n 详细布置 \n\n力扣上没有纯粹的完全背包的题目，所以大家看本篇了解一下 完全背包的理论 \n\n后面的两道题目，都是完全背包的应用，做做感受一下 \n\n##  完全背包 \n\n视频讲解：https://www.bilibili.com/video/BV1uK411o7c9\n\n[https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html ](https://programmercarl.com/背包问题理论基础完全背包.html)  \n\n## 518. 零钱兑换 II \n\n视频讲解：https://www.bilibili.com/video/BV1KM411k75j\n\n[https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html](https://programmercarl.com/0518.零钱兑换II.html)  \n\n## 377. 组合总和 Ⅳ \n\n视频讲解：https://www.bilibili.com/video/BV1V14y1n7B6\n\n[https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html](https://programmercarl.com/0377.组合总和Ⅳ.html)\n\nhttps://docs.qq.com/doc/DUEVMRHZOemN5S2Vm)\n\n# 39 动态规划part07\n\n​                ● 70. 爬楼梯 （进阶）\n\n​                ● 322. 零钱兑换 \n\n​                ● 279.完全平方数 \n\n 详细布置 \n\n##  70. 爬楼梯 （进阶） \n\n这道题目 爬楼梯之前我们做过，这次再用完全背包的思路来分析一遍 \n\n[https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html](https://programmercarl.com/0070.爬楼梯完全背包版本.html)  \n\n## 322 零钱兑换 \n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n\n这句话结合本题 大家要好好理解。\n\n视频讲解：https://www.bilibili.com/video/BV14K411R7yv\n\n[https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html](https://programmercarl.com/0322.零钱兑换.html)  \n\n##  279.完全平方数 \n\n本题 和 322. 零钱兑换 基本是一样的，大家先自己尝试做一做 \n\n视频讲解：https://www.bilibili.com/video/BV12P411T7Br\n\n[https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html](https://programmercarl.com/0279.完全平方数.html)  \n\n# 40 动态规划part08\n\n​                ● 139.单词拆分 \n\n​                ● 关于多重背包，你该了解这些！ \n\n​                ● 背包问题总结篇！ \n\n 详细布置 \n\n关于 多重背包，力扣上没有相关的题目，所以今天大家的重点就是回顾一波 自己做的背包题目吧。 \n\n##  139.单词拆分 \n\n视频讲解：https://www.bilibili.com/video/BV1pd4y147Rh\n\n[https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html](https://programmercarl.com/0139.单词拆分.html)\n\n 关于多重背包，你该了解这些！ \n\n[https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html](https://programmercarl.com/背包问题理论基础多重背包.html)\n\n 背包问题总结篇！ \n\n[https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/背包总结篇.html)  \n\n# 41 动态规划part09\n\n​                ● 198.打家劫舍 \n\n​                ● 213.打家劫舍II \n\n​                ● 337.打家劫舍III\n\n 详细布置 \n\n今天就是打家劫舍的一天，这个系列不算难，大家可以一口气拿下。\n\n##  198.打家劫舍 \n\n视频讲解：https://www.bilibili.com/video/BV1Te411N7SX\n\n[https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html](https://programmercarl.com/0198.打家劫舍.html)  \n\n##  213.打家劫舍II \n\n视频讲解：https://www.bilibili.com/video/BV1oM411B7xq\n\n[https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html](https://programmercarl.com/0213.打家劫舍II.html) \n\n##  337.打家劫舍III \n\n视频讲解：https://www.bilibili.com/video/BV1H24y1Q7sY\n\n[https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html](https://programmercarl.com/0337.打家劫舍III.html)\n\n# 42 动态规划part10\n\n​                ● 121. 买卖股票的最佳时机 \n\n​                ● 122.买卖股票的最佳时机II \n\n 详细布置 \n\n股票问题是一个动态规划的系列问题，今日安排的题目不多，大家可以慢慢消化。\n\n## 121. 买卖股票的最佳时机 \n\n视频讲解：https://www.bilibili.com/video/BV1Xe4y1u77q\n\n[https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html](https://programmercarl.com/0121.买卖股票的最佳时机.html)\n\n##  122.买卖股票的最佳时机II \n\n视频讲解：https://www.bilibili.com/video/BV1D24y1Q7Ls\n\n[https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html](https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html)  \n\n# 43 动态规划part11\n\n​                ● 123.买卖股票的最佳时机III \n\n​                ● 188.买卖股票的最佳时机IV \n\n 详细布置 \n\n##  123.买卖股票的最佳时机III \n\n这道题一下子就难度上来了，关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。\n\n视频讲解：https://www.bilibili.com/video/BV1WG411K7AR\n\n[https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html](https://programmercarl.com/0123.买卖股票的最佳时机III.html)  \n\n##  188.买卖股票的最佳时机IV \n\n本题是123.买卖股票的最佳时机III 的进阶版 \n\n视频讲解：https://www.bilibili.com/video/BV16M411U7XJ\n\n[https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html](https://programmercarl.com/0188.买卖股票的最佳时机IV.html)\n\n# 44 动态规划part12\n\n​                ● 309.最佳买卖股票时机含冷冻期 \n\n​                ● 714.买卖股票的最佳时机含手续费 \n\n​                ● 总结\n\n##  309.最佳买卖股票时机含冷冻期 \n\n本题加了一个冷冻期，状态就多了，有点难度，大家要把各个状态分清，思路才能清晰 \n\n视频讲解：https://www.bilibili.com/video/BV1rP4y1D7ku\n\n[https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html](https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html)  \n\n##  714.买卖股票的最佳时机含手续费 \n\n相对122.买卖股票的最佳时机II ，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的，可以尝试自己做一做。\n\n视频讲解：https://www.bilibili.com/video/BV1z44y1Z7UR\n\n[https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html](https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html)\n\n 股票总结 \n\n股票问题做一个总结吧\n\n[https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/动态规划-股票问题总结篇.html)  \n\n# 45 动态规划part13\n\n​                ● 300.最长递增子序列 \n\n​                ● 674. 最长连续递增序列 \n\n​                ● 718. 最长重复子数组 \n\n 详细布置 \n\n##  300.最长递增子序列 \n\n今天开始正式子序列系列，本题是比较简单的，感受感受一下子序列题目的思路。 \n\n视频讲解：https://www.bilibili.com/video/BV1ng411J7xP\n\n[https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0300.最长上升子序列.html)\n\n##  674. 最长连续递增序列 \n\n本题相对于昨天的动态规划：300.最长递增子序列 最大的区别在于“连续”。 先尝试自己做做，感受一下区别 \n\n视频讲解：https://www.bilibili.com/video/BV1bD4y1778v\n\n[https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0674.最长连续递增序列.html)  \n\n##  718. 最长重复子数组 \n\n稍有难度，要使用二维dp数组了\n\n视频讲解：https://www.bilibili.com/video/BV178411H7hV\n\n[https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html](https://programmercarl.com/0718.最长重复子数组.html)\n\n# 46 动态规划part14\n\n​                ● 1143.最长公共子序列 \n\n​                ● 1035.不相交的线  \n\n​                ● 53. 最大子序和 动态规划 \n\n 详细布置 \n\n##  1143.最长公共子序列 \n\n体会一下本题和 718. 最长重复子数组 的区别 \n\n视频讲解：https://www.bilibili.com/video/BV1ye4y1L7CQ\n\n[https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/1143.最长公共子序列.html)\n\n##  1035.不相交的线 \n\n其实本题和 1143.最长公共子序列 是一模一样的，大家尝试自己做一做。\n\n视频讲解：https://www.bilibili.com/video/BV1h84y1x7MP\n\n[https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html](https://programmercarl.com/1035.不相交的线.html)\n\n##  53. 最大子序和 \n\n这道题我们用贪心做过，这次 再用dp来做一遍 \n\n视频讲解：https://www.bilibili.com/video/BV19V4y1F7b5\n\n[https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html](https://programmercarl.com/0053.最大子序和（动态规划）.html)\n\n# 47 动态规划part15\n\n​                ● 392.判断子序列 \n\n​                ● 115.不同的子序列 \n\n 详细布置 \n\n##  392.判断子序列 \n\n这道题目算是 编辑距离问题 的入门题目（毕竟这里只是涉及到减法），慢慢的，后面就要来解决真正的 编辑距离问题了\n\n[https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0392.判断子序列.html)\n\n##  115.不同的子序列 \n\n但相对于刚讲过 392.判断子序列，本题 就有难度了 ，感受一下本题和 392.判断子序列 的区别。 \n\n[https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0115.不同的子序列.html)\n\n# 48 动态规划part16\n\n​                ● 583. 两个字符串的删除操作 \n\n​                ● 72. 编辑距离 \n\n​                ● 编辑距离总结篇  \n\n##  详细布置 \n\n## 583. 两个字符串的删除操作 \n\n本题和动态规划：115.不同的子序列 相比，其实就是两个字符串都可以删除了，情况虽说复杂一些，但整体思路是不变的。\n\n[https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html](https://programmercarl.com/0583.两个字符串的删除操作.html)\n\n##  72. 编辑距离 \n\n最终我们迎来了编辑距离这道题目，之前安排题目都是为了 编辑距离做铺垫。 \n\n[https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html](https://programmercarl.com/0072.编辑距离.html)  \n\n 编辑距离总结篇 \n\n做一个总结吧\n\n[https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html](https://programmercarl.com/为了绝杀编辑距离，卡尔做了三步铺垫.html)  \n\n# 49 动态规划part17\n\n​                ● 647. 回文子串 \n\n​                ● 516.最长回文子序列\n\n​                ● 动态规划总结篇\n\n今天 我们就要结束动态规划章节了，大家激不激动！！！ \n\n 详细布置 \n\n##  647. 回文子串  \n\n动态规划解决的经典题目，如果没接触过的话，别硬想 直接看题解。\n\n[https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html](https://programmercarl.com/0647.回文子串.html)  \n\n##  516.最长回文子序列 \n\n \\647. 回文子串，求的是回文子串，而本题要求的是回文子序列， 大家要搞清楚两者之间的区别。 \n\n[https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html](https://programmercarl.com/0516.最长回文子序列.html)  \n\n 动态规划总结篇 \n\n[https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/动态规划总结篇.html)  \n\n# 50 单调栈 part01\n\n \t\t\t     ● 739. 每日温度 \n\n​                ● 496.下一个更大元素 I \n\n 详细布置 \n\n##  739. 每日温度 \n\n今天正式开始单调栈，这是单调栈一篇扫盲题目，也是经典题。\n\n大家可以读题，思考暴力的解法，然后在看单调栈的解法。 就能感受出单调栈的巧妙\n\n[https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html](https://programmercarl.com/0739.每日温度.html)  \n\n##  496.下一个更大元素 I \n\n本题和 739. 每日温度 看似差不多，其实 有加了点难度。\n\n[https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html](https://programmercarl.com/0496.下一个更大元素I.html)  \n\n# 51 单调栈part02\n\n​                ● 503.下一个更大元素II \n\n​                ● 42. 接雨水 \n\n 详细布置 \n\n##  503.下一个更大元素II \n\n这道题和 739. 每日温度 几乎如出一辙，可以自己尝试做一做\n\n[https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html](https://programmercarl.com/0503.下一个更大元素II.html)  \n\n##  42. 接雨水 \n\n接雨水这道题目是 面试中特别高频的一道题，也是单调栈 应用的题目，大家好好做做。\n\n建议是掌握 双指针 和单调栈，因为在面试中 写出单调栈可能 有点难度，但双指针思路更直接一些。\n\n在时间紧张的情况有，能写出双指针法也是不错的，然后可以和面试官在慢慢讨论如何优化。 \n\n[https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html](https://programmercarl.com/0042.接雨水.html)  \n\n# 52 单调栈part03\n\n有了之前单调栈的铺垫，这道题目就不难了。 \n\n##  84.柱状图中最大的矩形\n\n[https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html](https://programmercarl.com/0084.柱状图中最大的矩形.html)\n\n今天是训练营最后一天，恭喜坚持两个月的录友们，接下来可以写一篇自己 代码随想录一刷的总结。好好回顾一下，这两个月自己的博客内容，以及自己的收获。 \n\nhttps://docs.qq.com/doc/DUHhnTHZUSGpHZ0Z2)\n"}]