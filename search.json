[{"title":"Graph","url":"/2024/01/25/algorithm-graph/","content":"\n| 编号 | 是否完成 | 题号                                   | 标签 |\n| ---- | -------- | -------------------------------------- | ---- |\n| 1    |          | [🟡797. 所有可能的路径](#head1)         |      |\n| 2    |          | [🟡200. 岛屿数量](#head2)               |      |\n| 3    |          | [🟡695. 岛屿的最大面积](#head3)         |      |\n| 4    |          | [🟡1020. 飞地的数量](#head4)            |      |\n| 5    |          | [🟡1254. 统计封闭岛屿的数目](#head5)    |      |\n| 6    |          | [🟡130. 被围绕的区域](#head6)           |      |\n| 7    |          | [🟡417. 太平洋大西洋水流问题](#head7)   |      |\n| 8    |          | [🔴827.最大人工岛](#head8)              |      |\n| 9    |          | [🔴127. 单词接龙](#head9)               |      |\n| 10   |          | [🟡841. 钥匙和房间](#head10)            |      |\n| 11   |          | [🟢463. 岛屿的周长](#head11)            |      |\n| 12   |          | [🟢1971. 寻找图中是否存在路径](#head12) |      |\n| 13   |          | [ 🟡684.冗余连接](#head13)              |      |\n| 14   |          | [ 🔴685.冗余连接II](#head14)            |      |\n\n\n\n# <span id=\"head1\">🟡797. 所有可能的路径</span>\n\n# <span id=\"head2\">🟡200. 岛屿数量</span>\n\n# <span id=\"head3\">🟡695. 岛屿的最大面积</span>\n\n# <span id=\"head4\">🟡1020. 飞地的数量</span>\n\n# <span id=\"head5\">🟡1254. 统计封闭岛屿的数目</span>\n\n# <span id=\"head6\">🟡130. 被围绕的区域</span>\n\n# <span id=\"head7\">🟡417. 太平洋大西洋水流问题</span>\n\n# <span id=\"head8\"> 🔴827.最大人工岛</span>\n\n# <span id=\"head9\">🔴127. 单词接龙</span>\n\n# <span id=\"head10\">🟡841. 钥匙和房间</span>\n\n# <span id=\"head11\">🟢463. 岛屿的周长</span>\n\n# <span id=\"head12\">🟢1971. 寻找图中是否存在路径</span>\n\n# <span id=\"head13\"> 🟡684.冗余连接</span>\n\n# <span id=\"head14\"> 🔴685.冗余连接II</span>\n","categories":["algorithm learning"]},{"title":"Coding Interviews Special","url":"/2024/01/25/problem-set-coding-interviews-special/","content":"\n# 挑战1：整数\n\n# 挑战2：数组\n\n# 挑战3：字符串\n\n# 挑战4：链表\n\n# 挑战5：哈希表\n\n# 挑战6：栈\n\n# 挑战7：队列\n\n# 挑战8：树\n\n# 挑战9：堆\n\n# 挑战10：前缀树\n\n# 挑战11：二分查找\n\n# 挑战12：排序\n\n# 挑战13：回溯法\n\n# 挑战14：动态规划\n\n# 挑战15：图\n\n# \n","categories":["algorithm training"]},{"title":"Cracking the Coding Interview","url":"/2024/01/25/problem-set-cracking-the-coding-interview/","content":"\n# 数组与字符串\n\n# 链表\n\n# 栈与队列\n\n# 树与图\n\n# 位操作\n\n# 递归与动态规划\n\n# 排序与查找\n\n# 中等难题\n\n# 高难度题\n","categories":["algorithm training"]},{"title":"LeetCode 75","url":"/2024/01/25/problem-set-leetcode-75/","content":"\n# 数组/字符串\n\n# 双指针\n\n# 滑动窗口\n\n# 前缀和\n\n# 哈希表/哈希集合\n\n# 栈\n\n# 队列\n\n# 链表\n\n# 二叉树-深度优先搜索\n\n# 二叉树-深度优先遍历\n\n# 二叉搜索树\n\n# 图-深度优先搜索\n\n# 图-广度优先搜索\n\n# 堆/优先队列\n\n# 二分查找\n\n# 回溯\n\n# 动态规划-一维\n\n# 动态规划-多维\n\n# 位运算\n\n# 前缀树\n\n# 区间集合\n\n# 单调栈\n\n","categories":["algorithm training"]},{"title":"LeetCode top interview 150","url":"/2024/01/25/problem-set-top-interview-150/","content":"\n# 数组/字符串\n\n# 双指针\n\n# 滑动窗口\n\n# 矩阵\n\n# 哈希表\n\n# 区间\n\n# 栈\n\n# 链表\n\n# 二叉树\n\n# 二叉树层序遍历\n\n# 二叉搜索树\n\n# 图\n\n# 图的广度优先搜索\n\n# 字典树\n\n# 回溯\n\n# 分治\n\n# kadane算法\n\n# 二分算法\n\n# 堆\n\n# 位运算\n\n# 数学\n\n# 一维动态规划\n\n# 多维动态规划\n\n","categories":["algorithm training"]},{"title":"LeetCode top 100","url":"/2024/01/25/problem-set-top-100/","content":"\n# 哈希\n\n# 双指针\n\n# 滑动窗口\n\n# 子串\n\n# 普通数组\n\n# 矩阵\n\n# 链表\n\n# 二叉树\n\n# 图论\n\n# 回溯\n\n# 二分查找\n\n# 栈\n\n# 堆\n\n# 贪心算法\n\n# 动态规划\n\n# 多维动态规划\n\n# 技巧\n","categories":["algorithm training"]},{"title":"🟢2859. sum of values at indices with k set bits","url":"/2024/01/25/coding-2859-sum-of-values-at-indices-with-k-set-bits/","content":"\n# 问题描述\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。\n>\n> 请你用整数形式返回 `nums` 中的特定元素之 **和** ，这些特定元素满足：其对应下标的二进制表示中恰存在 `k` 个置位。\n>\n> 整数的二进制表示中的 1 就是这个整数的 **置位** 。\n>\n> 例如，`21` 的二进制表示为 `10101` ，其中有 `3` 个置位。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [5,10,1,5,2], k = 1\n> 输出：13\n> 解释：下标的二进制表示是： \n> 0 = 0002\n> 1 = 0012\n> 2 = 0102\n> 3 = 0112\n> 4 = 1002 \n> 下标 1、2 和 4 在其二进制表示中都存在 k = 1 个置位。\n> 因此，答案为 nums[1] + nums[2] + nums[4] = 13 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,3,2,1], k = 2\n> 输出：1\n> 解释：下标的二进制表示是： \n> 0 = 002\n> 1 = 012\n> 2 = 102\n> 3 = 112\n> 只有下标 3 的二进制表示中存在 k = 2 个置位。\n> 因此，答案为 nums[3] = 1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `1 <= nums[i] <= 105`\n> - `0 <= k <= 10`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n\n# 解答\n\n```java\nclass Solution {\n    public int sumIndicesWithKSetBits(List<Integer> nums, int k) {\n        int res=0;\n        for (int i = 0; i < nums.size(); i++) {\n            int t=Integer.bitCount(i);\n            if(t==k){\n                res+=nums.get(i);\n            }\n        }\n        return res;\n    }\n}\n```\n\n","tags":["algorithm-array","algorithm-bit manipulation"]},{"title":"🟡2865.beautiful towers i","url":"/2024/01/24/coding-2865-beautiful-towers-i/","content":"\n# 题目描述\n\n> 给你一个长度为 `n` 下标从 **0** 开始的整数数组 `maxHeights` 。\n>\n> 你的任务是在坐标轴上建 `n` 座塔。第 `i` 座塔的下标为 `i` ，高度为 `heights[i]` 。\n>\n> 如果以下条件满足，我们称这些塔是 **美丽** 的：\n>\n> 1. `1 <= heights[i] <= maxHeights[i]`\n> 2. `heights` 是一个 **山脉** 数组。\n>\n> 如果存在下标 `i` 满足以下条件，那么我们称数组 `heights` 是一个 **山脉** 数组：\n>\n> - 对于所有 `0 < j <= i` ，都有 `heights[j - 1] <= heights[j]`\n> - 对于所有 `i <= k < n - 1` ，都有 `heights[k + 1] <= heights[k]`\n>\n> 请你返回满足 **美丽塔** 要求的方案中，**高度和的最大值** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：maxHeights = [5,3,4,1,1]\n> 输出：13\n> 解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：\n> - 1 <= heights[i] <= maxHeights[i]  \n> - heights 是个山脉数组，峰值在 i = 0 处。\n> 13 是所有美丽塔方案中的最大高度和。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：maxHeights = [6,5,3,9,2,7]\n> 输出：22\n> 解释： 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：\n> - 1 <= heights[i] <= maxHeights[i]\n> - heights 是个山脉数组，峰值在 i = 3 处。\n> 22 是所有美丽塔方案中的最大高度和。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：maxHeights = [3,2,5,5,2,3]\n> 输出：18\n> 解释：和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：\n> - 1 <= heights[i] <= maxHeights[i]\n> - heights 是个山脉数组，最大值在 i = 2 处。\n> 注意，在这个方案中，i = 3 也是一个峰值。\n> 18 是所有美丽塔方案中的最大高度和。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n == maxHeights <= 103`\n> - `1 <= maxHeights[i] <= 109`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n","tags":["algorithm-array","algorithm-stack","algorithm-monotone stack"]},{"title":"🟢2765.longest alternating subarray","url":"/2024/01/23/coding-2765-longest-alternating-subarray/","content":"\n# 题目描述\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` 。如果 `nums` 中长度为 `m` 的子数组 `s` 满足以下条件，我们称它是一个 **交替子数组** ：\n>\n> - `m` 大于 `1` 。\n> - `s1 = s0 + 1` 。\n> - 下标从 **0** 开始的子数组 `s` 与数组 `[s0, s1, s0, s1,...,s(m-1) % 2]` 一样。也就是说，`s1 - s0 = 1` ，`s2 - s1 = -1` ，`s3 - s2 = 1` ，`s4 - s3 = -1` ，以此类推，直到 `s[m - 1] - s[m - 2] = (-1)m` 。\n>\n> 请你返回 `nums` 中所有 **交替** 子数组中，最长的长度，如果不存在交替子数组，请你返回 `-1` 。\n>\n> 子数组是一个数组中一段连续 **非空** 的元素序列。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,3,4,3,4]\n> 输出：4\n> 解释：交替子数组有 [3,4] ，[3,4,3] 和 [3,4,3,4] 。最长的子数组为 [3,4,3,4] ，长度为4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,5,6]\n> 输出：2\n> 解释：[4,5] 和 [5,6] 是仅有的两个交替子数组。它们长度都为 2 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 100`\n> - `1 <= nums[i] <= 104`\n\n# 解答\n\n```java\nclass Solution {\n    public int alternatingSubarray(int[] nums) {\n        int max=1,flag=1,len=1;\n        for (int i = 1; i < nums.length; i++) {\n            if(nums[i]-nums[i-1]==flag){\n                len++;\n                flag*=-1;\n            }else if(nums[i]-nums[i-1]==1){\n                len=2;\n                flag=-1;\n            }else{\n                len=1;\n                flag=1;\n            }\n            max=Math.max(max,len);\n        }\n        return max==1?-1:max;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","tags":["algorithm-array","algorithm-enum"]},{"title":"🟡 670.maximum swap","url":"/2024/01/22/coding-670-maximum-swap/","content":"\n# 题目描述\n\n> 给定一个非负整数，你**至多**可以交换一次数字中的任意两位。返回你能得到的最大值。\n>\n> **示例 1 :**\n>\n> ```\n> 输入: 2736\n> 输出: 7236\n> 解释: 交换数字2和数字7。\n> ```\n>\n> **示例 2 :**\n>\n> ```\n> 输入: 9973\n> 输出: 9973\n> 解释: 不需要交换。\n> ```\n>\n> **注意:**\n>\n> 1. 给定数字的范围是 [0, 108]\n>\n> Related Topics\n>\n> 贪心\n>\n> 数学\n\n# 解答\n\n```java\nclass Solution {\n    public int maximumSwap(int num) {\n        List<Integer>list=new ArrayList<>();\n        String string=String.valueOf(num);\n        int len=string.length();\n        char[]chars=string.toCharArray();\n        for (int i = 0; i < len; i++) {\n            list.add(chars[i]-'0');\n        }\n        Collections.sort(list);\n        Collections.reverse(list);\n        int big;\n        for (int i = 0; i < len; i++) {\n            if(list.get(i)!=chars[i]-'0'){\n                big=list.get(i);\n                char ch= (char) ('0'+big);\n                int index=0;\n                for (int j = len-1; j >= i+1; j--) {\n                    if(chars[j]==ch){\n                        index=j;\n                        break;\n                    }\n                }\n                char temp=chars[index];\n                chars[index]=chars[i];\n                chars[i]=temp;\n                return Integer.valueOf(String.copyValueOf(chars));\n            }\n        }\n        return num;\n    }\n}\n```\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","tags":["algorithm-greedy","algorithm-math"]},{"title":"🔸381th LeetCode Weekly Contest","url":"/2024/01/21/contest-leetcode-weekly-contest-381/","content":"\n| 题号                                           | 标签         | 作答情况   |\n| ---------------------------------------------- | ------------ | ---------- |\n| [🟢3014输入单词需要的最少按键次数 I](#head1)    | 找规律       | 未参与比赛 |\n| [🟡3016. 输入单词需要的最少按键次数 II](#head2) | 哈希表的排序 | 未参与比赛 |\n| [🟡3015. 按距离统计房屋对数目 I](#head3)        |              | 未参与比赛 |\n| [🔴3017. 按距离统计房屋对数目 II](#head4)       |              | 未参与比赛 |\n\n# <span id=\"head1\">[🟢3014输入单词需要的最少按键次数 I](https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-i/)</span>\n\n> 给你一个字符串 `word`，由 **不同** 小写英文字母组成。\n>\n> 电话键盘上的按键与 **不同** 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 `2` 对应 `[\"a\",\"b\",\"c\"]`，我们需要按一次键来输入 `\"a\"`，按两次键来输入 `\"b\"`，按三次键来输入 `\"c\"`*。*\n>\n> 现在允许你将编号为 `2` 到 `9` 的按键重新映射到 **不同** 字母集合。每个按键可以映射到 **任意数量** 的字母，但每个字母 **必须** **恰好** 映射到 **一个** 按键上。你需要找到输入字符串 `word` 所需的 **最少** 按键次数。\n>\n> 返回重新映射按键后输入 `word` 所需的 **最少** 按键次数。\n>\n> 下面给出了一种电话键盘上字母到按键的映射作为示例。注意 `1`，`*`，`#` 和 `0` **不** 对应任何字母。\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png)\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png)\n>\n> ```\n> 输入：word = \"abcde\"\n> 输出：5\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"a\" -> 在按键 2 上按一次\n> \"b\" -> 在按键 3 上按一次\n> \"c\" -> 在按键 4 上按一次\n> \"d\" -> 在按键 5 上按一次\n> \"e\" -> 在按键 6 上按一次\n> 总成本为 1 + 1 + 1 + 1 + 1 = 5 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv1e2.png)\n>\n> ```\n> 输入：word = \"xycdefghij\"\n> 输出：12\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"x\" -> 在按键 2 上按一次\n> \"y\" -> 在按键 2 上按两次\n> \"c\" -> 在按键 3 上按一次\n> \"d\" -> 在按键 3 上按两次\n> \"e\" -> 在按键 4 上按一次\n> \"f\" -> 在按键 5 上按一次\n> \"g\" -> 在按键 6 上按一次\n> \"h\" -> 在按键 7 上按一次\n> \"i\" -> 在按键 8 上按一次\n> \"j\" -> 在按键 9 上按一次\n> 总成本为 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= word.length <= 26`\n> - `word` 仅由小写英文字母组成。\n> - `word` 中的所有字母互不相同。\n\n```java\nclass Solution {\n    public int minimumPushes(String word) {\n        int res=0;\n        for (int i = 0; i < word.length(); i++) {\n            res+=i/8+1;\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head2\">[🟡3016. 输入单词需要的最少按键次数 II](https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-ii/)</span>\n\n> 给你一个字符串 `word`，由 **不同** 小写英文字母组成。\n>\n> 电话键盘上的按键与 **不同** 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 `2` 对应 `[\"a\",\"b\",\"c\"]`，我们需要按一次键来输入 `\"a\"`，按两次键来输入 `\"b\"`，按三次键来输入 `\"c\"`*。*\n>\n> 现在允许你将编号为 `2` 到 `9` 的按键重新映射到 **不同** 字母集合。每个按键可以映射到 **任意数量** 的字母，但每个字母 **必须** **恰好** 映射到 **一个** 按键上。你需要找到输入字符串 `word` 所需的 **最少** 按键次数。\n>\n> 返回重新映射按键后输入 `word` 所需的 **最少** 按键次数。\n>\n> 下面给出了一种电话键盘上字母到按键的映射作为示例。注意 `1`，`*`，`#` 和 `0` **不** 对应任何字母。\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png)\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png)\n>\n> ```\n> 输入：word = \"abcde\"\n> 输出：5\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"a\" -> 在按键 2 上按一次\n> \"b\" -> 在按键 3 上按一次\n> \"c\" -> 在按键 4 上按一次\n> \"d\" -> 在按键 5 上按一次\n> \"e\" -> 在按键 6 上按一次\n> 总成本为 1 + 1 + 1 + 1 + 1 = 5 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/26/keypadv2e2.png)\n>\n> ```\n> 输入：word = \"xyzxyzxyzxyz\"\n> 输出：12\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"x\" -> 在按键 2 上按一次\n> \"y\" -> 在按键 3 上按一次\n> \"z\" -> 在按键 4 上按一次\n> 总成本为 1 * 4 + 1 * 4 + 1 * 4 = 12 。\n> 可以证明不存在其他成本更低的映射方案。\n> 注意按键 9 没有映射到任何字母：不必让每个按键都存在与之映射的字母，但是每个字母都必须映射到按键上。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/27/keypadv2.png)\n>\n> ```\n> 输入：word = \"aabbccddeeffgghhiiiiii\"\n> 输出：24\n> 解释：图片中给出的重新映射方案的输入成本最小。\n> \"a\" -> 在按键 2 上按一次\n> \"b\" -> 在按键 3 上按一次\n> \"c\" -> 在按键 4 上按一次\n> \"d\" -> 在按键 5 上按一次\n> \"e\" -> 在按键 6 上按一次\n> \"f\" -> 在按键 7 上按一次\n> \"g\" -> 在按键 8 上按一次\n> \"h\" -> 在按键 9 上按两次\n> \"i\" -> 在按键 9 上按一次\n> 总成本为 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24 。\n> 可以证明不存在其他成本更低的映射方案。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= word.length <= 105`\n> - `word` 仅由小写英文字母组成。\n\n```java\nclass Solution {\n    public int minimumPushes(String word) {\n        Map<Character,Integer>cnt=new TreeMap<>();\n        int res=0;\n        for (int i = 0; i < word.length(); i++) {\n            char key=word.charAt(i);\n            cnt.put(key,cnt.getOrDefault(key,0)+1);\n        }\n        List<Map.Entry<Character,Integer>>list=new ArrayList<>(cnt.entrySet());\n        Collections.sort(list, new Comparator<Map.Entry<Character, Integer>>() {\n            @Override\n            public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {\n                return o2.getValue()-o1.getValue();\n            }\n        });\n        for (int i=0;i< list.size();i++) {\n            res+=list.get(i).getValue()*(i/8+1);\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head3\">[🟡3015. 按距离统计房屋对数目 I](https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-i/)</span>\n\n> 给你三个 **正整数** `n` 、`x` 和 `y` 。\n>\n> 在城市中，存在编号从 `1` 到 `n` 的房屋，由 `n` 条街道相连。对所有 `1 <= i < n` ，都存在一条街道连接编号为 `i` 的房屋与编号为 `i + 1` 的房屋。另存在一条街道连接编号为 `x` 的房屋与编号为 `y` 的房屋。\n>\n> 对于每个 `k`（`1 <= k <= n`），你需要找出所有满足要求的 **房屋对** `[house1, house2]` ，即从 `house1` 到 `house2` 需要经过的 **最少** 街道数为 `k` 。\n>\n> 返回一个下标从 **1** 开始且长度为 `n` 的数组 `result` ，其中 `result[k]` 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 **最少** 街道数为 `k` 。\n>\n> **注意**，`x` 与 `y` 可以 **相等** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example2.png)\n>\n> ```\n> 输入：n = 3, x = 1, y = 3\n> 输出：[6,0,0]\n> 解释：让我们检视每个房屋对\n> - 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。\n> - 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。\n> - 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。\n> - 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。\n> - 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。\n> - 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example3.png)\n>\n> ```\n> 输入：n = 5, x = 2, y = 4\n> 输出：[10,8,2,0,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。\n> - 对于 k == 4 和 k == 5，不存在满足要求的房屋对。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example5.png)\n>\n> ```\n> 输入：n = 4, x = 1, y = 1\n> 输出：[6,4,2,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。\n> - 对于 k == 4，不存在满足要求的房屋对。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n <= 100`\n> - `1 <= x, y <= n`\n\n\n\n# <span id=\"head4\">[🔴3017. 按距离统计房屋对数目 II](https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-ii/)</span>\n\n> 给你三个 **正整数** `n` 、`x` 和 `y` 。\n>\n> 在城市中，存在编号从 `1` 到 `n` 的房屋，由 `n` 条街道相连。对所有 `1 <= i < n` ，都存在一条街道连接编号为 `i` 的房屋与编号为 `i + 1` 的房屋。另存在一条街道连接编号为 `x` 的房屋与编号为 `y` 的房屋。\n>\n> 对于每个 `k`（`1 <= k <= n`），你需要找出所有满足要求的 **房屋对** `[house1, house2]` ，即从 `house1` 到 `house2` 需要经过的 **最少** 街道数为 `k` 。\n>\n> 返回一个下标从 **1** 开始且长度为 `n` 的数组 `result` ，其中 `result[k]` 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 **最少** 街道数为 `k` 。\n>\n> **注意**，`x` 与 `y` 可以 **相等** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example2.png)\n>\n> ```\n> 输入：n = 3, x = 1, y = 3\n> 输出：[6,0,0]\n> 解释：让我们检视每个房屋对\n> - 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。\n> - 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。\n> - 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。\n> - 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。\n> - 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。\n> - 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example3.png)\n>\n> ```\n> 输入：n = 5, x = 2, y = 4\n> 输出：[10,8,2,0,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。\n> - 对于 k == 4 和 k == 5，不存在满足要求的房屋对。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode.com/uploads/2023/12/20/example5.png)\n>\n> ```\n> 输入：n = 4, x = 1, y = 1\n> 输出：[6,4,2,0]\n> 解释：对于每个距离 k ，满足要求的房屋对如下：\n> - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。\n> - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。\n> - 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。\n> - 对于 k == 4，不存在满足要求的房屋对。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `2 <= n <= 105`\n> - `1 <= x, y <= n`\n\n\n\n","tags":["contest"]},{"title":"🔹29th NewCoder Weekly Contest (1249/2252)","url":"/2024/01/21/contest-newcoder-weekly-contest-29/","content":"\n|    题号     |                            标题                             | 标签   | 我的状态 |\n| :---------: | :---------------------------------------------------------: | ------ | :------: |\n| [A](#head1) | [小红大战小紫](https://ac.nowcoder.com/acm/contest/73422/A) | -      |   通过   |\n| [B](#head2) | [小红的白日梦](https://ac.nowcoder.com/acm/contest/73422/B) | -      |   通过   |\n| [C](#head3) | [小红的小小红](https://ac.nowcoder.com/acm/contest/73422/C) | 字符串 |   通过   |\n| [D](#head4) | [小红的中位数](https://ac.nowcoder.com/acm/contest/73422/D) |        |  未通过  |\n|      E      | [小红构造数组](https://ac.nowcoder.com/acm/contest/73422/E) |        |  未通过  |\n|      F      | [小红又战小紫](https://ac.nowcoder.com/acm/contest/73422/F) |        |  未通过  |\n\n# <span id=\"head1\">A 小红大战小紫</span>\n\n> 链接：https://ac.nowcoder.com/acm/contest/73422/B\n> 来源：牛客网题目描述                    \n>\n> ## 题目描述:    \n>\n> 小红正在和小紫对战，给定两个人的胜场数量，请你判断最终是谁获胜了。\n>\n> ## 输入描述:\n>\n> ```\n>两个正整数a,ba,ba,b，用空格隔开。aaa代表小红的胜场，bbb代表小紫的胜场。\n> 1≤a,b≤1091\\leq a,b \\leq 10^91≤a,b≤109\n> ```\n> \n> ## 输出描述:\n>\n> ```\n>如果小红获胜了，请输出\"kou\"。如果小紫获胜了，请输出\"yukari\"。如果最终平局，请输出\"draw\"。\n> ```\n> \n> ​                            示例1                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n>3 1\n> ```\n> \n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n>kou\n> ```\n> \n> ​                            示例2                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n>114514 114514\n> ```\n> \n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n>draw\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in) ;\n        int num1=in.nextInt();\n        int num2=in.nextInt();\n        if(num1<num2){\n            System.out.println(\"yukari\");\n        } else if (num1>num2) {\n            System.out.println(\"kou\");\n        }else{\n            System.out.println(\"draw\");\n        }\n    }\n}\n```\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n\n# <span id=\"head2\">B 小红的白日梦 </span>\n\n> 链接：https://ac.nowcoder.com/acm/contest/73422/B\n> 来源：牛客网\n>\n> \n>\n> ## 题目描述                    \n>\n> 小红经常会做梦，但她比较喜欢做白日梦。\n>  已知小红白天做梦可以获得 2 点幸福度，晚上做梦可以获得 1 点幸福度。现在给定小红每天中午和晚上睡觉的做梦情况。她可以每天将晚上的梦提前移到白天来做，请问小红总共最多可以获得多少幸福度？\n>  注：只有当白天没做梦且晚上做梦的时候才可以移动梦境。\n>\n> ## 输入描述:\n>\n> ```\n> 第一行输入一个正整数nnn，代表总天数。\n> 第二行输入一个长度为nnn的、仅由'Y'和'N'组成字符串，代表每天中午的做梦情况。\n> 第二行输入一个长度为nnn的、仅由'Y'和'N'组成字符串，代表每天晚上的做梦情况。\n> 'Y'代表做梦了，'N'代表没做梦。\n> 1≤n≤1051\\leq n \\leq 10^51≤n≤105\n> ```\n>\n> ## 输出描述:\n>\n> ```\n> 一个整数，代表最多的幸福度。\n> ```\n>\n> ​                            示例1                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 4\n> NNNN\n> NNNN\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 0\n> ```\n>\n> ## 说明\n>\n> ```\n> 小红一个梦都没做，最终幸福度为 0。\n> ```\n>\n> ​                            示例2                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 3\n> YYN\n> NYY\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 7\n> ```\n>\n> ## 说明\n>\n> ```\n> 第一天小红中午做梦了，晚上没做梦，获得了 2 幸福度。\n> 第二天小红白天和晚上都做梦了，获得了 3 幸福度。\n> 第三天小红将晚上的梦提前到白天来做，获得了 2 幸福度。\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in) ;\n        int res=0;\n        int n=in.nextInt();\n        String day=in.next();\n        String night=in.next();\n        for (int i = 0; i < n; i++) {\n            if(day.charAt(i)=='Y'&&night.charAt(i)=='Y'){\n                res+=3;\n            } else if (day.charAt(i)=='Y'||night.charAt(i)=='Y') {\n                res+=2;\n            }\n        }\n        System.out.println(res);\n    }\n}\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n# <span id=\"head3\">C 小红的小小红</span>\n\n> 链接：https://ac.nowcoder.com/acm/contest/73422/C\n> 来源：牛客网\n>\n> \n>\n> ## 题目描述                    \n>\n> 小红拿到了一个字符串，其中一定包含连续子串\"xiao\"，和连续子串\"hong\"。\n>  请你将字符串重排，使得该字符串包含\"xiaohong\"的连续子串。\n>\n> ## 输入描述:\n>\n> ```\n> 输入一个仅包含小写字母的字符串，长度不超过10^5\n> 保证字符串一定包含\"xiao\"子串和\"hong\"子串。\n> ```\n>\n> ## 输出描述:\n>\n> ```\n> 重排后的字符串。有多解时输出任意即可。\n> ```\n>\n> ​                            示例1                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> honghongxiao\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> xiaohonghong\n> ```\n>\n> ​                            示例2                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> xaohonghonxiao\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> xaoxiaohonghon\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.next();\n        List<Integer>list1=kmp(string,\"xiao\");\n        List<Integer>list2=kmp(string,\"hong\");\n        if(list1.isEmpty()||list2.isEmpty()){\n            System.out.println(string);\n        }\n        int min_num=Math.min(list1.size(),list2.size());\n        StringBuilder sb=new StringBuilder();\n        StringBuilder str=new StringBuilder(string);\n        for (int i = 0; i < min_num; i++) {\n            sb.append(\"xiaohong\");\n            int index_xiao=kmp(str.toString(),\"xiao\").get(0);\n            int index_hong=kmp(str.toString(),\"hong\").get(0);\n            str.delete(index_xiao,index_xiao+4);\n            str.delete(index_hong,index_hong+4);\n        }\n        sb.append(str);\n        System.out.println(sb);\n    }\n    static List<Integer> kmp(String text, String pattern) {\n        List<Integer> res = new ArrayList<>();\n        int len = pattern.length();\n        int[] next = new int[len];\n        int j = 0;\n        for (int i = 1; i < len; i++) {\n            char ch = pattern.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            next[i] = j;\n        }\n        j = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char ch = text.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            if (j == len) {\n                res.add(i - len + 1);\n                j = next[j - 1];\n            }\n        }\n        return res;\n    }\n}\n```\n\n发现读错题了，没有说是多个字符匹配……\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String string = in.nextLine();\n        \n        int xiao = string.indexOf(\"xiao\");\n\n        int hong= string.lastIndexOf(\"hong\");\n\n        StringBuilder res= new StringBuilder();\n\n        // 将\"xiao\"子串和\"hong\"子串之间的部分放在新字符串的开头\n        res.append(\"xiaohong\");\n\n        // 删除原字符串中的\"xiao\"子串和\"hong\"子串\n        string = string.replaceFirst(\"xiao\", \"\").replaceFirst(\"hong\", \"\");\n\n        // 将剩余的原字符串依次添加到新字符串的末尾\n        res.append(string);\n        System.out.println(res);\n    }\n\n}\n```\n\n之前没用过的函数：\n\n```java\nString.indexOf()\n\nString.lastIndexOf()\n\nString.replaceFirst()\n```\n\n\n\n# <span id=\"head4\">D 小红的中位数</span>\n\n> 链接：https://ac.nowcoder.com/acm/contest/73422/D\n> 来源：牛客网\n>\n> \n>\n> ## 题目描述                    \n>\n> 小红拿到了一个数组：a1,a2,...,an。她定义 f(i) 为，删除第i个元素后，数组的中位数。现在小红想让你求出f(1),f(2)...f(n)的值，你能帮帮她吗？\n>\n> ## 输入描述:\n>\n> ```\n> 第一行输入一个正整数nnn，代表数组的大小。\n> 第二行输入n个正整数ai，代表数组的元素。\n> 2≤n≤10^5\n> 1≤ai≤10^9\n> ```\n>\n> ## 输出描述:\n>\n> ```\n> 输出n行，每行输出一个浮点数，第iii行代表f(i)的值。保留一位小数。\n> ```\n>\n> ​                            示例1                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 4\n> 2 5 8 1\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 5.0\n> 2.0\n> 2.0\n> 5.0\n> ```\n>\n> ​                            示例2                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 3\n> 1 2 3\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 2.5\n> 2.0\n> 1.5\n> ```\n\n```java\n```\n\n","tags":["contest"]},{"title":"🔸122th LeetCode Biweekly Contest (1489/3547)","url":"/2024/01/20/contest-leetcode-biweekly-contest-122/","content":"\n| 题号                                          | 标签          | 作答情况 |\n| --------------------------------------------- | ------------- | -------- |\n| [🟢将数组分成最小总代价的子数组 I](#head1)     | 小模拟        | 23min    |\n| [🟡3011. 判断一个数组是否可以变为有序](#head2) | 位数+冒泡排序 | 80min🪲3  |\n| [ 🟡通过操作使数组长度最小](#head3)            |               | 未作答   |\n| [🔴将数组分成最小总代价的子数组 II](#head4)    |               | 未作答   |\n\n# <span id=\"head1\">🟢将数组分成最小总代价的子数组 I</span>\n\n> 给你一个长度为 `n` 的整数数组 `nums` 。\n>\n> 一个数组的 **代价** 是它的 **第一个** 元素。比方说，`[1,2,3]` 的代价是 `1` ，`[3,4,1]` 的代价是 `3` 。\n>\n> 你需要将 `nums` 分成 `3` 个 **连续且没有交集** 的子数组。\n>\n> 请你返回这些子数组的 **最小** 代价 **总和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,12]\n> 输出：6\n> 解释：最佳分割成 3 个子数组的方案是：[1] ，[2] 和 [3,12] ，总代价为 1 + 2 + 3 = 6 。\n> 其他得到 3 个子数组的方案是：\n> - [1] ，[2,3] 和 [12] ，总代价是 1 + 2 + 12 = 15 。\n> - [1,2] ，[3] 和 [12] ，总代价是 1 + 3 + 12 = 16 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,4,3]\n> 输出：12\n> 解释：最佳分割成 3 个子数组的方案是：[5] ，[4] 和 [3] ，总代价为 5 + 4 + 3 = 12 。\n> 12 是所有分割方案里的最小总代价。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [10,3,1,1]\n> 输出：12\n> 解释：最佳分割成 3 个子数组的方案是：[10,3] ，[1] 和 [1] ，总代价为 10 + 1 + 1 = 12 。\n> 12 是所有分割方案里的最小总代价。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= n <= 50`\n>\n> - `1 <= nums[i] <= 50`\n>\n>\n\n```java\nclass Solution {\n    public int minimumCost(int[] nums) {\n        int res=0;\n        int min1_index=0,min1=Integer.MAX_VALUE,min2_index=0,min2=Integer.MAX_VALUE,min3_index=0,min3=Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<min1){\n                min1=nums[i];\n                min1_index=i;\n            }\n        }\n        res+=min1;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<min2&&i!=min1_index){\n                min2=nums[i];\n                min2_index=i;\n            }\n        }\n        res+=min2;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<min3&&i!=min1_index&&i!=min2_index){\n                min3=nums[i];\n                min3_index=i;\n            }\n        }\n        if(min1_index!=0&&min2_index!=0){\n            return res+nums[0];\n        }else{\n            return res+min3;\n        }\n    }\n}\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n# <span id=\"head2\">🟡3011. 判断一个数组是否可以变为有序</span>\n\n> 给你一个下标从 **0** 开始且全是 **正** 整数的数组 `nums` 。\n>\n> 一次 **操作** 中，如果两个 **相邻** 元素在二进制下数位为 **1** 的数目 **相同** ，那么你可以将这两个元素交换。你可以执行这个操作 **任意次** （**也可以 0 次**）。\n>\n> 如果你可以使数组变有序，请你返回 `true` ，否则返回 `false` 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [8,4,2,30,15]\n> 输出：true\n> 解释：我们先观察每个元素的二进制表示。 2 ，4 和 8 分别都只有一个数位为 1 ，分别为 \"10\" ，\"100\" 和 \"1000\" 。15 和 30 分别有 4 个数位为 1 ：\"1111\" 和 \"11110\" 。\n> 我们可以通过 4 个操作使数组有序：\n> - 交换 nums[0] 和 nums[1] 。8 和 4 分别只有 1 个数位为 1 。数组变为 [4,8,2,30,15] 。\n> - 交换 nums[1] 和 nums[2] 。8 和 2 分别只有 1 个数位为 1 。数组变为 [4,2,8,30,15] 。\n> - 交换 nums[0] 和 nums[1] 。4 和 2 分别只有 1 个数位为 1 。数组变为 [2,4,8,30,15] 。\n> - 交换 nums[3] 和 nums[4] 。30 和 15 分别有 4 个数位为 1 ，数组变为 [2,4,8,15,30] 。\n> 数组变成有序的，所以我们返回 true 。\n> 注意我们还可以通过其他的操作序列使数组变得有序。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5]\n> 输出：true\n> 解释：数组已经是有序的，所以我们返回 true 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,16,8,4,2]\n> 输出：false\n> 解释：无法通过操作使数组变为有序。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `1 <= nums[i] <= 28`\n\n```java\nclass Solution {\n     public boolean canSortArray(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n           for (int j = 0; j < nums.length-i; j++) {\n                int bite1=Integer.bitCount(nums[j]);\n                int bite2=Integer.bitCount(nums[j+1]);\n                if(bite1==bite2&&nums[j]>nums[j+1]){\n                    int temp=nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                }\n            }\n        }\n        for (int i = 1; i < nums.length; i++) {\n            if(nums[i]<nums[i-1]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(1)\n\n小小改进了一下，减少了循环次数\n\n```java\nclass Solution {\n     public boolean canSortArray(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = 0; j < nums.length-i; j++){\n                int bite1=Integer.bitCount(nums[j]);\n                int bite2=Integer.bitCount(nums[j+1]);\n                if(bite1==bite2&&nums[j]>nums[j+1]){\n                    int temp=nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                }else if(nums[j]>nums[j+1]){\n\t\t\t\t\treturn false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n两个可以复习的点：\n\n1.Integer.bitCount(num)函数：num转化为二进制后1的个数\n\n2.冒泡排序的两层循环：\n\n```java\nfor (int i = 1; i < nums.length; i++) {//循环次数为len-1\n    for (int j = 0; j < nums.length-i; j++) {//j:0~len-i-1\n        swap(arr[j],arr[j+1]);\n    }\n}\n```\n\n\n\n# <span id=\"head3\"> 🟡通过操作使数组长度最小</span>\n\n> 给你一个下标从 **0** 开始的整数数组 `nums` ，它只包含 **正** 整数。\n>\n> 你的任务是通过进行以下操作 **任意次** （可以是 0 次） **最小化** `nums` 的长度：\n>\n> - 在 `nums` 中选择 **两个不同** 的下标 `i` 和 `j` ，满足 `nums[i] > 0` 且 `nums[j] > 0` 。\n> - 将结果 `nums[i] % nums[j]` 插入 `nums` 的结尾。\n> - 将 `nums` 中下标为 `i` 和 `j` 的元素删除。\n>\n> 请你返回一个整数，它表示进行任意次操作以后 `nums` 的 **最小长度** 。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,4,3,1]\n> 输出：1\n> 解释：使数组长度最小的一种方法是：\n> 操作 1 ：选择下标 2 和 1 ，插入 nums[2] % nums[1] 到数组末尾，得到 [1,4,3,1,3] ，然后删除下标为 2 和 1 的元素。\n> nums 变为 [1,1,3] 。\n> 操作 2 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [1,1,3,1] ，然后删除下标为 1 和 2 的元素。\n> nums 变为 [1,1] 。\n> 操作 3 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [1,1,0] ，然后删除下标为 1 和 0 的元素。\n> nums 变为 [0] 。\n> nums 的长度无法进一步减小，所以答案为 1 。\n> 1 是可以得到的最小长度。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [5,5,5,10,5]\n> 输出：2\n> 解释：使数组长度最小的一种方法是：\n> 操作 1 ：选择下标 0 和 3 ，插入 nums[0] % nums[3] 到数组末尾，得到 [5,5,5,10,5,5] ，然后删除下标为 0 和 3 的元素。\n> nums 变为 [5,5,5,5] 。\n> 操作 2 ：选择下标 2 和 3 ，插入 nums[2] % nums[3] 到数组末尾，得到 [5,5,5,5,0] ，然后删除下标为 2 和 3 的元素。\n> nums 变为 [5,5,0] 。\n> 操作 3 ：选择下标 0 和 1 ，插入 nums[0] % nums[1] 到数组末尾，得到 [5,5,0,0] ，然后删除下标为 0 和 1 的元素。\n> nums 变为 [0,0] 。\n> nums 的长度无法进一步减小，所以答案为 2 。\n> 2 是可以得到的最小长度。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [2,3,4]\n> 输出：1\n> 解释：使数组长度最小的一种方法是：\n> 操作 1 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [2,3,4,3] ，然后删除下标为 1 和 2 的元素。\n> nums 变为 [2,3] 。\n> 操作 2 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [2,3,1] ，然后删除下标为 1 和 0 的元素。\n> nums 变为 [1] 。\n> nums 的长度无法进一步减小，所以答案为 1 。\n> 1 是可以得到的最小长度。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `1 <= nums[i] <= 109`\n\n# <span id=\"head4\">🔴将数组分成最小总代价的子数组 II</span>\n\n> 给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和两个 **正** 整数 `k` 和 `dist` 。\n>\n> 一个数组的 **代价** 是数组中的 **第一个** 元素。比方说，`[1,2,3]` 的代价为 `1` ，`[3,4,1]` 的代价为 `3` 。\n>\n> 你需要将 `nums` 分割成 `k` 个 **连续且互不相交** 的子数组，满足 **第二** 个子数组与第 `k` 个子数组中第一个元素的下标距离 **不超过** `dist` 。换句话说，如果你将 `nums` 分割成子数组 `nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)]` ，那么它需要满足 `ik-1 - i1 <= dist` 。\n>\n> 请你返回这些子数组的 **最小** 总代价。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,2,6,4,2], k = 3, dist = 3\n> 输出：5\n> 解释：将数组分割成 3 个子数组的最优方案是：[1,3] ，[2,6,4] 和 [2] 。这是一个合法分割，因为 ik-1 - i1 等于 5 - 2 = 3 ，等于 dist 。总代价为 nums[0] + nums[2] + nums[5] ，也就是 1 + 2 + 2 = 5 。\n> 5 是分割成 3 个子数组的最小总代价。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [10,1,2,2,2,1], k = 4, dist = 3\n> 输出：15\n> 解释：将数组分割成 4 个子数组的最优方案是：[10] ，[1] ，[2] 和 [2,2,1] 。这是一个合法分割，因为 ik-1 - i1 等于 3 - 1 = 2 ，小于 dist 。总代价为 nums[0] + nums[1] + nums[2] + nums[3] ，也就是 10 + 1 + 2 + 2 = 15 。\n> 分割 [10] ，[1] ，[2,2,2] 和 [1] 不是一个合法分割，因为 ik-1 和 i1 的差为 5 - 1 = 4 ，大于 dist 。\n> 15 是分割成 4 个子数组的最小总代价。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [10,8,18,9], k = 3, dist = 1\n> 输出：36\n> 解释：将数组分割成 4 个子数组的最优方案是：[10] ，[8] 和 [18,9] 。这是一个合法分割，因为 ik-1 - i1 等于 2 - 1 = 1 ，等于 dist 。总代价为 nums[0] + nums[1] + nums[2] ，也就是 10 + 8 + 18 = 36 。\n> 分割 [10] ，[8,18] 和 [9] 不是一个合法分割，因为 ik-1 和 i1 的差为 3 - 1 = 2 ，大于 dist 。\n> 36 是分割成 3 个子数组的最小总代价。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `3 <= n <= 105`\n> - `1 <= nums[i] <= 109`\n> - `3 <= k <= n`\n> - `k - 2 <= dist <= n - 2`\n","tags":["contest"]},{"title":"Java New Features","url":"/2024/01/20/java-new-features/","content":"\n","categories":["Java"]},{"title":"Java Concurrent","url":"/2024/01/20/java-concurrent/","content":"\n","categories":["Java"]},{"title":"Java JVM","url":"/2024/01/20/java-jvm/","content":"\n","categories":["Java"]},{"title":"Java I/O","url":"/2024/01/20/java-io/","content":"\n","categories":["Java"]},{"title":"Java Basics","url":"/2024/01/20/java-basics/","content":"\n","categories":["Java"]},{"title":"🟢788. split strings by separator","url":"/2024/01/20/coding-2788-split-strings-by-separator/","content":"\n# 题目描述\n\n> 给你一个字符串数组 `words` 和一个字符 `separator` ，请你按 `separator` 拆分 `words` 中的每个字符串。\n>\n> 返回一个由拆分后的新字符串组成的字符串数组，**不包括空字符串** 。\n>\n> **注意**\n>\n> - `separator` 用于决定拆分发生的位置，但它不包含在结果字符串中。\n> - 拆分可能形成两个以上的字符串。\n> - 结果字符串必须保持初始相同的先后顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：words = [\"one.two.three\",\"four.five\",\"six\"], separator = \".\"\n> 输出：[\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]\n> 解释：在本示例中，我们进行下述拆分：\n> \n> \"one.two.three\" 拆分为 \"one\", \"two\", \"three\"\n> \"four.five\" 拆分为 \"four\", \"five\"\n> \"six\" 拆分为 \"six\" \n> \n> 因此，结果数组为 [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words = [\"$easy$\",\"$problem$\"], separator = \"$\"\n> 输出：[\"easy\",\"problem\"]\n> 解释：在本示例中，我们进行下述拆分：\n> \n> \"$easy$\" 拆分为 \"easy\"（不包括空字符串）\n> \"$problem$\" 拆分为 \"problem\"（不包括空字符串）\n> \n> 因此，结果数组为 [\"easy\",\"problem\"] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words = [\"|||\"], separator = \"|\"\n> 输出：[]\n> 解释：在本示例中，\"|||\" 的拆分结果将只包含一些空字符串，所以我们返回一个空数组 [] 。 \n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= words.length <= 100`\n> - `1 <= words[i].length <= 20`\n> - `words[i]` 中的字符要么是小写英文字母，要么就是字符串 `\".,|$#@\"` 中的字符（不包括引号）\n> - `separator` 是字符串 `\".,|$#@\"` 中的某个字符（不包括引号）\n>\n> Related Topics\n>\n> 数组\n>\n> 字符串\n\n# 代码\n\n```java\nclass Solution {\n    public List<String> splitWordsBySeparator(List<String> words, char separator) {\n        List<String>res=new ArrayList<String>();\n        String pat;\n        if(separator=='.'||separator=='$'||separator=='|'){\n            pat=\"\\\\\"+separator;\n        }else {\n            pat=String.valueOf(separator);\n        }\n        for (String word : words) {\n            String[] splited = word.split(pat);\n            for (String str: splited) {\n                if(!str.isEmpty()){\n                    res.add(str);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n以为上来直接秒了，结果发现String.split()函数中涉及的正则表达式，之前不熟悉\n\n# 做题整理\n\n### 1.  '.'、'$'、'|'分别代表什么\n\n在正则表达式中，点号（`.`）、美元符号（`$`）和竖线（`|`）都有特殊的含义。\n\n- `.`（点号）：在正则表达式中，点号表示匹配任意单个字符，除了换行符。例如，正则表达式`a.b`可以匹配\"acb\"、“abb”、\"a1b\"等。\n- `$`（美元符号）：美元符号用于匹配字符串的结尾。例如，正则表达式`abc$`用于匹配以\"abc\"结尾的字符串。\n- `|`（竖线）：竖线用于表示选择操作，意味着\"或\"的关系。例如，正则表达式`a|b`表示匹配字符\"a\"或字符\"b\"。它可以用于多个模式的选择。\n\n需要注意的是，这些字符在正则表达式中具有特殊的意义，如果你想要匹配它们本身而不是其特殊含义，需要进行转义，即在字符前加上反斜杠（`\\.`, `\\$`, `\\|`）。\n\n### 2.还有其它类似字符吗\n\n除了`.`、`$`和`|`之外，还有许多其他在正则表达式中具有特殊含义的字符。下面列出了一些常用的特殊字符：\n\n- `*`：表示前一个字符出现零次或多次。例如，正则表达式`ab*c`可以匹配\"ac\"、“abc”、\"abbc\"等。\n- `+`：表示前一个字符出现一次或多次。例如，正则表达式`ab+c`可以匹配\"abc\"、“abbc”、\"abbbc\"等。\n- `?`：表示前一个字符出现零次或一次。例如，正则表达式`ab?c`可以匹配\"ac\"、“abc”。\n- `[]`：方括号用于创建一个字符类，表示匹配其中的任意一个字符。例如，正则表达式`[aeiou]`表示匹配任意一个元音字母。\n- `^`：在字符类的开头使用，表示取反操作或匹配字符串的开头。例如，正则表达式`[^0-9]`表示匹配任意一个非数字字符；而正则表达式`^abc`表示匹配以\"abc\"开头的字符串。\n- `()`：用于创建一个捕获组，可以对其中的内容进行分组和引用。例如，正则表达式`(ab)+`表示匹配一个或多个\"ab\"。\n\n这些特殊字符在正则表达式中常用于表示不同的模式和操作。如果你需要特别匹配这些字符本身，也需要使用反斜杠进行转义，例如`\\*`、`\\+`、`\\?`、`\\[`等。\n\n### 3.正则表达式还有什么需要注意的吗\n\n1. 特殊字符的转义：一些字符在正则表达式中具有特殊意义，比如`.`、`$`、`|`等。如果你想要匹配这些字符本身而不是其特殊意义，需要在其前面加上反斜杠进行转义，例如`\\.`、`\\$`、`\\|`。\n2. 字符类：方括号`[]`用于表示一个字符类，可以匹配其中任意一个字符。在字符类中的某些字符也具有特殊意义，比如`-`用于表示一个范围，比如`[a-z]`表示从小写字母a到z的任意一个字符。如果想要匹配字符类中的特殊字符本身，同样需要进行转义。\n3. 量词：量词用于指定一个模式出现的次数，比如`*`表示出现零次或多次，`+`表示出现一次或多次，`?`表示出现零次或一次。默认情况下，量词是贪婪的，即会尽量多地匹配字符。如果想要量词变为非贪婪模式，可以在量词后面加上`?`，例如`*?`、`+?`、`??`。\n4. 捕获组：括号`()`用于创建一个捕获组，可以通过编号引用捕获的内容。捕获组的编号从1开始，可以使用`\\1`、`\\2`等进行引用。\n5. 边界匹配：`^`表示匹配字符串的开头，`$`表示匹配字符串的结尾。如果想要匹配整个字符串，可以在正则表达式的两端加上这两个边界符。\n6. 负向匹配：`[^]`表示匹配任意不在括号中的字符。\n","tags":["algorithm-array","algorithm-string"]},{"title":"creational pattern","url":"/2024/01/18/system-design-creational-pattern/","content":"\n","categories":["system design"]},{"title":"Git","url":"/2024/01/18/tools-git/","content":"\n","categories":["tools"]},{"title":"Java Collections","url":"/2024/01/18/java-collection/","content":"\n# Collection\n\n## List\n\n### ArrayList⭐\n\n### CopyOnWriteArrayList⭐\n\n### LinkedList⭐\n\n### Stack\n\n## Set\n\n### HashSet\n\n### TreeSet\n\n### LinkedHashSet\n\n## Queue\n\n### ArrayDeque\n\n### PriorityQueue⭐\n\n### ArrayBlockingQueue⭐\n\n### DelayQueue⭐\n\n# Map\n\n### HashMap⭐\n\n### ConcurrentHashMap⭐\n\n### TreeMap\n\n### Hashtable\n\n### LinkedHashMap⭐\n\n","categories":["Java"]},{"title":"Algorithms","url":"/2024/01/18/cs-basics-algorithms/","content":"\n# 1. 搜索\n\n# 2. 排序\n\n# 3. 分治\n\n# 4. 回溯\n\n# 5. 动态规划\n\n# 6. 贪心\n","categories":["CS basics"]},{"title":"Data Structure","url":"/2024/01/18/cs-basics-data-structure/","content":"\n# 1. 数据结构绪论\n\n# 2. 数组与链表\n\n# 3. 栈与队列\n\n# 4. 哈希表\n\n# 5. 树\n\n# 6. 堆\n\n# 7. 图\n\n","categories":["CS basics"]},{"title":"Operating System","url":"/2024/01/18/cs-basics-operating-system/","content":"\n \n\n# 1. 计算机系统概述\n\n# 2. 进程与线程\n\n# 3. 内存管理\n\n# 4. 文件管理\n\n# 5. IO管理\n","categories":["CS basics"]},{"title":"Network","url":"/2024/01/18/cs-basics-network/","content":"\n| [1. 计算机网络体系结构](#head1) |                        |                                   |\n| ------------------------------- | ---------------------- | --------------------------------- |\n| [2. 物理层](#head2)             | [2.1 通信基础](#head3) | [ 2.1.1物理层基本概念](#head4)    |\n|                                 |                        | [ 2.1.2奈斯准则&香农定理](#head5) |\n|                                 |                        | [ 2.1.3编码与调制](#head6)        |\n|                                 | [2.2 传输介质](#head7) |                                   |\n|                                 |                        |                                   |\n|                                 |                        |                                   |\n|                                 |                        |                                   |\n|                                 |                        |                                   |\n\n# <span id=\"head1\">1. 计算机网络体系结构</span>\n\n![image-20240120214043276](cs-basics-network/image-20240120214043276.png)\n\n![image-20240120214803863](cs-basics-network/image-20240120214803863.png)\n\n![image-20240120214942082](cs-basics-network/image-20240120214942082.png)\n\n![image-20240120215004255](cs-basics-network/image-20240120215004255.png)\n\n# <span id=\"head2\">2. 物理层</span>\n\n![image-20240120215701701](cs-basics-network/image-20240120215701701.png)\n\n## <span id=\"head3\">2.1 通信基础</span>\n\n### <span id=\"head4\"> 2.1.1物理层基本概念</span>\n\n![image-20240120215854657](cs-basics-network/image-20240120215854657.png)\n\n![image-20240120215930135](cs-basics-network/image-20240120215930135.png)\n\n![image-20240120220531468](cs-basics-network/image-20240120220531468.png)\n\n### <span id=\"head5\"> 2.1.2奈斯准则&香农定理</span>\n\n![image-20240120221716246](cs-basics-network/image-20240120221716246.png)\n\n![image-20240120221820513](cs-basics-network/image-20240120221820513.png)\n\n![image-20240120221912500](cs-basics-network/image-20240120221912500.png)\n\n### <span id=\"head6\"> 2.1.3编码与调制</span>\n\n![image-20240120222053428](cs-basics-network/image-20240120222053428.png)\n\n![image-20240120222114377](cs-basics-network/image-20240120222114377.png)\n\n\n\n## <span id=\"head7\">2.2 传输介质</span>\n\n\n\n# \n","categories":["CS basics"]},{"title":"50 questions on High Frequency SQL","url":"/2024/01/18/database-sql-free-50/","content":"\n| 分类            | 题目                                       | 完成 |\n| --------------- | ------------------------------------------ | ---- |\n| [ 查询](#head1) | [🟢1757. 可回收且低脂的产品](#head2)        | ✅    |\n|                 | [🟢584. 寻找用户推荐人](#head3)             | ✅    |\n|                 | [🟢595. 大的国家](#head4)                   | ✅    |\n|                 | [🟢1148. 文章浏览 I](#head5)                | ✅    |\n|                 | [🟢1683. 无效的推文](#head6)                | ✅    |\n| [ 连接](#head7) | [ 🟢1378.使用唯一标识码替换员工ID2](#head8) |      |\n|                 |                                            |      |\n|                 |                                            |      |\n\n# <span id=\"head1\"> 查询</span>\n\n## <span id=\"head2\">🟢1757. 可回收且低脂的产品</span>\n\n> 表：`Products`\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | product_id  | int     |\n> | low_fats    | enum    |\n> | recyclable  | enum    |\n> +-------------+---------+\n> product_id 是该表的主键（具有唯一值的列）。\n> low_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。\n> recyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。\n> ```\n>\n>  \n>\n> 编写解决方案找出既是低脂又是可回收的产品编号。\n>\n> 返回结果 **无顺序要求** 。\n>\n> 返回结果格式如下例所示：\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Products 表：\n> +-------------+----------+------------+\n> | product_id  | low_fats | recyclable |\n> +-------------+----------+------------+\n> | 0           | Y        | N          |\n> | 1           | Y        | Y          |\n> | 2           | N        | Y          |\n> | 3           | Y        | Y          |\n> | 4           | N        | N          |\n> +-------------+----------+------------+\n> 输出：\n> +-------------+\n> | product_id  |\n> +-------------+\n> | 1           |\n> | 3           |\n> +-------------+\n> 解释：\n> 只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。\n> ```\n\n```mysql\nselect product_id \nfrom products \nwhere low_fats='Y' and recyclable='Y'\n```\n\n## <span id=\"head3\">🟢584. 寻找用户推荐人</span>\n\n> 表: `Customer`\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | id          | int     |\n> | name        | varchar |\n> | referee_id  | int     |\n> +-------------+---------+\n> 在 SQL 中，id 是该表的主键列。\n> 该表的每一行表示一个客户的 id、姓名以及推荐他们的客户的 id。\n> ```\n>\n> 找出那些 **没有被** `id = 2` 的客户 **推荐** 的客户的姓名。\n>\n> 以 **任意顺序** 返回结果表。\n>\n> 结果格式如下所示。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入： \n> Customer 表:\n> +----+------+------------+\n> | id | name | referee_id |\n> +----+------+------------+\n> | 1  | Will | null       |\n> | 2  | Jane | null       |\n> | 3  | Alex | 2          |\n> | 4  | Bill | null       |\n> | 5  | Zack | 1          |\n> | 6  | Mark | 2          |\n> +----+------+------------+\n> 输出：\n> +------+\n> | name |\n> +------+\n> | Will |\n> | Jane |\n> | Bill |\n> | Zack |\n> +------+\n> ```\n\n```mysql\nselect name \nfrom customer \nwhere referee_id!=2 or referee_id is null\n```\n\n## <span id=\"head4\">🟢595. 大的国家</span>\n\n> `World` 表：\n>\n> ```\n> +-------------+---------+\n> | Column Name | Type    |\n> +-------------+---------+\n> | name        | varchar |\n> | continent   | varchar |\n> | area        | int     |\n> | population  | int     |\n> | gdp         | bigint  |\n> +-------------+---------+\n> name 是该表的主键（具有唯一值的列）。\n> 这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。\n> ```\n>\n>  \n>\n> 如果一个国家满足下述两个条件之一，则认为该国是 **大国** ：\n>\n> - 面积至少为 300 万平方公里（即，`3000000 km2`），或者\n> - 人口至少为 2500 万（即 `25000000`）\n>\n> 编写解决方案找出 **大国** 的国家名称、人口和面积。\n>\n> 按 **任意顺序** 返回结果表。\n>\n> 返回结果格式如下例所示。\n>\n>  \n>\n> **示例：**\n>\n> ```\n> 输入：\n> World 表：\n> +-------------+-----------+---------+------------+--------------+\n> | name        | continent | area    | population | gdp          |\n> +-------------+-----------+---------+------------+--------------+\n> | Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n> | Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n> | Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n> | Andorra     | Europe    | 468     | 78115      | 3712000000   |\n> | Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n> +-------------+-----------+---------+------------+--------------+\n> 输出：\n> +-------------+------------+---------+\n> | name        | population | area    |\n> +-------------+------------+---------+\n> | Afghanistan | 25500100   | 652230  |\n> | Algeria     | 37100000   | 2381741 |\n> +-------------+------------+---------+\n> ```\n\n```mysql\nselect name, population, area\nfrom world\nwhere area >=3000000 or population >=25000000\n```\n\n\n\n## <span id=\"head5\">🟢1148. 文章浏览 I</span>\n\n> `Views` 表：\n>\n> ```\n> +---------------+---------+\n> | Column Name   | Type    |\n> +---------------+---------+\n> | article_id    | int     |\n> | author_id     | int     |\n> | viewer_id     | int     |\n> | view_date     | date    |\n> +---------------+---------+\n> 此表可能会存在重复行。（换句话说，在 SQL 中这个表没有主键）\n> 此表的每一行都表示某人在某天浏览了某位作者的某篇文章。\n> 请注意，同一人的 author_id 和 viewer_id 是相同的。\n> ```\n>\n>  \n>\n> 请查询出所有浏览过自己文章的作者\n>\n> 结果按照 `id` 升序排列。\n>\n> 查询结果的格式如下所示：\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Views 表：\n> +------------+-----------+-----------+------------+\n> | article_id | author_id | viewer_id | view_date  |\n> +------------+-----------+-----------+------------+\n> | 1          | 3         | 5         | 2019-08-01 |\n> | 1          | 3         | 6         | 2019-08-02 |\n> | 2          | 7         | 7         | 2019-08-01 |\n> | 2          | 7         | 6         | 2019-08-02 |\n> | 4          | 7         | 1         | 2019-07-22 |\n> | 3          | 4         | 4         | 2019-07-21 |\n> | 3          | 4         | 4         | 2019-07-21 |\n> +------------+-----------+-----------+------------+\n> \n> 输出：\n> +------+\n> | id   |\n> +------+\n> | 4    |\n> | 7    |\n> +------+\n> ```\n\n```mysql\nselect  distinct author_id as 'id'\nfrom views\nwhere viewer_id=author_id\norder by author_id\n```\n\n## <span id=\"head6\">🟢1683. 无效的推文</span>\n\n> 表：`Tweets`\n>\n> ```\n> +----------------+---------+\n> | Column Name    | Type    |\n> +----------------+---------+\n> | tweet_id       | int     |\n> | content        | varchar |\n> +----------------+---------+\n> 在 SQL 中，tweet_id 是这个表的主键。\n> 这个表包含某社交媒体 App 中所有的推文。\n> ```\n>\n>  \n>\n> 查询所有无效推文的编号（ID）。当推文内容中的字符数**严格大于** `15` 时，该推文是无效的。\n>\n> 以**任意顺序**返回结果表。\n>\n> 查询结果格式如下所示：\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Tweets 表：\n> +----------+----------------------------------+\n> | tweet_id | content                          |\n> +----------+----------------------------------+\n> | 1        | Vote for Biden                   |\n> | 2        | Let us make America great again! |\n> +----------+----------------------------------+\n> \n> 输出：\n> +----------+\n> | tweet_id |\n> +----------+\n> | 2        |\n> +----------+\n> 解释：\n> 推文 1 的长度 length = 14。该推文是有效的。\n> 推文 2 的长度 length = 32。该推文是无效的。\n> ```\n\n```mysql\nselect tweet_id\nfrom tweets\nwhere  length(content)>15\n```\n\n# <span id=\"head7\"> 连接</span>\n\n## <span id=\"head8\"> 🟢1378.使用唯一标识码替换员工ID2</span>\n\n> `Employees` 表：\n>\n> ```\n> +---------------+---------+\n> | Column Name   | Type    |\n> +---------------+---------+\n> | id            | int     |\n> | name          | varchar |\n> +---------------+---------+\n> 在 SQL 中，id 是这张表的主键。\n> 这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。\n> ```\n>\n>  \n>\n> `EmployeeUNI` 表：\n>\n> ```\n> +---------------+---------+\n> | Column Name   | Type    |\n> +---------------+---------+\n> | id            | int     |\n> | unique_id     | int     |\n> +---------------+---------+\n> 在 SQL 中，(id, unique_id) 是这张表的主键。\n> 这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。\n> ```\n>\n>  \n>\n> 展示每位用户的 **唯一标识码（unique ID ）**；如果某位员工没有唯一标识码，使用 null 填充即可。\n>\n> 你可以以 **任意** 顺序返回结果表。\n>\n> 返回结果的格式如下例所示。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> Employees 表:\n> +----+----------+\n> | id | name     |\n> +----+----------+\n> | 1  | Alice    |\n> | 7  | Bob      |\n> | 11 | Meir     |\n> | 90 | Winston  |\n> | 3  | Jonathan |\n> +----+----------+\n> EmployeeUNI 表:\n> +----+-----------+\n> | id | unique_id |\n> +----+-----------+\n> | 3  | 1         |\n> | 11 | 2         |\n> | 90 | 3         |\n> +----+-----------+\n> 输出：\n> +-----------+----------+\n> | unique_id | name     |\n> +-----------+----------+\n> | null      | Alice    |\n> | null      | Bob      |\n> | 2         | Meir     |\n> | 3         | Winston  |\n> | 1         | Jonathan |\n> +-----------+----------+\n> 解释：\n> Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。\n> Meir 的唯一标识码是 2 。\n> Winston 的唯一标识码是 3 。\n> Jonathan 唯一标识码是 1 。\n> ```\n\n```mysql\nselect e2.unique_id,e1.name\nfrom Employees e1\nleft join EmployeeUNI e2\non e1.id=e2.id\n```\n\n","categories":["database"]},{"title":"🟢 2744. find maximum number of string pairs","url":"/2024/01/17/coding-2744-find-maximum-number-of-string-pairs/","content":"\n# 题目描述\n\n> 给你一个下标从 **0** 开始的数组 `words` ，数组中包含 **互不相同** 的字符串。\n>\n> 如果字符串 `words[i]` 与字符串 `words[j]` 满足以下条件，我们称它们可以匹配：\n>\n> - 字符串 `words[i]` 等于 `words[j]` 的反转字符串。\n> - `0 <= i < j < words.length`\n>\n> 请你返回数组 `words` 中的 **最大** 匹配数目。\n>\n> 注意，每个字符串最多匹配一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\n> 输出：2\n> 解释：在此示例中，我们可以通过以下方式匹配 2 对字符串：\n> - 我们将第 0 个字符串与第 2 个字符串匹配，因为 word[0] 的反转字符串是 \"dc\" 并且等于 words[2]。\n> - 我们将第 1 个字符串与第 3 个字符串匹配，因为 word[1] 的反转字符串是 \"ca\" 并且等于 words[3]。\n> 可以证明最多匹配数目是 2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words = [\"ab\",\"ba\",\"cc\"]\n> 输出：1\n> 解释：在此示例中，我们可以通过以下方式匹配 1 对字符串：\n> - 我们将第 0 个字符串与第 1 个字符串匹配，因为 words[1] 的反转字符串 \"ab\" 与 words[0] 相等。\n> 可以证明最多匹配数目是 1 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words = [\"aa\",\"ab\"]\n> 输出：0\n> 解释：这个例子中，无法匹配任何字符串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= words.length <= 50`\n> - `words[i].length == 2`\n> - `words` 包含的字符串互不相同。\n> - `words[i]` 只包含小写英文字母。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 模拟\n\n# 代码\n\n```java\nclass Solution {\n    public int maximumNumberOfStringPairs(String[] words) {\n        Set<String>set=new HashSet<>();\n        int res=0;\n        for (int i = 0; i < words.length; i++) {\n            if(set.contains(words[i])){\n               res++;\n            }else{\n                StringBuilder temp=new StringBuilder(words[i]);\n                set.add(temp.reverse().toString());\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(n)\n","tags":["algorithm-array","algorithm-hash table","algorithm-string","algorithm-simulation"]},{"title":"🟡82. remove duplicates from sorted list ii","url":"/2024/01/15/coding-82-remove-duplicates-from-sorted-list-ii/","content":"\n# 题目描述\n\n> 给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,3,4,4,5]\n> 输出：[1,2,5]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n>\n> ```\n> 输入：head = [1,1,1,2,3]\n> 输出：[2,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n# 代码\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head)  {\n        // 节点数为0,1\n        if(head==null||head.next==null){\n            return head;\n        }\n        // 节点为2\n        if(head.next.next==null&&head.val==head.next.val){\n            return null;\n        }else if(head.next.next==null){\n            return head;\n        }\n        // 确定head\n        ListNode p=head.next;\n        while(p!=null&&p.val==head.val){\n            while(p!=null&&p!=null&&p.val==head.val){\n                p=p.next;\n            }\n            head=p;\n            if(p!=null){\n                p=p.next;\n            }\n            //每次换了head之后再筛一下\n            if(head==null||head.next==null){\n                return head;\n            }\n            if(head.next.next==null&&head.val==head.next.val){\n                return null;\n            }else if(head.next.next==null){\n                return head;\n            }\n        }\n        // 中间，此时节点数>=3，而且前两个节点不相等\n        ListNode p1=head,p2=p1.next,p3=p2.next;\n        while(p3!=null){\n            if(p3.val==p2.val){\n                while(p3!=null&&p3.val==p2.val){\n                    p3=p3.next;\n                }\n                p1.next=p3;\n                p2=p3;\n                if(p2!=null){\n                    p3 = p2.next;\n                }\n\n            }else{\n                p1=p2;\n                p2=p3;\n                p3=p3.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(1)\n\n# 做题感想\n\n修修补补的做题过程😩\n","tags":["algorithm-linked list","algorithm-two pointers"]},{"title":"🔹28th NewCoder Weekly Contest","url":"/2024/01/14/contest-newcoder-weekly-contest-28/","content":"\n| 题号 |                             标题                             | 标签 | 作答情况 |\n| :--: | :----------------------------------------------------------: | ---- | :------: |\n|  A   | [小红的新周赛](https://ac.nowcoder.com/acm/contest/73239/A)  | -    |   通过   |\n|  B   | [小红的字符串](https://ac.nowcoder.com/acm/contest/73239/B)  | 排序 |   通过   |\n|  C   | [小红的炸砖块](https://ac.nowcoder.com/acm/contest/73239/C)  |      |  未通过  |\n|  D   | [小红统计区间（easy）](https://ac.nowcoder.com/acm/contest/73239/D) |      |  未通过  |\n|  E   | [小红的好数组](https://ac.nowcoder.com/acm/contest/73239/E)  |      |  未通过  |\n|  F   | [小红统计区间（hard）](https://ac.nowcoder.com/acm/contest/73239/F) |      |  未通过  |\n\n# A 小红的新周赛\n\n> 链接：https://ac.nowcoder.com/acm/contest/73239/A\n> 来源：牛客网\n>\n> ## 题目描述\n>\n> 小红正在参加牛客周赛，已知周赛一共有 6 道题，现在给定小红每道题的得分，请你计算小红最终的总分。\n>\n> ### 输入描述:\n>\n> ```\n> 六个非负整数A,B,C,D,E,F，用空格隔开。代表小红 6 道题的得分。\n> 每道题的得分均为不超过 1000 的非负整数。\n> ```\n>\n> ### 输出描述:\n>\n> ```\n> 小红最终的总分。\n> ```\n>\n> ### 示例1                        \n>\n> #### 输入\n>\n> ```\n> 100 150 200 0 0 0\n> ```\n>\n> #### 输出\n>\n> ```\n> 450\n> ```\n\n## 代码\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int sum=0;\n        for(int i=0;i<6;i++){\n            sum+=in.nextInt();\n        }\n        System.out.println(sum);\n    }\n}\n```\n\n- 时间复杂度：O(1)\n\n- 空间复杂度：O(1)\n\n# B 小红的字符串\n\n> 链接：https://ac.nowcoder.com/acm/contest/73239/B\n> 来源：牛客网\n>\n> ## 题目描述\n>\n> 小红拿到了一个长度为n的，仅包含小写字母的字符串str，请你取出所有长度恰好为 2 的连续子串，并将它们按字典序升序输出。\n>  \n>  字典序的定义：两个字符串s和t，从左到右数第一个不相同的字符，ascii 码更小的所属的字符串字典序更小。例如，\"ab\"的字典序小于\"ca\"。\n>\n> ### 输入描述:\n>\n> ```\n> 一个仅包含小写字母的字符串str。长度不超过100000\n> ```\n>\n> ### 输出描述:\n>\n> ```\n> n−1行字符串，代表排序后的连续子串。\n> ```\n>\n> ###  示例1                        \n>\n> #### 输入\n>\n> ```\n> ababa\n> ```\n>\n> #### 输出\n>\n> ```\n> ab\n> ab\n> ba\n> ba\n> ```\n\n## 做题感想\n\n一开始专门写了排序方法如下，结果发现不写也不影响\n\n```java\nComparator<String>comp=new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                if(o1.charAt(0)!=o2.charAt(0)){\n                    return o1.charAt(0)-o2.charAt(0);\n                }else{\n                    return o1.charAt(1)-o2.charAt(1);\n                }\n            }\n        };\n        Collections.sort(list,comp);\n```\n\n## 代码\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String str=in.nextLine();\n        int len=str.length();\n        List<String> list=new ArrayList<>();\n        for(int i=0;i<len-1;i++){\n            list.add(str.substring(i,i+2));\n        }\n        Collections.sort(list);\n        for (int i = 0; i < len-1; i++) {\n            System.out.println(list.get(i));\n        }\n    }\n}\n```\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(n)\n\n# C小红的炸砖块\n\n> 链接：https://ac.nowcoder.com/acm/contest/73239/C\n> 来源：牛客网\n>\n> \n>\n> ## 题目描述                    \n>\n> 小红正在玩一个“炸砖块”游戏，游戏的规则如下：\n>  初始有一个n∗m的砖块矩阵。小红会炸k次，每次会向一个位置投炸弹，如果这个位置有一个砖块，则砖块消失，上方的砖块向下落。\n>  小红希望你画出最终砖块的图案。\n>\n> ## 输入描述:\n>\n> ```\n> 第一行输入三个正整数n,m,k，代表矩阵的行数、列数和小红的炸砖块次数。\n> 接下来的kkk行，每行输入两个正整数x,y，代表小红瞄准的是第x行第y列的坐标。\n> 1≤n,m≤1000\n> 10^51≤k≤10^5\n> 1≤x≤n\n> 1≤y≤m\n> ```\n>\n> ## 输出描述:\n>\n> ```\n> 输出n行，每行输出一个长度为m的、仅由'.'和'*'两种字符组成的字符串。'.'代表空白，'*'代表砖块。\n> ```\n>\n> ​                            示例1                        \n>\n> ## 输入\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> 3 3 4\n> 3 1\n> 3 3\n> 2 3\n> 1 3\n> ```\n>\n> ## 输出\n>\n> [复制](javascript:void(0);)\n>\n> ```\n> .*.\n> **.\n> ***\n> ```\n>\n> ## 说明\n>\n> 链接：https://ac.nowcoder.com/acm/contest/73239/C\n> 来源：牛客网\n>\n> \n>\n> 如下图，初始有9个砖块：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20240109/0_1704795884883/70E0C9CFFF067D7E249882B6770BEAD2)\n>\n> 小红第一次炸掉了第三行第一列的砖块，然后上方两个砖块向下落：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20240109/0_1704795954410/28CD6206D96E7DAB0732C9724B3C987F)\n>\n> 之后小红炸掉第三行第三列的砖块，然后上方两个砖块向下落：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20240109/0_1704796009483/9D7C4D15E24156CD9F4A1425877CF31E)\n>\n> 之后小红炸掉第二行第三列的砖块，由于上方没有砖块，所以不会有砖块下落：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20240109/0_1704796030999/2A1BA5B653FF1B19E5E184ABD99E737B)\n>\n> 最后小红准备炸第一行第三列，显然此处已没有砖块：\n>\n> ![img](https://uploadfiles.nowcoder.com/images/20240109/0_1704796088450/71FCCBA7F34B6AE8E219070172C86A40)\n","tags":["contest"]},{"title":"🟢83. remove duplicates from sorted list","url":"/2024/01/14/coding-83-remove-duplicates-from-sorted-list/","content":"\n# 题目描述\n\n> 给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。\n>\n>  \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n>\n> ```\n> 输入：head = [1,1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n>\n> ```\n> 输入：head = [1,1,2,3,3]\n> 输出：[1,2,3]\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - 链表中节点数目在范围 `[0, 300]` 内\n> - `-100 <= Node.val <= 100`\n> - 题目数据保证链表已经按升序 **排列**\n\n# 代码\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode last=head,p=last.next;\n        while(p.next!=null) {//p不是最后一个\n            if (p.val == last.val) {\n                last.next = p.next;\n            }else{\n                last = p;\n            }\n            p = p.next;\n        }\n        if(p.val==last.val){\n            last.next=null;\n        }\n        return head;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(1)\n\n# 做题感想\n\n链表问题保险的做法还是画图\n\n","tags":["algorithm-linked list"]},{"title":"🔸380th LeetCode Weekly Contest (2381/3325)","url":"/2024/01/14/contest-leetcode-weekly-contest-380/","content":"\n| 题号                                         | 标签        | 作答情况 |\n| -------------------------------------------- | ----------- | -------- |\n| [🟢3005. 最大频率元素计数](#head1)            | 数组 哈希表 | 14min    |\n| [🟡3006. 找出数组中的美丽下标 I](#head2)      | KMP         | 通过     |\n| [🟡3007. 价值和小于等于 K 的最大数字](#head3) |             | 没作答   |\n| [🔴3008. 找出数组中的美丽下标 II](#head4)     | KMP+双指针  | 通过     |\n\n# <span id=\"head1\">[🟢3005. 最大频率元素计数](https://leetcode.cn/problems/count-elements-with-maximum-frequency/)</span>\n\n> 给你一个由 **正整数** 组成的数组 `nums` 。\n>\n> 返回数组 `nums` 中所有具有 **最大** 频率的元素的 **总频率** 。\n>\n> 元素的 **频率** 是指该元素在数组中出现的次数。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,2,3,1,4]\n> 输出：4\n> 解释：元素 1 和 2 的频率为 2 ，是数组中的最大频率。\n> 因此具有最大频率的元素在数组中的数量是 4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5]\n> 输出：5\n> 解释：数组中的所有元素的频率都为 1 ，是最大频率。\n> 因此具有最大频率的元素在数组中的数量是 5 。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `1 <= nums[i] <= 100`\n\n通过的代码如下，但是我疑惑的是被注释掉的地方为什么没有按照我的想法解决问题呢？\n\n```java\nclass Solution {\n    public int maxFrequencyElements(int[] nums) {\n         HashMap<Integer,Integer>hm=new HashMap<>();\n        int max_cnt=0,res=0;\n        for (int i = 0; i < nums.length; i++) {\n//            hm.put(nums[i],hm.getOrDefault(hm.get(nums[i]),0)+1);\n            if(hm.containsKey(nums[i])){\n                hm.put(nums[i],hm.get(nums[i])+1 );\n            }else{\n                hm.put(nums[i],1);\n            }\n            if(hm.get(nums[i])>max_cnt){\n                max_cnt=hm.get(nums[i]);\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if(hm.get(nums[i])==max_cnt){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(n)\n\n用了chatgpt查到实际上是逻辑出现了错误🙃\n\n```java\npublic int maxFrequencyElements(int[] nums) {\n        HashMap<Integer,Integer>map=new HashMap<>();\n        int max_cnt=0,res=0;\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n            if (map.get(num) > max_cnt) {\n                max_cnt = map.get(num);\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if(map.get(nums[i])==max_cnt){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head2\">[🟡3006. 找出数组中的美丽下标 I](https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-i/)</span>\n\n> 给你一个下标从 **0** 开始的字符串 `s` 、字符串 `a` 、字符串 `b` 和一个整数 `k` 。\n>\n> 如果下标 `i` 满足以下条件，则认为它是一个 **美丽下标**：\n>\n> - `0 <= i <= s.length - a.length`\n>\n> - `s[i..(i + a.length - 1)] == a`\n>\n> - 存在下标`i`,`j`\n>\n>   使得：\n>\n>   - `0 <= j <= s.length - b.length`\n>   - `s[j..(j + b.length - 1)] == b`\n>   - `|j - i| <= k`\n>\n> 以数组形式按 **从小到大排序** 返回美丽下标。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n> 输出：[16,33]\n> 解释：存在 2 个美丽下标：[16,33]。\n> - 下标 16 是美丽下标，因为 s[16..17] == \"my\" ，且存在下标 4 ，满足 s[4..11] == \"squirrel\" 且 |16 - 4| <= 15 。\n> - 下标 33 是美丽下标，因为 s[33..34] == \"my\" ，且存在下标 18 ，满足 s[18..25] == \"squirrel\" 且 |33 - 18| <= 15 。\n> 因此返回 [16,33] 作为结果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\", a = \"a\", b = \"a\", k = 4\n> 输出：[0]\n> 解释：存在 1 个美丽下标：[0]。\n> - 下标 0 是美丽下标，因为 s[0..0] == \"a\" ，且存在下标 0 ，满足 s[0..0] == \"a\" 且 |0 - 0| <= 4 。\n> 因此返回 [0] 作为结果。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= k <= s.length <= 105`\n> - `1 <= a.length, b.length <= 10`\n> - `s`、`a`、和 `b` 只包含小写英文字母。\n\n第一思路，写的超时了：\n\n```java\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        int len_s=s.length(),len_a=a.length(),len_b=b.length();\n        List<Integer>res=new ArrayList<>();\n        for (int i = 0; i <= len_s-len_a; i++) {\n            if(s.substring(i,i+len_a).equals(a)){\n                for (int j = 0; j <= len_s-len_b; j++) {\n                    if(s.substring(j,j+len_b).equals(b)&&Math.abs(j-i)<=k){\n                        res.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O((len_s-len_a)*(len_s-len_b))\n\n- 空间复杂度：O(n)//? 存疑 待讨论\n\n是一个不错的契机实战一下KMP算法：\n\n```java\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {        \n        List<Integer>list_a=kmp(s,a);\n        List<Integer>list_b=kmp(s,b);\n        List<Integer>res=new ArrayList<>();\n        for(int i=0;i<list_a.size();i++){\n           for(int j=0;j<list_b.size();j++){\n               if(Math.abs(list_a.get(i)-list_b.get(j))<=k){\n                   res.add(list_a.get(i));\n                   break;\n               }\n            }\n        }\n        return res;\n    } \n    List<Integer> kmp(String text, String pattern) {\n        List<Integer> res = new ArrayList<>();\n        int len = pattern.length();\n        int[] next = new int[len];\n        int j = 0;\n        for (int i = 1; i < len; i++) {\n            char ch = pattern.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            next[i] = j;\n        }        \n        j = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char ch = text.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            if (j == len) {\n                res.add(i - len + 1);\n                j = next[j - 1];\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O((len_s-len_a)*(len_s-len_b)+m+n)\n\n- 空间复杂度：O(n)//? 存疑 待讨论\n\n# <span id=\"head3\">[🟡3007. 价值和小于等于 K 的最大数字](https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/)</span>\n\n> 给你一个整数 `k` 和一个整数 `x` 。\n>\n> 令 `s` 为整数 `num` 的下标从 **1** 开始的二进制表示。我们说一个整数 `num` 的 **价值** 是满足 `i % x == 0` 且 `s[i]` 是 **设置位** 的 `i` 的数目。\n>\n> 请你返回 **最大** 整数 `num` ，满足从 `1` 到 `num` 的所有整数的 **价值** 和小于等于 `k` 。\n>\n> **注意：**\n>\n> - 一个整数二进制表示下 **设置位** 是值为 `1` 的数位。\n> - 一个整数的二进制表示下标从右到左编号，比方说如果 `s == 11100` ，那么 `s[4] == 1` 且 `s[2] == 0` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：k = 9, x = 1\n> 输出：6\n> 解释：数字 1 ，2 ，3 ，4 ，5 和 6 二进制表示分别为 \"1\" ，\"10\" ，\"11\" ，\"100\" ，\"101\" 和 \"110\" 。\n> 由于 x 等于 1 ，每个数字的价值分别为所有设置位的数目。\n> 这些数字的所有设置位数目总数是 9 ，所以前 6 个数字的价值和为 9 。\n> 所以答案为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：k = 7, x = 2\n> 输出：9\n> 解释：由于 x 等于 2 ，我们检查每个数字的偶数位。\n> 2 和 3 在二进制表示下的第二个数位为设置位，所以它们的价值和为 2 。\n> 6 和 7 在二进制表示下的第二个数位为设置位，所以它们的价值和为 2 。\n> 8 和 9 在二进制表示下的第四个数位为设置位但第二个数位不是设置位，所以它们的价值和为 2 。\n> 数字 1 ，4 和 5 在二进制下偶数位都不是设置位，所以它们的价值和为 0 。\n> 10 在二进制表示下的第二个数位和第四个数位都是设置位，所以它的价值为 2 。\n> 前 9 个数字的价值和为 6 。\n> 前 10 个数字的价值和为 8，超过了 k = 7 ，所以答案为 9 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= 10^15`\n> - `1 <= x <= 8`\n>\n> Related Topics\n>\n> 位运算\n>\n> 二分查找\n>\n> 动态规划\n\n\n\n# <span id=\"head4\">[🔴3008. 找出数组中的美丽下标 II](https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-ii/)</span>\n\n> 给你一个下标从 **0** 开始的字符串 `s` 、字符串 `a` 、字符串 `b` 和一个整数 `k` 。\n>\n> 如果下标 `i` 满足以下条件，则认为它是一个 **美丽下标** ：\n>\n> - `0 <= i <= s.length - a.length`\n>\n> - `s[i..(i + a.length - 1)] == a`\n>\n> - 存在下标` i`,`j`\n>\n>    使得：\n>\n>   - `0 <= j <= s.length - b.length`\n>   - `s[j..(j + b.length - 1)] == b`\n>   - `|j - i| <= k`\n>\n> 以数组形式按 **从小到大排序** 返回美丽下标。\n>\n>  \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n> 输出：[16,33]\n> 解释：存在 2 个美丽下标：[16,33]。\n> - 下标 16 是美丽下标，因为 s[16..17] == \"my\" ，且存在下标 4 ，满足 s[4..11] == \"squirrel\" 且 |16 - 4| <= 15 。\n> - 下标 33 是美丽下标，因为 s[33..34] == \"my\" ，且存在下标 18 ，满足 s[18..25] == \"squirrel\" 且 |33 - 18| <= 15 。\n> 因此返回 [16,33] 作为结果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\", a = \"a\", b = \"a\", k = 4\n> 输出：[0]\n> 解释：存在 1 个美丽下标：[0]。\n> - 下标 0 是美丽下标，因为 s[0..0] == \"a\" ，且存在下标 0 ，满足 s[0..0] == \"a\" 且 |0 - 0| <= 4 。\n> 因此返回 [0] 作为结果。\n> ```\n>\n>  \n>\n> **提示：**\n>\n> - `1 <= k <= s.length <= 5 * 105`\n> - `1 <= a.length, b.length <= 5 * 105`\n> - `s`、`a`、和 `b` 只包含小写英文字母。\n\n相对于之前的[🟡3006. 找出数组中的美丽下标 I](#head2) 对于得到的b位置数组的遍历进行了优化\n\n```java\nclass Solution {\n    public List<Integer> beautifulIndices(String s, String a, String b, int k) {\n        List<Integer>list_a=kmp(s,a);\n        List<Integer>list_b=kmp(s,b);\n        List<Integer>res=new ArrayList<>();\n        //优化了遍历方式↓\n        int j = 0;\n        for (int i : list_a) {//对于每个a位置数组的元素，只需寻找到一个在范围内的b位置数组中元素存在\n            while (j < list_b.size() && list_b.get(j) < i - k) {\n                j++;//滑动指针到a位置数组的元素i的左领域之前\n            }\n            if (j < list_b.size() && Math.abs(list_b.get(j) - i) <= k) {//继续滑动到领域内，一旦发现符合的元素，就纳入i\n                res.add(i);\n            }\n        }\n        return res;\n    }\n    List<Integer> kmp(String text, String pattern) {\n        List<Integer> res = new ArrayList<>();\n        int len = pattern.length();\n        int[] next = new int[len];\n        int j = 0;\n        for (int i = 1; i < len; i++) {\n            char ch = pattern.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            next[i] = j;\n        }\n        j = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char ch = text.charAt(i);\n            while (j > 0 && pattern.charAt(j) != ch) {\n                j = next[j - 1];\n            }\n            if (pattern.charAt(j) == ch) {\n                j++;\n            }\n            if (j == len) {\n                res.add(i - len + 1);\n                j = next[j - 1];\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O(m + n + len_a + len_b)\n\n- 空间复杂度：O(n)//? 存疑 待讨论\n","tags":["contest"]},{"title":"🟢 2085. count common words with one occurrence","url":"/2024/01/12/coding-2085-count-common-words-with-one-occurrence/","content":"\n# 题目\n\n> 给你两个字符串数组 `words1` 和 `words2` ，请你返回在两个字符串数组中 **都恰好出现一次** 的字符串的数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n> 输出：2\n> 解释：\n> - \"leetcode\" 在两个数组中都恰好出现一次，计入答案。\n> - \"amazing\" 在两个数组中都恰好出现一次，计入答案。\n> - \"is\" 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。\n> - \"as\" 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。\n> 所以，有 2 个字符串在两个数组中都恰好出现了一次。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n> 输出：0\n> 解释：没有字符串在两个数组中都恰好出现一次。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n> 输出：1\n> 解释：唯一在两个数组中都出现一次的字符串是 \"ab\" 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= words1.length, words2.length <= 1000`\n> - `1 <= words1[i].length, words2[j].length <= 30`\n> - `words1[i]` 和 `words2[j]` 都只包含小写英文字母。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n# 代码\n\n使用两个哈希表\n\n```java\nclass Solution {\n    public int countWords(String[] words1, String[] words2) {\n        HashMap<String,Integer>hashMap1=new HashMap<>();\n        HashMap<String,Integer>hashMap2=new HashMap<>();\n        int cnt=0;\n        for (int i = 0; i < words1.length; i++) {\n            hashMap1.put(words1[i],hashMap1.getOrDefault(words1[i],0)+1);\n        }\n        for (int i = 0; i < words2.length; i++) {\n            hashMap2.put(words2[i],hashMap2.getOrDefault(words2[i],0)+1);\n        }\n        for (int i = 0; i < words2.length; i++) {\n            if(hashMap1.containsKey(words2[i])&&hashMap1.get(words2[i])==1&&hashMap2.get(words2[i])==1){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n> - 时间复杂度：O(n+m)\n>\n> - 空间复杂度：O(n+m)\n","tags":["algorithm-array","algorithm-hash table","algorithm-string","algorithm-counting"]},{"title":"20-day special training","url":"/2023/12/24/problem-set-0D/","content":"\n| 天数                           | 主题                                          | 编号 | 题目                                                       | 是否完成 |\n| ------------------------------ | --------------------------------------------- | ---- | :--------------------------------------------------------- | -------- |\n| [ 第一天](#head2)              | [设计](#head3)                                | 1    | [🟢1603.设计停车系统](#head4)                               | ✅        |\n|                                | [ 栈](#head5)                                 | 2    | [ 🟢20.有效的括号](#head6)                                  | ✅        |\n|                                |                                               | 3    | [ 2023Q1A-括号检查](#head7)                                | ✅        |\n|                                | [ 队列](#head8)                               | 4    | [ 🟢剑指offerⅡ041.滑动窗口的平均值](#head9)                 | ✅        |\n|                                | [作业](#head10)                               | 5    | [ 🟢1614.括号的最大嵌套深度](#head11)                       | ✅        |\n|                                |                                               | 6    | [ 🟢1047.删除字符串中的所有相邻重复项](#head12)             | ✅        |\n|                                |                                               | 7    | [ 2023Q1A-身高提供排序](#head13)                           | ✅        |\n| [ 第二天](#head14)             | [ 栈](#head15)                                | 8    | [ 🟡150.逆波兰表达式求值](#head16)                          | ✅        |\n|                                |                                               | 9    | [ 🔴224.基本计算器](#head17)                                |          |\n|                                |                                               | 10   | [🟡155.最小栈](#head18)                                     | ✅        |\n|                                |                                               | 11   | [ 🟡394.字符串解码](#head19)                                | ✅        |\n|                                | [ 作业](#head20)                              | 12   | [ 🟡71.简化路径](#head21)                                   |          |\n|                                |                                               | 13   | [ 🟡946.检证栈序列](#head22)                                | ✅        |\n|                                |                                               | 14   | [ 2023Q1A-投篮大赛](#head23)                               | ✅        |\n|                                |                                               | 15   | [ 2023Q1A-解压缩算法](#head24)                             | ✅        |\n| [ 第三天](#head25)             | [ 哈希集合](#head26)                          | 16   | [ 🟢217.存在重复元素](#head27)                              | ✅        |\n|                                |                                               | 17   | [ 🟢349.两个数字的交集](#head28)                            | ✅        |\n|                                | [ 哈希表-用于统计频率](#head29)               | 18   | [ 🟢242.有效的字母异位词](#head30)                          | ✅        |\n|                                |                                               | 19   | [ 🟢383.赎金信](#head31)                                    | ✅        |\n|                                |                                               | 20   | [ 2023Q1A-集五福](#head32)                                 | ✅        |\n|                                |                                               | 21   | [ 2023Q1A-删除最少字符](#head33)                           | ✅        |\n|                                | [ 作业](#head34)                              | 22   | [ 🟢387.字符串中的第一个唯一字符](#head35)                  | ✅        |\n|                                |                                               | 23   | [ 🟢350.两个数组的交集Ⅱ](#head36)                           | ✅        |\n|                                |                                               | 24   | [ 2023Q1A-寻找关键钥匙](#head37)                           | ✅        |\n|                                |                                               | 25   | [ 2023Q1A-明明的随机数](#head38)                           | ✅        |\n|                                |                                               | 26   | [ 2023Q1A-统计匹配的二元组个数](#head39)                   | ✅        |\n| [ 第四天](#head40)             | [ 哈希表-用于下表查询](#head41)               | 27   | [ 🟢1.两数之和](#head42)                                    | ✅        |\n|                                |                                               | 28   | [ 🟢219.存在重复元素Ⅱ](#head43)                             | ✅        |\n|                                | [ 哈希表-用于元素配对](#head44)               | 29   | [ 🟢205.同构字符串](#head45)                                | ✅        |\n|                                |                                               | 30   | [🟡49.字母异位词分组](#head46)                              | ✅        |\n|                                | [ 作业](#head47)                              | 31   | [ 🟢290.单词规律](#head48)                                  | ✅        |\n|                                |                                               | 32   | [ 2023Q1A-字符串重新排序](#head49)                         | ✅        |\n|                                |                                               | 33   | [2023Q2B-选修课](#head50)                                  |          |\n|                                |                                               | 34   | [ 2023Q1A-相同数字的积木游戏](#head51)                     | ✅        |\n|                                |                                               | 35   | [ 2023Q1A-英文输入法](#head52)                             | ✅        |\n|                                |                                               | 36   | [ 2023Q1A-寻找密码](#head53)                               | ✅        |\n| [ 第五天](#head54)             | [ 单调栈](#head55)                            | 37   | [ 🟢1475.商品折扣后的最终价格](#head56)                     | ✅        |\n|                                |                                               | 38   | [ 🟡739.每日温度](#head57)                                  | ✅        |\n|                                |                                               | 39   | [🔴42.接雨水](#head58)                                      |          |\n|                                | [ 栈与队列综合](#head59)                      | 40   | [ 🟢232.用栈实现队列](#head60)                              | ✅        |\n|                                | [ 作业](#head61)                              | 41   | [ 🟢225.用队列实现栈](#head62)                              |          |\n|                                |                                               | 42   | [ 🟢496.下一个更大的元素Ⅰ](#head63)                         |          |\n|                                |                                               | 43   | [ 2023Q1A-找朋友](#head64)                                 |          |\n|                                |                                               | 44   | [ 2023Q1A-删除重复数字后的最大数字](#head65)               |          |\n|                                |                                               | 45   | [ 2023Q1B-找最小数](#head66)                               |          |\n| [ 第六天](#head67)             | [ 双指针-同向双指针](#head68)                 | 46   | [ 🟢88.合并两个有序数组](#head69)                           |          |\n|                                |                                               | 47   | [ 🟢26.删除有序数组的重复项](#head70)                       |          |\n|                                |                                               | 48   | [🟡80.删除有序数组的重复项Ⅱ](#head71)                       |          |\n|                                |                                               | 49   | [🟢485.最大连续1的个数](#head72)                            |          |\n|                                | [ 作业](#head73)                              | 50   | [ 🟢283.移动零](#head74)                                    |          |\n|                                |                                               | 51   | [ 🟢27.移除数组](#head75)                                   |          |\n|                                |                                               | 52   | [2023Q1A-最长的元音字符串](#head76)                        |          |\n| [ 第七天](#head77)             | [ 相向双指针](#head78)                        | 53   | [ 🟢9.回文数](#head79)                                      |          |\n|                                |                                               | 54   | [ 🟢125.验证回文数](#head80)                                |          |\n|                                |                                               | 55   | [ 🟡167.两数之和Ⅱ-输入有序数组](#head81)                    |          |\n|                                |                                               | 56   | [ 🟡11.盛水最多的容器](#head82)                             |          |\n|                                |                                               | 57   | [ 🟡15.三数之和](#head83)                                   |          |\n|                                |                                               | 58   | [🟡75.颜色分类](#head84)                                    |          |\n|                                | [ 作业](#head85)                              | 59   | [ 🟢680.验证回文串Ⅱ](#head86)                               |          |\n|                                |                                               | 60   | [ 2023Q1A-两数之和绝对值最小](#head87)                     |          |\n|                                |                                               | 61   | [ 2023Q1A-双十一](#head88)                                 |          |\n| [ 第八天](#head89)             | [ 贪心](#head90)                              | 62   | [ 🟢455.分发饼干](#head91)                                  |          |\n|                                |                                               | 63   | [ 🟡134.加油站](#head92)                                    |          |\n|                                |                                               | 64   | [ 🟢860.柠檬水找零](#head93)                                |          |\n|                                |                                               | 65   | [ 🟢605.种花问题](#head94)                                  |          |\n|                                |                                               | 66   | [ 🟡376.摆动序列](#head95)                                  |          |\n|                                |                                               | 67   | [ 2023Q1A-快递货车](#head96)                               |          |\n|                                | [ 作业](#head97)                              | 68   | [ 2023Q1A-停车找车位](#head98)                             |          |\n|                                |                                               | 69   | [2023Q1A-卡片组成的最大数字](#head99)                      |          |\n| [ 第九天](#head100)            | [ 贪心](#head101)                             | 70   | [ 🟡881.救生艇](#head102)                                   |          |\n|                                |                                               | 71   | [ 🟢122.买卖股票的最佳时机Ⅱ](#head103)                      |          |\n|                                |                                               | 72   | [ 🟡45.跳跃游戏Ⅱ](#head104)                                 |          |\n|                                |                                               | 73   | [ 🔴135.分发糖果](#head105)                                 |          |\n|                                | [ 作业](#head106)                             | 74   | [ 🟡55.跳跃游戏](#head107)                                  |          |\n|                                |                                               | 75   | [ 2023Q1A-卡片组成的最大数字](#head108)                    |          |\n|                                |                                               | 76   | [ 2023Q1A-贪心的商人](#head109)                            |          |\n|                                |                                               | 77   | [ 2023B-观看文艺汇演](#head110)                            |          |\n| [ 第十天](#head111)            | [ 滑动窗口-长度可变](#head112)                | 78   | [ 🟡3.无重复字符的最长字符](#head113)                       |          |\n|                                |                                               | 79   | [ 🟡209.长度最小的子数组](#head114)                         |          |\n|                                |                                               | 80   | [ 🟡904.水果成蓝](#head115)                                 |          |\n|                                |                                               | 81   | [ 🟡159.至多包含两个不同的字符的最长字串](#head116)         |          |\n|                                |                                               | 82   | [ 🟡340.至多包含k个不同的字符的最长字串](#head117)          |          |\n|                                |                                               | 83   | [ 🔴76.最小覆盖字串](#head118)                              |          |\n|                                |                                               | 84   | [ 2023Q1A-区块链文件转储系统](#head119)                    |          |\n|                                |                                               | 85   | [ 2023Q2-寻找符合要求的最长字串](#head120)                 |          |\n|                                | [ 作业](#head121)                             | 86   | [ 🟡1695.删除子数组的最大分数](#head122)                    |          |\n|                                |                                               | 87   | [ 🟡2024.考试的最大扰度](#head123)                          |          |\n|                                |                                               | 88   | [ 🟡1658.将x减到0的最小操作数](#head124)                    |          |\n|                                |                                               | 89   | [ 2023Q1A-完美走位](#head125)                              |          |\n| [ 第十一天](#head126)          | [ 滑动窗口-长度不可变](#head127)              | 90   | [ 🟢1984.学生分数的最小差值](#head128)                      |          |\n|                                |                                               | 91   | [ 🟡1456.定长子串中元音的最大数目](#head129)                |          |\n|                                |                                               | 92   | [ 🟡567.字符串的排列](#head130)                             |          |\n|                                |                                               | 93   | [ 🟡1052.爱生气的书店老板](#head131)                        |          |\n|                                |                                               | 94   | [ 2023Q1A-找出通过车辆最多颜色](#head132)                  |          |\n|                                |                                               | 95   | [ 2023Q1A-知识图谱新词挖掘](#head133)                      |          |\n|                                | [ 作业](#head134)                             | 96   | [ 🟢2269.找到一个数字的k美丽值](#head135)                   |          |\n|                                |                                               | 97   | [ 🟡1876.长度为三且字符不同的子字符串](#head136)            |          |\n|                                |                                               | 98   | [ 🟡438.找到字符串中所有字母异位词](#head137)               |          |\n| [ 第十二天](#head138)          | [ 序列DP-入门](#head139)                      | 99   | [🟢509.斐波那契数](#head140)                                |          |\n|                                |                                               | 100  | [ 🟢70.爬楼梯](#head141)                                    |          |\n|                                | [ 序列DP-路径问题](#head142)                  | 101  | [ 🟡62.不同路径](#head143)                                  |          |\n|                                |                                               | 102  | [ 🟡63.不同路径Ⅱ](#head144)                                 |          |\n|                                |                                               | 103  | [ 🟡64.最小路径和](#head145)                                |          |\n|                                | [ 序列DP-打家劫舍](#head146)                  | 104  | [ 🟡198.打家劫舍](#head147)                                 |          |\n|                                |                                               | 105  | [ 🟡213.打家劫舍Ⅱ](#head148)                                |          |\n|                                | [ 作业](#head149)                             | 106  | [ 🟢1137.第n个泰波那锲数](#head150)                         |          |\n|                                |                                               | 107  | [ 🟡120.三角形最小路径和](#head151)                         |          |\n|                                |                                               | 108  | [ 🟡931.下降路径最小和](#head152)                           |          |\n|                                |                                               | 109  | [ 2023Q1A-猴子爬山](#head153)                              |          |\n|                                |                                               | 110  | [ 2023Q2-超级玛丽过吊桥](#head154)                         |          |\n| [ 第十三天](#head155)          | [ 序列DP-最长递增子序列(LIS)](#head156)       | 111  | [ 🟡300.最长递增子序列](#head157)                           |          |\n|                                |                                               | 112  | [ 🟡673.最长递增子序列的个数](#head158)                     |          |\n|                                |                                               | 113  | [ 🟡334.递增的三元组](#head159)                             |          |\n|                                | [ 序列DP-最长公共子序列(LCS)](#head160)       | 114  | [ 🟡718.最长重复子数字](#head161)                           |          |\n|                                |                                               | 115  | [ 🟡1143.最长公共子序列](#head162)                          |          |\n|                                | [ 作业](#head163)                             | 116  | [ 面试题17.08马戏团人塔](#head164)                         |          |\n|                                |                                               | 117  | [ 🟡1035.不相交的线](#head165)                              |          |\n|                                |                                               | 118  | [ 2023Q1A-寻找重复代码](#head166)                          |          |\n|                                |                                               | 119  | [2023Q2-高速公路休息站充电规则](#head167)                  |          |\n| [ 第十四天](#head168)          | [ 状态DP-入门](#head169)                      | 120  | [🟡LCR 091.粉刷房子](#head170)                              |          |\n|                                | [ 状态DP-股票问题](#head171)                  | 121  | [ 🔴188.买卖股票的最佳时机Ⅳ](#head172)                      |          |\n|                                |                                               | 122  | [ 🟢121.买卖股票的最佳时机](#head173)                       |          |\n|                                |                                               | 123  | [ 🔴123.买卖股票的最佳时机Ⅲ](#head174)                      |          |\n|                                |                                               | 124  | [ 🟡122.买卖股票的最佳时机Ⅱ](#head175)                      |          |\n|                                |                                               | 125  | [ 🟡309.最佳买卖股票时机含冷冻期](#head176)                 |          |\n|                                |                                               | 126  | [ 🟡714.买卖股票的的最佳时机含手续费](#head177)             |          |\n|                                | [ 作业](#head178)                             | 127  | [ 2023Q1A-贪心的商人](#head179)                            |          |\n|                                |                                               | 128  | [2023Q1A-递增字符串](#head180)                             |          |\n| [ 第十五天](#head181)          | [ 背包DP-01背包](#head182)                    | 129  | [ 🟡494.目标和](#head183)                                   |          |\n|                                | [ 背包DP-完全背包](#head184)                  | 130  | [ 🟡322.零钱兑换](#head185)                                 |          |\n|                                |                                               | 131  | [ 🟡518.零钱兑换Ⅱ](#head186)                                |          |\n|                                | [ 作业](#head187)                             | 132  | [🟡416.分割等和子集](#head188)                              |          |\n|                                |                                               | 133  | [ 🟡1049.最后一块石头的重量Ⅱ](#head189)                     |          |\n| [ 第十六天](#head190)          | [ 二分查找-在排序数组中](#head191)            | 134  | [ 🟢35.搜索插入位置](#head192)                              |          |\n|                                |                                               | 135  | [🟢704.二分查找](#head193)                                  |          |\n|                                |                                               | 136  | [🟡34.在排序数组中查找元素的第一个和最后一个位置](#head194) |          |\n|                                | [ 二分查找-在数轴中](#head195)                | 137  | [ 🟢367.有效的完全平方数](#head196)                         |          |\n|                                |                                               | 138  | [🟢69.x 的平方根](#head197)                                 |          |\n|                                | [ 二分查找-利用问题的二段性](#head198)        | 139  | [ 🟡875.爱吃香蕉的珂珂](#head199)                           |          |\n|                                |                                               | 140  | [ 2023Q1A-开放日活动](#head200)                            |          |\n|                                |                                               | 141  | [ 2023B-食堂供餐](#head201)                                |          |\n|                                | [ 作业](#head202)                             | 142  | [🟢374.猜数字大小](#head203)                                |          |\n|                                |                                               | 143  | [ 🟡1011.在D天内送达包裹的能力](#head204)                   |          |\n|                                |                                               | 144  | [ 2023Q1A-农场施肥](#head205)                              |          |\n|                                |                                               | 145  | [ 2023B-最佳植树距离](#head206)                            |          |\n| [ 第十七天/第十八天](#head207) | [ DFS/BFS-前置问题](#head208)                 | 146  | [ 2023B-统计监控](#head209)                                |          |\n|                                | [ DFS/BFS-二维矩阵表示图(岛屿问题)](#head210) | 147  | [ 🟡200.岛屿数量](#head211)                                 |          |\n|                                |                                               | 148  | [ 🟡695.岛屿的最大面积](#head212)                           |          |\n|                                |                                               | 149  | [ 2023Q1A-开心消消乐](#head213)                            |          |\n|                                |                                               | 150  | [ 2023B-寻找最大价值的矿堆](#head214)                      |          |\n|                                | [ DFS/BFS-邻接矩阵表示图](#head215)           | 151  | [ 🟡547.省份数量](#head216)                                 |          |\n|                                |                                               | 152  | [ 2023Q1A-Linux发行版的数量](#head217)                     |          |\n|                                | [ DFS/BFS-邻接表表示图](#head218)             | 153  | [ 🟡841.钥匙和房间](#head219)                               |          |\n|                                | [ 作业](#head220)                             | 154  | [ 🟢463.岛屿的周长](#head221)                               |          |\n|                                |                                               | 155  | [ 🟢733.图像渲染](#head222)                                 |          |\n|                                |                                               | 156  | [ 2023Q2-广播服务器](#head223)                             |          |\n|                                |                                               | 157  | [ 2023Q1A-机器人活动区域](#head224)                        |          |\n| [ 第十九天](#head225)          | [ BFS](#head226)                              | 158  | [ 🟡994.腐烂的橘子](#head227)                               |          |\n|                                |                                               | 159  | [ 2023Q1-快速开租建站](#head228)                           |          |\n|                                | [ DFS](#head229)                              | 160  | [ 🟢1971.寻找图中是否存在路径](#head230)                    |          |\n|                                |                                               | 161  | [ 🟡1376.通知所有员工所需的时间](#head231)                  |          |\n|                                |                                               | 162  | [ 2023Q2-获取食物游戏](#head232)                           |          |\n|                                | [ 作业](#head233)                             | 163  | [ 2023Q2B-火星改造](#head234)                              |          |\n|                                |                                               | 164  | [ 2023Q2-士兵突击](#head235)                               |          |\n| [ 第二十天](#head236)          | [ 回溯算法](#head237)                         | 165  | [🔴51.N 皇后](#head238)                                     |          |\n|                                |                                               | 166  | [🔴37.解数独](#head239)                                     |          |\n|                                | [ 作业](#head240)                             | 167  | [ 2023Q1A-基站维修工程师](#head241)                        |          |\n|                                |                                               | 168  | [ 2023Q1-硬件产品销售方案](#head242)                       |          |\n|                                |                                               | 169  | [ 2023B-猜密码](#head243)                                  |          |\n\n# <span id=\"head1\"> 主要知识点</span>\n\n<table>   \n   <tr>\n    <th rowspan=\"2\">知识点</th>\n    <th colspan=\"2\">分类</th>\n  </tr>\n  <tr>\n    <th>分类一</th>\n    <th>分类二</th>\n  </tr>\n    <tr>        \n        <td>1.设计</td>     \n        <td></td>   \n        <td></td> \n    </tr>   \n    <tr> \n         <td rowspan=\"3\">2.栈&队列</td>     \n        <td>栈</td>  \n        <td></td> \n    </tr>   \n    <tr>       \n        <td>队列</td> \n        <td></td> \n    </tr>   \n    <tr>        \n        <td>栈和队列综合</td>   \n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"4\">3.哈希表</td>        \n        <td>哈希集合</td>   \n        <td></td> \n    </tr>   \n    <tr>          \n        <td rowspan=\"3\">哈希表</td>\n        <td>用于统计频率</td>   \n    </tr>   \n    <tr>        \n        <td>用于下表查询</td>   \n    </tr>   \n    <tr>        \n        <td>用于元素配对</td>   \n    </tr>   \n    <tr>     \n        <td rowspan=\"2\">4.双指针</td>   \n        <td>同向双指针</td> \n        <td></td> \n    </tr>   \n    <tr>      \n        <td>相向双指针</td> \n        <td></td> \n    </tr>   \n    <tr>     \n        <td>5.贪心</td>      \n        <td></td>  \n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"2\">6.滑动窗口</td>\n        <td>长度可变</td> \n        <td></td> \n    </tr>   \n    <tr>                 \n        <td>长度不可变</td>\n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"7\">7.DP</td>     \n        <td rowspan=\"3\">序列DP</td>\n        <td>入门</td>   \n    </tr>   \n    <tr>       \n        <td>路径问题</td>   \n    </tr>   \n    <tr>        \n        <td>打家劫舍问题</td>   \n    </tr>   \n    <tr>       \n        <td rowspan=\"2\">状态DP</td>\n        <td>入门</td>  \n    </tr>   \n    <tr>       \n        <td>股票问题</td>  \n    </tr>   \n    <tr>       \n        <td rowspan=\"2\">背包DP</td>\n        <td>01背包</td>  \n    </tr>   \n    <tr>        \n        <td>完全背包</td>  \n    </tr>   \n    <tr>    \n        <td rowspan=\"3\">8.二分查找</td>       \n        <td>在排序数组中</td>\n        <td></td> \n    </tr>   \n    <tr>       \n        <td>在数轴中</td>  \n        <td></td> \n    </tr>   \n    <tr>    \n        <td>利用问题的二段性</td>  \n        <td></td> \n    </tr>   \n    <tr>     \n        <td rowspan=\"6\">9.BFS&DFS</td>        \n        <td>前置问题</td>   \n        <td></td>\n    </tr>   \n    <tr>        \n        <td>二维矩阵表示图（岛屿问题）</td> \n        <td></td>\n    </tr>   \n    <tr>         \n        <td>邻接矩阵表示图</td>\n        <td></td>\n    </tr>   \n    <tr>         \n        <td>邻接表表示图</td>   \n        <td></td>\n    </tr>   \n    <tr>        \n        <td>BFS</td>   \n        <td></td>\n    </tr>   \n    <tr>        \n        <td>DFS</td>  \n        <td></td>\n    </tr>   \n    <tr>     \n        <td>10.回溯算法</td>     \n        <td></td>     \n        <td></td>   \n    </tr> \n</table>\n\n\n# <span id=\"head2\"> 第一天</span>\n\n## <span id=\"head3\">设计</span>\n\n### <span id=\"head4\"> 🟢1603.设计停车系统</span>\n\n> 请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。\n>\n> 请你实现 `ParkingSystem` 类：\n>\n> - `ParkingSystem(int big, int medium, int small)` 初始化 `ParkingSystem` 类，三个参数分别对应每种停车位的数目。\n> - `bool addCar(int carType)` 检查是否有 `carType` 对应的停车位。 `carType` 有三种类型：大，中，小，分别用数字 `1`， `2` 和 `3` 表示。**一辆车只能停在** `carType` 对应尺寸的停车位中。如果没有空车位，请返回 `false` ，否则将该车停入车位并返回 `true` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n> [[1, 1, 0], [1], [2], [3], [1]]\n> 输出：\n> [null, true, true, false, false]\n> \n> 解释：\n> ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\n> parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位\n> parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位\n> parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位\n> parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= big, medium, small <= 1000`\n> - `carType` 取值为 `1`， `2` 或 `3`\n> - 最多会调用 `addCar` 函数 `1000` 次\n>\n> Related Topics\n>\n> 设计\n>\n> 计数\n>\n> 模拟\n\n```java\nclass ParkingSystem {\n    int big_num;\n    int medium_num;\n    int small_num;\n\n    public ParkingSystem(int big, int medium, int small) {\n        this.big_num=big;\n        this.medium_num=medium;\n        this.small_num=small;\n    }\n    \n    public boolean addCar(int carType) {\n        switch (carType){\n            case 1:{\n                if(this.big_num>0){\n                    this.big_num--;\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n            case 2:{\n                if(this.medium_num>0){\n                    this.medium_num--;\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n            case 3:{\n                if(this.small_num>0){\n                    this.small_num--;\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n\n        }\n        return false;\n    }\n}\n```\n\n\n\n## <span id=\"head5\"> 栈</span>\n\n### <span id=\"head6\"> 🟢20.有效的括号</span>\n\n> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n>\n> 有效字符串需满足：\n>\n> 1. 左括号必须用相同类型的右括号闭合。\n> 2. 左括号必须以正确的顺序闭合。\n> 3. 每个右括号都有一个对应的相同类型的左括号。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"()\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"()[]{}\"\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"(]\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅由括号 `'()[]{}'` 组成\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\n    public boolean isValid(String s) {\n        Stack<Character>stack=new Stack<>();\n        for (char ch: s.toCharArray()) {\n            if(ch=='('||ch=='{'||ch=='['){\n                stack.push(ch);\n            } else if(!stack.isEmpty()&&ch==')'&&stack.peek()=='('){\n                stack.pop();\n            } else if(!stack.isEmpty()&&ch=='}'&&stack.peek()=='{') {\n                stack.pop();\n            }else if(!stack.isEmpty()&&ch==']'&&stack.peek()=='[') {\n                stack.pop();\n            }else {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n\n\n### <span id=\"head7\"> 2023Q1A-括号检查</span>\n\n[【华为OD统一考试B卷 | 100分】括号匹配（C++ Java JavaScript Python）_括号检查 华为od-CSDN博客](https://blog.csdn.net/banxia_frontend/article/details/130175261)\n\n> 题目描述给定一个字符串，里边可能包含“()”、“[]”、“{}”三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。若括号成对出现且嵌套关系正确，或该字符串中无括号字符，输出：true；若未正确使用括号字符，输出：false\n>\n> 实现时，无需考虑非法输入。\n>\n> 输入描述\n>\n> 无\n>\n> 输出描述\n>\n> 无\n>\n> 用例\n>\n> 输入 \n>\n> ```\n> (1+2)/(0.5+1)\n> ```\n>\n> 输出\n>\n> ```\n>  true\n> ```\n>\n> 说明 \n>\n> 无\n\n```java\nimport java.util.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n        boolean flag=true;\n        Set<Character>set=new HashSet<>();\n        set.add('(');\n        set.add(')');\n        set.add('{');\n        set.add('}');\n        set.add('[');\n        set.add(']');\n\n        Scanner in=new Scanner(System.in);\n        String str=in.nextLine();\n        Stack<Character>stack=new Stack<>();\n        for (char ch:\n             str.toCharArray()) {\n            if(set.contains(ch)){\n                if(ch=='('||ch=='{'||ch=='['){\n                    stack.push(ch);\n                } else if (!stack.isEmpty() && (ch == ')' && stack.peek() == '(' ||ch=='}'&&stack.peek()=='{'||ch==']'&&stack.peek()=='[')) {\n                    stack.pop();\n                }else{\n                    flag=false;\n                }\n            }\n        }\n        if(stack.isEmpty()&&flag){\n            System.out.println(\"true\");\n        }else{\n            System.out.println(\"false\");\n        }\n\n    }\n}\n```\n\n\n\n## <span id=\"head8\"> 队列</span>\n\n### <span id=\"head9\"> 🟢剑指offerⅡ041.滑动窗口的平均值</span>\n\n> 给定一个窗口大小和一个整数数据流，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。\n>\n> 实现 `MovingAverage` 类：\n>\n> - `MovingAverage(int size)` 用窗口大小 `size` 初始化对象。\n> - `double next(int val)` 成员函数 `next` 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 `size` 个值的移动平均值，即滑动窗口里所有数字的平均值。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> inputs = [\"MovingAverage\", \"next\", \"next\", \"next\", \"next\"]\n> inputs = [[3], [1], [10], [3], [5]]\n> 输出：\n> [null, 1.0, 5.5, 4.66667, 6.0]\n> \n> 解释：\n> MovingAverage movingAverage = new MovingAverage(3);\n> movingAverage.next(1); // 返回 1.0 = 1 / 1\n> movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\n> movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\n> movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= size <= 1000`\n> - `-105 <= val <= 105`\n> - 最多调用 `next` 方法 `104` 次\n>\n> \n>\n> 注意：本题与主站 346 题相同： https://leetcode-cn.com/problems/moving-average-from-data-stream/\n>\n> Related Topics\n>\n> 设计\n>\n> 队列\n>\n> 数组\n>\n> 数据流\n\n```java\nclass MovingAverage {\n\n    /** Initialize your data structure here. */\n    Queue<Integer>q;\n    int size;\n\n    public MovingAverage(int size) {\n        this.size=size;\n        this.q=new LinkedList<>();\n    }\n    \n    public double next(int val) {\n        if(this.q.size()==this.size){//满了\n            q.poll();\n            Queue<Integer>t=new LinkedList<>();\n            int sum=0;\n            while(!this.q.isEmpty()){\n                int temp=this.q.poll();\n                sum+=temp;\n                t.offer(temp);\n            }\n            while(!t.isEmpty()){\n                int temp=t.poll();\n                this.q.offer(temp);\n            }\n            this.q.offer(val);\n            sum+=val;\n            return (double) sum/this.size;\n        }else{//还没满\n            Queue<Integer>t=new LinkedList<>();\n            int sum=0;\n            while(!this.q.isEmpty()){\n                int temp=this.q.poll();\n                sum+=temp;\n                t.offer(temp);\n            }\n            while(!t.isEmpty()){\n                int temp=t.poll();\n                this.q.offer(temp);\n            }\n            this.q.offer(val);\n            sum+=val;\n            return (double) sum/this.q.size();\n        }\n    }\n}\n```\n\n## <span id=\"head10\"> 作业</span>\n\n### <span id=\"head11\"> 🟢1614.括号的最大嵌套深度</span>\n\n> 如果字符串满足以下条件之一，则可以称之为 **有效括号字符串****（valid parentheses string**，可以简写为 **VPS**）：\n>\n> - 字符串是一个空字符串 `\"\"`，或者是一个不为 `\"(\"` 或 `\")\"` 的单字符。\n> - 字符串可以写为 `AB`（`A` 与 `B` 字符串连接），其中 `A` 和 `B` 都是 **有效括号字符串** 。\n> - 字符串可以写为 `(A)`，其中 `A` 是一个 **有效括号字符串** 。\n>\n> 类似地，可以定义任何有效括号字符串 `S` 的 **嵌套深度** `depth(S)`：\n>\n> - `depth(\"\") = 0`\n> - `depth(C) = 0`，其中 `C` 是单个字符的字符串，且该字符不是 `\"(\"` 或者 `\")\"`\n> - `depth(A + B) = max(depth(A), depth(B))`，其中 `A` 和 `B` 都是 **有效括号字符串**\n> - `depth(\"(\" + A + \")\") = 1 + depth(A)`，其中 `A` 是一个 **有效括号字符串**\n>\n> 例如：`\"\"`、`\"()()\"`、`\"()(()())\"` 都是 **有效括号字符串**（嵌套深度分别为 0、1、2），而 `\")(\"` 、`\"(()\"` 都不是 **有效括号字符串** 。\n>\n> 给你一个 **有效括号字符串** `s`，返回该字符串的 `s` **嵌套深度** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"(1+(2*3)+((8)/4))+1\"\n> 输出：3\n> 解释：数字 8 在嵌套的 3 层括号中。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"(1)+((2))+(((3)))\"\n> 输出：3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 100`\n> - `s` 由数字 `0-9` 和字符 `'+'`、`'-'`、`'*'`、`'/'`、`'('`、`')'` 组成\n> - 题目数据保证括号表达式 `s` 是 **有效的括号表达式**\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public int maxDepth(String s) {\n        Stack<Character>stack=new Stack<>();\n        int depth=0;\n        for (char ch:\n             s.toCharArray()) {\n            if(ch=='('){\n                stack.push(ch);\n                depth=Math.max(depth,stack.size());\n            } else if (ch==')') {\n                stack.pop();\n            }\n        }\n        return depth;\n    }\n}\n```\n\n### <span id=\"head12\"> 🟢1047.删除字符串中的所有相邻重复项</span>\n\n> 给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。\n>\n> 在 S 上反复执行重复项删除操作，直到无法继续删除。\n>\n> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\"abbaca\"\n> 输出：\"ca\"\n> 解释：\n> 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> 1. `1 <= S.length <= 20000`\n> 2. `S` 仅由小写英文字母组成。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        Stack<Character>stack=new Stack<>();\n        for (char ch:\n             s.toCharArray()) {\n            if(stack.isEmpty()){\n                stack.push(ch);\n            }else{\n                char temp=stack.peek();\n                if(temp==ch){\n                    stack.pop();\n                }else{\n                    stack.push(ch);\n                }\n            }\n        }\n        StringBuilder sb=new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}\n```\n\n### <span id=\"head13\"> 2023Q1A-身高提供排序</span>\n\n> ![image-20240111162226447](23-12-24-algorithm-OD/image-20240111162226447.png)\n\n```java\nimport java.util.*;\nclass Student{\n    int i,height,weight;\n    Student(int i,int height){\n        this.i=i;\n        this.height=height;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        Student[]students=new Student[n];\n        for (int i = 0; i < n; i++) {\n            students[i]=new Student(i+1,in.nextInt());\n        }\n        for (int i = 0; i < n; i++) {\n            students[i].weight=in.nextInt();\n        }\n\n        Comparator<Student>camp=new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2){\n                if(o1.height!= o2.height){\n                    return o1.height-o2.height;\n                }else if(o1.weight!=o2.weight){\n                    return o1.weight- o2.weight;\n                }else{\n                    return o1.i-o2.i;\n                }\n            }\n        };\n        Arrays.sort(students,camp);\n        for (int i = 0; i < n; i++) {\n            System.out.print(students[i].i+\" \");\n        }\n\n    }\n}\n```\n\n\n\n# <span id=\"head14\"> 第二天</span>\n\n## <span id=\"head15\"> 栈</span>\n\n### <span id=\"head16\"> 🟡150.逆波兰表达式求值</span>\n\n> 给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。\n>\n> 请你计算该表达式。返回一个表示表达式值的整数。\n>\n> **注意：**\n>\n> - 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。\n> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n> - 两个整数之间的除法总是 **向零截断** 。\n> - 表达式中不含除零运算。\n> - 输入是一个根据逆波兰表示法表示的算术表达式。\n> - 答案及所有中间计算结果可以用 **32 位** 整数表示。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n> 输出：9\n> 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n> 输出：6\n> 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n> 输出：22\n> 解释：该算式转化为常见的中缀算术表达式为：\n>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n> = ((10 * (6 / (12 * -11))) + 17) + 5\n> = ((10 * (6 / -132)) + 17) + 5\n> = ((10 * 0) + 17) + 5\n> = (0 + 17) + 5\n> = 17 + 5\n> = 22\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= tokens.length <= 104`\n> - `tokens[i]` 是一个算符（`\"+\"`、`\"-\"`、`\"*\"` 或 `\"/\"`），或是在范围 `[-200, 200]` 内的一个整数\n>\n> \n>\n> **逆波兰表达式：**\n>\n> 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n>\n> - 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。\n> - 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。\n>\n> 逆波兰表达式主要有以下两个优点：\n>\n> - 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。\n> - 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer>stack=new Stack<>();\n        for (String str:\n             tokens) {\n            switch (str.charAt(0)){\n                case '+':{\n                    int num1=stack.pop();\n                    int num2=stack.pop();\n                    stack.push(num2+num1);\n                    break;\n                }\n                case '-':{\n                    if(str.length()==1){\n                        int num1=stack.pop();\n                        int num2=stack.pop();\n                        stack.push(num2-num1);\n                    }else{\n                        stack.push(convert2(str));\n                    }\n                    break;\n                }\n                case '*' :{\n                    int num1=stack.pop();\n                    int num2=stack.pop();\n                    stack.push(num2*num1);\n                    break;\n                }\n                case '/' :{\n                    int num1=stack.pop();\n                    int num2=stack.pop();\n                    stack.push(num2/num1);\n                    break;\n                }\n                default:{\n                    stack.push(convert2(str));\n                }\n            }\n        }\n        return stack.pop();\n    }\n    int convert2(String s){\n        if(s.charAt(0)=='-') {\n            return -convert1(s.substring(1));\n        }else{\n            return convert1(s);\n        }\n    }\n    int convert1(String s){\n        int sum=0,len=s.length();\n        int k=1;\n        for (int i = len-1; i >=0 ; i--) {\n            sum+=(s.charAt(i)-'0')*k;\n            k*=10;\n        }\n        return sum;\n    }\n}\n```\n\n### <span id=\"head17\"> 🔴224.基本计算器</span>\n\n> 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。\n>\n> 注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"1 + 1\"\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \" 2-1 + 2 \"\n> 输出：3\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"(1+(4+5+2)-3)+(6+8)\"\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 3 * 105`\n> - `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成\n> - `s` 表示一个有效的表达式\n> - '+' 不能用作一元运算(例如， \"+1\" 和 `\"+(2 + 3)\"` 无效)\n> - '-' 可以用作一元运算(即 \"-1\" 和 `\"-(2 + 3)\"` 是有效的)\n> - 输入中不存在两个连续的操作符\n> - 每个数字和运行的计算将适合于一个有符号的 32位 整数\n>\n> Related Topics\n>\n> 栈\n>\n> 递归\n>\n> 数学\n>\n> 字符串\n\n```java\n```\n\n### <span id=\"head18\">🟡155.最小栈</span>\n\n> 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n>\n> 实现 `MinStack` 类:\n>\n> - `MinStack()` 初始化堆栈对象。\n> - `void push(int val)` 将元素val推入堆栈。\n> - `void pop()` 删除堆栈顶部的元素。\n> - `int top()` 获取堆栈顶部的元素。\n> - `int getMin()` 获取堆栈中的最小元素。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入：\n> [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n> [[],[-2],[0],[-3],[],[],[],[]]\n> \n> 输出：\n> [null,null,null,null,-3,null,0,-2]\n> \n> 解释：\n> MinStack minStack = new MinStack();\n> minStack.push(-2);\n> minStack.push(0);\n> minStack.push(-3);\n> minStack.getMin();   --> 返回 -3.\n> minStack.pop();\n> minStack.top();      --> 返回 0.\n> minStack.getMin();   --> 返回 -2.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `-231 <= val <= 231 - 1`\n> - `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用\n> - `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n\n```java\nclass MinStack {\n    LinkedList<Integer>list;\n    int min;\n    public MinStack() {\n        this.list=new LinkedList<>();\n        this.min=Integer.MAX_VALUE;\n    }    \n    public void push(int val) {\n        this.list.add(val);\n        this.min=Math.min(this.min,val);\n    }    \n    public void pop() {\n        int temp=list.getLast();\n        this.list.removeLast();\n        if(temp==this.min){\n            this.min=Integer.MAX_VALUE;\n            for (int i = 0; i < this.list.size(); i++) {\n                this.min=Math.min(this.min,this.list.get(i));\n            }\n        }\n    }    \n    public int top() {\n        return this.list.getLast();\n    }\n    public int getMin() {\n        return this.min;\n    }\n}\n```\n\n\n\n### <span id=\"head19\"> 🟡394.字符串解码</span>\n\n> 给定一个经过编码的字符串，返回它解码后的字符串。\n>\n> 编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n>\n> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n>\n> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"3[a]2[bc]\"\n> 输出：\"aaabcbc\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"3[a2[c]]\"\n> 输出：\"accaccacc\"\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"2[abc]3[cd]ef\"\n> 输出：\"abcabccdcdcdef\"\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：s = \"abc3[cd]xyz\"\n> 输出：\"abccdcdcdxyz\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 30`\n> - `s` 由小写英文字母、数字和方括号 `'[]'` 组成\n> - `s` 保证是一个 **有效** 的输入。\n> - `s` 中所有整数的取值范围为 `[1, 300]`\n>\n> Related Topics\n>\n> 栈\n>\n> 递归\n>\n> 字符串\n\n```java\nclass Solution {\n    public String decodeString(String s){\n        Stack<Character>stack=new Stack<>();\n        for(char ch: s.toCharArray()){\n            if(ch!=']'){\n                stack.push(ch);\n            }else{\n                StringBuilder str=new StringBuilder();\n                while(!stack.isEmpty()&&stack.peek()!='['){\n                    str.append(stack.pop());\n                }\n                stack.pop();//排出[\n                StringBuilder num=new StringBuilder();\n                while(!stack.isEmpty()&&stack.peek()>='0'&&stack.peek()<='9'){\n                    num.append(stack.pop());\n                }\n                String build=builder(Integer.valueOf(num.reverse().toString()),str.reverse().toString());\n                for (int i = 0; i < build.length(); i++) {\n                    stack.push(build.charAt(i));\n                }\n            }\n        }\n        StringBuilder res=new StringBuilder();\n        while(!stack.isEmpty()){\n            res.append(stack.pop());\n        }\n        return res.reverse().toString();\n\n    }\n\n    String builder(int num,String str) {\n        StringBuilder sb=new StringBuilder();\n        for (int i = 0; i < num; i++) {\n            sb.append(str);\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n## <span id=\"head20\"> 作业</span>\n\n### <span id=\"head21\"> 🟡71.简化路径</span>\n\n> 给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。\n>\n> 在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。\n>\n> 请注意，返回的 **规范路径** 必须遵循下述格式：\n>\n> - 始终以斜杠 `'/'` 开头。\n> - 两个目录名之间必须只有一个斜杠 `'/'` 。\n> - 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。\n> - 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。\n>\n> 返回简化后得到的 **规范路径** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：path = \"/home/\"\n> 输出：\"/home\"\n> 解释：注意，最后一个目录名后面没有斜杠。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：path = \"/../\"\n> 输出：\"/\"\n> 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：path = \"/home//foo/\"\n> 输出：\"/home/foo\"\n> 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：path = \"/a/./b/../../c/\"\n> 输出：\"/c\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= path.length <= 3000`\n> - `path` 由英文字母，数字，`'.'`，`'/'` 或 `'_'` 组成。\n> - `path` 是一个有效的 Unix 风格绝对路径。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\n```\n\n\n\n### <span id=\"head22\"> 🟡946.检证栈序列</span>\n\n> 给定 `pushed` 和 `popped` 两个序列，每个序列中的 **值都不重复**，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 `true`；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n> 输出：true\n> 解释：我们可以按以下顺序执行：\n> push(1), push(2), push(3), push(4), pop() -> 4,\n> push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n> 输出：false\n> 解释：1 不能在 2 之前弹出。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= pushed.length <= 1000`\n> - `0 <= pushed[i] <= 1000`\n> - `pushed` 的所有元素 **互不相同**\n> - `popped.length == pushed.length`\n> - `popped` 是 `pushed` 的一个排列\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 模拟\n\n```java\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        Stack<Integer>stack=new Stack<>();\n        int len=popped.length;\n        int idx=0;\n        for (int i = 0; i < len; i++) {\n            if(stack.isEmpty()){\n                stack.push(pushed[idx++]);\n            }\n            if(stack.peek()!=popped[i]&&stack.contains(popped[i])){\n                return false;\n            }\n           while(stack.peek()!=popped[i]){\n               stack.push(pushed[idx++]);\n           }\n           stack.pop();\n        }\n        return true;\n    }\n}\n```\n\n\n\n### <span id=\"head23\"> 2023Q1A-投篮大赛</span>\n\n> ![image-20240111203435403](23-12-24-algorithm-OD/image-20240111203435403.png)\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        String[] splited= string.split(\" \");\n        Stack<Integer>stack=new Stack<>();\n        for (String str: splited) {\n             switch (str.charAt(0)){\n                 case 'C':{\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     stack.pop();\n                     break;\n                 }\n                 case 'D':{\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     int temp=stack.peek();\n                     stack.push(temp*2);                     \n                     break;\n                 }\n                 case '+':{\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     int num1=stack.pop();\n                     if(stack.isEmpty()){\n                         System.out.println(-1);\n                         return;\n                     }\n                     int num2=stack.peek();\n                     stack.push(num1);\n                     stack.push(num1+num2);\n                     break;\n                 }\n                 default:{\n                     try{\n                         stack.push(Integer.valueOf(str));\n                     }catch (NumberFormatException e){\n                         System.out.println(-1);\n                         return;\n                     }\n\n                 }\n             }\n        }\n        int sum=0;\n        while(!stack.isEmpty()){\n            sum+=stack.pop();\n        }\n        System.out.println(sum);\n    }\n}\n```\n\n\n\n### <span id=\"head24\"> 2023Q1A-解压缩算法</span>\n\n> ![image-20240111211130956](23-12-24-algorithm-OD/image-20240111211130956.png)\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        StringBuilder res=new StringBuilder();\n\n        String[]strings=string.split(\"[0-9]+\");\n        String[]nums=string.split(\"[a-z]+\");\n\n        List<String>str_list=new ArrayList<>();\n        for (int i = 0; i < strings.length; i++) {\n            if(strings[i]!=\"\"){\n                str_list.add(strings[i]);\n                //筛选@\n                for (int j = 0; j < strings[i].length(); j++) {\n                    if(strings[i].charAt(j)>'z'||strings[i].charAt(j)<'a'){\n                        System.out.println(\"!error\");\n                        return;\n                    }\n                }\n            }\n        }\n        //筛选uuuu\n        int cnt=0;\n        char last_ch=str_list.get(0).charAt(0);\n        for (int i = 0; i < str_list.size(); i++) {\n            for (int j = 0; j < str_list.get(i).length(); j++) {\n                if(i==0&&j==0){\n                    continue;\n                }\n                if(str_list.get(i).charAt(j)==last_ch){\n                    cnt++;\n                }else{\n                    cnt=0;\n                }\n                if(cnt>3){\n                    System.out.println(\"!error\");\n                    return;\n                }\n            }\n        }\n\n        List<Integer>num_list=new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(!Objects.equals(nums[i], \"\")){\n                num_list.add(Integer.valueOf(nums[i]));\n            }\n        }\n        //筛选1h 2h\n        for (int i = 0; i < num_list.size(); i++) {\n            if(num_list.get(i)<3){\n                System.out.println(\"!error\");\n                return;\n            }\n        }\n        int idx=0;\n        if(string.charAt(0)>='a'&&string.charAt(0)<='z'){//字母开头\n            res.append(str_list.get(idx++));\n        }\n        for (int i = 0; i < num_list.size(); i++) {\n            for (int j = 0; j < num_list.get(i); j++) {\n                res.append(str_list.get(idx).charAt(0));\n            }\n            if(str_list.get(idx).length()>1){\n                for (int j = 1; j < str_list.get(idx).length(); j++) {\n                    res.append(str_list.get(idx).charAt(j));\n                }\n            }\n            idx++;\n        }\n        System.out.println(res);\n    }\n}\n```\n\n贴一个短的学习一下：\n\n```java\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        String pat = \"[^0-9a-z]\";//\n        String num = \"\";\n        String res = \"\";\n        Pattern pattern = Pattern.compile(pat);\n        Matcher matcher = pattern.matcher(s);\n        if (matcher.find()) {\n            res = \"!error\";\n        } else {\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (Character.isDigit(c)) {\n                    num += c;\n                } else if (!num.equals(\"\")) {\n                    if (Integer.parseInt(num) <= 2) {\n                        res = \"!error\";\n                        break;\n                    } else {\n                        for (int j = 0; j < Integer.parseInt(num); j++) {\n                            res += c;\n                        }\n                        num = \"\";\n                    }\n                } else {\n                    res += c;\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\n```\n\n\n\n# <span id=\"head25\"> 第三天</span>\n\n## <span id=\"head26\"> 哈希集合</span>\n\n### <span id=\"head27\"> 🟢217.存在重复元素</span>\n\n> 给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,4]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,1,1,3,3,4,3,2,4,2]\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(set.contains(nums[i])){\n                return true;\n            }else{\n                set.add(nums[i]);\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n### <span id=\"head28\"> 🟢349.两个数字的交集</span>\n\n> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[9,4]\n> 解释：[4,9] 也是可通过的\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        int[] hashtable=new int[1001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable[nums1[i]]=1;\n        }\n        Set<Integer>set=new HashSet<>();\n        for (int i = 0; i < nums2.length; i++) {\n            if(hashtable[nums2[i]]==1) {\n                set.add(nums2[i]);\n            }\n        }\n        System.out.println(set);\n        int[]res=new int[set.size()];\n        int idx=0;\n        Iterator<Integer> it=set.iterator();\n        while(it.hasNext()){\n            res[idx++]=it.next();\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head29\"> 哈希表-用于统计频率</span>\n\n### <span id=\"head30\"> 🟢242.有效的字母异位词</span>\n\n> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。\n>\n> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"anagram\", t = \"nagaram\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"rat\", t = \"car\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, t.length <= 5 * 104`\n> - `s` 和 `t` 仅包含小写字母\n>\n> \n>\n> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int[]hashtable=new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < t.length(); i++) {\n            hashtable[t.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtable[i]!=0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n### <span id=\"head31\"> 🟢383.赎金信</span>\n\n> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n>\n> 如果可以，返回 `true` ；否则返回 `false` 。\n>\n> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ransomNote = \"a\", magazine = \"b\"\n> 输出：false\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"ab\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"aab\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= ransomNote.length, magazine.length <= 105`\n> - `ransomNote` 和 `magazine` 由小写英文字母组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[]hashtaable=new int[26];\n        for (int i = 0; i < magazine.length(); i++) {\n            hashtaable[magazine.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < ransomNote.length(); i++) {\n            hashtaable[ransomNote.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtaable[i]<0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head32\"> 2023Q1A-集五福</span>\n\n> **题目描述**\n> 集五福作为近年来大家喜闻乐见迎新春活动，集合爱国福、富强福、和谐福、友善福、敬业福即可分享超大红包。以 0 和 1 组成的长度为 5 的字符串代表每个人所得到的福卡，每一位代表一种福卡，1 表示已经获得该福卡，单类型福卡不超过 1 张，随机抽取一个小于 10 人团队，求该团队最多可以集齐多少套五福？\n>\n> **输入描述**\n> 输入若干个由0、1组成的长度等于5的字符串，代表团队中每个人福卡获得情况 \n>\n> 注意1：1人也可以是一个团队 \n>\n> 注意2：1人可以有0到5张福卡，但福卡不能重复\n>\n> **输出描述**\n> 输出该团队最多能凑齐多少套五福\n>\n> **示例一**\n> **输入**\n>\n> ```\n> 11001,11101\n> ```\n>\n> **输出**\n>\n> ```\n> 0\n> ```\n>\n> **示例二**\n> **输入**\n>\n> ```\n> 11101,10111\n> ```\n>\n> **输出**\n>\n> ```\n> 1\n> ```\n\n### <span id=\"head33\"> 2023Q1A-删除最少字符</span>\n\n> **题目描述**\n> 删除字符串中出现次数最少的字符，如果多个字符出现次数一样则都删除\n>\n> **输入描述**\n> 输入只包含小写字母\n>\n> **输出描述**\n> 输出删除后剩余的字符，若删除后字符串长度为0，则输出empty\n>\n> **示例一**\n> **输入**\n>\n> ```\n> abcdd\n> ```\n>\n> **输出**\n>\n> ```\n> dd\n> ```\n>\n> **示例二**\n> **输入**\n>\n> ```\n> aabbccdd\n> ```\n>\n> **输出**\n>\n> ```\n> empty\n> ```\n\n## <span id=\"head34\"> 作业</span>\n\n### <span id=\"head35\"> 🟢387.字符串中的第一个唯一字符</span>\n\n> 给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"leetcode\"\n> 输出: 0\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"loveleetcode\"\n> 输出: 2\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"aabb\"\n> 输出: -1\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length <= 105`\n> - `s` 只包含小写字母\n>\n> Related Topics\n>\n> 队列\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character,Integer>map=new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0)+1);\n        }\n        int res=-1;\n        for (int i = 0; i < s.length(); i++) {\n            if(map.get(s.charAt(i))==1){\n                res=i;\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head36\"> 🟢350.两个数组的交集Ⅱ</span>\n\n> 给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2,2]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[4,9]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> \n>\n> ***\\*进阶\\**：**\n>\n> - 如果给定的数组已经排好序呢？你将如何优化你的算法？\n> - 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？\n> - 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        HashMap<Integer,Integer>map1=new HashMap<>();\n        HashMap<Integer,Integer>map2=new HashMap<>();\n        for (int i = 0; i < nums1.length; i++) {\n            map1.put(nums1[i],map1.getOrDefault(nums1[i],0)+1);\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(map1.containsKey(nums2[i])){\n                map2.put(nums2[i],map2.getOrDefault(nums2[i],0)+1);\n            }\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(map1.containsKey(nums2[i])){\n                int temp=Math.min(map1.get(nums2[i]),map2.get(nums2[i]));\n                map2.put(nums2[i],temp);\n            }\n        }\n        int len=0;\n        for (int num:\n             map2.values()) {\n            len+=num;\n        }\n        int[]res=new int[len];\n        int index=0;\n        for (Map.Entry<Integer,Integer> entry:\n             map2.entrySet()) {\n            for (int i = 0; i < entry.getValue(); i++) {\n                res[index++]=entry.getKey();\n            }\n        }\n        return res;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n不如4个月之前写的：\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        int[]hashtable1=new int[1001];\n        int[]hashtable2=new int[1001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable1[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            hashtable2[nums2[i]]++;\n        }\n        ArrayList<Integer> al=new ArrayList<>();\n        for (int i = 0; i < 1001; i++) {\n            if(hashtable1[i]>hashtable2[i]){\n                hashtable1[i]=hashtable2[i];\n            }\n            for (int j = 0; j < hashtable1[i]; j++) {\n                al.add(i);\n            }\n        }\n        int[]res=new int[al.size()];\n        for (int i = 0; i < al.size(); i++) {\n            res[i]=al.get(i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head37\"> 2023Q1A-寻找关键钥匙</span>\n\n> #### 题目描述\n>\n> ​\t\t小强正在参加《密室逃生》游戏，当前关卡要求找到符合给定密码 `K`（升序的不重复小写字母组成）的箱子，并给出箱子编号，箱子编号为 `1~N`。 \n>\n> ​\t\t每个箱子中都有一个字符串 `s`，字符串由大写字母，小写字母，数字，标点符号，空格组成，需要在这些字符串中找出所有的字母，忽略大小写且去重后排列出对应的密码串，并返回匹配密码的箱子序号。 \n>\n> ​\t\t注意：满足条件的箱子不超过 `1` 个。\n>\n> #### 输入\n>\n> ​        第一行为表示密码 K 的字符串 \n>\n> ​        第二行为一系列箱子 boxes，为字符串数组样式，以空格分隔 \n>\n> ​        箱子 N 数量满足 1<=N<=10000，代表每一个箱子的字符串 s 的长度满足 0 <= s.length <= 50，密码为仅包含小写字母的升序字符串，且不存在重复字母，密码 K 长度满足1 <= K.length <= 26\n>\n> #### 输出\n>\n> ​\t\t返回对应箱子编号，如不存在符合要求的密码箱，则返回`-1`\n>\n> #### 样例输入 复制\n>\n> ```plain\n> abc\n> s,sdf134 A2c4b\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 2\n> ```\n\n```java\nimport java.util.*;\n\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String key=in.nextLine();\n        String strings=in.nextLine();\n        int res=-1;\n        String[]splited=strings.split(\" \");\n        for (int i = 0; i < splited.length; i++) {\n            if(builder(splited[i]).equals(key)){\n                res=i+1;\n            }\n        }\n        System.out.println(res);\n    }\n    static String builder(String str) {\n        StringBuilder sb=new StringBuilder();\n        ArrayList<Character>list=new ArrayList<>();\n        for (int i = 0; i < str.length(); i++) {\n            char ch=str.charAt(i);\n            if(ch>='a'&&ch<='z'){\n                list.add(ch);\n            }\n            if(ch>='A'&&ch<='Z'){\n                list.add((char)(ch+'a'-'A'));\n            }\n        }\n        Collections.sort(list);\n        for (char ch:\n             list) {\n            sb.append(ch);\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n\n\n### <span id=\"head38\"> 2023Q1A-明明的随机数</span>\n\n> #### 题目描述\n>\n> ​\t\t明明生成了`N` 个 `1` 至 `500` 之间的随机整数。请你**删去其中重复的数字**，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数**从小到大排序**，按照排好的顺序输出。 \n>\n> ​\t\t数据范围： `1 ≤ N ≤ 1000` ，输入的数字大小 `val` 满足 `1 ≤ val ≤ 500`  \n>\n> \n>\n> #### 输入\n>\n> ​\t\t第一行先输入随机整数的个数 `N` 。 接下来的 `N` 行每行输入一个整数，代表明明生成的随机数。 \n>\n> \n>\n> #### 输出\n>\n> ​        输出多行，表示输入数据处理后的结果。\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 3\n> 2\n> 2\n> 1\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 1\n> 2\n> ```\n\n```java\nimport java.util.*;\n\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        Set<Integer>set=new TreeSet<>();\n        for (int i = 0; i < n; i++) {\n            set.add(in.nextInt());\n        }\n        for (Integer integer : set) {\n            System.out.println(integer);\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head39\"> 2023Q1A-统计匹配的二元组个数</span>\n\n> #### 题目描述\n>\n> ​\t\t给定两个数组 `A` 和 `B`，若数组 `A` 的某个元素 `A[i]` 与数组 `B` 中的某个元素 `B[j]` 满足 `A[i]==B[j]`，则寻找到一个匹配的二元组`(i,j)` ，请统计再这两个数组 `A` 和 `B` 中，一共存在多少个这样的二元组。 \n>\n> \n>\n> #### 输入\n>\n> 第一行输入数组 A 的长度 M ； \n>\n> 第一行输入数组 B 的长度 N ；\n>\n>  第三行输入数组 A 的值； \n>\n> 第四行输入数组 B 的值。 1 ≤ M, N ≤ 100000 A，B 数组中数值的取值均小于 100000\n>\n> #### 输出\n>\n> 输出匹配的二元组个数\n>\n> ## 示例一\n>\n> ### 输入\n>\n> ```plaintext\n> 5\n> 4\n> 1 2 3 4 5\n> 4 3 2 1\n> ```\n>\n> Copy\n>\n> ### 输出\n>\n> ```plaintext\n> 4\n> ```\n>\n> Copy\n>\n> ### 说明\n>\n> 若下标从 00 开始，则匹配的二元组分别为`(0,3), (1,2), (2,1), (3,0)`，共计 44 个\n>\n> ## 示例二\n>\n> ### 输入\n>\n> ```plaintext\n> 6\n> 3\n> 1 2 4 4 2 1\n> 1 2 3\n> ```\n>\n> Copy\n>\n> ### 输出\n>\n> ```plaintext\n> 4\n> ```\n>\n> Copy\n>\n> ### 说明\n>\n> 若下标从 00 开始，则匹配的二元组分别为`(0,0), (1,1), (4,1), (5,0)`，共计 44 个\n>\n> ## 备注\n\n```java\nimport java.util.*;\n\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt(),m=in.nextInt();\n        int[]hashtable=new int[1000001];\n        for (int i = 0; i < n; i++) {\n            hashtable[in.nextInt()]++;\n        }\n        int cnt=0;\n        for (int i = 0; i < m; i++) {\n            int num=in.nextInt();\n            if(hashtable[num]>0){\n                cnt+=hashtable[num];\n            }\n        }\n        System.out.println(cnt);\n    }\n}\n```\n\n\n\n# <span id=\"head40\"> 第四天</span>\n\n## <span id=\"head41\"> 哈希表-用于下表查询</span>\n\n### <span id=\"head42\"> 🟢1.两数之和</span>\n\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n>\n> 你可以按任意顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,4], target = 6\n> 输出：[1,2]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,3], target = 6\n> 输出：[0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= nums.length <= 104`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n> - **只会存在一个有效答案**\n>\n> \n>\n> **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> hashmap=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            hashmap.put(nums[i],i);\n        }\n        int[]res=new int[2];\n        for (int i = 0; i < nums.length; i++) {\n            if(hashmap.containsKey(target-nums[i])&&i!=hashmap.get(target-nums[i])){\n                res[0]=i;\n                res[1]=hashmap.get(target-nums[i]);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head43\"> 🟢219.存在重复元素Ⅱ</span>\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3,1], k = 3\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,0,1,1], k = 1\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,3,1,2,3], k = 2\n> 输出：false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-109 <= nums[i] <= 109`\n> - `0 <= k <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(map.containsKey(nums[i])&&Math.abs(i-map.get(nums[i]))<=k){\n                return true;\n            }else{\n                map.put(nums[i],i);\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n## <span id=\"head44\"> 哈希表-用于元素配对</span>\n\n### <span id=\"head45\"> 🟢205.同构字符串</span>\n\n> 给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。\n>\n> 如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。\n>\n> 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入：s = \"egg\", t = \"add\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"foo\", t = \"bar\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"paper\", t = \"title\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - `1 <= s.length <= 5 * 104`\n> - `t.length == s.length`\n> - `s` 和 `t` 由任意有效的 ASCII 字符组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        Map<Character,Character> map=new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(map.containsKey(s.charAt(i))){\n                if(map.get(s.charAt(i))!=t.charAt(i)){\n                    return false;\n                }\n            }else {\n                if (!map.containsValue(t.charAt(i))) {\n                    map.put(s.charAt(i), t.charAt(i));\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head46\">🟡49.字母异位词分组</span>\n\n> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n>\n> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n> 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: strs = [\"\"]\n> 输出: [[\"\"]]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: strs = [\"a\"]\n> 输出: [[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 104`\n> - `0 <= strs[i].length <= 100`\n> - `strs[i]` 仅包含小写字母\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>>res=new ArrayList<>();\n        Map<String,Integer>map=new HashMap<>();\n        int index=0;\n        for (int i = 0; i < strs.length; i++) {\n            String key=sort(strs[i]);\n            if(!map.containsKey(key)){\n                map.put(key,index);\n                List<String>list=new ArrayList<>();\n                list.add(strs[i]);\n                res.add(index++,list);\n            }else{\n                int pos=map.get(key);\n                res.get(pos).add(strs[i]);\n            }\n        }\n        return res;\n    }\n    String sort(String str){\n        char[]chars=str.toCharArray();\n        Arrays.sort(chars);\n        return String.copyValueOf(chars);\n    }\n}\n```\n\n## <span id=\"head47\"> 作业</span>\n\n### <span id=\"head48\"> 🟢290.单词规律</span>\n\n> 给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。\n>\n> 这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。\n>\n> \n>\n> **示例1:**\n>\n> ```\n> 输入: pattern = \"abba\", s = \"dog cat cat dog\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入:pattern = \"abba\", s = \"dog cat cat fish\"\n> 输出: false\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: pattern = \"aaaa\", s = \"dog cat cat dog\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= pattern.length <= 300`\n> - `pattern` 只包含小写英文字母\n> - `1 <= s.length <= 3000`\n> - `s` 只包含小写英文字母和 `' '`\n> - `s` **不包含** 任何前导或尾随对空格\n> - `s` 中每个单词都被 **单个空格** 分隔\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String s) {\n        String[]splited=s.split(\" \");\n        if(splited.length!=pattern.length()){\n            return false;\n        }\n        Map<Character,String> map=new HashMap<>();\n        for (int i = 0; i < pattern.length(); i++) {\n            if(map.containsKey(pattern.charAt(i))){\n                if(!map.get(pattern.charAt(i)).equals(splited[i])){\n                    return false;\n                }\n            }else{\n                if(!map.containsValue(splited[i])){\n                    map.put(pattern.charAt(i),splited[i]);\n                }else{\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n### <span id=\"head49\"> 2023Q1A-字符串重新排序</span>\n\n> #### 题目描述\n>\n> 给定一个字符串 s，s 包含以空格分隔的若干个单词，请对 s 进行如下处理后输出：\n> \\1. 单词内部调整：对每个单词字母重新按字典序排序；\n> \\2. 单词间顺序调整：\n>   a. 统计每个单词出现的次数，并按次数降序排列；\n>   b. 次数相同时，按单词长度升序排列；\n>   c. 次数和单词长度均相同时，按字典序升序排列。\n> 请输出处理后的字符串，每个单词以一个空格分隔。\n>\n> #### 输入\n>\n> 一行字符串，每个字符取值范围为[a-z, A-Z, 0-9] 以及空格\" \"\n>\n> 字符串长度范围：[1, 1000]\n>\n> #### 输出\n>\n> 重新排序后的字符串，每个单词间隔 1 个空格，且首尾无空格\n>\n> #### 样例输入 复制\n>\n> ```plain\n> This is an apple\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> an is This aelpp\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String string=in.nextLine();\n        String[]splited=string.split(\" \");\n        Map<String,Integer>map=new HashMap<>();\n        for (int i = 0; i < splited.length; i++) {\n            char[]chars=splited[i].toCharArray();\n            Arrays.sort(chars);\n            String key=String.copyValueOf(chars);\n            map.put(key,map.getOrDefault(key,0)+1);\n        }\n        Comparator<Map.Entry>comp=new Comparator<Map.Entry>() {\n            @Override\n            public int compare(Map.Entry o1, Map.Entry o2) {\n                if((int)o1.getValue()!=(int)o2.getValue()){\n                    return (int)o2.getValue()-(int)o1.getValue();\n                } else if (o1.getKey().toString().length()!=o2.getKey().toString().length()) {\n                    return o1.getKey().toString().length()-o2.getKey().toString().length();\n                }else {\n                    return o1.getKey().toString().compareTo(o2.getKey().toString());\n                }\n            }\n        };\n        List<Map.Entry<?, ?>> entries = new ArrayList<>(map.entrySet());\n        Collections.sort(entries, comp);\n        for (int i = 0; i < entries.size(); i++) {\n            for (int j = 0; j < (int)entries.get(i).getValue(); j++) {\n                System.out.print(entries.get(i).getKey()+\" \");\n            }\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head50\">2023Q2B-选修课</span>\n\n> #### 题目描述\n>\n> 现有两门选修课，每门选修课都有一部分学生选修，每个学生都有选修课的成绩，需要你找出同时选修了两门选修课的学生，先按照班级进行划分，班级编号小的先输出，每个班级按照两门选修课成绩和的降序排序，成绩相同时按照学生的学号升序排序。\n>\n> #### 输入\n>\n> ​\t\t第一行为第一门选修课学生的成绩，第二行为第二门选修课学生的成绩，每行数据中学生之间以英文分号分隔，每个学生的学号和成绩以英文逗号分隔，学生学号的格式为 `8` 位数字(`2` 位院系编号+入学年份后 `2` 位+院系内部 `1` 位专业编号+所在班级 `3` 位学号)，学生成绩的取值范围为 `[0,100]` 之间的整数，两门选修课选修学生数的取值范围为 `[1-2000]` 之间的整数。 \n>\n> \n>\n> #### 输出\n>\n> 同时选修了两门选修课的学生的学号，如果没有同时选修两门选修课的学生输出 NULL，否则，先按照班级划分，班级编号小的先输出，每个班级先输出班级编号(学号前五位)，然后另起一行输出这个班级同时选修两门选修课的学生学号，学号按照要求排序(按照两门选修课成绩和的降序，成绩和相同时按照学号升序)，学生之间以英文分号分隔。\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 01202021,75;01201033,95;01202008,80;01203006,90;01203088,100\n> 01202008,70;01203088,85;01202111,80;01202021,75;01201100,88\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 01202\n> 01202008;01202021\n> 01203\n> 01203088\n> ```\n\n### <span id=\"head51\"> 2023Q1A-相同数字的积木游戏</span>\n\n> #### 题目描述\n>\n> ​\t\t小华和小薇一起通过玩积木游戏学习数学。他们有很多积木，每个积木块上都有一个数字，积木块上的数字可能相同。小华随机拿一些积木挨着排成一排，请小薇找到这排积木中数字相同且所处位置最远的 `2` 块积木块，计算他们的距离。小薇请你帮忙替她解决这个问题。 \n>\n> \n>\n> #### 输入\n>\n> ​\t\t第一行输入为 `N` ，表示小华排成一排的积木总数。 接下来 `N` 行每行一个数字，表示小花排成一排的积木上数字。 \n>\n> \n>\n> #### 输出\n>\n> ​        相同数字的积木的位置最远距离；如果所有积木数字都不相同，请返回 -1\n>\n> #### 样例输入 复制\n>\n> ```plain\n> 5\n> 1\n> 2\n> 3\n> 1\n> 4\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> 3\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n= in.nextInt();\n        int max=-1;\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int key=in.nextInt();\n            if(map.containsKey(key)){\n                if(i-map.get(key)>max){\n                    max=i-map.get(key);\n                }\n            }else{\n                map.put(key,i);\n            }\n        }\n        System.out.println(max);\n    }\n}\n\n```\n\n\n\n### <span id=\"head52\"> 2023Q1A-英文输入法</span>\n\n> #### 题目描述\n>\n> 主管期望你来实现英文输入法单词联想功能，需求如下： \n>\n> \\1. 依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词。 \n>\n> \\2. 按字典序输出联想到的单词序列，如果联想不到，请输出用户输入的单词前缀。 \n>\n> \n>\n> 注意：\n>\n> \\1. 英文单词联想时区分大小写 \n>\n> \\2. 缩略形式如\"don’t\" 判定为两个单词 \"don\"和 “t” \n>\n> \\3. 输出的单词序列不能有重复单词，且只能是英文单词，不能有标点符号\n>\n> #### 输入\n>\n> 输入两行。 \n>\n> 首行输入一段由英文单词word和标点构成的语句str，接下来一行为一个英文单词前缀pre。 \n>\n> 0 < word.length() <= 20\n>\n> 0 < str.length() <= 10000，0 < pre.length() <= 20\n>\n> #### 输出\n>\n> 输出符合要求的单词序列或单词前缀。存在多个时，单词之间以单个空格分割\n>\n> #### 样例输入 复制\n>\n> ```plain\n> I love you\n> He\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> He\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String string= in.nextLine();\n        String put=in.nextLine();\n        String[]splited=string.split(\"[^A-Za-z]\");\n        List<String>res=new ArrayList<>();\n        for (int i = 0; i < splited.length; i++) {\n            if(splited[i].startsWith(put)){\n                res.add(splited[i]);\n            }\n        }\n        Collections.sort(res);\n        if(res.isEmpty()){\n            System.out.println(put);\n        }else{\n            for (int i = 0; i < res.size(); i++) {\n                System.out.print(res.get(i)+\" \");\n            }\n        }\n    }\n}\n\n```\n\n\n\n### <span id=\"head53\"> 2023Q1A-寻找密码</span>\n\n> #### 题目描述\n>\n> ​        小王在进行游戏大闯关，有一个关卡需要输入一个密码才能通过，密码获得的条件如下：在一个密码本中，每一页都有一个由 26 个小写字母组成的若干位密码，从它的末尾开始依次去掉一位得到的新密码也在密码本中存在。请输出符合要求的密码，如果由多个符合要求的密码，则返回字典序最大的密码。若没有符合要求的密码，则返回空字符串。\n>\n> #### 输入\n>\n> ​\t\t密码本由一个字符串数组组成，不同元素之间使用空格隔开，每一个元素代表密码本每一页的密码。 \n>\n> #### 输出\n>\n> ​        一 个字符串\n>\n> \n>\n> #### 样例输入 复制\n>\n> ```plain\n> h he hel hell hello\n> ```\n>\n> #### 样例输出 复制\n>\n> ```plain\n> hello\n> ```\n\n```java\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        String string= in.nextLine();\n        String[]splited=string.split(\" \");\n        Set<String> set = new HashSet<>(Arrays.asList(splited));\n        Comparator<String>comparator=new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                if(o1.length()!=o2.length()){\n                    return o1.length()-o2.length();\n                }else{\n                    return o1.compareTo(o2);\n                }\n            }\n        };\n        Arrays.sort(splited,comparator);\n        List<String>res=new ArrayList<>();\n        for (int i = splited.length-1;i >= 0; i--) {\n            int flag=1;\n            for (int j = 0; j < splited[i].length()-1; j++) {\n                if(!set.contains(splited[i].substring(0,j+1))){\n                    flag=0;\n                    break;\n                }\n            }\n            if(flag==1){\n                res.add(splited[i]);\n            }\n        }\n        if(res.isEmpty()){\n            System.out.println();\n        }else{\n            System.out.println(res.get(0));\n        }\n    }\n}\n```\n\n# <span id=\"head54\"> 第五天</span>\n\n## <span id=\"head55\"> 单调栈</span>\n\n### <span id=\"head56\"> 🟢1475.商品折扣后的最终价格</span>\n\n> 给你一个数组 `prices` ，其中 `prices[i]` 是商店里第 `i` 件商品的价格。\n>\n> 商店里正在进行促销活动，如果你要买第 `i` 件商品，那么你可以得到与 `prices[j]` 相等的折扣，其中 `j` 是满足 `j > i` 且 `prices[j] <= prices[i]` 的 **最小下标** ，如果没有满足条件的 `j` ，你将没有任何折扣。\n>\n> 请你返回一个数组，数组中第 `i` 个元素是折扣后你购买商品 `i` 最终需要支付的价格。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [8,4,6,2,3]\n> 输出：[4,2,4,2,3]\n> 解释：\n> 商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n> 商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n> 商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n> 商品 3 和 4 都没有折扣。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,2,3,4,5]\n> 输出：[1,2,3,4,5]\n> 解释：在这个例子中，所有商品都没有折扣。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：prices = [10,1,1,6]\n> 输出：[9,0,1,6]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 500`\n> - `1 <= prices[i] <= 10^3`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] finalPrices(int[] prices) {\n        int len= prices.length;\n        Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isEmpty()&&prices[stack.peek()]>=prices[i]){\n                System.out.println(prices[i]+\"  \"+prices[stack.peek()]);\n                prices[stack.peek()]-=prices[i];\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return prices;\n    }\n}\n```\n\n### <span id=\"head57\"> 🟡739.每日温度</span>\n\n> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: temperatures = [73,74,75,71,69,72,76,73]\n> 输出: [1,1,4,2,1,1,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: temperatures = [30,40,50,60]\n> 输出: [1,1,1,0]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: temperatures = [30,60,90]\n> 输出: [1,1,0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= temperatures.length <= 105`\n> - `30 <= temperatures[i] <= 100`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n       int len= temperatures.length;\n       int[]res=new int[len];\n       Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isEmpty()&&temperatures[stack.peek()]<temperatures[i]){\n                res[stack.peek()]=i-stack.peek();\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return res;\n    }\n}\n```\n\n### <span id=\"head58\">🔴42.接雨水</span>\n\n## <span id=\"head59\"> 栈与队列综合</span>\n\n### <span id=\"head60\"> 🟢232.用栈实现队列</span>\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n>\n> 实现 `MyQueue` 类：\n>\n> - `void push(int x)` 将元素 x 推到队列的末尾\n> - `int pop()` 从队列的开头移除并返回元素\n> - `int peek()` 返回队列开头的元素\n> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n>\n> **说明：**\n>\n> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> \n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\n>\n> \n>\n> **进阶：**\n>\n> - 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyQueue {\n    Stack<Integer>s1=new Stack<>();\n    Stack<Integer>s2=new Stack<>();    \n    public void push(int x) {\n        s2Tos1();\n        s1.push(x);\n        s1Tos2();\n    }    \n    public int pop() {\n        return s2.pop();\n    }    \n    public int peek() {\n        return s2.peek();\n    }    \n    public boolean empty() {\n        return s2.empty();\n    }\n    void s1Tos2(){\n        while(!s1.isEmpty()){\n            s2.push(s1.pop());\n        }\n    }\n    void s2Tos1(){\n        while(!s2.isEmpty()){\n            s1.push(s2.pop());\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head61\"> 作业</span>\n\n### <span id=\"head62\"> 🟢225.用队列实现栈</span>\n\n> \n\n### <span id=\"head63\"> 🟢496.下一个更大的元素Ⅰ</span>\n\n### <span id=\"head64\"> 2023Q1A-找朋友</span>\n\n### <span id=\"head65\"> 2023Q1A-删除重复数字后的最大数字</span>\n\n### <span id=\"head66\"> 2023Q1B-找最小数</span>\n\n# <span id=\"head67\"> 第六天</span>\n\n## <span id=\"head68\"> 双指针-同向双指针</span>\n\n### <span id=\"head69\"> 🟢88.合并两个有序数组</span>\n\n### <span id=\"head70\"> 🟢26.删除有序数组的重复项</span>\n\n### <span id=\"head71\">🟡80.删除有序数组的重复项Ⅱ</span>\n\n### <span id=\"head72\">🟢485.最大连续1的个数</span>\n\n## <span id=\"head73\"> 作业</span>\n\n### <span id=\"head74\"> 🟢283.移动零</span>\n\n### <span id=\"head75\"> 🟢27.移除数组</span>\n\n### <span id=\"head76\">2023Q1A-最长的元音字符串</span>\n\n# <span id=\"head77\"> 第七天</span>\n\n## <span id=\"head78\"> 相向双指针</span>\n\n### <span id=\"head79\"> 🟢9.回文数</span>\n\n### <span id=\"head80\"> 🟢125.验证回文数</span>\n\n### <span id=\"head81\"> 🟡167.两数之和Ⅱ-输入有序数组</span>\n\n### <span id=\"head82\"> 🟡11.盛水最多的容器</span>\n\n### <span id=\"head83\"> 🟡15.三数之和</span>\n\n### <span id=\"head84\">🟡75.颜色分类</span>\n\n## <span id=\"head85\"> 作业</span>\n\n### <span id=\"head86\"> 🟢680.验证回文串Ⅱ</span>\n\n### <span id=\"head87\"> 2023Q1A-两数之和绝对值最小</span>\n\n### <span id=\"head88\"> 2023Q1A-双十一</span>\n\n# <span id=\"head89\"> 第八天</span>\n\n## <span id=\"head90\"> 贪心</span>\n\n### <span id=\"head91\"> 🟢455.分发饼干</span>\n\n### <span id=\"head92\"> 🟡134.加油站</span>\n\n### <span id=\"head93\"> 🟢860.柠檬水找零</span>\n\n### <span id=\"head94\"> 🟢605.种花问题</span>\n\n### <span id=\"head95\"> 🟡376.摆动序列</span>\n\n### <span id=\"head96\"> 2023Q1A-快递货车</span>\n\n## <span id=\"head97\"> 作业</span>\n\n### <span id=\"head98\"> 2023Q1A-停车找车位</span>\n\n### <span id=\"head99\">2023Q1A-卡片组成的最大数字</span>\n\n# <span id=\"head100\"> 第九天</span>\n\n## <span id=\"head101\"> 贪心</span>\n\n### <span id=\"head102\"> 🟡881.救生艇</span>\n\n### <span id=\"head103\"> 🟢122.买卖股票的最佳时机Ⅱ</span>\n\n### <span id=\"head104\"> 🟡45.跳跃游戏Ⅱ</span>\n\n### <span id=\"head105\"> 🔴135.分发糖果</span>\n\n## <span id=\"head106\"> 作业</span>\n\n### <span id=\"head107\"> 🟡55.跳跃游戏</span>\n\n### <span id=\"head108\"> 2023Q1A-卡片组成的最大数字</span>\n\n### <span id=\"head109\"> 2023Q1A-贪心的商人</span>\n\n### <span id=\"head110\"> 2023B-观看文艺汇演</span>\n\n# <span id=\"head111\"> 第十天</span>\n\n## <span id=\"head112\"> 滑动窗口-长度可变</span>\n\n### <span id=\"head113\"> 🟡3.无重复字符的最长字符</span>\n\n### <span id=\"head114\"> 🟡209.长度最小的子数组</span>\n\n### <span id=\"head115\"> 🟡904.水果成蓝</span>\n\n### <span id=\"head116\"> 🟡159.至多包含两个不同的字符的最长字串</span>\n\n### <span id=\"head117\"> 🟡340.至多包含k个不同的字符的最长字串</span>\n\n### <span id=\"head118\"> 🔴76.最小覆盖字串</span>\n\n### <span id=\"head119\"> 2023Q1A-区块链文件转储系统</span>\n\n### <span id=\"head120\"> 2023Q2-寻找符合要求的最长字串</span>\n\n## <span id=\"head121\"> 作业</span>\n\n### <span id=\"head122\"> 🟡1695.删除子数组的最大分数</span>\n\n### <span id=\"head123\"> 🟡2024.考试的最大扰度</span>\n\n### <span id=\"head124\"> 🟡1658.将x减到0的最小操作数</span>\n\n### <span id=\"head125\"> 2023Q1A-完美走位</span>\n\n# <span id=\"head126\"> 第十一天</span>\n\n## <span id=\"head127\"> 滑动窗口-长度不可变</span>\n\n### <span id=\"head128\"> 🟢1984.学生分数的最小差值</span>\n\n### <span id=\"head129\"> 🟡1456.定长子串中元音的最大数目</span>\n\n### <span id=\"head130\"> 🟡567.字符串的排列</span>\n\n### <span id=\"head131\"> 🟡1052.爱生气的书店老板</span>\n\n### <span id=\"head132\"> 2023Q1A-找出通过车辆最多颜色</span>\n\n### <span id=\"head133\"> 2023Q1A-知识图谱新词挖掘</span>\n\n## <span id=\"head134\"> 作业</span>\n\n### <span id=\"head135\"> 🟢2269.找到一个数字的k美丽值</span>\n\n### <span id=\"head136\"> 🟡1876.长度为三且字符不同的子字符串</span>\n\n### <span id=\"head137\"> 🟡438.找到字符串中所有字母异位词</span>\n\n# <span id=\"head138\"> 第十二天</span>\n\n## <span id=\"head139\"> 序列DP-入门</span>\n\n### <span id=\"head140\">🟢509.斐波那契数</span>\n\n### <span id=\"head141\"> 🟢70.爬楼梯</span>\n\n## <span id=\"head142\"> 序列DP-路径问题</span>\n\n### <span id=\"head143\"> 🟡62.不同路径</span>\n\n### <span id=\"head144\"> 🟡63.不同路径Ⅱ</span>\n\n### <span id=\"head145\"> 🟡64.最小路径和</span>\n\n## <span id=\"head146\"> 序列DP-打家劫舍</span>\n\n### <span id=\"head147\"> 🟡198.打家劫舍</span>\n\n### <span id=\"head148\"> 🟡213.打家劫舍Ⅱ</span>\n\n## <span id=\"head149\"> 作业</span>\n\n### <span id=\"head150\"> 🟢1137.第n个泰波那锲数</span>\n\n### <span id=\"head151\"> 🟡120.三角形最小路径和</span>\n\n### <span id=\"head152\"> 🟡931.下降路径最小和</span>\n\n### <span id=\"head153\"> 2023Q1A-猴子爬山</span>\n\n### <span id=\"head154\"> 2023Q2-超级玛丽过吊桥</span>\n\n# <span id=\"head155\"> 第十三天</span>\n\n## <span id=\"head156\"> 序列DP-最长递增子序列(LIS)</span>\n\n### <span id=\"head157\"> 🟡300.最长递增子序列</span>\n\n### <span id=\"head158\"> 🟡673.最长递增子序列的个数</span>\n\n### <span id=\"head159\"> 🟡334.递增的三元组</span>\n\n## <span id=\"head160\"> 序列DP-最长公共子序列(LCS)</span>\n\n### <span id=\"head161\"> 🟡718.最长重复子数字</span>\n\n### <span id=\"head162\"> 🟡1143.最长公共子序列</span>\n\n## <span id=\"head163\"> 作业</span>\n\n### <span id=\"head164\"> 面试题17.08马戏团人塔</span>\n\n### <span id=\"head165\"> 🟡1035.不相交的线</span>\n\n### <span id=\"head166\"> 2023Q1A-寻找重复代码</span>\n\n### <span id=\"head167\">2023Q2-高速公路休息站充电规则</span>\n\n# <span id=\"head168\"> 第十四天</span>\n\n## <span id=\"head169\"> 状态DP-入门</span>\n\n### <span id=\"head170\">🟡LCR 091.粉刷房子</span>\n\n## <span id=\"head171\"> 状态DP-股票问题</span>\n\n### <span id=\"head172\"> 🔴188.买卖股票的最佳时机Ⅳ</span>\n\n### <span id=\"head173\"> 🟢121.买卖股票的最佳时机</span>\n\n### <span id=\"head174\"> 🔴123.买卖股票的最佳时机Ⅲ</span>\n\n### <span id=\"head175\"> 🟡122.买卖股票的最佳时机Ⅱ</span>\n\n### <span id=\"head176\"> 🟡309.最佳买卖股票时机含冷冻期</span>\n\n### <span id=\"head177\"> 🟡714.买卖股票的的最佳时机含手续费</span>\n\n## <span id=\"head178\"> 作业</span>\n\n### <span id=\"head179\"> 2023Q1A-贪心的商人</span>\n\n### <span id=\"head180\">2023Q1A-递增字符串</span>\n\n# <span id=\"head181\"> 第十五天</span>\n\n## <span id=\"head182\"> 背包DP-01背包</span>\n\n### <span id=\"head183\"> 🟡494.目标和</span>\n\n## <span id=\"head184\"> 背包DP-完全背包</span>\n\n### <span id=\"head185\"> 🟡322.零钱兑换</span>\n\n### <span id=\"head186\"> 🟡518.零钱兑换Ⅱ</span>\n\n## <span id=\"head187\"> 作业</span>\n\n### <span id=\"head188\">🟡416.分割等和子集</span>\n\n### <span id=\"head189\"> 🟡1049.最后一块石头的重量Ⅱ</span>\n\n# <span id=\"head190\"> 第十六天</span>\n\n## <span id=\"head191\"> 二分查找-在排序数组中</span>\n\n### <span id=\"head192\"> 🟢35.搜索插入位置</span>\n\n### <span id=\"head193\">🟢704.二分查找</span>\n\n### <span id=\"head194\">🟡34.在排序数组中查找元素的第一个和最后一个位置</span>\n\n## <span id=\"head195\"> 二分查找-在数轴中</span>\n\n### <span id=\"head196\"> 🟢367.有效的完全平方数</span>\n\n### <span id=\"head197\">🟢69.x 的平方根</span>\n\n## <span id=\"head198\"> 二分查找-利用问题的二段性</span>\n\n### <span id=\"head199\"> 🟡875.爱吃香蕉的珂珂</span>\n\n### <span id=\"head200\"> 2023Q1A-开放日活动</span>\n\n### <span id=\"head201\"> 2023B-食堂供餐</span>\n\n## <span id=\"head202\"> 作业</span>\n\n### <span id=\"head203\">🟢374.猜数字大小</span>\n\n### <span id=\"head204\"> 🟡1011.在D天内送达包裹的能力</span>\n\n### <span id=\"head205\"> 2023Q1A-农场施肥</span>\n\n### <span id=\"head206\"> 2023B-最佳植树距离</span>\n\n# <span id=\"head207\"> 第十七天/第十八天</span>\n\n## <span id=\"head208\"> DFS/BFS-前置问题</span>\n\n### <span id=\"head209\"> 2023B-统计监控</span>\n\n## <span id=\"head210\"> DFS/BFS-二维矩阵表示图(岛屿问题)</span>\n\n### <span id=\"head211\"> 🟡200.岛屿数量</span>\n\n### <span id=\"head212\"> 🟡695.岛屿的最大面积</span>\n\n### <span id=\"head213\"> 2023Q1A-开心消消乐</span>\n\n### <span id=\"head214\"> 2023B-寻找最大价值的矿堆</span>\n\n## <span id=\"head215\"> DFS/BFS-邻接矩阵表示图</span>\n\n### <span id=\"head216\"> 🟡547.省份数量</span>\n\n### <span id=\"head217\"> 2023Q1A-Linux发行版的数量</span>\n\n## <span id=\"head218\"> DFS/BFS-邻接表表示图</span>\n\n### <span id=\"head219\"> 🟡841.钥匙和房间</span>\n\n## <span id=\"head220\"> 作业</span>\n\n### <span id=\"head221\"> 🟢463.岛屿的周长</span>\n\n### <span id=\"head222\"> 🟢733.图像渲染</span>\n\n### <span id=\"head223\"> 2023Q2-广播服务器</span>\n\n### <span id=\"head224\"> 2023Q1A-机器人活动区域</span>\n\n# <span id=\"head225\"> 第十九天</span>\n\n## <span id=\"head226\"> BFS</span>\n\n### <span id=\"head227\"> 🟡994.腐烂的橘子</span>\n\n### <span id=\"head228\"> 2023Q1-快速开租建站</span>\n\n## <span id=\"head229\"> DFS</span>\n\n### <span id=\"head230\"> 🟢1971.寻找图中是否存在路径</span>\n\n### <span id=\"head231\"> 🟡1376.通知所有员工所需的时间</span>\n\n### <span id=\"head232\"> 2023Q2-获取食物游戏</span>\n\n## <span id=\"head233\"> 作业</span>\n\n### <span id=\"head234\"> 2023Q2B-火星改造</span>\n\n### <span id=\"head235\"> 2023Q2-士兵突击</span>\n\n# <span id=\"head236\"> 第二十天</span>\n\n## <span id=\"head237\"> 回溯算法</span>\n\n### <span id=\"head238\">🔴51.N 皇后</span>\n\n### <span id=\"head239\"> 🔴37.解数独</span>\n\n## <span id=\"head240\"> 作业</span>\n\n### <span id=\"head241\"> 2023Q1A-基站维修工程师</span>\n\n### <span id=\"head242\"> 2023Q1-硬件产品销售方案</span>\n\n### <span id=\"head243\"> 2023B-猜密码</span>\n","categories":["algorithm training"]},{"title":"🟢836. rectangle overlap","url":"/2023/11/26/coding-836-rectangle-overlap/","content":"\n# 题目\n\n> 矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。\n>\n> 如果相交的面积为 **正** ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n>\n> 给出两个矩形 `rec1` 和 `rec2` 。如果它们重叠，返回 `true`；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `rect1.length == 4`\n> - `rect2.length == 4`\n> - `-109 <= rec1[i], rec2[i] <= 109`\n> - `rec1` 和 `rec2` 表示一个面积不为零的有效矩形\n\n# 思路\n\n按照两个矩阵起点的位置分了四种情况分别分析。\n\n# 代码\n\n```java\nclass Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        if(rec1[0]<=rec2[0]&&rec1[1]<=rec2[1]) {//1\n            if(rec2[0]<rec1[2]&&rec2[1]<rec1[3]){\n                return true;\n            }else{\n                return false;\n            }\n        }else if(rec1[0]<=rec2[0]){//2\n            if(rec2[0]<=rec1[2]&&rec2[3]>=rec1[1]){\n                return true;\n            }else{\n                return false;\n            }\n        } else if (rec1[1]<=rec2[1]) {//4\n            if(rec2[1]<=rec1[3]&&rec2[2]>=rec1[0]){\n                return true;\n            }else{\n                return false;\n            }\n        }else{//3\n            if(rec2[2]>rec1[0]&&rec2[3]>rec1[1]){\n                return true;\n            }else{\n                return false;\n            }\n        }\n    }\n}\n```\n\n- 时间复杂度：O(1)\n\n- 空间复杂度：O(1)\n","tags":["algorithm-math","algorithm-geometry"]},{"title":"Monotone Stack","url":"/2023/09/11/algorithm-monotonestack/","content":"\n| 编号 | 是否完成 | 题号                              | 标签   |\n| ---- | :------: | :-------------------------------- | ------ |\n| 1    |    ✅     | [🟡739. 每日温度](#head1)          | 单调栈 |\n| 2    |    ✅     | [🟢496. 下一个更大元素 I](#head2)  | 单调栈 |\n| 3    |    ✅     | [🟡503. 下一个更大元素 II](#head3) | 单调栈 |\n| 4    |          | [🔴42. 接雨水](#head4)             |        |\n| 5    |          | [🔴84. 柱状图中最大的矩形](#head5) |        |\n\n# <span id=\"head1\">🟡739. 每日温度</span>\n\n> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: temperatures = [73,74,75,71,69,72,76,73]\n> 输出: [1,1,4,2,1,1,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: temperatures = [30,40,50,60]\n> 输出: [1,1,1,0]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: temperatures = [30,60,90]\n> 输出: [1,1,0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= temperatures.length <= 105`\n> - `30 <= temperatures[i] <= 100`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int len=temperatures.length;\n        int[]res=new int[len];\n        Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < len; i++) {\n            while(!stack.isEmpty()&&temperatures[stack.peek()]<temperatures[i]){\n                res[stack.peek()]=i-stack.peek();\n                stack.pop();\n            }\n            stack.push(i);\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head2\">🟢496. 下一个更大元素 I</span>\n\n> `nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。\n>\n> 给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。\n>\n> 对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。\n>\n> 返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n> 输出：[-1,3,-1]\n> 解释：nums1 中每个值的下一个更大元素如下所述：\n> - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n> - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n> - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [2,4], nums2 = [1,2,3,4].\n> 输出：[3,-1]\n> 解释：nums1 中每个值的下一个更大元素如下所述：\n> - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。\n> - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length <= nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 104`\n> - `nums1`和`nums2`中所有整数 **互不相同**\n> - `nums1` 中的所有整数同样出现在 `nums2` 中\n>\n> \n>\n> **进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 哈希表\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int len= nums1.length;\n        Map<Integer,Integer>map=new HashMap<>();\n        for (int i = 0; i < len; i++) {\n            map.put(nums1[i],i);\n        }\n        int[]res=new int[len];\n        Arrays.fill(res,-1);\n        Stack<Integer>stack=new Stack<>();\n        for (int i = 0; i < nums2.length; i++) {\n            while(!stack.isEmpty()&&nums2[stack.peek()]<nums2[i]){\n                int pre=nums2[stack.pop()];\n                if(map.containsKey(pre)){\n                    res[map.get(pre)]=nums2[i];\n                }\n            }\n            stack.push(i);\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head3\">🟡503. 下一个更大元素 II</span>\n\n> 给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。\n>\n> 数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [1,2,1]\n> 输出: [2,-1,2]\n> 解释: 第一个 1 的下一个更大的数是 2；\n> 数字 2 找不到下一个更大的数； \n> 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [1,2,3,4,3]\n> 输出: [2,3,4,-1,4]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= nums.length <= 104`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\nclass Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int len=nums.length;\n        int[]res=new int[len];\n        Arrays.fill(res,-1);\n        Stack<Integer> stack=new Stack<>();\n        for (int i = 0; i < len*2; i++) {\n            while(!stack.isEmpty()&&nums[i%len]>nums[stack.peek()]){\n                res[stack.peek()]=nums[i%len];\n                stack.pop();\n            }\n            stack.push(i%len);\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head4\">🔴42. 接雨水</span>\n\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n>\n> ```\n> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n> 输出：6\n> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：height = [4,2,0,3,2,5]\n> 输出：9\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == height.length`\n> - `1 <= n <= 2 * 104`\n> - `0 <= height[i] <= 105`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 双指针\n>\n> 动态规划\n>\n> 单调栈\n\n```java\n```\n\n\n\n# <span id=\"head5\">🔴84. 柱状图中最大的矩形</span>\n\n> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n>\n> 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)\n>\n> ```\n> 输入：heights = [2,1,5,6,2,3]\n> 输出：10\n> 解释：最大的矩形为图中红色区域，面积为 10\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)\n>\n> ```\n> 输入： heights = [2,4]\n> 输出： 4\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= heights.length <=105`\n> - `0 <= heights[i] <= 104`\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 单调栈\n\n```java\n```\n\n","categories":["algorithm learning"]},{"title":"Dynamic Programming","url":"/2023/09/10/algorithm-dp/","content":"\n|                          |                          | 编号 | 是否完成 | 题号                                        | 标签                 |\n| :----------------------: | ------------------------ | ---- | :------: | :------------------------------------------ | -------------------- |\n| [ 动态规划基础](#head1)  |                          | 1    |    ✅     | [ 🟢509.斐波那契数](#head2)                  | dp                   |\n|                          |                          | 2    |    ✅     | [🟢70. 爬楼梯](#head3)                       | dp                   |\n|                          |                          | 3    |    ✅     | [🟢746. 使用最小花费爬楼梯](#head4)          | dp                   |\n|                          |                          | 4    |    ✅     | [🟡62. 不同路径](#head5)                     | 二维dp               |\n|                          |                          | 5    |    ✅     | [🟡63. 不同路径 II](#head6)                  | 二维dp               |\n|                          |                          | 6    |    ✅     | [🟡343. 整数拆分](#head7)                    | dp                   |\n|                          |                          | 7    |    ✅     | [🟡96. 不同的二叉搜索树](#head8)             | dp 图                |\n|   [ 背包系列](#head9)    | [ 01背包问题](#head10)   | 8    |    ✅     | [🟡416. 分割等和子集](#head11)               | 01背包               |\n|                          |                          | 9    |    ✅     | [🟡1049. 最后一块石头的重量 II](#head12)     | 01背包               |\n|                          |                          | 10   |    ✅     | [🟡494. 目标和](#head13)                     | 01背包（累加最大）   |\n|                          |                          | 11   |    ✅     | [🟡474. 一和零](#head14)                     | 01背包（两个维度）   |\n|                          | [ 完全背包问题](#head15) | 12   |    ✅     | [🟡518. 零钱兑换 II](#head16)                | 完全背包             |\n|                          |                          | 13   |    ✅     | [🟡377. 组合总和 Ⅳ](#head17)                 | 完全背包（排列）     |\n|                          |                          | 14   |    ✅     | [ 🟢57. 爬楼梯（第八期模拟笔试）](#head18)   | 完全背包（排列）     |\n|                          |                          | 15   |    ✅     | [🟡322. 零钱兑换](#head19)                   | 完全背包（累加最小） |\n|                          |                          | 16   |    ✅     | [🟡279. 完全平方数](#head20)                 | 完全背包（累加最小） |\n|                          |                          | 17   |    ✅     | [🟡139. 单词拆分](#head21)                   | 完全背包             |\n| [ 打家劫舍系列](#head22) |                          | 18   |    ✅     | [🟡198. 打家劫舍](#head23)                   | dp                   |\n|                          |                          | 19   |    ✅     | [🟡213. 打家劫舍 II](#head24)                | dp                   |\n|                          |                          | 20   |    ✅     | [🟡337. 打家劫舍 III](#head25)               | 树形dp               |\n|   [ 股票系列](#head26)   |                          | 21   |    ✅     | [🟢121. 买卖股票的最佳时机](#head27)         | dp                   |\n|                          |                          | 22   |    ✅     | [🟡122. 买卖股票的最佳时机 II](#head28)      | dp                   |\n|                          |                          | 23   |    ✅     | [🔴123. 买卖股票的最佳时机 III](#head29)     | dp                   |\n|                          |                          | 24   |    ✅     | [🔴188. 买卖股票的最佳时机 IV](#head30)      | dp                   |\n|                          |                          | 25   |    ✅     | [🟡309. 买卖股票的最佳时机含冷冻期](#head31) | 状态dp               |\n|                          |                          | 26   |    ✅     | [🟡714. 买卖股票的最佳时机含手续费](#head32) | dp                   |\n|  [ 子序列系列](#head33)  | [ 不连续子序列](#head34) | 27   |    ✅     | [🟡300. 最长递增子序列](#head35)             | dp                   |\n|                          |                          | 28   |    ✅     | [🟡1143. 最长公共子序列](#head36)            | dp                   |\n|                          |                          | 29   |    ✅     | [🟡1035. 不相交的线](#head37)                | dp                   |\n|                          | [ 连续子序列](#head38)   | 30   |    ✅     | [🟢674. 最长连续递增序列](#head39)           | dp                   |\n|                          |                          | 31   |    ✅     | [🟡718. 最长重复子数组](#head40)             | dp                   |\n|                          |                          | 32   |    ✅     | [🟡53. 最大子数组和](#head41)                | dp                   |\n|                          | [ 编辑距离](#head42)     | 33   |    ✅     | [🟢392. 判断子序列](#head43)                 | dp                   |\n|                          |                          | 34   |          | [🔴115. 不同的子序列](#head44)               |                      |\n|                          |                          | 35   |    ✅     | [🟡583. 两个字符串的删除操作](#head45)       | dp                   |\n|                          |                          | 36   |          | [🔴72. 编辑距离](#head46)                    |                      |\n|                          | [ 回文](#head47)         | 37   |          | [🟡647. 回文子串](#head48)                   |                      |\n|                          |                          | 38   |          | [🟡516. 最长回文子序列](#head49)             |                      |\n\n# <span id=\"head1\"> 动态规划基础</span>\n\n### <span id=\"head2\"> 🟢509.斐波那契数</span>\n\n> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n>\n> ```\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n> ```\n>\n> 给定 `n` ，请计算 `F(n)` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 2\n> 输出：1\n> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 3\n> 输出：2\n> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：n = 4\n> 输出：3\n> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= n <= 30`\n>\n> Related Topics\n>\n> 递归\n>\n> 记忆化搜索\n>\n> 数学\n>\n> 动态规划\n\n```java\npublic int fib(int n) {\n        if(n==1||n==2){\n            return 1;\n        }\n        int f1=1,f2=1,res=0;\n        int i=3;\n        while(i<=n){\n            res=f1+f2;\n            f1=f2;\n            f2=res;\n            i++;\n        }\n        return res;\n    }\n```\n\n### <span id=\"head3\">🟢70. 爬楼梯</span>\n\n> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n>\n> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 2\n> 输出：2\n> 解释：有两种方法可以爬到楼顶。\n> 1. 1 阶 + 1 阶\n> 2. 2 阶\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 3\n> 输出：3\n> 解释：有三种方法可以爬到楼顶。\n> 1. 1 阶 + 1 阶 + 1 阶\n> 2. 1 阶 + 2 阶\n> 3. 2 阶 + 1 阶\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 45`\n>\n> Related Topics\n>\n> 记忆化搜索\n>\n> 数学\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        if(n<2){\n            return n;\n        }\n        int[]dp=new int[n+1];\n        dp[1]=1;\n        dp[2]=2;\n        for (int i = 3; i <= n; i++) {\n            dp[i]=dp[i-1]+dp[i-2];\n        }\n        return dp[n];\n    }\n}\n```\n\n### <span id=\"head4\">🟢746. 使用最小花费爬楼梯</span>\n\n> 给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n>\n> 你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。\n>\n> 请你计算并返回达到楼梯顶部的最低花费。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：cost = [10,15,20]\n> 输出：15\n> 解释：你将从下标为 1 的台阶开始。\n> - 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n> 总花费为 15 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：cost = [1,100,1,1,1,100,1,1,100,1]\n> 输出：6\n> 解释：你将从下标为 0 的台阶开始。\n> - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n> - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n> - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n> - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n> - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n> - 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n> 总花费为 6 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `2 <= cost.length <= 1000`\n> - `0 <= cost[i] <= 999`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int len=cost.length;\n        int[]dp=new int[len+1];\n        dp[0]=0;\n        dp[1]=0;\n        for (int i = 2; i <= len; i++) {\n            dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]) ;\n        }\n        return dp[len];\n    }\n}\n```\n\n### <span id=\"head5\">🟡62. 不同路径</span>\n\n> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n>\n> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n>\n> 问总共有多少条不同的路径？\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)\n>\n> ```\n> 输入：m = 3, n = 7\n> 输出：28\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：m = 3, n = 2\n> 输出：3\n> 解释：\n> 从左上角开始，总共有 3 条路径可以到达右下角。\n> 1. 向右 -> 向下 -> 向下\n> 2. 向下 -> 向下 -> 向右\n> 3. 向下 -> 向右 -> 向下\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：m = 7, n = 3\n> 输出：28\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：m = 3, n = 3\n> 输出：6\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= m, n <= 100`\n> - 题目数据保证答案小于等于 `2 * 109`\n>\n> Related Topics\n>\n> 数学\n>\n> 动态规划\n>\n> 组合数学\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][]dp=new int[m][n];\n        for (int i = 0; i < m; i++) {\n            dp[i][0]=1;\n        }\n        for (int i = 0; i < n; i++) {\n            dp[0][i]=1;\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j]=dp[i][j-1]+dp[i-1][j];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}\n```\n\n### <span id=\"head6\">🟡63. 不同路径 II</span>\n\n> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n>\n> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n>\n> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n>\n> 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)\n>\n> ```\n> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n> 输出：2\n> 解释：3x3 网格的正中间有一个障碍物。\n> 从左上角到右下角一共有 2 条不同的路径：\n> 1. 向右 -> 向右 -> 向下 -> 向下\n> 2. 向下 -> 向下 -> 向右 -> 向右\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)\n>\n> ```\n> 输入：obstacleGrid = [[0,1],[0,0]]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == obstacleGrid.length`\n> - `n == obstacleGrid[i].length`\n> - `1 <= m, n <= 100`\n> - `obstacleGrid[i][j]` 为 `0` 或 `1`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n>\n> 矩阵\n\n```java\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m=obstacleGrid.length,n=obstacleGrid[0].length;\n        int[][]dp=new int[m][n];\n        for (int i = 0; i < m; i++) {\n            if(obstacleGrid[i][0]==1){\n                break;\n            }else{\n                dp[i][0]=1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if(obstacleGrid[0][i]==1){\n                break;\n            }else{\n                dp[0][i]=1;\n            }\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if(obstacleGrid[i][j]==1){\n                    dp[i][j]=0;\n                }else{\n                    dp[i][j]=dp[i][j-1]+dp[i-1][j];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}\n```\n\n### <span id=\"head7\">🟡343. 整数拆分</span>\n\n> 给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。\n>\n> 返回 *你可以获得的最大乘积* 。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: n = 2\n> 输出: 1\n> 解释: 2 = 1 + 1, 1 × 1 = 1。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: n = 10\n> 输出: 36\n> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `2 <= n <= 58`\n>\n> Related Topics\n>\n> 数学\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int integerBreak(int n) {\n         int[]dp=new int[n+1];\n        dp[2]=1;\n        for (int i = 3; i <= n; i++) {\n            for (int j = 1; j <= i-j; j++) {\n                dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n\n\n### <span id=\"head8\">🟡96. 不同的二叉搜索树</span>\n\n> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)\n>\n> ```\n> 输入：n = 3\n> 输出：5\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 19`\n>\n> Related Topics\n>\n> 树\n>\n> 二叉搜索树\n>\n> 数学\n>\n> 动态规划\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int numTrees(int n) {\n        int[]dp=new int[n+1];\n        dp[0]=1;\n        dp[1]=1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 0; j < i; j++) {\n                dp[i]+=dp[j]*dp[i-j-1];\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n思路：\n\n计算两个节点的过程：dp [ 2 ] = dp [  0 ] × dp [  1 ] +  dp [  1 ] × dp [  0 ]\n\n计算三个节点的过程：dp [ 3 ] = dp [  0 ] × dp [  2 ] +  dp [  1 ] × dp [  1 ] +  dp [  2 ] × dp [  0 ]\n\n# <span id=\"head9\"> 背包系列</span>\n\n## <span id=\"head10\"> 01背包问题</span>\n\n### <span id=\"head11\">🟡416. 分割等和子集</span>\n\n> 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,5,11,5]\n> 输出：true\n> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,5]\n> 输出：false\n> 解释：数组不能分割成两个元素和相等的子集。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 200`\n> - `1 <= nums[i] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n二维dp：\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int SUM= Arrays.stream(nums).sum();\n        if(nums.length==1||SUM%2==1){\n            return false;\n        }\n        int target=SUM/2;\n        int len= nums.length;\n        boolean [][]dp=new boolean[len][target+1];//dp[i][j]：前i个元素存在总和恰好为j则为true\n        if(nums[0] <= target){\n            dp[0][nums[0]]=true;\n        }\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                } else if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len-1][target];\n    }\n}\n```\n\n一维dp：\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int SUM= Arrays.stream(nums).sum();\n        if(nums.length==1||SUM%2==1){\n            return false;\n        }\n        int target=SUM/2;\n        int len= nums.length;\n        boolean []dp=new boolean[target+1];//dp[j]：总和恰好为j则为true\n        if(nums[0] <= target){\n            dp[nums[0]]=true;\n        }\n        for (int i = 1; i < len; i++) {\n            for (int j = target; j >=0 ; j--) {\n                if (nums[i] == j) {\n                    dp[j] = true;\n                    continue;\n                } else if (nums[i] < j) {\n                    dp[j] = dp[j] || dp[j - nums[i]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n```\n\n按照卡哥的思路重新写的一遍：\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int SUM= Arrays.stream(nums).sum();\n        if(nums.length==1||SUM%2==1){\n            return false;\n        }\n        int target=SUM/2;\n        int len= nums.length;\n        int []dp=new int[target+1];//dp[j]：容量为j的数组总和\n\n        for (int i = 0; i < len; i++) {\n            for (int j = target; j >=nums[i] ; j--) {                \n                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);\n            }\n        }\n        for (int i = 0; i <= target; i++) {\n            System.out.print(dp[i]+\"\\t\");\n        }\n        return dp[target]==target;\n    }\n}\n```\n\n### <span id=\"head12\">🟡1049. 最后一块石头的重量 II</span>\n\n> 有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。\n>\n> 每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n>\n> - 如果 `x == y`，那么两块石头都会被完全粉碎；\n> - 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n>\n> 最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：stones = [2,7,4,1,8,1]\n> 输出：1\n> 解释：\n> 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n> 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n> 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n> 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：stones = [31,26,33,21,40]\n> 输出：5\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= stones.length <= 30`\n> - `1 <= stones[i] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n二维dp：\n\n```java\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum=Arrays.stream(stones).sum();\n        int target= sum/2;\n        int num=stones.length;\n        int[][]dp=new int[num][target+1];//前i个元素内任选若干个总和恰好等于j的最大值\n        for (int j = stones[0]; j <= target; j++) {\n            dp[0][j]=stones[0];\n        }\n        for (int i = 1; i < num; i++) {\n            for (int j = 1; j <= target; j++) {                \n                if(j<stones[i]){\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n                }else{\n\t\t\t\t\tdp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);\n                }\n            }\n        }\n        return sum-dp[num-1][target]-dp[num-1][target];\n    }\n}\n```\n\n一维dp：\n\n```java\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum=Arrays.stream(stones).sum();\n        int target= sum/2;\n        int num=stones.length;\n        int[]dp=new int[target+1];//任选若干个总和恰好等于j的最大值\n        for (int j = stones[0]; j <= target; j++) {\n            dp[j]=stones[0];\n        }\n        for (int i = 1; i < num; i++) {\n            for (int j = target; j >= stones[i]; j--) {\n                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\n\n            }\n        }\n        return sum-dp[target]-dp[target];\n    }\n}\n```\n\n### <span id=\"head13\">🟡494. 目标和</span>\n\n> 给你一个非负整数数组 `nums` 和一个整数 `target` 。\n>\n> 向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：\n>\n> - 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `\"+2-1\"` 。\n>\n> 返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,1,1,1], target = 3\n> 输出：5\n> 解释：一共有 5 种方法让最终目标和为 3 。\n> -1 + 1 + 1 + 1 + 1 = 3\n> +1 - 1 + 1 + 1 + 1 = 3\n> +1 + 1 - 1 + 1 + 1 = 3\n> +1 + 1 + 1 - 1 + 1 = 3\n> +1 + 1 + 1 + 1 - 1 = 3\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1], target = 1\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 20`\n> - `0 <= nums[i] <= 1000`\n> - `0 <= sum(nums[i]) <= 1000`\n> - `-1000 <= target <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n>\n> 回溯\n\n```java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum= Arrays.stream(nums).sum();\n        int left=(sum+target)/2;\n        int num=nums.length;\n        if(sum<Math.abs(target)||(sum+target)%2==1){\n            return 0;\n        }\n        int[]dp=new int[left+1];//前i个物品中填满j（包括j）这么大容积的包，有dp[j]种方法\n        dp[0]=1;//❗\n        for (int i = 0; i < num; i++) {\n            for (int j = left; j >= nums[i]; j--) {\n                dp[j]+=dp[j-nums[i]];//❗\n            }\n        }\n        return dp[left];\n    }\n}\n```\n\n### <span id=\"head14\">🟡474. 一和零</span>\n\n> 给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。\n>\n> 请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。\n>\n> 如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n> 输出：4\n> 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\n> 其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n> 输出：2\n> 解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 600`\n> - `1 <= strs[i].length <= 100`\n> - `strs[i]` 仅由 `'0'` 和 `'1'` 组成\n> - `1 <= m, n <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 字符串\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][]dp=new int[m+1][n+1];//含有m个0，n个1的最大字符串数；\n        int cnt_0=0,cnt_1=0;\n        for (String str:strs) {\n            cnt_0=cnt_1=0;\n            for (char ch: str.toCharArray()) {\n                if(ch=='0'){\n                    cnt_0++;\n                }else{\n                    cnt_1++;\n                }\n            }\n            for (int i = m; i >= cnt_0; i--) {\n                for (int j = n; j >= cnt_1; j--) {\n                    dp[i][j]=Math.max(dp[i][j],dp[i-cnt_0][j-cnt_1]+1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n\n\n## <span id=\"head15\"> 完全背包问题</span>\n\n### <span id=\"head16\">🟡518. 零钱兑换 II</span>\n\n> 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。\n>\n> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。\n>\n> 假设每一种面额的硬币有无限个。\n>\n> 题目数据保证结果符合 32 位带符号整数。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：amount = 5, coins = [1, 2, 5]\n> 输出：4\n> 解释：有四种方式可以凑成总金额：\n> 5=5\n> 5=2+2+1\n> 5=2+1+1+1\n> 5=1+1+1+1+1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：amount = 3, coins = [2]\n> 输出：0\n> 解释：只用面额 2 的硬币不能凑成总金额 3 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：amount = 10, coins = [10] \n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= coins.length <= 300`\n> - `1 <= coins[i] <= 5000`\n> - `coins` 中的所有值 **互不相同**\n> - `0 <= amount <= 5000`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp=new int[amount+1];\n        dp[0]=1;\n        for (int i = 0; i < coins.length; i++) {\n            for (int j = coins[i]; j <= amount; j++) {\n                dp[j]+=dp[j-coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n\n\n\n### <span id=\"head17\">🟡377. 组合总和 Ⅳ</span>\n\n> 给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。\n>\n> 题目数据保证答案符合 32 位整数范围。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3], target = 4\n> 输出：7\n> 解释：\n> 所有可能的组合为：\n> (1, 1, 1, 1)\n> (1, 1, 2)\n> (1, 2, 1)\n> (1, 3)\n> (2, 1, 1)\n> (2, 2)\n> (3, 1)\n> 请注意，顺序不同的序列被视作不同的组合。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [9], target = 3\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 200`\n> - `1 <= nums[i] <= 1000`\n> - `nums` 中的所有元素 **互不相同**\n> - `1 <= target <= 1000`\n>\n> \n>\n> **进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n这道题和上一题的区别在于，上题是组合问题不care元素中间的顺序，本题是排列问题，需将内外循环更换顺序。\n\n```java\nclass Solution {\n    public int combinationSum4(int[] nums, int target) {\n        int[] dp=new int[target+1];\n        dp[0]=1;\n        for (int i = 0; i <= target; i++) {\n            for (int j = 0; j < nums.length; j++) {\n                if(i>=nums[j]){\n                    dp[i]+=dp[i-nums[j]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n```\n\n### <span id=\"head18\"> 🟢57. 爬楼梯（第八期模拟笔试）</span>\n\n> [题目页面 (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1067)\n>\n> ###### 题目描述\n>\n> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 \n>\n> 每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ \n>\n> 注意：给定 n 是一个正整数。\n>\n> ###### 输入描述\n>\n> 输入共一行，包含两个正整数，分别表示n, m\n>\n> ###### 输出描述\n>\n> 输出一个整数，表示爬到楼顶的方法数。\n>\n> ###### 输入示例\n>\n> ```\n> 3 2\n> ```\n>\n> ###### 输出示例\n>\n> ```\n> 3\n> ```\n>\n> ###### 提示信息\n>\n> 数据范围：\n> 1 <= m < n <= 32;\n>\n> 当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。\n>\n> 此时你有三种方法可以爬到楼顶。\n>\n> \n>\n> 1. 1 阶 + 1 阶 + 1 阶段\n> 2. 1 阶 + 2 阶\n> 3. 2 阶 + 1 阶\n\n```java\nimport java.util.*;\nclass Main{\n    public static void main(String[]args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt(),m=in.nextInt();\n        int[]dp=new int[n+1];\n        dp[0]=1;\n        for (int i=1;i<=n;i++ ){\n            for(int j=1;j<=m;j++){\n                if(i>=j){\n                    dp[i]+=dp[i-j];\n                }\n            }\n        } \n        System.out.println(dp[n]);\n    }\n}\n```\n\n### <span id=\"head19\">🟡322. 零钱兑换</span>\n\n> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。\n>\n> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。\n>\n> 你可以认为每种硬币的数量是无限的。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：coins = [1, 2, 5], amount = 11\n> 输出：3 \n> 解释：11 = 5 + 5 + 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：coins = [2], amount = 3\n> 输出：-1\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：coins = [1], amount = 0\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= coins.length <= 12`\n> - `1 <= coins[i] <= 231 - 1`\n> - `0 <= amount <= 104`\n>\n> Related Topics\n>\n> 广度优先搜索\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(amount==0){\n            return 0;\n        }\n        int max=Integer.MAX_VALUE;\n        int num=coins.length;\n        int[]dp=new int[amount+1];//dp[j]表示总和为j的集合最小硬币个数\n        Arrays.fill(dp,max);\n        dp[0]=0;\n        for (int i = 0; i < num; i++) {\n            for (int j = coins[i]; j <= amount; j++) {\n                if(dp[j-coins[i]]!=max){\n                    dp[j]=Math.min(dp[j],dp[j-coins[i]]+1);\n                }\n            }\n        }\n        if(dp[amount]==max){\n            return -1;\n        }else{\n            return dp[amount];\n        }\n    }\n}\n```\n\n\n\n### <span id=\"head20\">🟡279. 完全平方数</span>\n\n> 给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。\n>\n> **完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 12\n> 输出：3 \n> 解释：12 = 4 + 4 + 4\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 13\n> 输出：2\n> 解释：13 = 4 + 9\n> ```\n>\n> **提示：**\n>\n> - `1 <= n <= 104`\n>\n> Related Topics\n>\n> 广度优先搜索\n>\n> 数学\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int numSquares(int n) {\n        int[]dp=new int[n+1];\n        int max=Integer.MAX_VALUE;\n        Arrays.fill(dp,max);\n        dp[0]=0;\n        for (int i = 1; i <= 100; i++) {\n            for (int j = i*i; j <= n; j++) {\n                if(dp[j-i*i]!=max){\n                    dp[j]=Math.min(dp[j],dp[j-i*i]+1);\n                }\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n\n\n### <span id=\"head21\">🟡139. 单词拆分</span>\n\n> 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。\n>\n> **注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n> 输出: true\n> 解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n> 输出: true\n> 解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n>      注意，你可以重复使用字典中的单词。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n> 输出: false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 300`\n> - `1 <= wordDict.length <= 1000`\n> - `1 <= wordDict[i].length <= 20`\n> - `s` 和 `wordDict[i]` 仅由小写英文字母组成\n> - `wordDict` 中的所有字符串 **互不相同**\n>\n> Related Topics\n>\n> 字典树\n>\n> 记忆化搜索\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 动态规划\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String>set=new HashSet<>(wordDict);\n        int num=s.length();\n        boolean []dp=new boolean[num+1];\n        dp[0]=true;\n\n        for (int i = 1; i <= num; i++) {\n            for (int j = 0; j < i&&!dp[i]; j++) {\n                if(set.contains(s.substring(j,i))&&dp[j]){\n                    dp[i]=true;\n                }\n            }\n        }\n        return dp[num];\n    }\n}\n```\n\n\n\n# <span id=\"head22\"> 打家劫舍系列</span>\n\n### <span id=\"head23\">🟡198. 打家劫舍</span>\n\n> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n>\n> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：[1,2,3,1]\n> 输出：4\n> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n>      偷窃到的最高金额 = 1 + 3 = 4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：[2,7,9,3,1]\n> 输出：12\n> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `0 <= nums[i] <= 400`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length==1){\n            return nums[0];\n        }\n        int num= nums.length;\n        int[]dp=new int[num];\n        dp[0]=nums[0];\n        dp[1]=Math.max(nums[0],nums[1]);\n        for (int i = 2; i < num; i++) {\n            dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);\n        }\n        return dp[num-1];\n    }\n}\n```\n\n\n\n### <span id=\"head24\">🟡213. 打家劫舍 II</span>\n\n> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。\n>\n> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,3,2]\n> 输出：3\n> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3,1]\n> 输出：4\n> 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n>      偷窃到的最高金额 = 1 + 3 = 4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 100`\n> - `0 <= nums[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        int len= nums.length;\n        if(len==1){\n            return nums[0];\n        }\n        int without_head=rob_(nums,1,len);\n        int without_tail=rob_(nums,0,len-1);\n\n        return Math.max(without_head,without_tail);\n    }\n    public int rob_(int[] nums,int start,int end){\n        int x=0,y=0,z=0;\n        for (int i = start; i < end; i++) {\n            y=z;\n            z=Math.max(x+nums[i],y);\n            x=y;\n        }\n        return z;\n    }\n}\n```\n\n\n\n### <span id=\"head25\">🟡337. 打家劫舍 III</span>\n\n> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。\n>\n> 除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。\n>\n> 给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。\n>\n> \n>\n> **示例 1:**\n>\n> ![rob1-tree](23-9-10-algorithm-dp/rob1-tree.jpg)\n>\n> ```\n> 输入: root = [3,2,3,null,3,null,1]\n> 输出: 7 \n> 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\n> ```\n>\n> **示例 2:**\n>\n> ![rob2-tree](23-9-10-algorithm-dp/rob2-tree.jpg)\n>\n> ```\n> 输入: root = [3,4,5,1,3,null,1]\n> 输出: 9\n> 解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - 树的节点数在 `[1, 104]` 范围内\n> - `0 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 动态规划\n>\n> 二叉树\n\n在后序遍历+树形DP的思路下，写出以下代码，超时了\n\n```java\nclass Solution {\n    public int rob(TreeNode root) {\n        //后序遍历-stack\n        Stack<TreeNode>s=new Stack<TreeNode>();\n        s.push(root);\n        int[]tou=new int[2];\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                s.push(node);\n                s.push(null);\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.pop();\n                tou=fuc(node);\n            }\n        }\n        return Math.max(tou[0],tou[1]);\n    }\n    int[]fuc(TreeNode root){\n        int[]tou=new int[2];\n        if(root.left==null&&root.right==null){//叶子节点\n            tou[0]=0;\n            tou[1]=root.val;\n        } else if (root.left==null) {\n            tou[0]=Math.max(fuc(root.right)[0],fuc(root.right)[1]);\n            tou[1]=root.val+fuc(root.right)[0];\n        }else if(root.right==null){\n            tou[0]=Math.max(fuc(root.left)[0],fuc(root.left)[1]);\n            tou[1]=root.val+fuc(root.left)[0];\n        }else{\n            tou[0]=Math.max(fuc(root.left)[0],fuc(root.left)[1])+Math.max(fuc(root.right)[0],fuc(root.right)[1]);\n            tou[1]=root.val+fuc(root.left)[0]+fuc(root.right)[0];\n        }\n        return tou;\n    }\n}\n```\n\n更改遍历方式\n\n```java\nclass Solution {\n    public int rob(TreeNode root) {\n        int[]tou=fuc(root);\n        return Math.max(tou[0],tou[1]);\n    }\n    int[]fuc(TreeNode root){\n        int[]tou=new int[2];\n        if(root==null){\n            return tou;\n        }\n        int[]left=fuc(root.left);\n        int[]right=fuc(root.right);\n\n        tou[0]=Math.max(left[0],left[1])+Math.max(right[0],right[1]);\n        tou[1]=root.val+left[0]+right[0];\n        return tou;\n    }\n}\n```\n\n\n\n# <span id=\"head26\"> 股票系列</span>\n\n### <span id=\"head27\">🟢121. 买卖股票的最佳时机</span>\n\n>\n>\n>给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n>\n>你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n>\n>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：[7,1,5,3,6,4]\n>输出：5\n>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：prices = [7,6,4,3,1]\n>输出：0\n>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= prices.length <= 105`\n>- `0 <= prices[i] <= 104`\n>\n>Related Topics\n>\n>数组\n>\n>动态规划\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int len=prices.length;\n        int[][]dp=new int[len][2];\n        dp[0][0]=prices[0];\n        for (int i = 1; i < len; i++) {\n            dp[i][0]=Math.min(prices[i],dp[i-1][0]);\n            dp[i][1]=Math.max(dp[i-1][1],prices[i]-dp[i-1][0]);\n        }\n        return dp[len-1][1];\n    }\n}\n```\n\n贴一下卡哥的方便学习：\n\n```java \nclass Solution {\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        // dp[i][0]代表第i天持有股票的最大收益=买入/不卖出\n        // dp[i][1]代表第i天不持有股票的最大收益=不买入/卖出\n        int[][] dp = new int[len][2];\n        dp[0][0] = -prices[0];//第一天就买入\n        dp[0][1] = 0;//第一天不买入\n        for (int i = 1; i < len; i++) {\n            //dp[i - 1][0]：今天没动作=前一天持有股票的最大利益\n            //-prices[i]：换买入今天的股票\n            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n            //dp[i - 1][1]：今天没动作=前一天不持有股票的最大利益\n            //dp[i - 1][0] + prices[i]：今天卖出之前持有的股票\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n        }\n        return dp[len - 1][1];\n    }\n}\n```\n\n\n\n### <span id=\"head28\">🟡122. 买卖股票的最佳时机 II</span>\n\n> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n>\n> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n>\n> 返回 *你能获得的 **最大** 利润* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [7,1,5,3,6,4]\n> 输出：7\n> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n>      总利润为 4 + 3 = 7 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,2,3,4,5]\n> 输出：4\n> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n>      总利润为 4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：prices = [7,6,4,3,1]\n> 输出：0\n> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 3 * 104`\n> - `0 <= prices[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution{\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        int[][] dp = new int[len][2];\n        dp[0][0] = -prices[0];//第一天就买入股票\n        dp[0][1] = 0;//第一天不买入股票\n        for (int i = 1; i < len; i++) {\n            //dp[i - 1][0]:今天无动作\n            //dp[i - 1][1] - prices[i]：在之前的基础上买入今天的股票\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n            //dp[i - 1][1]：今天无动作\n            //dp[i - 1][0] + prices[i]：今天卖出之前的股票\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n        }\n        return dp[len - 1][1];   \n    }\n}\n```\n\n\n\n### <span id=\"head29\">🔴123. 买卖股票的最佳时机 III</span>\n\n> 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。\n>\n> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。\n>\n> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入：prices = [3,3,5,0,0,3,1,4]\n> 输出：6\n> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,2,3,4,5]\n> 输出：4\n> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：prices = [7,6,4,3,1] \n> 输出：0 \n> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：prices = [1]\n> 输出：0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 105`\n> - `0 <= prices[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution{\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        int[][] dp = new int[len][4];\n        dp[0][0] = -prices[0];\n        dp[0][2] = -prices[0];\n        for (int i = 1; i < len; i++) {\n            //dp[i - 1][0]：今天没动作\n            //-prices[i]：换买入今天的股票\n            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n            //dp[i - 1][1]：今天没动作\n            //dp[i - 1][0] + prices[i]：今天卖出之前持有的股票\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n            //dp[i - 1][2]:今天无动作\n            //dp[i - 1][1] - prices[i]：在之前的基础上买入今天的股票\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]);\n            //dp[i - 1][3]：今天无动作\n            //dp[i - 1][2] + prices[i]：今天卖出之前的股票\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);\n        }\n        return dp[len - 1][3];\n    }\n}\n```\n\n\n\n### <span id=\"head30\">🔴188. 买卖股票的最佳时机 IV</span>\n\n> 给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。\n>\n> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。\n>\n> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：k = 2, prices = [2,4,1]\n> 输出：2\n> 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：k = 2, prices = [3,2,6,5,0,3]\n> 输出：7\n> 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n>      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= k <= 100`\n> - `1 <= prices.length <= 1000`\n> - `0 <= prices[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution{\n    public int maxProfit(int k, int[] prices) {\n        int len = prices.length;\n        int[][] dp = new int[len][k*2];\n        for (int i = 0; i < k; i++) {\n            dp[0][i*2]=-prices[0];\n        }\n        for (int i = 1; i < len; i++) {\n            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n            for (int j = 1; j < k; j++) {\n                dp[i][j*2]=Math.max(dp[i - 1][j*2], dp[i - 1][j*2-1] - prices[i]);\n                dp[i][j*2+1] = Math.max(dp[i - 1][j*2+1], dp[i - 1][j*2] + prices[i]);\n            }\n        }\n        return dp[len - 1][k*2-1];\n    }\n}\n```\n\n\n\n### <span id=\"head31\">🟡309. 买卖股票的最佳时机含冷冻期</span>\n\n> 给定一个整数数组 `prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。\n>\n> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n>\n> - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n>\n> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: prices = [1,2,3,0,2]\n> 输出: 3 \n> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: prices = [1]\n> 输出: 0\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 5000`\n> - `0 <= prices[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n![image-20240110170035948](23-9-10-algorithm-dp/image-20240110170035948.png)\n\n```java \nclass Solution {\n    public int maxProfit(int[] prices) {\n        int len=prices.length;\n        int[][]dp=new int[len][4];\n        dp[0][0]=-prices[0];\n        for (int i = 1; i < len; i++) {\n            //dp[i][0]：买入状态\n                //dp[i-1][0]：无动作\n                //dp[i-1][1]-price[i]：在原先的基础上买入股票\n                //dp[i-1][3]-price[i]：冻结之后买入股票\n            dp[i][0]=Math.max(dp[i-1][0],Math.max(dp[i-1][1],dp[i-1][3])-prices[i]);\n            //dp[i][1]：卖出状态\n                //dp[i-1][1]：无动作\n                //dp[i-1][3]：冻结之后进入卖出状态\n            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][3]);\n            //dp[i][2]：今天卖出\n                //dp[i-1][0]+prices[i]：卖出股票\n            dp[i][2]=dp[i-1][0]+prices[i];\n            //dp[i][3]：冻结状态\n                //dp[i-1][2]：等于前一天的\n            dp[i][3]=dp[i-1][2];\n        }\n        return Math.max(dp[len-1][1],Math.max(dp[len-1][2],dp[len-1][3]));\n    }\n}\n```\n\n### <span id=\"head32\">🟡714. 买卖股票的最佳时机含手续费</span>\n\n> 给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。\n>\n> 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n>\n> 返回获得利润的最大值。\n>\n> **注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2\n> 输出：8\n> 解释：能够达到的最大利润:  \n> 在此处买入 prices[0] = 1\n> 在此处卖出 prices[3] = 8\n> 在此处买入 prices[4] = 4\n> 在此处卖出 prices[5] = 9\n> 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,3,7,5,10,3], fee = 3\n> 输出：6\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 5 * 104`\n> - `1 <= prices[i] < 5 * 104`\n> - `0 <= fee < 5 * 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int len = prices.length;\n        int[][] dp = new int[len][2];\n        dp[0][0] = -prices[0];//第一天就买入股票\n        dp[0][1] = 0;//第一天不买入股票\n        for (int i = 1; i < len; i++) {\n            //dp[i - 1][0]:今天无动作\n            //dp[i - 1][1] - prices[i]：在之前的基础上买入今天的股票\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n            //dp[i - 1][1]：今天无动作\n            //dp[i - 1][0] + prices[i]：今天卖出之前的股票\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]-fee);\n        }\n        return dp[len - 1][1];\n    }\n}\n```\n\n\n\n# <span id=\"head33\"> 子序列系列</span>\n\n## <span id=\"head34\"> 不连续子序列</span>\n\n### <span id=\"head35\">🟡300. 最长递增子序列</span>\n\n> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n>\n> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [10,9,2,5,3,7,101,18]\n> 输出：4\n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,0,3,2,3]\n> 输出：4\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [7,7,7,7,7,7,7]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 2500`\n> - `-104 <= nums[i] <= 104`\n>\n> \n>\n> **进阶：**\n>\n> - 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int len= nums.length;\n        if(len==1){\n            return 1;\n        }\n        int[]dp=new int[len];\n        Arrays.fill(dp,1);\n        int res=0;\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j < i; j++) {\n                if(nums[i]>nums[j]){\n                    dp[i]=Math.max(dp[j]+1,dp[i]);\n                }\n            }\n            res=Math.max(res,dp[i]);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### <span id=\"head36\">🟡1143. 最长公共子序列</span>\n\n> 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n>\n> 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n>\n> - 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n>\n> 两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：text1 = \"abcde\", text2 = \"ace\" \n> 输出：3  \n> 解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：text1 = \"abc\", text2 = \"abc\"\n> 输出：3\n> 解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：text1 = \"abc\", text2 = \"def\"\n> 输出：0\n> 解释：两个字符串没有公共子序列，返回 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= text1.length, text2.length <= 1000`\n> - `text1` 和 `text2` 仅由小写英文字符组成。\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m=text1.length(),n=text2.length();\n        int[][]dp=new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if(text1.charAt(i-1)==text2.charAt(j-1)){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n### <span id=\"head37\">🟡1035. 不相交的线</span>\n\n> 在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。\n>\n> 现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：\n>\n> - `nums1[i] == nums2[j]`\n> - 且绘制的直线不与任何其他连线（非水平线）相交。\n>\n> 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n>\n> 以这种方法绘制线条，并返回可以绘制的最大连线数。\n>\n> \n>\n> **示例 1：**\n>\n> <img src=\"https://assets.leetcode.com/uploads/2019/04/26/142.png\" alt=\"img\" style=\"zoom: 25%;\" />\n>\n> ```\n> 输入：nums1 = [1,4,2], nums2 = [1,2,4]\n> 输出：2\n> 解释：可以画出两条不交叉的线，如上图所示。 \n> 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n> 输出：3\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 500`\n> - `1 <= nums1[i], nums2[j] <= 2000`\n>\n> \n>\n> Related Topics\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int maxUncrossedLines(int[] nums1, int[] nums2) {\n        int m=nums1.length,n=nums2.length;\n        int [][]dp=new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if(nums1[i-1]==nums2[j-1]){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```\n\n## <span id=\"head38\"> 连续子序列</span>\n\n### <span id=\"head39\">🟢674. 最长连续递增序列</span>\n\n> 给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。\n>\n> **连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,5,4,7]\n> 输出：3\n> 解释：最长连续递增序列是 [1,3,5], 长度为3。\n> 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,2,2,2,2]\n> 输出：1\n> 解释：最长连续递增序列是 [2], 长度为1。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-109 <= nums[i] <= 109`\n>\n> Related Topics\n>\n> 数组\n\n```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        int max=1;\n        int len=nums.length;\n        for (int i = 1; i < len; i++) {\n            int cnt=1;\n            for (int j = i; j < len; j++) {\n                if(nums[j]>nums[j-1]){\n                    cnt++;\n                }else{\n                    break;\n                }\n            }\n            if(cnt>max){\n                max=cnt;\n            }\n        }\n        return max;\n    }\n}\n```\n\n### <span id=\"head40\">🟡718. 最长重复子数组</span>\n\n> 给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n> 输出：3\n> 解释：长度最长的公共子数组是 [3,2,1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n> 输出：5\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 二分查找\n>\n> 动态规划\n>\n> 滑动窗口\n>\n> 哈希函数\n>\n> 滚动哈希\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int m=nums1.length,n=nums2.length;\n        int res=0;\n        int[][]dp=new int[m+1][n+1];\n        for (int i = 1; i <=m ; i++) {\n            for (int j = 1; j <=n ; j++) {\n                if(nums1[i-1]==nums2[j-1]){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                if(dp[i][j]>res){\n                    res=dp[i][j];\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n### <span id=\"head41\">🟡53. 最大子数组和</span>\n\n> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n> **子数组** 是数组中的一个连续部分。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：1\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [5,4,-1,7,8]\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-104 <= nums[i] <= 104`\n>\n> \n>\n> **进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int len=nums.length;\n        int res = nums[0];\n        int[] dp = new int[len];\n        dp[0] = nums[0];\n        for (int i = 1; i < len; i++) {\n            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);\n            res = res > dp[i] ? res : dp[i];\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head42\"> 编辑距离</span>\n\n### <span id=\"head43\">🟢392. 判断子序列</span>\n\n> 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。\n>\n> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n>\n> **进阶：**\n>\n> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n>\n> **致谢：**\n>\n> 特别感谢 [@pbrother ](https://leetcode.com/pbrother/)添加此问题并且创建所有测试用例。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abc\", t = \"ahbgdc\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"axc\", t = \"ahbgdc\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= s.length <= 100`\n> - `0 <= t.length <= 10^4`\n> - 两个字符串都只由小写字符组成。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n>\n> 动态规划\n\n```java\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int m=s.length(),n=t.length();\n        int[][]dp=new int[m+1][n+1];\n        for (int i = 1; i <= m ; i++) {\n            for (int j = 1; j <= n; j++) {\n                if(s.charAt(i-1)==t.charAt(j-1)){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n]==m;\n    }\n}\n```\n\n### <span id=\"head44\">🔴115. 不同的子序列</span>\n\n> 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"rabbbit\", t = \"rabbit\"\n> 输出：3\n> 解释：\n> 如下所示, 有 3 种可以从 s 中得到 \"rabbit\" 的方案。\n> ```\n>\n> ![image-20240111144859038](23-9-10-algorithm-dp/image-20240111144859038.png)\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"babgbag\", t = \"bag\"\n> 输出：5\n> 解释：\n> 如下所示, 有 5 种可以从 s 中得到 \"bag\" 的方案。 \n> ```\n>\n> ![image-20240111144833629](23-9-10-algorithm-dp/image-20240111144833629.png)\n>\n> **提示：**\n>\n> - `1 <= s.length, t.length <= 1000`\n> - `s` 和 `t` 由英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n\n```java\n```\n\n\n\n### <span id=\"head45\">🟡583. 两个字符串的删除操作</span>\n\n> 给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。\n>\n> **每步** 可以删除任意一个字符串中的一个字符。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: word1 = \"sea\", word2 = \"eat\"\n> 输出: 2\n> 解释: 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：word1 = \"leetcode\", word2 = \"etco\"\n> 输出：4\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= word1.length, word2.length <= 500`\n> - `word1` 和 `word2` 只包含小写英文字母\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int m=word1.length(),n=word2.length();\n        int[][]dp=new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if(word1.charAt(i-1)==word2.charAt(j-1)){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }else{\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return m+n-2*dp[m][n];\n    }\n}\n```\n\n### <span id=\"head46\">🔴72. 编辑距离</span>\n\n> 给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。\n>\n> 你可以对一个单词进行如下三种操作：\n>\n> - 插入一个字符\n> - 删除一个字符\n> - 替换一个字符\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：word1 = \"horse\", word2 = \"ros\"\n> 输出：3\n> 解释：\n> horse -> rorse (将 'h' 替换为 'r')\n> rorse -> rose (删除 'r')\n> rose -> ros (删除 'e')\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：word1 = \"intention\", word2 = \"execution\"\n> 输出：5\n> 解释：\n> intention -> inention (删除 't')\n> inention -> enention (将 'i' 替换为 'e')\n> enention -> exention (将 'n' 替换为 'x')\n> exention -> exection (将 'n' 替换为 'c')\n> exection -> execution (插入 'u')\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= word1.length, word2.length <= 500`\n> - `word1` 和 `word2` 由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n\n```java\n```\n\n\n\n## <span id=\"head47\"> 回文</span>\n\n### <span id=\"head48\">🟡647. 回文子串</span>\n\n> 给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。\n>\n> **回文字符串** 是正着读和倒过来读一样的字符串。\n>\n> **子字符串** 是字符串中的由连续字符组成的一个序列。\n>\n> 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abc\"\n> 输出：3\n> 解释：三个回文子串: \"a\", \"b\", \"c\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"aaa\"\n> 输出：6\n> 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 1000`\n> - `s` 由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n\n```java\n```\n\n### <span id=\"head49\">🟡516. 最长回文子序列</span>\n","categories":["algorithm learning"]},{"title":"Greedy","url":"/2023/09/09/algorithm-greedy/","content":"\n|                   |              分类               | 编号 | 是否完成 | 题号                                        | 标签         |\n| ----------------- | :-----------------------------: | ---- | :------: | :------------------------------------------ | ------------ |\n| [ 简单题](#head1) |                                 | 1    |    ✅     | [🟢455. 分发饼干](#head2)                    | 双指针       |\n|                   |                                 | 2    |    ✅     | [🟢1005.K 次取反后最大化的数组和](#head3)    | 贪心         |\n|                   |                                 | 3    |    ✅     | [🟢860. 柠檬水找零](#head4)                  | 贪心         |\n| 中等问题          |       [ 序列问题](#head5)       | 4    |    ✅     | [🟡376. 摆动序列](#head6)                    | 贪心         |\n|                   |                                 | 5    |    ✅     | [🟡738. 单调递增的数字](#head7)              | 简化数组     |\n|                   | [ 贪心算法解决股票问题](#head8) | 6    |    ✅     | [🟡122.买卖股票的最佳时机 II](#head9)        | 贪心         |\n|                   |                                 | 7    |          | [🟡714. 买卖股票的最佳时机含手续费](#head10) |              |\n|                   | [ 两个维度的权衡问题](#head11)  | 8    |    ✅     | [ 🔴135.分发糖果](#head12)                   | 贪心         |\n|                   |                                 | 9    |    ✅     | [🟡406. 根据身高重建队列](#head13)           | 贪心         |\n| 有点难度          |      [ 区间问题](#head14)       | 10   |    ✅     | [🟡55. 跳跃游戏](#head15)                    | 贪心         |\n|                   |                                 | 11   |    ✅     | [🟡45. 跳跃游戏 II](#head16)                 | 贪心         |\n|                   |                                 | 12   |    ✅     | [ 🟡452.用最少数量的箭引爆气球](#head17)     | 贪心         |\n|                   |                                 | 13   |    ✅     | [🟡435. 无重叠区间](#head18)                 | 贪心         |\n|                   |                                 | 14   |    ✅     | [🟡763. 划分字母区间](#head19)               | 贪心  字符串 |\n|                   |                                 | 15   |    ✅     | [🟡56. 合并区间](#head20)                    | 贪心         |\n|                   |        [ 其他](#head21)         | 16   |    ✅     | [🟡53. 最大子数组和](#head22)                | 贪心         |\n|                   |                                 | 17   |          | [ 🟡134.加油站](#head23)                     |              |\n|                   |                                 | 18   |          | [🔴968. 监控二叉树](#head24)                 |              |\n\n# <span id=\"head1\"> 简单题</span>\n\n## <span id=\"head2\">🟢455. 分发饼干</span>\n\n> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n>\n> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n>\n> **示例 1:**\n>\n> ```\n> 输入: g = [1,2,3], s = [1,1]\n> 输出: 1\n> 解释: \n> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n> 所以你应该输出1。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: g = [1,2], s = [1,2,3]\n> 输出: 2\n> 解释: \n> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n> 你拥有的饼干数量和尺寸都足以让所有孩子满足。\n> 所以你应该输出2.\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= g.length <= 3 * 104`\n> - `0 <= s.length <= 3 * 104`\n> - `1 <= g[i], s[j] <= 231 - 1`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        int cnt=0;\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i=0,j=0;\n        while(i<g.length&&j<s.length){\n            if(g[i]<=s[j]){\n                cnt++;\n                i++;\n                j++;\n            }else if(i<g.length){\n                j++;\n            }else{\n                i++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n## <span id=\"head3\">🟢1005.K 次取反后最大化的数组和</span>\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：\n>\n> - 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。\n>\n> 重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。\n>\n> 以这种方式修改数组后，返回数组 **可能的最大和** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,2,3], k = 1\n> 输出：5\n> 解释：选择下标 1 ，nums 变为 [4,-2,3] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,-1,0,2], k = 3\n> 输出：6\n> 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [2,-3,-1,5,-4], k = 2\n> 输出：13\n> 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-100 <= nums[i] <= 100`\n> - `1 <= k <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 排序\n\n```java\nclass Solution {\n    public int largestSumAfterKNegations(int[] nums, int k) {\n        Arrays.sort(nums);\n        int res=0;\n        for (int i = 0; i < nums.length; i++) {\n            if(nums[i]<0&&k>0){\n                nums[i]=(-1)*nums[i];\n                k--;\n            } else if (k>0&&k%2==1) {\n                Arrays.sort(nums);\n                nums[0]=(-1)*nums[0];                \n                k=0;\n            }\n        }\n        if(k>0&&k%2==1){\n            Arrays.sort(nums);\n            nums[0]=(-1)*nums[0];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            res+=nums[i];\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head4\">🟢860. 柠檬水找零</span>\n\n> 在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n>\n> 每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n>\n> 注意，一开始你手头没有任何零钱。\n>\n> 给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：bills = [5,5,5,10,20]\n> 输出：true\n> 解释：\n> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n> 由于所有客户都得到了正确的找零，所以我们输出 true。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：bills = [5,5,10,10,20]\n> 输出：false\n> 解释：\n> 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n> 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n> 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n> 由于不是每位顾客都得到了正确的找零，所以答案是 false。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= bills.length <= 105`\n> - `bills[i]` 不是 `5` 就是 `10` 或是 `20`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n```java\nclass Solution {\n    public boolean lemonadeChange(int[] bills) {\n        boolean  res=true;\n        int cnt_5=0,cnt_10=0;\n        for (int i = 0; i < bills.length; i++) {\n            if(bills[i]==5){\n                cnt_5++;\n            }else if(bills[i]==10){\n                if(cnt_5>0){\n                    cnt_5--;\n                    cnt_10++;\n                }else{\n                    res=false;\n                    break;\n                }\n            }else{\n                if(cnt_5>0&&cnt_10>0){\n                    cnt_5--;\n                    cnt_10--;\n                }else if(cnt_5>2){\n                    cnt_5-=3;\n                }else{\n                    res=false;\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n# <span id=\"head5\"> 序列问题</span>\n\n## <span id=\"head6\">🟡376. 摆动序列</span>\n\n> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n>\n> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。\n> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n>\n> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n>\n> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,7,4,9,2,5]\n> 输出：6\n> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,17,5,10,13,15,10,5,16,8]\n> 输出：7\n> 解释：这个序列包含几个长度为 7 摆动序列。\n> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1,2,3,4,5,6,7,8,9]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `0 <= nums[i] <= 1000`\n>\n> \n>\n> **进阶：**你能否用 `O(n)` 时间复杂度完成此题?\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int wiggleMaxLength(int[] nums) {\n        int len= nums.length;\n        if(len==1){\n            return 1;\n        }\n        if(len==2&&nums[0]!=nums[1]){\n            return 2;\n        }else if(len==2){\n            return 1;\n        }\n        int[] arr=new int[len-1];\n        for (int i = 0; i < len-1; i++) {\n            arr[i]=nums[i+1]-nums[i];\n        }\n        int index=0;\n        while(index<len-1&&arr[index]==0){\n            index++;\n        }\n        if(index==len-1){\n            return 1;\n        }\n        int flag=arr[index],cnt=2;\n        for (int i = index+1; i < len-1; i++) {\n            if(flag*arr[i]<0){\n                cnt++;\n                flag=arr[i];\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n用卡哥的方法试一下：\n\n```java\n public int wiggleMaxLength(int[] nums) {\n        int len= nums.length;\n        if(len==1){\n            return 1;\n        }\n        if(len==2&&nums[0]!=nums[1]){\n            return 2;\n        }else if(len==2){\n            return 1;\n        }\n        int res=1;\n        int lastDiff=0,curDiff=0;\n        for (int i = 1; i < nums.length; i++) {\n            curDiff=nums[i]-nums[i-1];\n            if(curDiff>0&&lastDiff<=0||curDiff<0&&lastDiff>=0){\n                res++;\n                lastDiff=curDiff;\n            }\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head7\">🟡738. 单调递增的数字</span>\n\n> 当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。\n>\n> 给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: n = 10\n> 输出: 9\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: n = 1234\n> 输出: 1234\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: n = 332\n> 输出: 299\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `0 <= n <= 109`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数学\n\n```java\nclass Solution {\n    public int monotoneIncreasingDigits(int n) {\n        StringBuilder sb=new StringBuilder(String.valueOf(n));\n        while(check(sb)!=-1){\n            int i=check(sb);\n            sb.replace(i-1,i,String.valueOf(sb.charAt(i-1)-'1'));\n            for (int j = i; j < sb.length(); j++) {\n                sb.replace(j,j+1,String.valueOf(9));\n            }\n        }\n        return Integer.valueOf(sb.toString());\n    }\n    int check(StringBuilder sb){\n        if(sb.length()==1){\n            return -1;\n        }\n        for (int i = 1; i < sb.length(); i++) {\n            if(sb.charAt(i)< sb.charAt(i-1)){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n# <span id=\"head8\"> 贪心算法解决股票问题</span>\n\n## <span id=\"head9\">🟡122.买卖股票的最佳时机 II</span>\n\n> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n>\n> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n>\n> 返回 *你能获得的 **最大** 利润* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [7,1,5,3,6,4]\n> 输出：7\n> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n>   总利润为 4 + 3 = 7 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,2,3,4,5]\n> 输出：4\n> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n>   总利润为 4 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：prices = [7,6,4,3,1]\n> 输出：0\n> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 3 * 104`\n> - `0 <= prices[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length==1){\n            return 0;\n        }\n        if(prices.length==2){\n            if(prices[0]<prices[1]){\n                return prices[1]-prices[0];\n            }else{\n                return 0;\n            }\n        }\n        int res=0;\n        for (int i = 1; i < prices.length-1; i++) {\n            if(prices[i-1]<prices[i]){//↑\n                if(prices[i]<prices[i+1]){//↑↑\n                    continue;\n                }else{//↑↓\n                    res+=prices[i];\n                }\n            }else{//↓\n                if(prices[i]<prices[i+1]){//↓↑\n                    res-=prices[i];\n                }else{//↓↓\n                    continue;\n                }\n            }\n        }\n        if(prices[0]<prices[1]){\n            res-=prices[0];\n        }\n        if(prices[prices.length-2]<prices[prices.length-1]){\n            res+=prices[prices.length-1];\n        }\n        return res;\n    }\n}\n```\n\nman，看完我写的，再看卡哥写的，太可笑了吧\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int result = 0;\n        for (int i = 1; i < prices.length; i++) {\n            result += Math.max(prices[i] - prices[i - 1], 0);\n        }\n        return result;\n    }\n}\n```\n\n## <span id=\"head10\">🟡714. 买卖股票的最佳时机含手续费</span>\n\n> 给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。\n>\n> 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n>\n> 返回获得利润的最大值。\n>\n> **注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2\n> 输出：8\n> 解释：能够达到的最大利润:  \n> 在此处买入 prices[0] = 1\n> 在此处卖出 prices[3] = 8\n> 在此处买入 prices[4] = 4\n> 在此处卖出 prices[5] = 9\n> 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：prices = [1,3,7,5,10,3], fee = 3\n> 输出：6\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= prices.length <= 5 * 104`\n> - `1 <= prices[i] < 5 * 104`\n> - `0 <= fee < 5 * 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\n\n```\n\n# <span id=\"head11\"> 两个维度的权衡问题</span>\n\n## <span id=\"head12\"> 🔴135.分发糖果</span>\n\n> `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。\n>\n> 你需要按照以下要求，给这些孩子分发糖果：\n>\n> - 每个孩子至少分配到 `1` 个糖果。\n> - 相邻两个孩子评分更高的孩子会获得更多的糖果。\n>\n> 请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ratings = [1,0,2]\n> 输出：5\n> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ratings = [1,2,2]\n> 输出：4\n> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。\n>      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == ratings.length`\n> - `1 <= n <= 2 * 104`\n> - `0 <= ratings[i] <= 2 * 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n按照模拟的简单思路，写了一个妥妥超时。\n\n```java\nclass Solution {\n    public int candy(int[] ratings) {\n        int len=ratings.length;\n        int[]arr=new int[len];\n        Arrays.fill(arr,1);\n        while(!check(ratings,arr)){\n            for (int i = 1; i < ratings.length; i++) {\n                if(ratings[i]>ratings[i-1]&&arr[i]<=arr[i-1]){\n                    arr[i]++;\n                }\n            }\n            for (int i = 0; i < ratings.length-1; i++) {\n                if(ratings[i]>ratings[i+1]&&arr[i]<=arr[i+1]){\n                    arr[i]++;\n                }\n            }\n        }\n        for (int i = 0; i < ratings.length; i++) {\n            System.out.print(arr[i]+\" \");\n        }\n        System.out.println();\n        return Arrays.stream(arr).sum();\n    }\n    boolean check(int[] ratings,int[] arr){\n        for (int i = 1; i < ratings.length; i++) {\n            if(ratings[i]>ratings[i-1]&&arr[i]<=arr[i-1]){\n                return false;\n            }\n        }\n        for (int i = 0; i < ratings.length-1; i++) {\n            if(ratings[i]>ratings[i+1]&&arr[i]<=arr[i+1]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n看了官方题解，左右两次遍历：\n\n```java\nclass Solution {\n    public int candy(int[] ratings) {\n        int len=ratings.length;\n        int[]arr=new int[len];\n        Arrays.fill(arr,1);\n        for (int i = 1; i < ratings.length; i++) {\n            if(ratings[i]>ratings[i-1]){\n                arr[i]=arr[i-1]+1;\n            }\n        }\n        for (int i = ratings.length-2; i >=0 ; i--) {\n            if(ratings[i]>ratings[i+1]&&arr[i]<=arr[i+1]){\n                arr[i]=Math.max(arr[i+1]+1,arr[i]);\n            }\n        }\n        return Arrays.stream(arr).sum();\n    }\n}\n```\n\n## <span id=\"head13\">🟡406. 根据身高重建队列</span>\n\n> 假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。\n>\n> 请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n> 解释：\n> 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n> 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n> 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n> 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n> 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n> 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n> 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n> 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= people.length <= 2000`\n> - `0 <= hi <= 106`\n> - `0 <= ki < people.length`\n> - 题目数据确保队列可以被重建\n>\n> Related Topics\n>\n> 贪心\n>\n> 树状数组\n>\n> 线段树\n>\n> 数组\n>\n> 排序\n\n```java\nclass Solution {\n    static class People{\n        int height;\n        int no;\n        People(int height,int no){\n            this.height=height;\n            this.no=no;\n        }\n    }\n    public int[][] reconstructQueue(int[][] people) {\n        List<Solution.People> list=new ArrayList<>();\n        for (int i = 0; i < people.length; i++) {\n            list.add(new Solution.People(people[i][0],people[i][1]));\n        }\n\n        Comparator<Solution.People>comp=new Comparator<Solution.People>() {\n            @Override\n            public int compare(Solution.People o1, Solution.People o2) {\n                if(o1.no== o2.no){\n                    return o1.height-o2.height;\n                }else{\n                    return o1.no-o2.no;\n                }\n            }\n        };\n        Collections.sort(list,comp);\n\n        for (int i = 0; i < list.size(); i++) {\n            int cnt=list.get(i).no;\n            int index=0;\n            while(cnt>0&&index<=i){\n                if(list.get(index).height>=list.get(i).height){\n                    cnt--;\n                }\n                index++;\n            }\n            while (list.get(index).height<list.get(i).height){\n                index++;\n            }\n            list.add(index,list.get(i));\n            list.remove(i+1);\n        }\n        for (int i = 0; i < people.length; i++) {\n            people[i][0]=list.get(i).height;\n            people[i][1]=list.get(i).no;\n        }\n        return people;\n    }\n}\n```\n\n我写的巨长，贴个卡哥的：\n\n```java\nclass Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        // 身高从大到小排（身高相同k小的站前面）\n        Arrays.sort(people, (a, b) -> {\n            if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列\n            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列\n        });\n\n        LinkedList<int[]> que = new LinkedList<>();\n\n        for (int[] p : people) {\n            que.add(p[1],p);   //Linkedlist.add(index, value)，會將value插入到指定index裡。\n        }\n\n        return que.toArray(new int[people.length][]);\n    }\n}\n\n```\n\ndamn! 有我没用过的方法：\n\n1.Arrays.sort(二维数组名,())：提供的代码使用了 `Arrays.sort()` 方法来根据两个标准对一个人员数组进行排序。它使用了一个 Lambda 表达式 `(a, b) -> { ... }` 来定义排序逻辑。\n\n在 Lambda 表达式内部，代码比较了 `a[0]` 和 `b[0]` 的值来确定元素的顺序。如果 `a[0]` 等于 `b[0]`，则会比较 `a[1]` 和 `b[1]` 来进一步细化排序顺序。这确保了当 `a[0]` 等于 `b[0]` 时，元素将按照 `a[1]` 的升序进行排序。\n\n然而，如果 `a[0]` 不等于 `b[0]`，代码返回 `b[0] - a[0]` 的结果。这意味着在 `a[0]` 不等于 `b[0]` 的情况下，元素将按照 `a[0]` 的降序进行排序。\n\n总之，这段代码根据特定规则对 `people` 数组进行排序：当 `a[0]` 等于 `b[0]` 时，按照 `a[1]` 的升序排序；当 `a[0]` 不等于 `b[0]` 时，按照 `a[0]` 的降序排序。\n\n```java\n Arrays.sort(people, (a, b) -> {\n            if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列\n            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列\n        });\n\n```\n\n2.容器顺序插入结果恰好即为所求\n\n# <span id=\"head14\"> 区间问题</span>\n\n## <span id=\"head15\">🟡55. 跳跃游戏</span>\n\n> 给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n>\n> 判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,1,0,4]\n> 输出：false\n> 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `0 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int max=0;\n        for (int i = 0; i < nums.length-1; i++) {\n            if(max>=i){\n                max=Math.max(max,i+nums[i]);\n            }\n        }\n        if(max>=nums.length-1){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n```\n\n## <span id=\"head16\">🟡45. 跳跃游戏 II</span>\n\n> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。\n>\n> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:\n>\n> - `0 <= j <= nums[i]`\n> - `i + j < n`\n>\n> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [2,3,1,1,4]\n> 输出: 2\n> 解释: 跳到最后一个位置的最小跳跃数是 2。\n>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [2,3,0,1,4]\n> 输出: 2\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= nums.length <= 104`\n> - `0 <= nums[i] <= 1000`\n> - 题目保证可以到达 `nums[n-1]`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int jump(int[] nums) {\n        int max=nums[0], cnt=0,index=1;\n        while(index<= nums.length-1){\n            int reach=max;\n            cnt++;\n            for (int i = index; i <= reach&& i< nums.length; i++) {\n                max=Math.max(max,i+nums[i]);\n            }\n            index=reach+1;\n        }\n        return cnt;\n    }\n}\n```\n\n## <span id=\"head17\"> 🟡452.用最少数量的箭引爆气球</span>\n\n> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。\n>\n> 一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足 `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。\n>\n> 给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。\n>\n> **示例 1：**\n>\n> ```\n> 输入：points = [[10,16],[2,8],[1,6],[7,12]]\n> 输出：2\n> 解释：气球可以用2支箭来爆破:\n> -在x = 6处射出箭，击破气球[2,8]和[1,6]。\n> -在x = 11处发射箭，击破气球[10,16]和[7,12]。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：points = [[1,2],[3,4],[5,6],[7,8]]\n> 输出：4\n> 解释：每个气球需要射出一支箭，总共需要4支箭。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：points = [[1,2],[2,3],[3,4],[4,5]]\n> 输出：2\n> 解释：气球可以用2支箭来爆破:\n> - 在x = 2处发射箭，击破气球[1,2]和[2,3]。\n> - 在x = 4处射出箭，击破气球[3,4]和[4,5]。\n> ```\n>\n> \n>\n> \n>\n> **提示:**\n>\n> - `1 <= points.length <= 105`\n> - `points[i].length == 2`\n> - `-231 <= xstart < xend <= 231 - 1`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 排序\n\n```java\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\n        int cnt=1;\n        for (int i = 1; i < points.length; i++) {\n            if(points[i][0]>points[i-1][1]){\n                cnt++;\n            }else{\n                points[i][1]=Math.min(points[i][1],points[i-1][1]);\n            }\n        }\n        return cnt;\n    }\n}\n```\n\n使用 Java 8 中的 Lambda 表达式来对 `points` 数组进行排序。`Arrays.sort` 方法接受一个比较器作为参数，该比较器用于确定数组中的元素的顺序：\n\n```java\n Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));\n```\n\n相当于：\n\n```java\nArrays.sort(points, new Comparator<int[]>() {\n    @Override\n    public int compare(int[] a, int[] b) {\n        return Integer.compare(a[0], b[0]);\n    }\n});\n```\n\n也相当于：\n\n```java\nArrays.sort(points, Comparator.comparingInt(arr -> arr[0]));\n```\n\n## <span id=\"head18\">🟡435. 无重叠区间</span>\n\n> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]\n> 输出: 1\n> 解释: 移除 [1,3] 后，剩下的区间没有重叠。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: intervals = [ [1,2], [1,2], [1,2] ]\n> 输出: 2\n> 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: intervals = [ [1,2], [2,3] ]\n> 输出: 0\n> 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n> ```\n>\n> **提示:**\n>\n> - `1 <= intervals.length <= 105`\n> - `intervals[i].length == 2`\n> - `-5 * 104 <= starti < endi <= 5 * 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n>\n> 动态规划\n>\n> 排序\n\n```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        int len=intervals.length;\n        Arrays.sort(intervals,(a,b)->Integer.compare(a[1],b[1]));\n        int cnt=1,right=intervals[0][1];\n        for (int i = 1; i < len; i++) {\n            if(intervals[i][0]>=intervals[i-1][1]){\n                cnt++;\n            }else{\n                intervals[i][1]=Math.min(intervals[i][1],intervals[i-1][1]);\n                continue;\n            }\n        }\n        return len-cnt;\n    }\n}\n```\n\n到了这道题才慢慢领悟到了贪心的奥义。题目要求移除最少的区间，那么相对于长区间，会偏向于短的区间。思路是从左至右保留更短的区间。因此，需要按区间右边排序。\n\n## <span id=\"head19\">🟡763. 划分字母区间</span>\n\n> 给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\n>\n> 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。\n>\n> 返回一个表示每个字符串片段的长度的列表。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ababcbacadefegdehijhklij\"\n> 输出：[9,7,8]\n> 解释：\n> 划分结果为 \"ababcbaca\"、\"defegde\"、\"hijhklij\" 。\n> 每个字母最多出现在一个片段中。\n> 像 \"ababcbacadefegde\", \"hijhklij\" 这样的划分是错误的，因为划分的片段数较少。 \n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"eccbbbbdec\"\n> 输出：[10]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 500`\n> - `s` 仅由小写英文字母组成\n>\n> Related Topics\n>\n> 贪心\n>\n> 哈希表\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public List<Integer> partitionLabels(String s) {\n        List<List<Integer>>temp=new ArrayList<>();\n        List<Integer>res=new ArrayList<>();\n        temp=build(s);\n        Collections.sort(temp,(a,b)->Integer.compare(a.get(0),b.get(0)));\n        int left=temp.get(0).get(0);\n        for (int i = 1; i < temp.size(); i++) {\n            if(temp.get(i).get(0)<temp.get(i-1).get(1)){//交叉\n                temp.get(i).set(1, Math.max(temp.get(i).get(1), temp.get(i-1).get(1)));\n            }else{//不交叉\n                res.add(temp.get(i).get(0)-left);\n                left=temp.get(i).get(0);\n            }\n        }\n        res.add(temp.get(temp.size()-1).get(1)-left+1);\n        return res;\n    }\n    List<List<Integer>> build(String s){\n        List<List<Integer>>out=new ArrayList<>();\n        Set<Character>set=new HashSet<>();\n        int index=0;\n        while(index<s.length()){\n            if(!set.contains(s.charAt(index))){\n                out.add(find(s,s.charAt(index)));\n                set.add(s.charAt(index));\n            }\n            index++;\n        }\n        return out;\n    }\n    List<Integer>find(String s,char c){\n        List<Integer>list=new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i)==c){\n                list.add(i);\n                break;\n            }\n        }\n        for (int i = s.length()-1; i >= 0; i--) {\n            if(s.charAt(i)==c){\n                list.add(i);\n                break;\n            }\n        }\n        return list;\n    }\n}\n```\n\n## <span id=\"head20\">🟡56. 合并区间</span>\n\n> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n> 输出：[[1,6],[8,10],[15,18]]\n> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：intervals = [[1,4],[4,5]]\n> 输出：[[1,5]]\n> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= intervals.length <= 104`\n> - `intervals[i].length == 2`\n> - `0 <= starti <= endi <= 104`\n>\n> Related Topics\n>\n> 数组\n>\n> 排序\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));\n        List<int []>list =new ArrayList<>();\n        int left=intervals[0][0],right=intervals[0][1];\n        for (int i = 1; i < intervals.length; i++) {\n            if(intervals[i][0]>right){//不交叉，更新左边界，记录之前的区间\n                list.add(new int[]{left,right});\n                left=intervals[i][0];\n                right=intervals[i][1];\n            }else{//交叉，更新右边界\n                right=Math.max(right,intervals[i][1]);\n            }\n        }\n        list.add(new int[]{left,right});\n        int n=list.size();\n        int [][] res=new int[n][2];\n        for (int i = 0; i < n; i++) {\n            res[i][0]=list.get(i)[0];\n            res[i][1]=list.get(i)[1];\n        }\n        return res;\n    }\n}\n```\n\n贴一下卡哥的，可以学到从List<int [ ] >   a到int [ ] [ ] b变形方法。\n\n```java\nb = a.toArray(new int[a.size()][]);\n```\n\n\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        List<int[]> res = new LinkedList<>();\n        //按照左边界排序\n        Arrays.sort(intervals, (x, y) -> Integer.compare(x[0], y[0]));\n        //initial start 是最小左边界\n        int start = intervals[0][0];\n        int rightmostRightBound = intervals[0][1];\n        for (int i = 1; i < intervals.length; i++) {\n            //如果左边界大于最大右边界\n            if (intervals[i][0] > rightmostRightBound) {\n                //加入区间 并且更新start\n                res.add(new int[]{start, rightmostRightBound});\n                start = intervals[i][0];\n                rightmostRightBound = intervals[i][1];\n            } else {\n                //更新最大右边界\n                rightmostRightBound = Math.max(rightmostRightBound, intervals[i][1]);\n            }\n        }\n        res.add(new int[]{start, rightmostRightBound});\n        return res.toArray(new int[res.size()][]);\n    }\n}\n```\n\n# <span id=\"head21\"> 其他</span>\n\n## <span id=\"head22\">🟡53. 最大子数组和</span>\n\n> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n> **子数组** 是数组中的一个连续部分。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：1\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [5,4,-1,7,8]\n> 输出：23\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-104 <= nums[i] <= 104`\n>\n> \n>\n> **进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。\n>\n> Related Topics\n>\n> 数组\n>\n> 分治\n>\n> 动态规划\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int len= nums.length,sum=0,max=Integer.MIN_VALUE;\n        if(len==1){\n            return nums[0];\n        }\n        int idx=0;\n        while(idx<len){\n            sum+=nums[idx];\n            if(max<sum){\n                max=sum;\n            }\n            if(sum<0){\n                sum=0;\n            }\n            idx++;\n        }\n        return max;\n    }\n}\n```\n\n## <span id=\"head23\"> 🟡134.加油站</span>\n\n> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。\n>\n> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。\n>\n> 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n> 输出: 3\n> 解释:\n> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n> 因此，3 可为起始索引。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: gas = [2,3,4], cost = [3,4,3]\n> 输出: -1\n> 解释:\n> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n> 因此，无论怎样，你都不可能绕环路行驶一周。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `gas.length == n`\n> - `cost.length == n`\n> - `1 <= n <= 105`\n> - `0 <= gas[i], cost[i] <= 104`\n>\n> Related Topics\n>\n> 贪心\n>\n> 数组\n\n```java\n```\n\n\n\n## <span id=\"head24\">🔴968. 监控二叉树</span>\n\n> 给定一个二叉树，我们在树的节点上安装摄像头。\n>\n> 节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**\n>\n> 计算监控树的所有节点所需的最小摄像头数量。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)\n>\n> ```\n> 输入：[0,0,null,0,0]\n> 输出：1\n> 解释：如图所示，一台摄像头足以监控所有节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)\n>\n> ```\n> 输入：[0,0,null,0,null,0,null,null,0]\n> 输出：2\n> 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n> ```\n>\n> \n> **提示：**\n>\n> 1. 给定树的节点数的范围是 `[1, 1000]`。\n> 2. 每个节点的值都是 0。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 动态规划\n>\n> 二叉树\n\n```java\n```\n\n","categories":["algorithm learning"]},{"title":"Back Traking","url":"/2023/09/08/algorithm-backtraking/","content":"\n|         分类         | 编号 | 是否完成 | 题号                              | 标签     |\n| :------------------: | ---- | :------: | :-------------------------------- | -------- |\n|   [ 组合](#head1)    | 1    |    ✅     | [🟡77. 组合](#head2)               | 回溯     |\n|                      | 2    |    ✅     | [ 🟡17.电话号码的字母组合](#head3) | 回溯     |\n|                      | 3    |    ✅     | [🟡216. 组合总和 III](#head22)     | 回溯     |\n|                      | 4    |    ✅     | [ 🟡39.组合总和](#head4)           | 回溯     |\n|                      | 5    |    ✅     | [🟡40. 组合总和 II](#head5)        | 回溯     |\n|   [ 分割](#head7)    | 6    |    ✅     | [🟡131. 分割回文串](#head8)        | 回溯     |\n|                      | 7    |    ✅     | [🟡93. 复原 IP 地址](#head9)       | 回溯     |\n|   [ 子集](#head10)   | 8    |    ✅     | [🟡78. 子集](#head11)              | 回溯     |\n|                      | 9    |    ✅     | [🟡90. 子集 II](#head12)           | 回溯     |\n|                      | 10   |    ✅     | [🟡491. 递增子序列](#head13)       | 回溯     |\n|   [ 排列](#head14)   | 11   |    ✅     | [ 🟡46.全排列](#head15)            | 回溯     |\n|                      | 12   |    ✅     | [🟡47. 全排列 II](#head16)         | 回溯     |\n| [ 棋盘问题](#head17) | 13   |    ✅     | [🔴51. N 皇后](#head18)            | 回溯     |\n|                      | 14   |    ✅     | [🔴37. 解数独](#head19)            | 二维回溯 |\n|   [ 其他](#head20)   | 15   |          | [🔴332. 重新安排行程](#head21)     |          |\n\n# <span id=\"head1\"> 组合</span>\n\n## <span id=\"head2\">🟡77. 组合</span>\n\n> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。\n>\n> 你可以按 **任何顺序** 返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 4, k = 2\n> 输出：\n> [\n> [2,4],\n> [3,4],\n> [2,3],\n> [1,2],\n> [1,3],\n> [1,4],\n> ]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1, k = 1\n> 输出：[[1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 20`\n> - `1 <= k <= n`\n>\n> Related Topics\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>> res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> combine(int n, int k) {\n        backtracking(n,k,1);\n        return res;\n    }\n\n    void backtracking(int n, int k, int num) {\n        if (path.size()==k) {\n            res.add(new ArrayList(path));\n            return;\n        }\n        for (int i=num;i<=n;i++) {\n            path.add(i);\n            backtracking(n,k,i+1); // 递归\n            path.removeLast();\n        }\n    }\n}\n```\n\n## <span id=\"head3\"> 🟡17.电话号码的字母组合</span>\n\n> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。\n>\n> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：digits = \"23\"\n> 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：digits = \"\"\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：digits = \"2\"\n> 输出：[\"a\",\"b\",\"c\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= digits.length <= 4`\n> - `digits[i]` 是范围 `['2', '9']` 的一个数字。\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 回溯\n\n```java\nclass Solution {\n    List<String> res=new ArrayList<>();\n    StringBuilder path=new StringBuilder();\n    String[]string={\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    public List<String> letterCombinations(String digits) {\n        if(digits.length()==0){\n            return res;\n        }\n        backtraking(0,digits);//\n        return res;\n    }\n    void backtraking(int num,String digits){//\n        if(path.length()==digits.length()){\n            res.add(path.toString());\n            return;\n        }\n        for (int i = 0; i < string[digits.charAt(num)-'2'].length(); i++) {//\n            path.append(string[digits.charAt(num)-'2'].charAt(i));//\n            backtraking(num+1,digits);//\n            path.deleteCharAt(path.length()-1);\n        }\n    }\n}\n```\n\n## <span id=\"head22\"> 🟡216. 组合总和 III</span>\n\n> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：\n>\n> - 只使用数字1到9\n> - 每个数字 **最多使用一次**\n>\n> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: k = 3, n = 7\n> 输出: [[1,2,4]]\n> 解释:\n> 1 + 2 + 4 = 7\n> 没有其他符合的组合了。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: k = 3, n = 9\n> 输出: [[1,2,6], [1,3,5], [2,3,4]]\n> 解释:\n> 1 + 2 + 6 = 9\n> 1 + 3 + 5 = 9\n> 2 + 3 + 4 = 9\n> 没有其他符合的组合了。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: k = 4, n = 1\n> 输出: []\n> 解释: 不存在有效的组合。\n> 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `2 <= k <= 9`\n> - `1 <= n <= 60`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        backtracking(k,n,1,0);\n        return res;\n    }\n    void backtracking(int k,int n,int start,int sum){\n        if(path.size()==k&&sum==n){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i <= 9; i++) {\n            path.add(i);\n            sum+=i;\n            backtracking(k,n,i+1,sum);\n            path.removeLast();\n            sum-=i;\n        }\n    }\n}\n```\n\n## <span id=\"head4\"> 🟡39.组合总和</span>\n\n> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。\n>\n> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n>\n> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：candidates = [2,3,6,7], target = 7\n> 输出：[[2,2,3],[7]]\n> 解释：\n> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n> 7 也是一个候选， 7 = 7 。\n> 仅有这两种组合。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: candidates = [2,3,5], target = 8\n> 输出: [[2,2,2,2],[2,3,3],[3,5]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入: candidates = [2], target = 1\n> 输出: []\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= candidates.length <= 30`\n> - `2 <= candidates[i] <= 40`\n> - `candidates` 的所有元素 **互不相同**\n> - `1 <= target <= 40`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>> res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\n        Arrays.sort(candidates);\n        backtracking(candidates,target,0,0);\n        return res;\n    }\n    void backtracking(int[] candidates,int target,int start,int sum){\n        if(sum==target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i < candidates.length ; i++) {\n            if(sum+candidates[i]>target){\n                break;\n            }\n            path.add(candidates[i]);\n            backtracking(candidates,target,i,sum+candidates[i]);\n            path.removeLast();\n        }\n    }\n}\n```\n\n## <span id=\"head5\">🟡40. 组合总和 II</span>\n\n> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。\n>\n> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。\n>\n> **注意：**解集不能包含重复的组合。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: candidates = [10,1,2,7,6,1,5], target = 8,\n> 输出:\n> [\n> [1,1,6],\n> [1,2,5],\n> [1,7],\n> [2,6]\n> ]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: candidates = [2,5,2,1,2], target = 5,\n> 输出:\n> [\n> [1,2,2],\n> [5]\n> ]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= candidates.length <= 100`\n> - `1 <= candidates[i] <= 50`\n> - `1 <= target <= 30`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer> > res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target){\n        Arrays.sort(candidates);\n        backtracking(candidates,target,0,0);\n        return res;\n    }\n    void backtracking(int[] candidates,int target,int start,int sum){\n        if(sum==target) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i < candidates.length ; i++) {\n            if(sum+candidates[i]>target){\n                break;\n            }\n            if(i>start&&candidates[i]==candidates[i-1]){//key：同一层的树节点去重\n                continue;\n            }\n            path.add(candidates[i]);\n            sum+=candidates[i];\n            backtracking(candidates,target,i+1,sum);\n            path.removeLast();\n            sum-=candidates[i];\n        }\n    }\n}\n```\n\n## <span id=\"head8\">🟡131. 分割回文串</span>\n\n> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。\n>\n> **回文串** 是正着读和反着读都一样的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"aab\"\n> 输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"a\"\n> 输出：[[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 16`\n> - `s` 仅由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 动态规划\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<String>> res=new ArrayList<>();\n    LinkedList<String> path=new LinkedList<>();\n    public List<List<String>> partition(String s) {\n        if(s.length()==1){\n            path.add(s);\n            res.add(path);\n            return res;\n        }\n        backtraking(0,s);//\n        return res;\n    }\n    void backtraking(int start,String s){//\n        if(start==s.length()){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start+1; i <= s.length(); i++) {//\n            if(isHuiWen(s.substring(start,i))){\n                path.add(s.substring(start,i));//\n                backtraking(i,s);//\n                path.removeLast();\n            }\n        }\n    }\n    boolean isHuiWen(String str){\n        int i=0,j=str.length()-1;\n        if(j==0){\n            return true;\n        }\n        if(j<0){\n            return false;\n        }\n        while(i<j){\n            if(str.charAt(i)!=str.charAt(j)){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n## <span id=\"head9\">🟡93. 复原 IP 地址</span>\n\n> **有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。\n>\n> - 例如：`\"0.1.2.201\"` 和` \"192.168.1.1\"` 是 **有效** IP 地址，但是 `\"0.011.255.245\"`、`\"192.168.1.312\"` 和 `\"192.168@1.1\"` 是 **无效** IP 地址。\n>\n> 给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"25525511135\"\n> 输出：[\"255.255.11.135\",\"255.255.111.35\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"0000\"\n> 输出：[\"0.0.0.0\"]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"101023\"\n> 输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 20`\n> - `s` 仅由数字组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 回溯\n\n```java\nclass Solution {\n    List<String>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    public List<String> restoreIpAddresses(String s) {\n        backtraking(0,s);//\n        return res;\n    }\n    void backtraking(int start,String s){//\n        if(path.size()==4&&start==s.length()){\n            res.add(build((path)));//\n            return;\n        }\n        if(path.size()>4){\n            return;\n        }\n        for (int i = start+1; i <=s.length(); i++) {\n            if(s.substring(start,i).length()>1&&s.substring(start,i).charAt(0)=='0'){\n                break;\n            }\n            int temp=convert(s.substring(start,i));\n            if(temp<=255&&temp>=0){\n                path.add(temp);\n                backtraking(i,s);\n                path.removeLast();\n            }\n        }\n    }\n    String build(LinkedList<Integer> al){\n        StringBuilder sb=new StringBuilder();\n        sb.append(al.get(0));\n        for (int i = 1; i < 4; i++) {\n            sb.append('.');\n            sb.append(al.get(i));\n        }\n        return sb.toString();\n    }\n    int convert(String str){\n        int out=0,k=1,i=str.length()-1;\n        while(i>=0){\n            out+=k*(str.charAt(i)-'0');\n            k*=10;\n            i--;\n        }\n        return out;\n    }\n}\n```\n\n\n\n# <span id=\"head10\"> 子集</span>\n\n## <span id=\"head11\">🟡78. 子集</span>\n\n> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。\n>\n> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0]\n> 输出：[[],[0]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 10`\n> - `-10 <= nums[i] <= 10`\n> - `nums` 中的所有元素 **互不相同**\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        backtraking(0,nums);\n        return res;\n    }\n    void backtraking(int start,int[]nums){\n        res.add(new ArrayList<>(path));\n        for (int i = start; i < nums.length; i++) {\n            path.add(nums[i]);\n            backtraking(i+1,nums);\n            path.removeLast();\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head12\">🟡90. 子集 II</span>\n\n> 给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n>\n> 解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。\n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,2]\n> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0]\n> 输出：[[],[0]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 10`\n> - `-10 <= nums[i] <= 10`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        backtraking(0,nums);\n        return res;\n    }\n    void backtraking(int start,int[]nums){\n        res.add(new ArrayList<>(path));\n        for (int i = start; i < nums.length; i++) {\n            if(i>start&&nums[i]==nums[i-1]){\n                continue;\n            }\n            path.add(nums[i]);\n            backtraking(i+1,nums);\n            path.removeLast();\n        }\n    }\n}\n```\n\n## <span id=\"head13\">🟡491. 递增子序列</span>\n\n> 给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。\n>\n> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [4,6,7,7]\n> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [4,4,3,2,1]\n> 输出：[[4,4]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 15`\n> - `-100 <= nums[i] <= 100`\n>\n> Related Topics\n>\n> 位运算\n>\n> 数组\n>\n> 哈希表\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer> path=new LinkedList<>();\n    Set<String>set=new TreeSet<>();\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        backtraking(0,nums);\n        return res;\n    }\n    void backtraking(int start,int[]nums){\n        if(check(path)&&!set.contains(path.toString())){\n            res.add(new ArrayList<>(path));\n            set.add(path.toString());\n        }\n\n        for (int i = start; i < nums.length; i++) {\n            if(i>start&&nums[i]==nums[i-1]){\n                continue;\n            }\n            path.add(nums[i]);\n            backtraking(i+1,nums);\n            path.removeLast();\n        }\n    }\n    boolean check(List<Integer>al){\n        if(al.size()<2){\n            return false;\n        }\n        for (int i = 1; i < al.size(); i++) {\n            if(al.get(i)<al.get(i-1)){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n# <span id=\"head14\"> 排列</span>\n\n## <span id=\"head15\"> 🟡46.全排列</span>\n\n> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1]\n> 输出：[[0,1],[1,0]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [1]\n> 输出：[[1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 6`\n> - `-10 <= nums[i] <= 10`\n> - `nums` 中的所有整数 **互不相同**\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    boolean[] used;\n    public List<List<Integer>> permute(int[] nums) {\n        int len= nums.length;\n        if(len==0){\n            return res;\n        }\n        used=new boolean[len];\n        backtraking(nums);\n        return res;\n    }\n    void backtraking(int[]nums){\n        if(path.size()==nums.length){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if(used[i]){\n                continue;\n            }\n            path.add(nums[i]);\n            used[i]=true;\n            backtraking(nums);\n            path.removeLast();\n            used[i]=false;\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head16\">🟡47. 全排列 II</span>\n\n> 给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：\n> [[1,1,2],\n> [1,2,1],\n> [2,1,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1,2,3]\n> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 8`\n> - `-10 <= nums[i] <= 10`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<Integer>>res=new ArrayList<>();\n    LinkedList<Integer>path=new LinkedList<>();\n    Set<String>set=new TreeSet<>();\n    boolean[] used;\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        int len= nums.length;\n        if(len==0){\n            return res;\n        }\n        used=new boolean[len];\n        backtraking(nums);\n        return res;\n    }\n    void backtraking(int[]nums){\n        if(path.size()==nums.length&&!set.contains(path.toString())){\n            res.add(new ArrayList<>(path));\n            set.add(path.toString());\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if(used[i]){\n                continue;\n            }\n            path.add(nums[i]);\n            used[i]=true;\n            backtraking(nums);\n            path.removeLast();\n            used[i]=false;\n        }\n    }\n}\n```\n\n# <span id=\"head17\"> 棋盘问题</span>\n\n## <span id=\"head18\">🔴51. N 皇后</span>\n\n> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\n>\n> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。\n>\n> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。\n>\n> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\n>\n> ```\n> 输入：n = 4\n> 输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n> 解释：如上图所示，4 皇后问题存在两个不同的解法。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 1\n> 输出：[[\"Q\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 9`\n>\n> Related Topics\n>\n> 数组\n>\n> 回溯\n\n```java\nclass Solution {\n    List<List<String>> res=new ArrayList<>();\n    LinkedList<String> path=new LinkedList<>();\n    public List<List<String>> solveNQueens(int n) {\n        backtraking(0,n);\n        return res;\n    }\n    void backtraking(int start,int n){\n        if(path.size()==n){\n            res.add(new ArrayList<>(path));\n        }\n        for (int i = 0; i < n; i++) {\n            boolean flag=true;//\n            for (int j = 0; j < path.size(); j++) {\n                int index=path.get(j).indexOf('Q');\n                if(index==i){\n                    flag=false;\n                }\n                if(Math.abs(index-i)==Math.abs(j- path.size())){\n                    flag=false;\n                }\n            }\n            if(flag){\n                path.add(build(n,i));\n                backtraking(i+1,n);\n                path.removeLast();\n            }\n        }\n    }\n    String build(int n,int k){\n        StringBuilder sb=new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if(i==k){\n                sb.append(\"Q\");\n            }else{\n                sb.append(\".\");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n## <span id=\"head19\">🔴37. 解数独</span>\n\n> 编写一个程序，通过填充空格来解决数独问题。\n>\n> 数独的解法需 **遵循如下规则**：\n>\n> 1. 数字 `1-9` 在每一行只能出现一次。\n> 2. 数字 `1-9` 在每一列只能出现一次。\n> 3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）\n>\n> 数独部分空格内已填入了数字，空白格用 `'.'` 表示。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](23-9-8-algorithm-backtraking/250px-sudoku-by-l2g-20050714svg.png)\n>\n> ```\n> 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n> 输出：[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n> 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：\n> ```\n>\n> ![img](23-9-8-algorithm-backtraking/250px-sudoku-by-l2g-20050714_solutionsvg.png)\n>\n> \n>\n> **提示：**\n>\n> - `board.length == 9`\n> - `board[i].length == 9`\n> - `board[i][j]` 是一位数字或者 `'.'`\n> - 题目数据 **保证** 输入数独仅有一个解\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 回溯\n>\n> 矩阵\n\n```java\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        backtraking(board);\n        return;\n    }\n    boolean backtraking(char[][] board){\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if(board[i][j]!='.'){\n                    continue;\n                }else{\n                    for (char k = '1'; k <= '9'; k++) {\n                        if(check(i,j,k,board)){\n                            board[i][j]=k;\n                            if(backtraking(board)){\n                                return true;\n                            }\n                            board[i][j]='.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    boolean check(int i,int j,char k,char[][] board){\n        for (int l = 0; l < 9; l++) {\n            if(board[i][l]==k){\n                return false;\n            }\n            if(board[l][j]==k){\n                return false;\n            }\n        }\n        int row=(i/3)*3,col=(j/3)*3;\n        for (int l = 0; l < 3; l++) {\n            for (int m = 0; m < 3; m++) {\n                if(board[row+l][col+m]==k){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n# <span id=\"head20\"> 其他</span>\n\n## <span id=\"head21\">🔴332. 重新安排行程</span>\n\n> 给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\n>\n> 所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\n>\n> - 例如，行程 `[\"JFK\", \"LGA\"]` 与 `[\"JFK\", \"LGB\"]` 相比就更小，排序更靠前。\n>\n> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)\n>\n> ```\n> 输入：tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n> 输出：[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)\n>\n> ```\n> 输入：tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n> 输出：[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n> 解释：另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] ，但是它字典排序更大更靠后。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= tickets.length <= 300`\n> - `tickets[i].length == 2`\n> - `fromi.length == 3`\n> - `toi.length == 3`\n> - `fromi` 和 `toi` 由大写英文字母组成\n> - `fromi != toi`\n>\n> Related Topics\n>\n> 深度优先搜索\n>\n> 图\n>\n> 欧拉回路\n\n```java\n\n```\n\n","categories":["algorithm learning"]},{"title":"BiTree","url":"/2023/09/07/algorithm-bitree/","content":"\n|                分类                | 编号 | 是否完成 | 题号                                                | 标签                 |\n| :--------------------------------: | ---- | :------: | :-------------------------------------------------- | -------------------- |\n|    [二叉树遍历方式    ](#head1)    | 1    |    ✅     | [ 🟢144.二叉树的前序遍历](#head2)                    | 递归  用栈迭代       |\n|                                    | 2    |    ✅     | [ 🟢145.二叉树的后序遍历](#head3)                    | 递归  用栈迭代       |\n|                                    | 3    |    ✅     | [ 🟢94.二叉树的中序遍历](#head4)                     | 递归  用栈和指针迭代 |\n|                                    | 4    |    ✅     | [ 🟡102.二叉树的层序遍历](#head5)                    | dfs 队列             |\n|                                    | 5    |    ✅     | [ 🟡107.二叉树的层次遍历II](#head6)                  | 队列(层序遍历)       |\n|                                    | 6    |    ✅     | [ 🟡199.二叉树的右视图](#head7)                      | 队列(层序遍历)       |\n|                                    | 7    |    ✅     | [ 🟢637.二叉树的层平均值](#head8)                    | 队列(层序遍历)       |\n|                                    | 8    |    ✅     | [ 🟡429.N叉树的层序遍历](#head9)                     | 队列(层序遍历)       |\n|                                    | 9    |    ✅     | [ 🟡515.在每个树行中找最大值](#head10)               | 队列(层序遍历)       |\n|                                    | 10   |    ✅     | [ 🟡116.填充每个节点的下一个右侧节点指针](#head11)   | 队列(层序遍历)       |\n|                                    | 11   |    ✅     | [ 🟡117.填充每个节点的下一个右侧节点指针II](#head12) | 队列(层序遍历)       |\n|     [二叉树属性     ](#head13)     | 12   |    ✅     | [🟢101. 对称二叉树](#head14)                         | 队列                 |\n|                                    | 13   |    ✅     | [ 🟢104.二叉树的最大深度](#head15)                   | 队列(层序遍历)       |\n|                                    | 14   |    ✅     | [ 🟢111.二叉树的最小深度](#head16)                   | 队列(层序遍历)       |\n|                                    | 15   |    ✅     | [ 🟡222.完全二叉树的节点个数](#head17)               | 栈                   |\n|                                    | 16   |    ✅     | [ 🟢110.平衡二叉树](#head18)                         | 栈(后序遍历)         |\n|                                    | 17   |    ✅     | [ 🟢257.二叉树的所有路径](#head19)                   | 回溯+递归            |\n|                                    | 18   |    ✅     | [ 🟢404.左叶子之和](#head20)                         | 栈                   |\n|                                    | 19   |    ✅     | [ 🟡513.找树左下角的值](#head21)                     | 队列 层序遍历        |\n|                                    | 20   |    ✅     | [ 🟢112.路径总和](#head22)                           | 回溯+递归            |\n| [二叉树的修改与构建     ](#head23) | 21   |    ✅     | [ 🟢226.翻转二叉树](#head24)                         | 递归                 |\n|                                    | 22   |    ✅     | [ 🟡106.从中序与后序遍历序列构造二叉树](#head25)     | dfs                  |\n|                                    | 23   |    ✅     | [ 🟡105.从前序与中序遍历序列构造二叉树](#head26)     | dfs                  |\n|                                    | 24   |    ✅     | [ 🟡654.最大二叉树](#head27)                         | dfs                  |\n|                                    | 25   |    ✅     | [ 🟢617.合并二叉树](#head28)                         | dfs                  |\n| [求搜索二叉树的属性     ](#head29) | 26   |    ✅     | [ 🟢700.二叉搜索树中的搜索](#head30)                 | 递归                 |\n|                                    | 27   |    ✅     | [ 🟡98.验证二叉搜索树](#head31)                      | 栈(中序遍历)         |\n|                                    | 28   |    ✅     | [ 🟢530.二叉搜索树的最小绝对差](#head32)             | 栈(中序遍历)         |\n|                                    | 29   |    ✅     | [ 🟢501.二叉搜索树中的众数](#head33)                 | 哈希表 栈            |\n|                                    | 30   |    ✅     | [ 🟡538.把二叉搜索树转换为累加树](#head34)           | 栈                   |\n|  [二叉树公共祖先问题   ](#head35)  | 31   |    ✅     | [ 🟡236.二叉树的最近公共祖先](#head36)               | 回溯                 |\n|                                    | 32   |    ✅     | [🟡235.二叉搜索树的最近公共祖先  ](#head37)          | 回溯                 |\n| [二叉搜索树的修改与构造 ](#head38) | 33   |    ✅     | [ 🟡701.二叉搜索树中的插入操作](#head39)             | dfs                  |\n|                                    | 34   |    ✅     | [ 🟡450.删除二叉搜索树中的节点](#head40)             | 搜索二叉树删除节点   |\n|                                    | 35   |    ✅     | [ 🟡669.修剪二叉搜索树](#head41)                     | 搜索二叉树删除节点   |\n|                                    | 36   |    ✅     | [ 🟢108.将有序数组转换为二叉搜索树](#head42)         | dfs                  |\n\n\n\n\n\n# <span id=\"head1\">二叉树遍历方式    </span>\n\n## <span id=\"head2\"> 🟢144.二叉树的前序遍历</span>\n\n> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[1,2,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> **示例 4：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)\n>\n> ```\n> 输入：root = [1,2]\n> 输出：[1,2]\n> ```\n>\n> **示例 5：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)\n>\n> ```\n> 输入：root = [1,null,2]\n> 输出：[1,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶：**递归算法很简单，你可以通过迭代算法完成吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n递归遍历\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result=new ArrayList<>();\n        preorder(root,result);\n        return result;\n    }\n    void preorder(TreeNode root, List<Integer> res){\n       if(root==null) {\n           return;\n       }\n       res.add(root.val);\n       preorder(root.left,res);\n       preorder(root.right,res);\n    }\n}\n```\n\n用栈迭代遍历(中→右→左)\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Stack<TreeNode> s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            res.add(node.val);\n            if(node.right!=null){\n                s.push(node.right);\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n        }\n        return res;\n    }\n}\n```\n\n统一迭代法遍历(背)\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null)s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n                s.push(node);\n                s.push(null);\n            }else{\n                s.pop();//排出null\n                node=s.pop();\n                res.add(node.val);\n            }\n        }\n\n        return res;\n    }\n}\n```\n\n## <span id=\"head3\"> 🟢145.二叉树的后序遍历</span>\n\n> 给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶：**递归算法很简单，你可以通过迭代算法完成吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n递归实现\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result=new ArrayList<>();\n        postorder(root,result);\n        return result;\n    }\n    void postorder(TreeNode root,List<Integer> res){\n        if(root==null){\n            return;\n        }\n        postorder(root.left,res);\n        postorder(root.right,res);\n        res.add(root.val);\n    }\n}\n```\n\n用栈迭代遍历(中→左→右,整体反转)\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Stack<TreeNode> s=new Stack<TreeNode>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node = s.pop();\n            res.add(node.val);\n            if(node.left!=null){\n                s.push(node.left);\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n统一迭代法遍历(背)\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null){\n            s.push(root);\n        }\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                s.push(node);\n                s.push(null);\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head4\"> 🟢94.二叉树的中序遍历</span>\n\n> 给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n>\n> ```\n> 输入：root = [1,null,2,3]\n> 输出：[1,3,2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶:** 递归算法很简单，你可以通过迭代算法完成吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n递归遍历\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result=new ArrayList<>();\n        inorder(root,result);\n        return result;\n    }\n    void inorder(TreeNode r,List<Integer> res){\n        if(r==null){\n            return;\n        };\n        inorder(r.left,res);\n        res.add(r.val);\n        inorder(r.right,res);\n    }\n\n}\n```\n\n用栈和指针迭代遍历(左→右)(背)\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        TreeNode cur=root;\n        while(cur!=null||!s.isEmpty()){\n            if(cur!=null){\n                s.push(cur);\n                cur=cur.left;\n            }else{\n                cur=s.pop();\n                res.add(cur.val);\n                cur=cur.right;\n            }\n        }\n        return res;\n    }\n}\n```\n\n统一迭代法遍历(背)\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new LinkedList<>();\n        Stack<TreeNode> s = new Stack<>();\n        if(root!=null){\n            s.push(root);\n        }\n        while(!s.empty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                s.push(node);\n                s.push(null);\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.pop();\n                res.add(node.val);\n            }\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head5\"> 🟡102.二叉树的层序遍历</span>\n\n> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[3],[9,20],[15,7]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-1000 <= Node.val <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n递归方式层序遍历\n\n```java\nclass Solution {\n    List<List<Integer>> res=new ArrayList<>();\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        levelorder(root,0);\n        return res;\n    }\n    void levelorder(TreeNode node, int deep){\n        if (node == null) {\n            return;\n        }\n        deep++;\n        if (res.size() < deep) {\n            List<Integer> item = new ArrayList<Integer>();\n            res.add(item);\n        }\n        res.get(deep - 1).add(node.val);\n        levelorder(node.left, deep);\n        levelorder(node.right, deep);\n    }\n}\n```\n\n非递归方式运用队列层序遍历\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res=new ArrayList<>();\n        Queue<TreeNode> q=new LinkedList<>();\n        if(root==null){\n            return res;\n        }\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            List<Integer> l=new ArrayList<>();\n            while(len-->0){\n                TreeNode node=q.poll();\n                l.add(node.val);\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res.add(l);\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head6\"> 🟡107.二叉树的层次遍历II</span>\n\n> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[[15,7],[9,20],[3]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[[1]]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[0, 2000]` 内\n> - `-1000 <= Node.val <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> res=new ArrayList<>();\n        Queue<TreeNode> q=new LinkedList<>();\n        if(root==null){\n            return res;\n        }\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            List<Integer> l=new ArrayList<>();\n            while(len-->0){\n                TreeNode node=q.poll();\n                l.add(node.val);\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res.add(l);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## <span id=\"head7\"> 🟡199.二叉树的右视图</span>\n\n> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\n>\n> ```\n> 输入: [1,2,3,null,5,null,4]\n> 输出: [1,3,4]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: [1,null,3]\n> 输出: [1,3]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: []\n> 输出: []\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 二叉树的节点个数的范围是 `[0,100]`\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer>res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->1){\n                TreeNode node=q.poll();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            TreeNode node=q.poll();\n            res.add(node.val);\n            if(node.left!=null){\n                q.offer(node.left);\n            }\n            if(node.right!=null){\n                q.offer(node.right);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head8\"> 🟢637.二叉树的层平均值</span>\n\n> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：[3.00000,14.50000,11.00000]\n> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n> 因此返回 [3, 14.5, 11] 。\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)\n>\n> ```\n> 输入：root = [3,9,20,15,7]\n> 输出：[3.00000,14.50000,11.00000]\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - 树中节点数量在 `[1, 104]` 范围内\n> - `-231 <= Node.val <= 231 - 1`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> res=new ArrayList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            double sum=0,cnt=len;\n            while(len-->0){\n                TreeNode node=q.poll();\n                sum+=node.val;\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res.add(sum/cnt);\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head9\"> 🟡429.N叉树的层序遍历</span>\n\n> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。\n>\n> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n>\n> ```\n> 输入：root = [1,null,3,2,4,null,5,6]\n> 输出：[[1],[3,2,4],[5,6]]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n>\n> ```\n> 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树的高度不会超过 `1000`\n> - 树的节点总数在 `[0, 10^4]` 之间\n>\n> Related Topics\n>\n> 树\n>\n> 广度优先搜索\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res=new LinkedList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<Node>q=new LinkedList<>() ;\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            List<Integer>l=new LinkedList<>();\n            while(len-->0){\n                Node node=q.poll();\n                l.add(node.val);\n                List<Node> n=node.children;\n                for (int i = 0; i < n.size(); i++) {\n                    q.offer(n.get(i));\n                }\n            }\n            res.add(l);\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head10\"> 🟡515.在每个树行中找最大值</span>\n\n> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。\n>\n> \n>\n> **示例1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg)\n>\n> ```\n> 输入: root = [1,3,2,5,3,null,9]\n> 输出: [1,3,9]\n> ```\n>\n> **示例2：**\n>\n> ```\n> 输入: root = [1,2,3]\n> 输出: [1,3]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 二叉树的节点个数的范围是 `[0,104]`\n> - `-231 <= Node.val <= 231 - 1`\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer> res=new LinkedList<>();\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            int max=Integer.MIN_VALUE;\n            while(len-->0){\n                TreeNode node=q.poll();\n                if(node.val>max){\n                    max=node.val;\n                }\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res.add(max);\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head11\"> 🟡116.填充每个节点的下一个右侧节点指针</span>\n\n> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n>\n> ```\n> struct Node {\n> int val;\n> Node *left;\n> Node *right;\n> Node *next;\n> }\n> ```\n>\n> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。\n>\n> 初始状态下，所有 next 指针都被设置为 `NULL`。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)\n>\n> ```\n> 输入：root = [1,2,3,4,5,6,7]\n> 输出：[1,#,2,3,#,4,5,6,7,#]\n> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n> ```\n>\n> \n>\n> **示例 2:**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数量在 `[0, 212 - 1]` 范围内\n> - `-1000 <= node.val <= 1000`\n>\n> \n>\n> **进阶：**\n>\n> - 你只能使用常量级额外空间。\n> - 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 链表\n>\n> 二叉树\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null){\n            return root;\n        }\n        root.next=null;\n        Queue<Node>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->1){\n                Node node=q.poll();\n                node.next=q.peek();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }                \n            }\n            Node node=q.poll();\n            node.next=null;\n            if(node.left!=null){\n                q.offer(node.left);\n            }\n            if(node.right!=null){\n                q.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n\n\n## <span id=\"head12\"> 🟡117.填充每个节点的下一个右侧节点指针II</span>\n\n> 给定一个二叉树：\n>\n> ```\n> struct Node {\n> int val;\n> Node *left;\n> Node *right;\n> Node *next;\n> }\n> ```\n>\n> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。\n>\n> 初始状态下，所有 next 指针都被设置为 `NULL` 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)\n>\n> ```\n> 输入：root = [1,2,3,4,5,null,7]\n> 输出：[1,#,2,3,#,4,5,7,#]\n> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中的节点数在范围 `[0, 6000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> **进阶：**\n>\n> - 你只能使用常量级额外空间。\n> - 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 链表\n>\n> 二叉树\n\n同上一题的代码,一字没动.\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null){\n            return root;\n        }\n        root.next=null;\n        Queue<Node>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->1){\n                Node node=q.poll();\n                node.next=q.peek();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }                \n            }\n            Node node=q.poll();\n            node.next=null;\n            if(node.left!=null){\n                q.offer(node.left);\n            }\n            if(node.right!=null){\n                q.offer(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n# <span id=\"head13\">二叉树属性     </span>\n\n## <span id=\"head14\">🟢101. 对称二叉树</span>\n\n> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)\n>\n> ```\n> 输入：root = [1,2,2,3,4,4,3]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)\n>\n> ```\n> 输入：root = [1,2,2,null,3,null,3]\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[1, 1000]` 内\n> - `-100 <= Node.val <= 100`\n>\n> \n>\n> **进阶：**你可以运用递归和迭代两种方法解决这个问题吗？\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        Queue<TreeNode> q=new LinkedList<>();\n        q.offer(root.left);\n        q.offer(root.right);\n        while(!q.isEmpty()){\n            TreeNode leftnode=q.poll();\n            TreeNode rightnode=q.poll();\n            if(leftnode==null&&rightnode==null){\n                continue;\n            }\n            if(leftnode==null||rightnode==null||leftnode.val!=rightnode.val){\n                return false;\n            }\n            q.offer(leftnode.left);\n            q.offer(rightnode.right);\n            q.offer(leftnode.right);\n            q.offer(rightnode.left);\n        }\n        return true;\n    }\n}\n```\n\n\n\n## <span id=\"head15\"> 🟢104.二叉树的最大深度</span>\n\n> 给定一个二叉树 `root` ，返回其最大深度。\n>\n> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\n>\n> \n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：3\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1,null,2]\n> 输出：2\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数量在 `[0, 104]` 区间内。\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        int res=0;\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->0){\n                TreeNode node=q.poll();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res++;\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head16\"> 🟢111.二叉树的最小深度</span>\n\n> 给定一个二叉树，找出其最小深度。\n>\n> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n>\n> **说明：**叶子节点是指没有子节点的节点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [2,null,3,null,4,null,5,null,6]\n> 输出：5\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数的范围在 `[0, 105]` 内\n> - `-1000 <= Node.val <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int minDepth(TreeNode root) {\n        int res=0;\n        if(root==null){\n            return res;\n        }\n        Queue<TreeNode>q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->0){\n                TreeNode node=q.poll();\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n                if(node.left==null&&node.right==null){\n                    return res+1;\n                }\n            }\n            res++;\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head17\"> 🟡222.完全二叉树的节点个数</span>\n\n> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。\n>\n> [完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)\n>\n> ```\n> 输入：root = [1,2,3,4,5,6]\n> 输出：6\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = []\n> 输出：0\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目范围是`[0, 5 * 104]`\n> - `0 <= Node.val <= 5 * 104`\n> - 题目数据保证输入的树是 **完全二叉树**\n>\n> \n>\n> **进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二分查找\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        int res=0;\n        if(root==null){\n            return res;\n        }\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }                \n                s.push(node);\n                s.push(null);\n\n            }else{\n                s.pop();\n                node=s.pop();\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head18\"> 🟢110.平衡二叉树</span>\n\n> 给定一个二叉树，判断它是否是高度平衡的二叉树。\n>\n> 本题中，一棵高度平衡二叉树定义为：\n>\n> > 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n>\n> ```\n> 输入：root = [3,9,20,null,null,15,7]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n>\n> ```\n> 输入：root = [1,2,2,3,3,null,null,4,4]\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中的节点数在范围 `[0, 5000]` 内\n> - `-104 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n\n    public boolean isBalanced(TreeNode root) {\n        if(root==null){\n            return true;\n        }\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                s.push(node);\n                s.push(null);\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n\n            }else{\n                s.pop();\n                node=s.pop();\n                change(node);\n                if(node.left==null&&node.right==null){\n                    continue;\n                }else if(node.left==null){\n                    if(node.right.val>1){\n                        return false;\n                    }\n                }else if(node.right==null){\n                    if(node.left.val>1){\n                        return false;\n                    }\n                }else{\n                    if(Math.abs(node.left.val-node.right.val)>1){\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    void change(TreeNode root){\n        if(root.left==null&&root.right==null){\n            root.val=1;\n        }else if(root.left==null){\n            root.val=1+root.right.val;\n        }else if(root.right==null){\n            root.val=1+root.left.val;\n        }else{\n            root.val=1+Math.max(root.left.val,root.right.val);\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head19\"> 🟢257.二叉树的所有路径</span>\n\n> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。\n>\n> **叶子节点** 是指没有子节点的节点。\n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)\n>\n> ```\n> 输入：root = [1,2,3,null,5]\n> 输出：[\"1->2->5\",\"1->3\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [1]\n> 输出：[\"1\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[1, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 字符串\n>\n> 回溯\n>\n> 二叉树\n\n```java\nclass Solution {\n    List<String>res=new ArrayList<>();\n    LinkedList<Integer>list=new LinkedList<>();\n\n    List<String> binaryTreePaths(TreeNode root) {\n        list.add(root.val);\n        backtraking(root);\n        return res;\n    }\n    \n   void backtraking(TreeNode root){\n        if(root.left==null&&root.right==null){\n            res.add(convert(list));\n            return;\n        }\n        if(root.left!=null){\n            list.add(root.left.val);\n            backtraking(root.left);\n            list.removeLast();\n        }\n        if(root.right!=null){\n            list.add(root.right.val);\n            backtraking(root.right);\n            list.removeLast();\n        }\n    }\n    \n    String convert(List<Integer> list){\n        StringBuilder sb=new StringBuilder();\n        int i=0;\n        for (; i < list.size()-1; i++) {\n            sb.append(list.get(i)+\"->\");\n        }\n        sb.append(list.get(i));\n        return sb.toString();\n    }\n}\n```\n\n\n\n## <span id=\"head20\"> 🟢404.左叶子之和</span>\n\n> 给定二叉树的根节点 `root` ，返回所有左叶子之和。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)\n>\n> ```\n> 输入: root = [3,9,20,null,null,15,7] \n> 输出: 24 \n> 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: root = [1]\n> 输出: 0\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 节点数在 `[1, 1000]` 范围内\n> - `-1000 <= Node.val <= 1000`\n>\n> \n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        int res=0;\n        Stack<TreeNode>s=new Stack<>();\n        if(root==null){\n            return res;\n        }\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            if(node.left!=null){\n                s.push(node.left);\n                if(node.left.left==null&&node.left.right==null){\n                    res+=node.left.val;\n                }\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head21\"> 🟡513.找树左下角的值</span>\n\n> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。\n>\n> 假设二叉树中至少有一个节点。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)\n>\n> ```\n> 输入: root = [2,1,3]\n> 输出: 1\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)\n>\n> ```\n> 输入: [1,2,3,4,null,5,6,null,null,7]\n> 输出: 7\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 二叉树的节点个数的范围是 `[1,104]`\n> - `-231 <= Node.val <= 231 - 1`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q=new LinkedList<>();\n        q.offer(root);\n        int res=0;\n        while(!q.isEmpty()){\n            int len=q.size();\n            List<Integer>list=new ArrayList<>();\n            while(len-->0){\n                TreeNode node=q.poll();\n                list.add(node.val);\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n            res= list.get(0);\n        }\n        return res;\n    }\n}\n```\n\n## <span id=\"head22\"> 🟢112.路径总和</span>\n\n> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> **叶子节点** 是指没有子节点的节点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)\n>\n> ```\n> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n> 输出：true\n> 解释：等于目标和的根节点到叶节点路径如上图所示。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)\n>\n> ```\n> 输入：root = [1,2,3], targetSum = 5\n> 输出：false\n> 解释：树中存在两条根节点到叶子节点的路径：\n> (1 --> 2): 和为 3\n> (1 --> 3): 和为 4\n> 不存在 sum = 5 的根节点到叶子节点的路径。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [], targetSum = 0\n> 输出：false\n> 解释：由于树是空的，所以不存在根节点到叶子节点的路径。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[0, 5000]` 内\n> - `-1000 <= Node.val <= 1000`\n> - `-1000 <= targetSum <= 1000`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n\n    boolean res=false;\n\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if(root==null){\n            return res;\n        }\n        backtracking(root,root.val,targetSum);\n        return res;\n    }\n\n    void backtracking(TreeNode root,int sum,int target){\n        if(res==true){\n            return;\n        }\n        if(sum==target&&root.left==null&&root.right==null){\n            res=true;\n            return;\n        }\n        if(root==null){\n            return;\n        }\n        if(root.left!=null){\n            sum+=root.left.val;\n            backtracking(root.left,sum,target);\n            sum-=root.left.val;\n        }\n        if(root.right!=null){\n            sum+=root.right.val;\n            backtracking(root.right,sum,target);\n            sum-=root.right.val;\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head23\">二叉树的修改与构建     </span>\n\n## <span id=\"head24\"> 🟢226.翻转二叉树</span>\n\n> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3,6,9]\n> 输出：[4,7,2,9,6,3,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n>\n> ```\n> 输入：root = [2,1,3]\n> 输出：[2,3,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目范围在 `[0, 100]` 内\n> - `-100 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null){\n            return root;\n        }\n        swap(root);\n        invertTree(root.left);\n        invertTree(root.right);\n        return root;\n    }\n    void swap(TreeNode r){\n        TreeNode t=r.left;\n        r.left=r.right;\n        r.right=t;\n    }\n}\n```\n\n## <span id=\"head25\"> 🟡106.从中序与后序遍历序列构造二叉树</span>\n\n> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n>\n> ```\n> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n> 输出：[3,9,20,null,null,15,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：inorder = [-1], postorder = [-1]\n> 输出：[-1]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= inorder.length <= 3000`\n> - `postorder.length == inorder.length`\n> - `-3000 <= inorder[i], postorder[i] <= 3000`\n> - `inorder` 和 `postorder` 都由 **不同** 的值组成\n> - `postorder` 中每一个值都在 `inorder` 中\n> - `inorder` **保证**是树的中序遍历\n> - `postorder` **保证**是树的后序遍历\n>\n> Related Topics\n>\n> 树\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        TreeNode res=new TreeNode(postorder[postorder.length-1]);\n        dfs(res,postorder,inorder,0,postorder.length-1,postorder.length-1);\n        return res;\n    }\n    //i,j:node在中序数组的范围          k:node在后序数组中的坐标\n    void dfs(TreeNode node,int[] postorder, int[] inorder,int i,int j,int k){\n        if(node==null){\n            return;\n        }\n        int index=0;\n        for (; index < inorder.length; index++) {\n            if(inorder[index]==node.val){\n                break;\n            }\n        }\n        int left_num=index-i;\n        int right_num=j-index;\n        if(left_num>0){\n            node.left=new TreeNode(postorder[k-1-right_num]);\n        }\n        if(right_num>0){\n            node.right=new TreeNode(postorder[k-1]);\n        }\n        dfs(node.left,postorder,inorder,i,index-1,k-1-right_num);\n        dfs(node.right,postorder,inorder,index+1,j,k-1);\n    }\n}\n```\n\n\n\n## <span id=\"head26\"> 🟡105.从前序与中序遍历序列构造二叉树</span>\n\n> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n>\n> ```\n> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n> 输出: [3,9,20,null,null,15,7]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: preorder = [-1], inorder = [-1]\n> 输出: [-1]\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= preorder.length <= 3000`\n> - `inorder.length == preorder.length`\n> - `-3000 <= preorder[i], inorder[i] <= 3000`\n> - `preorder` 和 `inorder` 均 **无重复** 元素\n> - `inorder` 均出现在 `preorder`\n> - `preorder` **保证** 为二叉树的前序遍历序列\n> - `inorder` **保证** 为二叉树的中序遍历序列\n>\n> Related Topics\n>\n> 树\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        TreeNode res=new TreeNode(preorder[0]);\n        dfs(res,preorder,inorder,0,preorder.length-1,0);\n        return res;\n    }\n    //i,j:node在中序数组的范围          k:node在前序数组中的坐标\n    void dfs(TreeNode node,int[] preorder, int[] inorder,int i,int j,int k){\n        if(node==null){\n            return;\n        }\n        int index=0;\n        for (; index < inorder.length; index++) {\n            if(inorder[index]==node.val){\n                break;\n            }\n        }\n        int left_num=index-i;\n        int right_num=j-index;\n        if(left_num>0){\n            node.left=new TreeNode(preorder[k+1]);\n        }\n        if(right_num>0){\n            node.right=new TreeNode(preorder[k+left_num+1]);\n        }\n        dfs(node.left,preorder,inorder,i,index-1,k+1);\n        dfs(node.right,preorder,inorder,index+1,j,k+left_num+1);\n    }\n}\n```\n\n## <span id=\"head27\"> 🟡654.最大二叉树</span>\n\n> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:\n>\n> 1. 创建一个根节点，其值为 `nums` 中的最大值。\n> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。\n> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。\n>\n> 返回 *`nums` 构建的* ***最大二叉树\\*** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)\n>\n> ```\n> 输入：nums = [3,2,1,6,0,5]\n> 输出：[6,3,5,null,2,0,null,null,1]\n> 解释：递归调用如下所示：\n> - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n>     - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n>         - 空数组，无子节点。\n>         - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n>             - 空数组，无子节点。\n>             - 只有一个元素，所以子节点是一个值为 1 的节点。\n>     - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n>         - 只有一个元素，所以子节点是一个值为 0 的节点。\n>         - 空数组，无子节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)\n>\n> ```\n> 输入：nums = [3,2,1]\n> 输出：[3,null,2,null,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 1000`\n> - `0 <= nums[i] <= 1000`\n> - `nums` 中的所有整数 **互不相同**\n>\n> Related Topics\n>\n> 栈\n>\n> 树\n>\n> 数组\n>\n> 分治\n>\n> 二叉树\n>\n> 单调栈\n\n```java\nclass Solution {\n    TreeNode res;\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        res=new TreeNode(nums[getMaxIndex(nums,0, nums.length-1)]);\n        dfs(res,nums,0,nums.length-1,getMaxIndex(nums,0, nums.length-1));\n        return res;\n    }\n    void dfs(TreeNode node,int[] arr,int from,int to,int index){\n        if(from<index){\n            node.left=new TreeNode(arr[getMaxIndex(arr,from,index-1)]);\n        }\n        if(index<to){\n            node.right=new TreeNode(arr[getMaxIndex(arr,index+1,to)]);\n        }\n        if(node.left!=null){\n            dfs(node.left,arr,from,index-1,getMaxIndex(arr,from,index-1));\n        }\n        if(node.right!=null){\n            dfs(node.right,arr,index+1,to,getMaxIndex(arr,index+1,to));\n        }\n    }\n    int getMaxIndex(int[]arr,int i,int j){\n        if(i==j){\n            return i;\n        }\n        int maxindex=i;\n        for (int k = i+1; k <= j; k++) {\n            if(arr[maxindex]<arr[k]){\n                maxindex=k;\n            }\n        }\n        return maxindex;\n    }\n}\n```\n\n\n\n## <span id=\"head28\"> 🟢617.合并二叉树</span>\n\n> 给你两棵二叉树： `root1` 和 `root2` 。\n>\n> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。\n>\n> 返回合并后的二叉树。\n>\n> **注意:** 合并过程必须从两个树的根节点开始。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)\n>\n> ```\n> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n> 输出：[3,4,5,5,4,null,7]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root1 = [1], root2 = [1,2]\n> 输出：[2,2]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 两棵树中的节点数目在范围 `[0, 2000]` 内\n> - `-104 <= Node.val <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        if(root1==null){\n            return root2;\n        }\n        if(root2==null){\n            return root1;\n        }\n        root1.val+= root2.val;\n        if(root1.left==null&&root2.left!=null){\n            root1.left=new TreeNode(0);\n        }\n        if(root1.right==null&&root2.right!=null){\n            root1.right=new TreeNode(0);\n        }\n        mergeTrees(root1.left,root2.left);\n        mergeTrees(root1.right,root2.right);\n        return  root1;\n    }\n}\n```\n\n\n\n# <span id=\"head29\">求搜索二叉树的属性     </span>\n\n## <span id=\"head30\"> 🟢700.二叉搜索树中的搜索</span>\n\n> 给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。\n>\n> 你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3], val = 2\n> 输出：[2,1,3]\n> ```\n>\n> **示例 2:**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3], val = 5\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 数中节点数在 `[1, 5000]` 范围内\n> - `1 <= Node.val <= 107`\n> - `root` 是二叉搜索树\n> - `1 <= val <= 107`\n>\n> Related Topics\n>\n> 树\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root==null||root.val==val){\n            return root;\n        }\n        if(val<root.val){\n            return searchBST(root.left, val);\n        }else{\n            return searchBST(root.right, val);\n        }\n    }\n}\n```\n\n## <span id=\"head31\"> 🟡98.验证二叉搜索树</span>\n\n> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。\n>\n> **有效** 二叉搜索树定义如下：\n>\n> - 节点的左子树只包含 **小于** 当前节点的数。\n> - 节点的右子树只包含 **大于** 当前节点的数。\n> - 所有左子树和右子树自身必须也是二叉搜索树。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\n>\n> ```\n> 输入：root = [2,1,3]\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\n>\n> ```\n> 输入：root = [5,1,4,null,null,3,6]\n> 输出：false\n> 解释：根节点的值是 5 ，但是右子节点的值是 4 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目范围在`[1, 104]` 内\n> - `-231 <= Node.val <= 231 - 1`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        List<Integer>list=new ArrayList<>();\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                s.push(node);\n                s.push(null);\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.pop();\n                list.add(node.val);\n            }\n        }\n        for (int i = 0; i < list.size()-1; i++) {\n            if(list.get(i)>=list.get(i+1)){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n## <span id=\"head32\"> 🟢530.二叉搜索树的最小绝对差</span>\n\n> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。\n>\n> 差值是一个正数，其数值等于两值之差的绝对值。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)\n>\n> ```\n> 输入：root = [4,2,6,1,3]\n> 输出：1\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)\n>\n> ```\n> 输入：root = [1,0,48,null,null,12,49]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目范围是 `[2, 104]`\n> - `0 <= Node.val <= 105`\n>\n> \n>\n> **注意：**本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 广度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int getMinimumDifference(TreeNode root) {\n        int res=Integer.MAX_VALUE;\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        int last=root.val;\n        TreeNode p=root;\n        while(p.left!=null){\n            p=p.left;\n        }\n        while(!s.isEmpty()){\n            TreeNode node=s.peek();\n            if(node!=null){\n                s.pop();\n                if(node.right!=null){\n                    s.push(node.right);\n                }\n                s.push(node);\n                s.push(null);\n                if(node.left!=null){\n                    s.push(node.left);\n                }\n            }else{\n                s.pop();\n                node=s.pop();\n                if(Math.abs(last- node.val)<res&&Math.abs(last- node.val)!=0){\n                    res=Math.abs(last- node.val);\n                }\n                last= node.val;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head33\"> 🟢501.二叉搜索树中的众数</span>\n\n> 给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。\n>\n> 如果树中有不止一个众数，可以按 **任意顺序** 返回。\n>\n> 假定 BST 满足如下定义：\n>\n> - 结点左子树中所含节点的值 **小于等于** 当前节点的值\n> - 结点右子树中所含节点的值 **大于等于** 当前节点的值\n> - 左子树和右子树都是二叉搜索树\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)\n>\n> ```\n> 输入：root = [1,null,2,2]\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [0]\n> 输出：[0]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点的数目在范围 `[1, 104]` 内\n> - `-105 <= Node.val <= 105`\n>\n> \n>\n> **进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public int[] findMode(TreeNode root) {\n        List<Integer>al=new ArrayList<>();\n        Map<Integer,Integer>map=new HashMap<>();\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            map.put(node.val,map.getOrDefault(node.val,0)+1);\n            if(node.right!=null){\n                s.push(node.right);\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n        }\n        int max=Collections.max(map.values());\n        Iterator it=map.entrySet().iterator();\n        while(it.hasNext()){\n            Map.Entry entry=(Map.Entry) it.next();\n            if((int) entry.getValue()==max){\n                al.add((int) entry.getKey());\n            }\n        }\n        int len=al.size();\n        int[]res=new int[len];\n        for (int i = 0; i < len; i++) {\n            res[i]=al.get(i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n## <span id=\"head34\"> 🟡538.把二叉搜索树转换为累加树</span>\n\n> 给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。\n>\n> 提醒一下，二叉搜索树满足下列约束条件：\n>\n> - 节点的左子树仅包含键 **小于** 节点键的节点。\n> - 节点的右子树仅包含键 **大于** 节点键的节点。\n> - 左右子树也必须是二叉搜索树。\n>\n> **注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n>\n> \n>\n> **示例 1：**\n>\n> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)**\n>\n> ```\n> 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n> 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [0,null,1]\n> 输出：[1,null,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1,0,2]\n> 输出：[3,3,2]\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：root = [3,2,4,1]\n> 输出：[7,9,4,10]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中的节点数介于 `0` 和 `104` 之间。\n> - 每个节点的值介于 `-104` 和 `104` 之间。\n> - 树中的所有值 **互不相同** 。\n> - 给定的树为二叉搜索树。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode convertBST(TreeNode root) {\n        if(root==null){\n            return root;\n        }\n        List<Integer>list=new ArrayList<>();\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            list.add(node.val);\n            if(node.left!=null){\n                s.push(node.left);\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n        }\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            int temp= node.val;\n            for (int n:\n                 list) {\n                if(n> temp){\n                    node.val+=n;\n                }\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n        }\n        return root;\n    }\n}\n```\n\n\n\n# <span id=\"head35\">二叉树公共祖先问题   </span>\n\n## <span id=\"head36\"> 🟡236.二叉树的最近公共祖先</span>\n\n> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n> 输出：3\n> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)\n>\n> ```\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n> 输出：5\n> 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [1,2], p = 1, q = 2\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数目在范围 `[2, 105]` 内。\n> - `-109 <= Node.val <= 109`\n> - 所有 `Node.val` `互不相同` 。\n> - `p != q`\n> - `p` 和 `q` 均存在于给定的二叉树中。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉树\n\n```java\nclass Solution {\n    static LinkedList<TreeNode> l=new LinkedList<>();\n    static LinkedList<TreeNode> l1,l2;\n    static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        l.add(root);\n        backTracking(root,p,0);\n        backTracking(root,q,1);\n        int index=0;\n        while(index< l1.size()&&index<l2.size()&&l1.get(index)==l2.get(index)){\n            index++;\n        }\n        return l1.get(index-1);\n    }\n    static void backTracking(TreeNode root, TreeNode node,int num){\n        if(root==node){\n            if(num==0){\n                l1= (LinkedList) l.clone();\n            }else{\n                l2= (LinkedList) l.clone();\n            }\n            return;\n        }\n        if(root.left!=null){\n            l.add(root.left);\n            backTracking(root.left,node,num);\n            l.removeLast();\n        }\n        if(root.right!=null){\n            l.add(root.right);\n            backTracking(root.right,node,num);\n            l.removeLast();\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head37\">🟡235.二叉搜索树的最近公共祖先  </span>\n\n> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n>\n> 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n> 输出: 6 \n> 解释: 节点 2 和节点 8 的最近公共祖先是 6。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n> 输出: 2\n> 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n> ```\n>\n> \n>\n> **说明:**\n>\n> - 所有节点的值都是唯一的。\n> - p、q 为不同节点且均存在于给定的二叉搜索树中。\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    static LinkedList<TreeNode> l=new LinkedList<>();\n    static LinkedList<TreeNode> l1,l2;\n    static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        l.add(root);\n        backTracking(root,p,0);\n        backTracking(root,q,1);\n        int index=0;\n        while(index< l1.size()&&index<l2.size()&&l1.get(index)==l2.get(index)){\n            index++;\n        }\n        return l1.get(index-1);\n    }\n    static void backTracking(TreeNode root, TreeNode node,int num){\n        if(root==node){\n            if(num==0){\n                l1= (LinkedList) l.clone();\n            }else{\n                l2= (LinkedList) l.clone();\n            }\n            return;\n        }\n        if(root.left!=null){\n            l.add(root.left);\n            backTracking(root.left,node,num);\n            l.removeLast();\n        }\n        if(root.right!=null){\n            l.add(root.right);\n            backTracking(root.right,node,num);\n            l.removeLast();\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head38\">二叉搜索树的修改与构造 </span>\n\n## <span id=\"head39\"> 🟡701.二叉搜索树中的插入操作</span>\n\n> 给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。\n>\n> **注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)\n>\n> ```\n> 输入：root = [4,2,7,1,3], val = 5\n> 输出：[4,2,7,1,3,5]\n> 解释：另一个满足题目要求可以通过的树是：\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：root = [40,20,60,10,30,50,70], val = 25\n> 输出：[40,20,60,10,30,50,70,null,null,25]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n> 输出：[4,2,7,1,3,5]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中的节点数将在 `[0, 104]`的范围内。\n> - `-108 <= Node.val <= 108`\n> - 所有值 `Node.val` 是 **独一无二** 的。\n> - `-108 <= val <= 108`\n> - **保证** `val` 在原始BST中不存在。\n>\n> Related Topics\n>\n> 树\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if(root==null){\n            return new TreeNode(val);\n        }\n        dfs(root,val);\n        return root;\n\n    }\n    void dfs(TreeNode node,int v){\n        if(v<node.val){\n            if(node.left!=null){\n                dfs(node.left,v);\n            }else{\n                node.left=new TreeNode(v);\n            }\n        }else{\n            if(node.right!=null){\n                dfs(node.right,v);\n            }else{\n                node.right=new TreeNode(v);\n            }\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head40\"> 🟡450.删除二叉搜索树中的节点</span>\n\n> 给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n>\n> 一般来说，删除节点可分为两个步骤：\n>\n> 1. 首先找到需要删除的节点；\n> 2. 如果找到了，删除它。\n>\n> \n>\n> **示例 1:**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)\n>\n> ```\n> 输入：root = [5,3,6,2,4,null,7], key = 3\n> 输出：[5,4,6,2,null,null,7]\n> 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n> 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n> 另一个正确答案是 [5,2,6,null,4,null,7]。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: root = [5,3,6,2,4,null,7], key = 0\n> 输出: [5,3,6,2,4,null,7]\n> 解释: 二叉树不包含值为 0 的节点\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: root = [], key = 0\n> 输出: []\n> ```\n>\n> \n>\n> **提示:**\n>\n> - 节点数的范围 `[0, 104]`.\n> - `-105 <= Node.val <= 105`\n> - 节点值唯一\n> - `root` 是合法的二叉搜索树\n> - `-105 <= key <= 105`\n>\n> \n>\n> **进阶：** 要求算法时间复杂度为 O(h)，h 为树的高度。\n>\n> Related Topics\n>\n> 树\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if(root==null){\n            return root;\n        }\n        if(root.val==key){\n            if(root.left==null&&root.right==null){\n                return null;\n            }else if(root.left==null){\n                return root.right;\n            } else if (root.right==null) {\n                return  root.left;\n            }else{\n                TreeNode p=root.right;\n                while(p.left!=null){\n                    p=p.left;\n                }\n                p.left=root.left;\n                return root.right;\n            }\n        }\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            if(node.left!=null&&node.left.val==key){\n                if(node.left.left==null&&node.left.right==null){\n                    node.left=null;\n                }else if(node.left.left==null){\n                    node.left=node.left.right;\n                } else if (node.left.right==null) {\n                    node.left=node.left.left;\n                }else{\n                    TreeNode p=node.left.right;\n                    while(p.left!=null){\n                        p=p.left;\n                    }\n                    p.left=node.left.left;\n                    node.left=node.left.right;\n                }\n            }\n            if(node.right!=null&&node.right.val==key){\n                if(node.right.left==null&&node.right.right==null){\n                    node.right=null;\n                }else if(node.right.left==null){\n                    node.right=node.right.right;\n                } else if (node.right.right==null) {\n                    node.right=node.right.left;\n                }else{\n                    TreeNode p=node.right.right;\n                    while(p.left!=null){\n                        p=p.left;\n                    }\n                    p.left=node.right.left;\n                    node.right=node.right.right;\n                }\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n        }\n        return root;\n    }\n}\n```\n\n\n\n## <span id=\"head41\"> 🟡669.修剪二叉搜索树</span>\n\n> 给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。\n>\n> 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)\n>\n> ```\n> 输入：root = [1,0,2], low = 1, high = 2\n> 输出：[1,null,2]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)\n>\n> ```\n> 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n> 输出：[3,2,null,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 树中节点数在范围 `[1, 104]` 内\n> - `0 <= Node.val <= 104`\n> - 树中每个节点的值都是 **唯一** 的\n> - 题目数据保证输入是一棵有效的二叉搜索树\n> - `0 <= low <= high <= 104`\n>\n> Related Topics\n>\n> 树\n>\n> 深度优先搜索\n>\n> 二叉搜索树\n>\n> 二叉树\n\n```java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {        \n        while(root!=null&&(root.val>high||root.val<low)){\n            root=modify(root);\n        }\n        if(root==null){\n            return null;\n        }\n        while(!check(root,low,high)){\n            doing(root,low,high);\n        }\n        return root;\n    }\n    static void doing(TreeNode root,int low,int high){\n        Stack<TreeNode>s=new Stack<>();\n        s.push(root);\n        while(!s.isEmpty()){\n            TreeNode node=s.pop();\n            if(node.left!=null&&(node.left.val>high||node.left.val<low)){\n                node.left=modify(node.left);\n            }\n            if(node.right!=null&&(node.right.val>high||node.right.val<low)){\n                node.right=modify(node.right);\n            }\n            if(node.right!=null){\n                s.push(node.right);\n            }\n            if(node.left!=null){\n                s.push(node.left);\n            }\n        }\n    }\n    static TreeNode modify(TreeNode node){\n        if(node.left==null&&node.right==null){\n            return null;\n        } else if (node.left==null) {\n            return node.right;\n        } else if (node.right==null) {\n            return node.left;\n        }else{\n            TreeNode p=node.right;\n            while(p.left!=null){\n                p=p.left;\n            }\n            p.left=node.left;\n            return node.right;\n        }\n    }\n    static boolean check(TreeNode root,int low,int high){\n        Queue<TreeNode> q=new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()){\n            int len=q.size();\n            while(len-->0){\n                TreeNode node=q.poll();\n                if(node.val>high||node.val<low){\n                    return false;\n                }\n                if(node.left!=null){\n                    q.offer(node.left);\n                }\n                if(node.right!=null){\n                    q.offer(node.right);\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\nman,竟然裂出了四个函数,官方寥寥几行的代码让我发现我没有利用搜索树的特性!!!!!\n\n```java\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val < low) {\n            return trimBST(root.right, low, high);\n        } else if (root.val > high) {\n            return trimBST(root.left, low, high);\n        } else {\n            root.left = trimBST(root.left, low, high);\n            root.right = trimBST(root.right, low, high);\n            return root;\n        }\n    }\n}\n```\n\n\n\n## <span id=\"head42\"> 🟢108.将有序数组转换为二叉搜索树</span>\n\n> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。\n>\n> **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)\n>\n> ```\n> 输入：nums = [-10,-3,0,5,9]\n> 输出：[0,-3,9,-10,null,5]\n> 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)\n>\n> ```\n> 输入：nums = [1,3]\n> 输出：[3,1]\n> 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 按 **严格递增** 顺序排列\n>\n> Related Topics\n>\n> 树\n>\n> 二叉搜索树\n>\n> 数组\n>\n> 分治\n>\n> 二叉树\n\n```   java\nclass Solution {\n    Set<Integer> set=new TreeSet<>();\n    public TreeNode sortedArrayToBST(int[] nums) {\n        TreeNode res=new TreeNode(nums[(nums.length-1)/2]);\n        set.add((nums.length-1)/2);\n        dfs(res,nums,0,nums.length-1);\n        return res;\n    }\n    void dfs(TreeNode node,int[]a,int i,int j){\n        if(node==null){\n            return;\n        }\n        int mid=(i+j)/2;\n        if(!set.contains((i+mid-1)/2)){\n            node.left=new TreeNode(a[(i+mid-1)/2]);\n            set.add((i+mid-1)/2);\n        }\n        if(!set.contains((mid+1+j)/2)){\n            node.right=new TreeNode(a[(mid+1+j)/2]);\n            set.add((mid+1+j)/2);\n        }\n        dfs(node.left,a,i,mid-1);\n        dfs(node.right,a,mid+1,j);\n    }\n}\n```\n","categories":["algorithm learning"]},{"title":"Stack & Queue","url":"/2023/09/06/algorithm-stack&queue/","content":"\n|      | 是否完成 | 题号                                          | 标签         |\n| ---- | :------: | --------------------------------------------- | :----------- |\n| 1    |    ✅     | [ 🟢232.用栈实现队列](#head1)                  | 栈 队列      |\n| 2    |    ✅     | [🟢225. 用队列实现栈 ](#head2)                 | 栈 队列      |\n| 3    |    ✅     | [🟢20. 有效的括号](#head3)                     | 栈           |\n| 4    |    ✅     | [🟢1047. 删除字符串中的所有相邻重复项](#head4) | 栈           |\n| 5    |    ✅     | [🟡150. 逆波兰表达式求值](#head5)              | 栈           |\n| 6    |          | [🔴239. 滑动窗口最大值](#head6)                |              |\n| 7    |    ✅     | [🟡347.前 K 个高频元素](#head7)                | 哈希表  排序 |\n\n# <span id=\"head1\"> 🟢232.用栈实现队列</span>\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n>\n> 实现 `MyQueue` 类：\n>\n> - `void push(int x)` 将元素 x 推到队列的末尾\n> - `int pop()` 从队列的开头移除并返回元素\n> - `int peek()` 返回队列开头的元素\n> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n>\n> **说明：**\n>\n> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> \n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n> ```\n>\n> \n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\n>\n> \n>\n> **进阶：**\n>\n> - 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyQueue {\n    Stack<Integer> in;\n    Stack<Integer> out;\n\n    public MyQueue() {\n        in=new Stack<>();\n        out=new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        pour1();\n        int res=out.pop();\n        pour2();\n        return res;\n    }\n    \n    public int peek() {\n        pour1();\n        int res=out.peek();\n        pour2();\n        return res;\n    }\n    \n    public boolean empty() {\n        return out.empty()&&in.empty();\n    }\n\n    void pour1(){\n        while(!in.empty()){\n            out.push(in.pop());\n        }\n    }\n    void pour2(){\n        while(!out.empty()){\n            in.push(out.pop());\n        }\n    }\n\n}\n```\n\n# <span id=\"head2\">🟢225. 用队列实现栈 </span>\n\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n>\n> 实现 `MyStack` 类：\n>\n> - `void push(int x)` 将元素 x 压入栈顶。\n> - `int pop()` 移除并返回栈顶元素。\n> - `int top()` 返回栈顶元素。\n> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。\n>\n> \n>\n> **注意：**\n>\n> - 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。\n> - 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\n> [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 2, 2, false]\n> \n> 解释：\n> MyStack myStack = new MyStack();\n> myStack.push(1);\n> myStack.push(2);\n> myStack.top(); // 返回 2\n> myStack.pop(); // 返回 2\n> myStack.empty(); // 返回 False\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= x <= 9`\n> - 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`\n> - 每次调用 `pop` 和 `top` 都保证栈不为空\n>\n> \n>\n> **进阶：**你能否仅用一个队列来实现栈。\n>\n> Related Topics\n>\n> 栈\n>\n> 设计\n>\n> 队列\n\n```java\nclass MyStack {\n    Queue<Integer>in;\n    Queue<Integer>out;\n\n    public MyStack() {\n        in = new LinkedList<>();\n        out = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        in.offer(x);\n    }\n    \n    public int pop() {\n        inToOut();\n        int res=in.poll();\n        outToIn();\n        return res;\n    }\n    \n    public int top() {\n        inToOut();\n        int res=in.peek();\n        out.offer(in.poll());\n        outToIn();\n        return res;\n    }\n    \n    public boolean empty() {\n        return in.isEmpty();\n    }\n    void inToOut(){\n        int size=in.size();\n        for (int i = 0; i < size-1; i++) {\n            out.offer(in.poll());\n        }\n    }\n    void outToIn(){\n        while(!out.isEmpty()){\n            in.offer(out.poll());\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head3\">🟢20. 有效的括号</span>\n\n> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n>\n> 有效字符串需满足：\n>\n> 1. 左括号必须用相同类型的右括号闭合。\n> 2. 左括号必须以正确的顺序闭合。\n> 3. 每个右括号都有一个对应的相同类型的左括号。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"()\"\n> 输出：true\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"()[]{}\"\n> 输出：true\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"(]\"\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅由括号 `'()[]{}'` 组成\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack=new Stack<>();\n        for (char ch:\n             s.toCharArray()) {\n            if(ch=='('||ch=='{'||ch=='['){\n                stack.push(ch);\n            } else if (!stack.empty()&&(ch==')'&&stack.peek()=='('\n            ||ch=='}'&&stack.peek()=='{'\n            ||ch==']'&&stack.peek()=='[')) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n        if(stack.empty()){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head4\">🟢1047. 删除字符串中的所有相邻重复项</span>\n\n> 给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。\n>\n> 在 S 上反复执行重复项删除操作，直到无法继续删除。\n>\n> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n>\n> \n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入：\"abbaca\"\n> 输出：\"ca\"\n> 解释：\n> 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> 1. `1 <= S.length <= 20000`\n> 2. `S` 仅由小写英文字母组成。\n>\n> Related Topics\n>\n> 栈\n>\n> 字符串\n\n```java\nclass Solution {\n    public String removeDuplicates(String s) {\n        Stack<Character> stack=new Stack<>();\n        char last;\n        for (char ch:\n                s.toCharArray()) {\n            if(stack.empty()){\n                stack.push(ch);\n                last=ch;\n            }else if(ch==stack.peek()){\n                stack.pop();\n\n            }else{\n                stack.push(ch);\n            }\n        }\n        Stack<Character> stack_=new Stack<>();\n        while(!stack.empty()){\n            stack_.push(stack.pop());\n        }\n        StringBuilder sb=new StringBuilder();\n        while(!stack_.empty()){\n            sb.append(stack_.pop());\n\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n# <span id=\"head5\">🟡150. 逆波兰表达式求值</span>\n\n> 给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。\n>\n> 请你计算该表达式。返回一个表示表达式值的整数。\n>\n> **注意：**\n>\n> - 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。\n> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n> - 两个整数之间的除法总是 **向零截断** 。\n> - 表达式中不含除零运算。\n> - 输入是一个根据逆波兰表示法表示的算术表达式。\n> - 答案及所有中间计算结果可以用 **32 位** 整数表示。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n> 输出：9\n> 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n> 输出：6\n> 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n> 输出：22\n> 解释：该算式转化为常见的中缀算术表达式为：\n>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n> = ((10 * (6 / (12 * -11))) + 17) + 5\n> = ((10 * (6 / -132)) + 17) + 5\n> = ((10 * 0) + 17) + 5\n> = (0 + 17) + 5\n> = 17 + 5\n> = 22\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= tokens.length <= 104`\n> - `tokens[i]` 是一个算符（`\"+\"`、`\"-\"`、`\"*\"` 或 `\"/\"`），或是在范围 `[-200, 200]` 内的一个整数\n>\n> \n>\n> **逆波兰表达式：**\n>\n> 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n>\n> - 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。\n> - 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。\n>\n> 逆波兰表达式主要有以下两个优点：\n>\n> - 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。\n> - 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\n>\n> Related Topics\n>\n> 栈\n>\n> 数组\n>\n> 数学\n\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> s=new Stack<>();\n        for (String str:\n                tokens) {\n            if(str.length()==1&&str.charAt(0)=='+'){\n                int temp=s.pop()+s.pop();\n                s.push(temp);\n            } else if(str.length()==1&&str.charAt(0)=='-'){\n                int t=s.pop();\n                int temp=s.pop()-t;\n                s.push(temp);\n            }else if(str.length()==1&&str.charAt(0)=='*'){\n                int temp=s.pop()*s.pop();\n                s.push(temp);\n            }else if(str.length()==1&&str.charAt(0)=='/'){\n                int t=s.pop();\n                int temp=s.pop()/t;\n                s.push(temp);\n            }else{\n                s.push(convert(str));\n            }\n        }\n        return s.pop();\n    }\n    int convert(String str){\n        int res=0;\n        if(str.charAt(0)=='-'){\n            for (int i = str.length()-1,j=1; i >0 ; i--,j*=10) {\n                res+=(str.charAt(i)-'0')*j;\n            }\n            res*=(-1);\n        }else{\n            for (int i = str.length()-1,j=1; i >=0 ; i--,j*=10) {\n                res+=(str.charAt(i)-'0')*j;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head6\">🔴239. 滑动窗口最大值</span>\n\n> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n>\n> 返回 *滑动窗口中的最大值* 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n> 输出：[3,3,5,5,6,7]\n> 解释：\n> 滑动窗口的位置                最大值\n> ---------------               -----\n> [1  3  -1] -3  5  3  6  7       3\n> 1 [3  -1  -3] 5  3  6  7       3\n> 1  3 [-1  -3  5] 3  6  7       5\n> 1  3  -1 [-3  5  3] 6  7       5\n> 1  3  -1  -3 [5  3  6] 7       6\n> 1  3  -1  -3  5 [3  6  7]      7\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [1], k = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `-104 <= nums[i] <= 104`\n> - `1 <= k <= nums.length`\n>\n> Related Topics\n>\n> 队列\n>\n> 数组\n>\n> 滑动窗口\n>\n> 单调队列\n>\n> 堆（优先队列）\n\n自己写的双指针竟然超时,why?\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[]res=new int[nums.length-k+1];\n        int i=0,j=0;\n        int max=Integer.MIN_VALUE;\n        for (; i < k; i++) {//after finish this i=k\n            if(nums[i]>max){\n                max=nums[i];\n            }\n        }\n        res[0]=max;\n        int index=1;\n        while(i< nums.length&&j< nums.length){\n            if(nums[j++]<max){\n                max=Math.max(max,nums[i++]);\n            }else{\n                int temp_max=Integer.MIN_VALUE;\n                for (int l = index; l < index+k; l++) {\n                    if(nums[l]>temp_max){\n                        temp_max=nums[l];\n                    }\n                }\n                max=Math.max(temp_max,nums[i++]);                \n            }\n            res[index++]=max;\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head7\">🟡347.前 K 个高频元素</span>\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [1,1,1,2,2,3], k = 2\n> 输出: [1,2]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [1], k = 1\n> 输出: [1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 105`\n> - `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`\n> - 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的\n>\n> \n>\n> **进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 分治\n>\n> 桶排序\n>\n> 计数\n>\n> 快速选择\n>\n> 排序\n>\n> 堆（优先队列）\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer,Integer> map=new TreeMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i],0)+1);\n        }\n        List<Map.Entry<Integer, Integer>> list = new ArrayList<Map.Entry<Integer, Integer>>(map.entrySet());\n        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {\n            @Override\n            public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\n                return o2.getValue().compareTo(o1.getValue());\n            }\n        });\n        int []res=new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i]= list.get(i).getKey();\n        }\n        return res;\n\n    }\n}\n```\n\n","categories":["algorithm learning"]},{"title":"Two Pointers","url":"/2023/09/05/algorithm-twopointers/","content":"\n|      | 是否完成 | 题号                                      | 标签        |\n| ---- | :------: | ----------------------------------------- | :---------- |\n| 1    |    ✅     | [ 🟢27. 移除元素](#head1)                  | 双指针      |\n| 2    |    ✅     | [🟢26. 删除有序数组中的重复项  ](#head2)   | 双指针      |\n| 3    |    ✅     | [🟢283. 移动零](#head3)                    | 双指针      |\n| 4    |          | [🟢844. 比较含退格的字符串](#head4)        |             |\n| 5    |    ✅     | [🟢977. 有序数组的平方](#head5)            | 双指针      |\n| 6    |    ✅     | [🟢344. 反转字符串](#head6)                | 双指针      |\n| 7    |    ✅     | [🟢LCR 122. 路径加密](#head7)              | replace函数 |\n| 8    |    ✅     | [🟡151. 反转字符串中的单词](#head8)        | 正则表达式  |\n| 9    |          | [🟢206. 反转链表](#head9)                  |             |\n| 10   |          | [🟡19. 删除链表的倒数第 N 个结点](#head10) |             |\n| 11   |          | [🟢面试题 02.07. 链表相交](#head11)        |             |\n| 12   |          | [🟡142. 环形链表](#head12)                 |             |\n| 13   |          | [🟡15. 三数之和](#head13)                  |             |\n| 14   |          | [🟡18. 四数之和](#head14)                  |             |\n\n# <span id=\"head1\"> 🟢27. 移除元素</span>\n\n> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n>\n> \n>\n> **说明:**\n>\n> 为什么返回数值是整数，但输出的答案是数组呢?\n>\n> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n> 你可以想象内部操作如下:\n>\n> ```\n> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n> int len = removeElement(nums, val);\n> \n> // 在函数里修改输入数组对于调用者是可见的。\n> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n> for (int i = 0; i < len; i++) {\n>     print(nums[i]);\n> }\n> ```\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [3,2,2,3], val = 3\n> 输出：2, nums = [2,2]\n> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2\n> 输出：5, nums = [0,1,4,0,3]\n> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= nums.length <= 100`\n> - `0 <= nums[i] <= 50`\n> - `0 <= val <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int len= nums.length;\n        if(len==1&&nums[0]!=val){\n            return 1;\n        }else if(len==1){\n            return 0;\n        }\n        int i=0,j=len-1;\n        while(i<j){\n            while(i<j&&nums[i]!=val){\n                i++;\n            }\n            while(i<j&&nums[j]==val){\n                j--;\n            }\n            if(i>=nums.length||j<0||i>=j){\n                break;\n            }\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n            i++;\n            j--;\n            if(i>=nums.length||j<0||i>=j){\n                break;\n            }\n        }\n        int index=nums.length;\n        for (int k = 0; k < nums.length; k++) {\n            if(nums[k]==val){\n                index=k;\n                break;\n            }\n        }\n        return index;\n    }\n}\n```\n\n\n\n# <span id=\"head2\">🟢26. 删除有序数组中的重复项 </span>\n\n> 给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。\n>\n> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：\n>\n> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。\n> - 返回 `k` 。\n>\n> **判题标准:**\n>\n> 系统会用下面的代码来测试你的题解:\n>\n> ```\n> int[] nums = [...]; // 输入数组\n> int[] expectedNums = [...]; // 长度正确的期望答案\n> \n> int k = removeDuplicates(nums); // 调用\n> \n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n> ```\n>\n> 如果所有断言都通过，那么您的题解将被 **通过**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2,_]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **升序** 排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len= nums.length;\n        if(len==1){\n            return 1;\n        }\n        int i=0,j=1;\n        while(j< len){\n            while(j< len&&nums[j]==nums[i]){\n                j++;\n            }\n            if(j>=len){\n                break;\n            }\n            int temp=nums[i+1];\n            nums[i+1]=nums[j];\n            nums[j]=temp;\n            i++;\n            j++;\n            if(j>=len){\n                break;\n            }\n        }\n        return i+1;\n    }\n}\n```\n\n\n\n# <span id=\"head4\">🟢283. 移动零</span>\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len= nums.length;\n       if(len==1){\n           return ;\n       }\n       int i=0,j=1;\n       while(j<len){\n           while(i<len&&nums[i]!=0){\n               i++;\n           }\n           j=i+1;\n           while(j<len&&nums[j]==0){\n               j++;\n           }\n           if(j>=len||i+1>=len){\n               break;\n           }\n           int temp=nums[i];\n           nums[i]=nums[j];\n           nums[j]=temp;\n           i++;\n           j++;\n           if(j>=len){\n               break;\n           }\n       }\n    }\n}\n```\n\n\n\n# <span id=\"head5\">🟢844. 比较含退格的字符串</span>\n\n> 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。\n>\n> **注意：**如果对空文本输入退格字符，文本继续为空。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ab#c\", t = \"ad#c\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"ac\"。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"ab##\", t = \"c#d#\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"\"。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a#c\", t = \"b\"\n> 输出：false\n> 解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length, t.length <= 200`\n> - `s` 和 `t` 只含有小写字母以及字符 `'#'`\n>\n> \n>\n> **进阶：**\n>\n> - 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 双指针\n>\n> 字符串\n>\n> 模拟\n\n```java\n```\n\n\n\n# <span id=\"head6\">🟢977. 有序数组的平方</span>\n\n> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-4,-1,0,3,10]\n> 输出：[0,1,9,16,100]\n> 解释：平方后，数组变为 [16,1,0,9,100]\n> 排序后，数组变为 [0,1,9,16,100]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [-7,-3,2,3,11]\n> 输出：[4,9,9,49,121]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **非递减顺序** 排序\n>\n> \n>\n> **进阶：**\n>\n> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int len= nums.length;\n        int i=0,j=len-1,index=j;\n        int[]res=new int[len];\n        while(index>=0&&i<=j){\n            if(nums[i]*nums[i]>nums[j]*nums[j]){\n                res[index--]=nums[i]*nums[i++];\n            }else{\n                res[index--]=nums[j]*nums[j--];\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head7\">🟢344. 反转字符串</span>\n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n>\n> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int i=0,j=s.length-1;\n        while(i<j){\n            char temp=s[i];\n            s[i]=s[j];\n            s[j]=temp;\n            i++;\n            j--;\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head8\">🟢LCR 122. 路径加密</span>\n\n> 假定一段路径记作字符串 `path`，其中以 \"`.`\" 作为分隔符。现需将路径加密，加密方法为将 `path` 中的分隔符替换为空格 \"` `\"，请返回加密后的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：path = \"a.aef.qerf.bb\"\n> \n> 输出：\"a aef qerf bb\"\n> ```\n>\n> \n>\n> **限制：**\n>\n> ```\n> 0 <= path.length <= 10000\n> ```\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public String pathEncryption(String path) {\n        return path.replace('.',' ');\n    }\n}\n```\n\n还是用双指针(单指针)做一下：\n\n```java\nclass Solution {\n    public String pathEncryption(String path) {\n        char[]chars=path.toCharArray();\n        for (int i = 0; i < path.length(); i++) {\n            if(chars[i]=='.'){\n                chars[i]=' ';\n            }\n        }\n        return String.copyValueOf(chars);\n    }\n}\n```\n\n# <span id=\"head9\">🟡151. 反转字符串中的单词</span>\n\n> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n>\n> **单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n>\n> 返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n>\n> **注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"the sky is blue\"\n> 输出：\"blue is sky the\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"  hello world  \"\n> 输出：\"world hello\"\n> 解释：反转后的字符串中不能存在前导空格和尾随空格。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a good   example\"\n> 输出：\"example good a\"\n> 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 包含英文大小写字母、数字和空格 `' '`\n> - `s` 中 **至少存在一个** 单词\n>\n> \n>\n> \n>\n> **进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        String[]strings=s.split(\"[ ]+\");\n        StringBuilder sb=new StringBuilder();\n        for (int i = strings.length-1; i >=0 ; i--) {\n            sb.append(strings[i]+\" \");\n        }\n        return sb.toString().trim();\n    }\n}\n```\n\n还是用双指针做一下：\n\n```java\n```\n\n\n\n# <span id=\"head10\">🟢206. 反转链表</span>\n\n> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n>\n> ```\n> 输入：head = [1,2]\n> 输出：[2,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[0, 5000]`\n> - `-5000 <= Node.val <= 5000`\n>\n> \n>\n> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\n```\n\n\n\n# <span id=\"head11\">🟡19. 删除链表的倒数第 N 个结点</span>\n\n> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [1], n = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1,2], n = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中结点的数目为 `sz`\n> - `1 <= sz <= 30`\n> - `0 <= Node.val <= 100`\n> - `1 <= n <= sz`\n>\n> \n>\n> **进阶：**你能尝试使用一趟扫描实现吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\n```\n\n\n\n# <span id=\"head12\">🟢面试题 02.07. 链表相交</span>\n\n# <span id=\"head13\">🟡142. 环形链表 II</span>\n\n# <span id=\"head14\">🟡15. 三数之和</span>\n\n# <span id=\"head15\">🟡18. 四数之和</span>\n","categories":["algorithm learning"]},{"title":"Strings","url":"/2023/09/04/algorithm-strings/","content":"\n|      | 是否完成 | 难度 | 题号                                         | 标签                                |\n| ---- | :------: | :--: | :------------------------------------------- | ----------------------------------- |\n| 1    |    ✅     |  🟢   | [ 344.反转字符串](#head1)                    | 字符串 字符数组                     |\n| 2    |    ✅     |  🟢   | [ 541.反转字符串II](#head2)                  | 字符串 字符数组                     |\n| 3    |    ✅     |  🟢   | [LCR 122. 路径加密](#head3)                  | 字符串 字符数组                     |\n| 4    |    ✅     |  🟡   | [ 151.翻转字符串里的单词](#head4)            | 去空格 字符串 字符数组 StringBuffer |\n| 5    |    ✅     |  🟢   | [LCR 182. 动态口令](#head5)                  | StringBuffer SubString              |\n| 6    |    ✅     |  🟢   | [ 28.找出字符串中第一个匹配项的下标](#head6) | 匹配                                |\n| 7    |    ✅     |  🟢   | [ 459.重复的子字符串](#head7)                | 匹配                                |\n\n# <span id=\"head1\"> 🟢344.反转字符串</span>\n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n>\n> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n> 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n> 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 105`\n> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int i=0,j=s.length-1;\n        while(i<j){\n            char temp=s[i];\n            s[i]=s[j];\n            s[j]=temp;\n            i++;\n            j--;\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head2\"> 🟢541.反转字符串II</span>\n\n> 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。\n>\n> - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。\n> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"abcdefg\", k = 2\n> 输出：\"bacdfeg\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"abcd\", k = 2\n> 输出：\"bacd\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 仅由小写英文组成\n> - `1 <= k <= 104`\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseStr(String s, int k) {\n        char [] ca=s.toCharArray();\n        int len=s.length();\n        for(int i=0;i<len;i+=2*k){\n            reverse(ca,i,Math.min(len-1,i+k-1));\n        }\n        return String.valueOf(ca);\n\n    }\n    void reverse(char[] ch_arr,int from,int to){\n        while(from<to&&from>=0&&to< ch_arr.length){\n            char temp=ch_arr[from];\n            ch_arr[from]=ch_arr[to];\n            ch_arr[to]=temp;\n            from++;\n            to--;\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head3\">🟢LCR 122. 路径加密</span>\n\n> 假定一段路径记作字符串 `path`，其中以 \"`.`\" 作为分隔符。现需将路径加密，加密方法为将 `path` 中的分隔符替换为空格 \"` `\"，请返回加密后的字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：path = \"a.aef.qerf.bb\"\n> \n> 输出：\"a aef qerf bb\"\n> ```\n>\n> \n>\n> **限制：**\n>\n> ```\n> 0 <= path.length <= 10000\n> ```\n>\n> Related Topics\n>\n> 字符串\n\n```java\nclass Solution {\n    public String pathEncryption(String path) {\n        char [] ca=path.toCharArray();\n        for (int i = 0; i < path.length(); i++) {\n            if(ca[i]=='.'){\n                ca[i]=' ';\n            }\n        }\n        return String.valueOf(ca);\n    }\n}\n```\n\n\n\n# <span id=\"head4\"> 🟡151.翻转字符串里的单词</span>\n\n> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n>\n> **单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n>\n> 返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n>\n> **注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"the sky is blue\"\n> 输出：\"blue is sky the\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"  hello world  \"\n> 输出：\"world hello\"\n> 解释：反转后的字符串中不能存在前导空格和尾随空格。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a good   example\"\n> 输出：\"example good a\"\n> 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length <= 104`\n> - `s` 包含英文大小写字母、数字和空格 `' '`\n> - `s` 中 **至少存在一个** 单词\n>\n> \n>\n> \n>\n> **进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n//        1.去除多余的空格\n        int index=0;\n        StringBuilder sb=new StringBuilder();\n        while(index<s.length()&&s.charAt(index)==' '){//index指向第一个非空格字符\n            index++;\n        }\n        for (int i = index; i < s.length(); i++) {\n            if(i>0&&s.charAt(i)==' '&&s.charAt(i-1)==' '){\n                continue;\n            }else{\n                sb.append(s.charAt(i));\n            }\n        }\n        if(sb.charAt(sb.length()-1)==' '){\n            sb.deleteCharAt(sb.length()-1);\n        }\n\n//        2.反转整个字符串\n        char[] ca= sb.toString().toCharArray();\n        reverse(ca,0,ca.length-1);\n\n//        3.挨个单词反转字符串\n        int i = 0, j=0;\n        for (; i < ca.length; i++) {\n            if(ca[i]==' '){\n                reverse(ca,j,i-1);\n                j=i+1;\n            }\n        }\n        reverse(ca,j,ca.length-1);\n        return String.valueOf(ca);\n    }\n    void reverse(char[]char_arr,int from,int to) {\n        while (from < to && from < char_arr.length && to >= 0) {\n            char temp = char_arr[from];\n            char_arr[from] = char_arr[to];\n            char_arr[to] = temp;\n            from++;\n            to--;\n        }\n    }\n}\n```\n\n贴上卡哥的代码:\n\n```java\nclass Solution {\n   /**\n     * 不使用Java内置方法实现\n     * 1.去除首尾以及中间多余空格\n     * 2.反转整个字符串\n     * 3.反转各个单词\n     */\n    public String reverseWords(String s) {\n        // 1.去除首尾以及中间多余空格\n        StringBuilder sb = removeSpace(s);\n        // 2.反转整个字符串\n        reverseString(sb, 0, sb.length() - 1);\n        // 3.反转各个单词\n        reverseEachWord(sb);\n        return sb.toString();\n    }\n\n    private StringBuilder removeSpace(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        while (s.charAt(start) == ' ') start++;\n        while (s.charAt(end) == ' ') end--;\n        StringBuilder sb = new StringBuilder();\n        while (start <= end) {\n            char c = s.charAt(start);\n            if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') {\n                sb.append(c);\n            }\n            start++;\n        }\n        return sb;\n    }\n\n    /**\n     * 反转字符串指定区间[start, end]的字符\n     */\n    public void reverseString(StringBuilder sb, int start, int end) {\n        while (start < end) {\n            char temp = sb.charAt(start);\n            sb.setCharAt(start, sb.charAt(end));\n            sb.setCharAt(end, temp);\n            start++;\n            end--;\n        }\n    }\n\n    private void reverseEachWord(StringBuilder sb) {\n        int start = 0;\n        int end = 1;\n        int n = sb.length();\n        while (start < n) {\n            while (end < n && sb.charAt(end) != ' ') {\n                end++;\n            }\n            reverseString(sb, start, end - 1);\n            start = end + 1;\n            end = start + 1;\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head5\">🟢LCR 182. 动态口令</span>\n\n> 某公司门禁密码使用动态口令技术。初始密码为字符串 `password`，密码更新均遵循以下步骤：\n>\n> - 设定一个正整数目标值 `target`\n> - 将 `password` 前 `target` 个字符按原顺序移动至字符串末尾\n>\n> 请返回更新后的密码字符串。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入: password = \"s3cur1tyC0d3\", target = 4\n> 输出: \"r1tyC0d3s3cu\"\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入: password = \"lrloseumgh\", target = 6\n> 输出: \"umghlrlose\"\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= target < password.length <= 10000`\n>\n> \n>\n> Related Topics\n>\n> 数学\n>\n> 双指针\n>\n> 字符串\n\n```java\nclass Solution {\n    public String dynamicPassword(String password, int target) {\n        StringBuilder res=new StringBuilder();\n        res.append(password.substring(target,password.length()));\n        res.append(password.substring(0,target));\n        return res.toString();\n    }\n}\n```\n\n\n\n# <span id=\"head6\"> 🟢28.找出字符串中第一个匹配项的下标</span>\n\n> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：haystack = \"sadbutsad\", needle = \"sad\"\n> 输出：0\n> 解释：\"sad\" 在下标 0 和 6 处匹配。\n> 第一个匹配项的下标是 0 ，所以返回 0 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：haystack = \"leetcode\", needle = \"leeto\"\n> 输出：-1\n> 解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= haystack.length, needle.length <= 104`\n> - `haystack` 和 `needle` 仅由小写英文字符组成\n>\n> Related Topics\n>\n> 双指针\n>\n> 字符串\n>\n> 字符串匹配\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int index=0;\n        while(index<=haystack.length()-needle.length()){\n            while(index<haystack.length()-needle.length()&&haystack.charAt(index)!=needle.charAt(0)){\n                index++;//index指向某一个匹配短字符串首字符的位置\n            }\n            int flag=1;\n            for (int i = 0; i < needle.length(); i++) {\n                if(haystack.charAt(index+i)!=needle.charAt(i)){\n                    flag=0;\n                    break;\n                }\n            }\n            if(flag==1){\n                return index;\n            }else{\n                index++;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n补充KMP知识：\n\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int[]next=next_arr(needle);\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i))\n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i))\n                j++;\n            if (j == needle.length())\n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    \n    int[]next_arr(String pat){//huo'qu\n        int len=pat.length();\n        int[]next=new int[len];\n        next[0]=0;\n        int j=0;\n        for (int i = 1; i < len; i++) {\n            while(j>0&&pat.charAt(j)!=pat.charAt(i)){\n                j=next[j-1];\n            }\n            if(pat.charAt(j)==pat.charAt(i)){\n                j++;\n            }\n            next[i]=j;\n        }\n        return next;\n    }\n}\n```\n\n\n\n\n\n# <span id=\"head7\"> 🟢459.重复的子字符串</span>\n\n> 给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"abab\"\n> 输出: true\n> 解释: 可由子串 \"ab\" 重复两次构成。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"aba\"\n> 输出: false\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"abcabcabcabc\"\n> 输出: true\n> 解释: 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。)\n> ```\n>\n> \n>\n> **提示：**\n>\n> \n>\n> - `1 <= s.length <= 104`\n> - `s` 由小写英文字母组成\n>\n> Related Topics\n>\n> 字符串\n>\n> 字符串匹配\n\n```java\nclass Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        for (int i = 1; i < s.length()/2+1; i++) {\n            if(repead(s,s.substring(0,i))){\n                return true;\n            }\n        }\n        return false;\n    }\n    boolean repead(String a,String b){\n        if(a.length()%b.length()!=0){\n            return false;\n        }\n        for (int i = 0; i < a.length(); i+=b.length()) {\n            for (int j = 0; j < b.length(); j++) {\n                if(a.charAt(i+j)!=b.charAt(j)){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n","categories":["algorithm learning"]},{"title":"Hashing","url":"/2023/09/03/algorithm-hashing/","content":"\n|      | 是否完成 | 难度 | 题号                                      | 标签                  |\n| ---- | :------: | :--: | :---------------------------------------- | --------------------- |\n| 1    |    ✅     |  🟢   | [ 242.有效的字母异位词](#head2)           | 哈希表                |\n| 2    |    ✅     |  🟢   | [ 383.赎金信](#head3)                     | 哈希表                |\n| 3    |    ✅     |  🟡   | [ 49.字母异位词分组](#head4)              | 哈希表                |\n| 4    |    ✅     |  🟡   | [ 438.找到字符串中所有字母异位词](#head5) | 哈希表                |\n| 5    |    ✅     |  🟢   | [349. 两个数组的交集](#head6)             | 哈希表                |\n| 6    |    ✅     |  🟢   | [350.两个数组的交集 II](#head7)           | 哈希表                |\n| 7    |    ✅     |  🟢   | [202. 快乐数](#head8)                     | 哈希表                |\n| 8    |    ✅     |  🟢   | [ 1. 两数之和](#head9)                    | 暴力 哈希表           |\n| 9    |    ✅     |  🟡   | [ 454.四数相加II](#head12)                | 哈希表                |\n| 10   |    *✅    |  🟡   | [ 15. 三数之和](#head13)                  | 哈希表(双指针 后面做) |\n| 11   |    *     |  🟡   | [18. 四数之和](#head14)                   | (双指针 后面做)       |\n\n\n\n# <span id=\"head2\"> 🟢242.有效的字母异位词</span>\n\n> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。\n>\n> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"anagram\", t = \"nagaram\"\n> 输出: true\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"rat\", t = \"car\"\n> 输出: false\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, t.length <= 5 * 104`\n> - `s` 和 `t` 仅包含小写字母\n>\n> \n>\n> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length()){\n            return false;\n        }\n        int[]hashtable=new int[26];\n        Arrays.fill(hashtable,0);        \n        for (int i = 0; i < s.length(); i++) {\n            hashtable[s.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            hashtable[t.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtable[i]!=0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n# <span id=\"head3\"> 🟢383.赎金信</span>\n\n> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n>\n> 如果可以，返回 `true` ；否则返回 `false` 。\n>\n> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：ransomNote = \"a\", magazine = \"b\"\n> 输出：false\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"ab\"\n> 输出：false\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：ransomNote = \"aa\", magazine = \"aab\"\n> 输出：true\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= ransomNote.length, magazine.length <= 105`\n> - `ransomNote` 和 `magazine` 由小写英文字母组成\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 计数\n\n```java\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        if(ransomNote.length()>magazine.length()){\n            return false;\n        }\n        int[] hashtable =new int[26];\n        Arrays.fill(hashtable,0);\n        for (int i = 0; i < ransomNote.length(); i++) {\n            hashtable[ransomNote.charAt(i)-'a']++;\n        }\n        for (int i = 0; i < magazine.length(); i++) {\n            hashtable[magazine.charAt(i)-'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if(hashtable[i]>0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n\n\n# <span id=\"head4\"> 🟡49.字母异位词分组</span>\n\n> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n>\n> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n> 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: strs = [\"\"]\n> 输出: [[\"\"]]\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: strs = [\"a\"]\n> 输出: [[\"a\"]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= strs.length <= 104`\n> - `0 <= strs[i].length <= 100`\n> - `strs[i]` 仅包含小写字母\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 字符串\n>\n> 排序\n\n自己一开始一口气了又臭又长的,妥妥超时:\n\n```java\nclass Solution {\n\n    public boolean equal(int[]arr1,int []arr2) {\n        for (int i = 0; i < arr1.length; i++) {\n            if(arr1[i]!=arr2[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> res=new ArrayList<>();\n\n        if(strs.length==1){\n            List<String> temp=new ArrayList<>();\n            temp.add(strs[0]);\n            res.add(temp);\n            return res;\n        }\n\n        ArrayList<int[]>hashtable=new ArrayList<>();\n        for (int i = 0; i < strs.length; i++) {\n            int [] arr=new int[26];\n            Arrays.fill(arr,0);\n            for (int j = 0; j < strs[i].length(); j++) {\n                arr[strs[i].charAt(j)-'a']++;\n            }\n            int flag=0;\n            for (int j = 0; j < hashtable.size(); j++) {\n                if(equal(hashtable.get(j),arr)){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0){\n                hashtable.add(arr);\n            }\n        }\n\n        for (int i = 0; i < hashtable.size(); i++) {\n            List<String>temparr=new ArrayList<>();\n            for (int j = 0; j < strs.length; j++) {\n                int []arr=new int [26];\n                Arrays.fill(arr,0);\n                for (int k = 0; k < strs[j].length(); k++) {\n                    arr[strs[j].charAt(k)-'a']++;\n                }\n                if(equal(arr,hashtable.get(i))){\n                    temparr.add(strs[j]);\n                }\n            }\n            res.add(temparr);\n        }\n        return res;\n    }\n}\n```\n\n\n\n看了一位朋友写的题解,发现自己思维定势:\n\n1.一种用int数组做哈希表,没想过用toCharArray(),Arrays.sort()和String.valueOf()快速获得哈希表\n\n2.hashmap适合当容器,之前没想到过5555555\n\n```java\nclass Solution {\n\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String,List> res=new HashMap<>();\n        for (String s: strs) {\n            char[]ca= s.toCharArray();\n            Arrays.sort(ca);\n            String key=String.valueOf(ca);\n            if(!res.containsKey(key)){\n                res.put(key,new ArrayList<>());\n            }\n            res.get(key).add(s);\n        }\n        return new ArrayList(res.values());\n    }\n}\n```\n\n\n\n# <span id=\"head5\"> 🟡438.找到字符串中所有字母异位词</span>\n\n> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n>\n> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: s = \"cbaebabacd\", p = \"abc\"\n> 输出: [0,6]\n> 解释:\n> 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n> 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: s = \"abab\", p = \"ab\"\n> 输出: [0,1,2]\n> 解释:\n> 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n> 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n> 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n> ```\n>\n> \n>\n> **提示:**\n>\n> - `1 <= s.length, p.length <= 3 * 104`\n> - `s` 和 `p` 仅包含小写字母\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res=new ArrayList<Integer>();\n        if(s.length()<p.length()){\n            return res;\n        }\n        int []hashtable=new int[26];\n        Arrays.fill(hashtable,0);\n        for (int i = 0; i < p.length(); i++) {\n            hashtable[p.charAt(i)-'a']++;\n        }\n        int index=0;\n        while(index-p.length()<=s.length()){\n            int []temp=hashtable.clone();\n            for (int i = index; i < index+p.length()&&i<s.length(); i++) {\n                temp[s.charAt(i)-'a']--;\n            }\n            int flag=1;\n            for (int i = 0; i < 26; i++) {\n                if(temp[i]!=0){\n                    flag=0;\n                }\n            }\n            if(flag==1){\n                res.add(index);\n            }\n            index++;\n        }\n        return res;\n   \n```\n\n\n\n# <span id=\"head6\">🟢349. 两个数组的交集</span>\n\n> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[9,4]\n> 解释：[4,9] 也是可通过的\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        int[]hashtable=new int[1001];\n        Arrays.fill(hashtable,0);\n        HashSet<Integer> set=new HashSet<>();\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if(hashtable[nums2[i]]>0){\n                set.add(nums2[i]);\n            }\n        }\n        int[]res=new int[set.size()];\n        Iterator<Integer> it=set.iterator();\n        for (int i = 0; i < set.size(); i++) {\n            res[i]=it.next();\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head7\">🟢350.两个数组的交集 II</span>\n\n> 给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2,2,1], nums2 = [2,2]\n> 输出：[2,2]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n> 输出：[4,9]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums1.length, nums2.length <= 1000`\n> - `0 <= nums1[i], nums2[i] <= 1000`\n>\n> \n>\n> ***\\*进阶\\**：**\n>\n> - 如果给定的数组已经排好序呢？你将如何优化你的算法？\n> - 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？\n> - 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 双指针\n>\n> 二分查找\n>\n> 排序\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        int[]hashtable1=new int[1001];\n        int[]hashtable2=new int[1001];\n        Arrays.fill(hashtable1,0);\n        Arrays.fill(hashtable2,0);\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable1[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            hashtable2[nums2[i]]++;\n        }\n        ArrayList<Integer> al=new ArrayList<>();\n        for (int i = 0; i < 1001; i++) {\n            if(hashtable1[i]>hashtable2[i]){\n                hashtable1[i]=hashtable2[i];\n            }\n            for (int j = 0; j < hashtable1[i]; j++) {\n                al.add(i);\n            }\n        }\n        int[]res=new int[al.size()];\n        for (int i = 0; i < al.size(); i++) {\n            res[i]=al.get(i);\n        }\n        return res;\n    }\n}\n```\n\n不如四个月之前写的：\n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        int[]hashtable1=new int[1001];\n        int[]hashtable2=new int[1001];\n        for (int i = 0; i < nums1.length; i++) {\n            hashtable1[nums1[i]]++;\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            hashtable2[nums2[i]]++;\n        }\n        ArrayList<Integer> al=new ArrayList<>();\n        for (int i = 0; i < 1001; i++) {\n            if(hashtable1[i]>hashtable2[i]){\n                hashtable1[i]=hashtable2[i];\n            }\n            for (int j = 0; j < hashtable1[i]; j++) {\n                al.add(i);\n            }\n        }\n        int[]res=new int[al.size()];\n        for (int i = 0; i < al.size(); i++) {\n            res[i]=al.get(i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head8\">🟢202. 快乐数</span>\n\n> 编写一个算法来判断一个数 `n` 是不是快乐数。\n>\n> **「快乐数」** 定义为：\n>\n> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。\n> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。\n>\n> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：n = 19\n> 输出：true\n> 解释：\n> 12 + 92 = 82\n> 82 + 22 = 68\n> 62 + 82 = 100\n> 12 + 02 + 02 = 1\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：n = 2\n> 输出：false\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= n <= 231 - 1`\n>\n> Related Topics\n>\n> 哈希表\n>\n> 数学\n>\n> 双指针\n\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        if(n==1){\n            return true;\n        }\n        Set<Integer> set=new HashSet<>();\n        while(true){\n            int sum=0;\n            while(n>0){\n                sum+=(n%10)*(n%10);\n                n/=10;\n            }\n            if(sum==1){\n                return true;\n            }else if(set.contains(sum)){\n                return false;\n            }else{\n                set.add(sum);\n                n=sum;\n                sum=0;\n            }\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head9\"> 🟢1. 两数之和</span>\n\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n>\n> 你可以按任意顺序返回答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [3,2,4], target = 6\n> 输出：[1,2]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [3,3], target = 6\n> 输出：[0,1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - xxxxxxxxxx14 1public class Solution {2    public ListNode detectCycle(ListNode head) {3        ListNode p=head;4        ArrayList<ListNode>al=new ArrayList<>();5        while(p!=null){6            if(al.contains(p)){7                return p;8            }9            al.add(p);10            p=p.next;11        }12        return null;13    }14}java\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n> - **只会存在一个有效答案**\n>\n> \n>\n> **进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n第一次做的时候没有思路,只能暴力了5555555\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[]res=new int[2];\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums.length&&j!=i; j++) {\n                if(nums[i]+nums[j]==target){\n                    res[0]=i;\n                    res[1]=j;\n                    return res;\n                }\n            }\n        }\n        return null;\n    }\n}\n```\n\n对照卡哥的重新写了一个.其中值得注意的是惯常思维是key是下标,value是值.然而hashmap自带的函数只可以按照key找value,所以这道题反过来安排\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[]res=new int[2];\n        HashMap<Integer,Integer> map=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if(map.containsKey(target-nums[i])){\n                res[0]=i;\n                res[1]=map.get(target-nums[i]);\n                break;\n            }\n            map.put(nums[i],i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head12\"> 🟡454.四数相加II</span>\n\n> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：\n>\n> - `0 <= i, j, k, l < n`\n> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n> 输出：2\n> 解释：\n> 两个元组如下：\n> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n> 输出：1\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `n == nums1.length`\n> - `n == nums2.length`\n> - `n == nums3.length`\n> - `n == nums4.length`\n> - `1 <= n <= 200`\n> - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n\n自己写的暴力O(n4)妥妥超时,按照卡哥的代码写了,学会了:\n\nhashmap.getOrDefault(key,value)这个函数\n\n```java\nclass Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int cnt=0;\n        Map<Integer,Integer> map=new HashMap<>();\n        for(int i:\n                nums1){\n            for(int j:\n                    nums2){\n                map.put(i+j,map.getOrDefault(i+j,0)+1);\n            }\n        }\n        for (int k:\n                nums3) {\n            for (int l:\n                    nums4) {\n                cnt+=map.getOrDefault(0-k-l,0);\n            }\n\n        }\n        return cnt;\n    }\n}\n```\n\n\n\n# <span id=\"head13\"> 🟡15. 三数之和</span>\n\n> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n>\n> 你返回所有和为 `0` 且不重复的三元组。\n>\n> **注意：**答案中不可以包含重复的三元组。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [-1,0,1,2,-1,-4]\n> 输出：[[-1,-1,2],[-1,0,1]]\n> 解释：\n> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\n> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\n> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n> 注意，输出的顺序和三元组的顺序并不重要。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,1,1]\n> 输出：[]\n> 解释：唯一可能的三元组和不为 0 。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：nums = [0,0,0]\n> 输出：[[0,0,0]]\n> 解释：唯一可能的三元组和为 0 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `3 <= nums.length <= 3000`\n> - `-105 <= nums[i] <= 105`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<String>set=new TreeSet<>();\n        List<List<Integer>>res=new ArrayList<>();\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i+1; j < nums.length; j++) {\n                if(Arrays.binarySearch(nums,0-nums[i]-nums[j])>=0&&\n                        Arrays.binarySearch(nums,0-nums[i]-nums[j])!=i&&\n                        Arrays.binarySearch(nums,0-nums[i]-nums[j])!=j){\n                    int k=Arrays.binarySearch(nums,0-nums[i]-nums[j]);\n                    int[]arr_=new int[3];\n                    arr_[0]=nums[i];\n                    arr_[1]=nums[j];\n                    arr_[2]=nums[k];\n                    Arrays.sort(arr_);\n                    String key=arr_[0]+\"\"+arr_[1]+\"\"+arr_[2];\n                    if(!set.contains(key)){\n                        List<Integer> al=new ArrayList<>();\n                        set.add(key);\n                        al.add(arr_[0]);\n                        al.add(arr_[1]);\n                        al.add(arr_[2]);\n                        res.add(al);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n# <span id=\"head14\">🟡18. 四数之和</span>\n\n> 给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：\n>\n> - `0 <= a, b, c, d < n`\n> - `a`、`b`、`c` 和 `d` **互不相同**\n> - `nums[a] + nums[b] + nums[c] + nums[d] == target`\n>\n> 你可以按 **任意顺序** 返回答案 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,0,-1,0,-2,2], target = 0\n> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [2,2,2,2,2], target = 8\n> 输出：[[2,2,2,2]]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 200`\n> - `-109 <= nums[i] <= 109`\n> - `-109 <= target <= 109`\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n>\n> 排序\n\n```java\n\n```\n\n","categories":["algorithm learning"]},{"title":"Linked List","url":"/2023/09/02/algorithm-linkedlist/","content":"\n|      | 是否完成 | 难度 | 题号                                    | 标签      |\n| ---- | :------: | :--: | :-------------------------------------- | --------- |\n| 1    |    ✅     |  🟢   | [ 203. 移除链表元素](#head2)            | 链表      |\n| 2    |    ✅     |  🟡   | [ 707.设计链表](#head3)                 | 链表 设计 |\n| 3    |    ✅     |  🟢   | [ 206.反转链表](#head4)                 | 链表 栈   |\n| 4    |    ✅     |  🟡   | [ 24. 两两交换链表中的节点](#head5)     | 链表      |\n| 5    |    ✅     |  🟡   | [19. 删除链表的倒数第 N 个结点](#head6) | 链表      |\n| 6    |    ✅     |  🟢   | [160.链表相交](#head7)                  | 链表 栈   |\n| 7    |    ✅     |  🟡   | [142.环形链表II](#head8)                | 链表      |\n\n\n\n# <span id=\"head2\"> 🟢203. 移除链表元素</span>\n\n> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)\n>\n> ```\n> 输入：head = [1,2,6,3,4,5,6], val = 6\n> 输出：[1,2,3,4,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [], val = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [7,7,7,7], val = 7\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 列表中的节点数目在范围 `[0, 104]` 内\n> - `1 <= Node.val <= 50`\n> - `0 <= val <= 50`\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        //不设置虚拟节点,仅使用一个指针\n        while(head!=null&&head.val==val){//头结点指向了第一个不等于val的节点\n            head=head.next;\n        }\n        ListNode p=head;\n        while(p!=null){\n            while(p.next!=null&&p.next.val==val){\n                p.next=p.next.next;\n            }\n            p=p.next;\n        }\n        return head;\n    }\n}\n```\n\n\n\n# <span id=\"head3\"> 🟡707.设计链表</span>\n\n> 你可以选择使用单链表或者双链表，设计并实现自己的链表。\n>\n> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。\n>\n> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。\n>\n> 实现 `MyLinkedList` 类：\n>\n> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。\n> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。\n> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\n> - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。\n> - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。\n> - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。\n>\n> \n>\n> **示例：**\n>\n> ```\n> 输入\n> [\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n> [[], [1], [3], [1, 2], [1], [1], [1]]\n> 输出\n> [null, null, null, null, 2, null, 3]\n> \n> 解释\n> MyLinkedList myLinkedList = new MyLinkedList();\n> myLinkedList.addAtHead(1);\n> myLinkedList.addAtTail(3);\n> myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3\n> myLinkedList.get(1);              // 返回 2\n> myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3\n> myLinkedList.get(1);              // 返回 3\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= index, val <= 1000`\n> - 请不要使用内置的 LinkedList 库。\n> - 调用 `get`、`addAtHead`、`addAtTail`、`addAtIndex` 和 `deleteAtIndex` 的次数不超过 `2000` 。\n>\n> Related Topics\n>\n> 设计\n>\n> 链表\n\n```java\nclass ListNode{\n    int val;\n    ListNode next;\n    ListNode(){}\n    ListNode(int val){\n        this.val=val;\n    }\n}\n\nclass MyLinkedList {\n\n    int size;\n    ListNode head;\n\n    public MyLinkedList() {\n        //无参构造\n        size=0;\n        head=new ListNode(0);//头节点\n    }\n\n    public int get(int index) {//获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\n        if(index<0||index>=size){\n            return -1;\n        }\n        ListNode cur=head;\n        for (int i = 0; i <= index; i++) {\n            cur=cur.next;\n        }\n        return cur.val;\n    }\n    //将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\n    public void addAtHead(int val) {\n        addAtIndex(0,val);\n    }\n\n    public void addAtTail(int val) {\n        addAtIndex(size,val);\n    }\n\n    public void addAtIndex(int index, int val) {\n        if(index>size){\n            return;\n        }\n        if (index < 0) {\n            index = 0;\n        }\n        ListNode p=new ListNode(val);\n        ListNode cur=head;\n        for(int i=0;i<index;i++){//cur指向index前一个结点\n            cur=cur.next;\n        }\n        p.next=cur.next;\n        cur.next=p;\n        size++;\n\n    }\n\n    public void deleteAtIndex(int index) {\n        if(index<0||index>=size){\n            return;\n        }\n        size--;\n        if(index==0){\n            head=head.next;\n            return ;\n        }\n        ListNode cur=head;\n        for(int i=0;i<index;i++){//cur指向index前一个结点\n            cur=cur.next;\n        }\n        cur.next=cur.next.next;\n\n    }\n}\n```\n\n\n\n# <span id=\"head4\"> 🟢206.反转链表</span>\n\n> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n>\n> ```\n> 输入：head = [1,2]\n> 输出：[2,1]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围是 `[0, 5000]`\n> - `-5000 <= Node.val <= 5000`\n>\n> \n>\n> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n自己一开始一口气了又臭又长的,妥妥超时:\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //没有虚拟节点,仅有一个指针\n        if(head==null){\n            return null;\n        }\n        Stack<Integer> s=new Stack<>();\n        ListNode p=head;\n        while(p!=null){\n            s.push(p.val);\n            p=p.next;\n        }\n        ListNode res;\n        ListNode node=new ListNode(s.pop());\n        ListNode cur=node;\n        while(!s.empty()){\n            ListNode newnode=new ListNode(s.pop());\n            cur.next=newnode;\n            cur=cur.next;\n        }\n        return node;\n    }\n}\n```\n\n# <span id=\"head5\"> 🟡24. 两两交换链表中的节点</span>\n\n> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4]\n> 输出：[2,1,4,3]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = []\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1]\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目在范围 `[0, 100]` 内\n> - `0 <= Node.val <= 100`\n>\n> Related Topics\n>\n> 递归\n>\n> 链表\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        while (head != null && head.next != null) {\n            ListNode firstNode = head;\n            ListNode secondNode = head.next;\n            // 交换相邻节点\n            prev.next = secondNode;\n            firstNode.next = secondNode.next;\n            secondNode.next = firstNode;\n            // 更新prev和head指针\n            prev = firstNode;\n            head = firstNode.next;\n        }\n        return dummy.next;\n    }\n}   \n```\n\n\n\n# <span id=\"head6\">🟡19. 删除链表的倒数第 N 个结点</span>\n\n> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n>\n> ```\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：head = [1], n = 1\n> 输出：[]\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：head = [1,2], n = 1\n> 输出：[1]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中结点的数目为 `sz`\n> - `1 <= sz <= 30`\n> - `0 <= Node.val <= 100`\n> - `1 <= n <= sz`\n>\n> \n>\n> **进阶：**你能尝试使用一趟扫描实现吗？\n>\n> Related Topics\n>\n> 链表\n>\n> 双指针\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int cnt=0;\n        ListNode p=head;\n        while(p!=null){\n            cnt++;\n            p=p.next;\n        }\n        if(n==cnt){\n            return head.next;\n        }\n        p=head;\n        while(p!=null){\n            if(cnt-1==n){\n                p.next=p.next.next;\n            }\n            cnt--;\n            p=p.next;\n        }\n        return head;\n    }\n}\n```\n\n\n\n# <span id=\"head7\">🟢160.链表相交</span>\n\n> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n>\n> 图示两个链表在节点 `c1` 开始相交**：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n>\n> 题目数据 **保证** 整个链式结构中不存在环。\n>\n> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n>\n> **自定义评测：**\n>\n> **评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：\n>\n> - `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`\n> - `listA` - 第一个链表\n> - `listB` - 第二个链表\n> - `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数\n> - `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数\n>\n> 评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。\n>\n> \n>\n> **示例 1：**\n>\n> [![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n>\n> ```\n> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n> 输出：Intersected at '8'\n> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n> — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n> ```\n>\n> \n>\n> **示例 2：**\n>\n> [![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n>\n> ```\n> 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n> 输出：Intersected at '2'\n> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n> 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n> ```\n>\n> **示例 3：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n>\n> ```\n> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n> 输出：null\n> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n> 这两个链表不相交，因此返回 null 。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `listA` 中节点数目为 `m`\n> - `listB` 中节点数目为 `n`\n> - `1 <= m, n <= 3 * 104`\n> - `1 <= Node.val <= 105`\n> - `0 <= skipA <= m`\n> - `0 <= skipB <= n`\n> - 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`\n> - 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`\n>\n> \n>\n> **进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Stack<ListNode> a=new Stack<>();\n        Stack<ListNode> b=new Stack<>();\n        ListNode pa=headA,pb=headB,res=headA;\n        int flag=0;\n        while(pa!=null){\n            a.push(pa);\n            pa=pa.next;\n        }\n        while(pb!=null){\n            b.push(pb);\n            pb=pb.next;\n        }\n        int cnt=0;\n        while(!a.empty()&&!b.empty()){\n            ListNode ap=a.pop(),bp=b.pop();\n            if(ap!=null&&ap==bp){\n                cnt++;\n                res=ap;\n                flag=1;\n            }\n        }\n        if(flag==1){\n            return res;\n        }else{\n            return null;\n        }\n\n    }\n}\n```\n\n# <span id=\"head8\">🟡142.环形链表II</span>\n\n> 给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n>\n> **不允许修改** 链表。\n>\n> \n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>\n> ```\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n>\n> ```\n> 输入：head = [1,2], pos = 0\n> 输出：返回索引为 0 的链表节点\n> 解释：链表中有一个环，其尾部连接到第一个节点。\n> ```\n>\n> **示例 3：**\n>\n> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n>\n> ```\n> 输入：head = [1], pos = -1\n> 输出：返回 null\n> 解释：链表中没有环。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - 链表中节点的数目范围在范围 `[0, 104]` 内\n> - `-105 <= Node.val <= 105`\n> - `pos` 的值为 `-1` 或者链表中的一个有效索引\n>\n> \n>\n> **进阶：**你是否可以使用 `O(1)` 空间解决此题？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 链表\n>\n> 双指针\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode p=head;\n        ArrayList<ListNode>al=new ArrayList<>();\n        while(p!=null){\n            if(al.contains(p)){\n                return p;\n            }\n            al.add(p);\n            p=p.next;\n        }\n        return null;\n    }\n}\n```\n","categories":["algorithm learning"]},{"title":"Array","url":"/2023/09/01/algorithm-array/","content":"\n\n\n|      | 是否完成 | 难度 | 题号                                                      | 标签                 |\n| ---- | :------: | :--: | --------------------------------------------------------- | :------------------- |\n| 1    |    ✅     |  🟢   | [[704]二分查找](#head1)                                   | 二分法               |\n| 2    |    ✅     |  🟢   | [[35]搜索插入位置 ](#head2)                               | 二分法 左边缘        |\n| 3    |    ✅     |  🟡   | [[34]在排序数组中查找元素的第一个和最后一个位置 ](#head3) | 二分法 左边缘 右边缘 |\n| 4    |    ✅     |  🟢   | [[69]x 的平方根](#head4)                                  | 二分法 右边界 数学   |\n| 5    |    ✅     |  🟢   | [[367]有效的完全平方数](#head5)                           | 二分法 右边界 数学   |\n| 6    |    ✅     |  🟢   | [[27]移除元素 ](#head6)                                   | 双指针               |\n| 7    |    ✅     |  🟢   | [[26]删除排序数组中的重复项](#head7)                      | 双指针               |\n| 8    |    ✅     |  🟢   | [[283]移动零](#head8)                                     | 双指针               |\n| 9    |    ✅     |  🟢   | [[844]比较含退格的字符串](#head9)                         | 栈 (双指针)          |\n| 10   |    ✅     |  🟢   | [[977]有序数组的平方 ](#head10)                           | 双指针               |\n| 11   |    ✅     |  🟡   | [[209]长度最小的子数组 ](#head11)                         | 滑动窗口 (队列)      |\n| 12   |    ✅     |  🟡   | [[904]水果成篮](#head12)                                  | 滑动窗口             |\n| 13   |          |  🔴   | [[76]最小覆盖子串](#head13)                               |                      |\n| 14   |    ✅     |  🟡   | [[59]螺旋矩阵II ](#head14)                                | 模拟                 |\n| 15   |    ✅     |  🟡   | [[54]螺旋矩阵](#head15)                                   | 模拟                 |\n\n\n\n# <span id=\"head1\"> 🟢[704]二分查找</span>\n\n>给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [-1,0,3,5,9,12], target = 9\n>输出: 4\n>解释: 9 出现在 nums 中并且下标为 4\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: nums = [-1,0,3,5,9,12], target = 2\n>输出: -1\n>解释: 2 不存在 nums 中因此返回 -1\n>```\n>\n>\n>\n>**提示：**\n>\n>1. 你可以假设 `nums` 中的所有元素是不重复的。\n>2. `n` 将在 `[1, 10000]`之间。\n>3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n\n        int len=nums.length;\n        int l=0,r=len-1;\n\n        while(l<=r){\n            //int mid=(l+r)>>1; 改进成下面↓,可以防止溢出.\n            int mid=l+((r-l)>>1);\n\n            if(target<nums[mid]){\n                r=mid-1;\n            }else if(target>nums[mid]){\n                l=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n- 时间复杂度：O(log(n))\n\n- 空间复杂度：O(1)\n\n# <span id=\"head2\">🟢[35]搜索插入位置 </span>\n\n>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n>\n>请必须使用时间复杂度为 `O(log n)` 的算法。\n>\n>\n>\n>**示例 1:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 5\n>输出: 2\n>```\n>\n>**示例 2:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 2\n>输出: 1\n>```\n>\n>**示例 3:**\n>\n>```\n>输入: nums = [1,3,5,6], target = 7\n>输出: 4\n>```\n>\n>\n>\n>**提示:**\n>\n>- `1 <= nums.length <= 104`\n>- `-104 <= nums[i] <= 104`\n>- `nums` 为 **无重复元素** 的 **升序** 排列数组\n>- `-104 <= target <= 104`\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n\n        int len=nums.length;\n        int l=0, r=len-1;\n\n        while(l<=r){\n            int mid=l+((r-l)>>1);\n            if(target<nums[mid]){\n                r=mid-1;\n            }else if(target>nums[mid]){\n                l=mid+1;\n            }else{\n                return mid;\n            }\n        }\n        return l;//此时l代表元素在数组中的左边缘.如果元素有重复,则是第一次出现的位置.\n    }\n}\n```\n\n- 时间复杂度：O(log(n))\n\n- 空间复杂度：O(1)\n\n# <span id=\"head3\">🟡[34]在排序数组中查找元素的第一个和最后一个位置 </span>\n\n>\n>\n>给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n>\n>如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n>\n>你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [5,7,7,8,8,10], target = 8\n>输出：[3,4]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [5,7,7,8,8,10], target = 6\n>输出：[-1,-1]\n>```\n>\n>**示例 3：**\n>\n>```\n>输入：nums = [], target = 0\n>输出：[-1,-1]\n>```\n>\n>\n>\n>**提示：**\n>\n>- `0 <= nums.length <= 105`\n>- `-109 <= nums[i] <= 109`\n>- `nums` 是一个非递减数组\n>- `-109 <= target <= 109`\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n\n        int len= nums.length;\n        int l=0,r=len-1;\n        int mid=0;\n        int[]ans={-1,-1};\n\n        if(len==0){\n            return ans;\n        }\n\t\t//以下是寻找元素在数组中第一次出现的位置\n        while(l<r){\n            mid=l+((r-l)>>1);\n            if(target<=nums[mid]){\n                r=mid;\n            }else{\n                l=mid+1;\n            }\n\n        }\n        if(target==nums[l]){\n            ans[0]=l;\n        }else{//元素不存在\n            return ans;\n        }\n        \n\t\t//以下是寻找元素在数组中最后一次出现的位置\t\n        l=0;\n        r=len-1;\n        while(l<r){\n            mid=l+((r-l+1)>>1);//找右边缘需要加一\n            if(target>=nums[mid]){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        ans[1]=r;\n\n        return ans;\n\n    }\n}\n```\n\n- 时间复杂度：O(log(n))\n\n- 空间复杂度：O(1)\n\n# <span id=\"head4\">🟢[69]x 的平方根</span>\n\n> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。\n>\n> 由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**\n>\n> **注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：x = 4\n> 输出：2\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：x = 8\n> 输出：2\n> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `0 <= x <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n首答超时\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l=0,r=x;\n        while(l<r){\n            int mid=l+((r-l)>>1);\n            if(x<=mid*mid){\n                r=mid;\n            }else{\n                l=mid+1;\n            }\n        }\n        if(l*l==x){\n            return l;\n        }\n        return l-1;\n    }\n}\n```\n\n接着看了别人题解，发现下面错误:：\n\n1. 根据数学理论，应当寻找右边界，而不是之前认为的左边界\n2. **if(x <= mid*mid)**可能导致乘法运算溢出，故改成**if(x/mid <= mid)**\n3. 需要考虑x=0和x=1的特殊情况\n\n```Java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==0||x==1){\n            return x;\n        }\n        int l=1,r=x-1,mid=0;\n        while(l<r){\n            mid=l+((r-l+1)>>1);\n            if(x/mid>=mid){//❗防止乘法运算溢出\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r;\n    }\n}\n```\n\n- 时间复杂度：O(log(n))\n\n- 空间复杂度：O(1)\n\n# <span id=\"head5\"> 🟢[367]有效的完全平方数</span>\n\n> 给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。\n>\n> **完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n>\n> 不能使用任何内置的库函数，如 `sqrt` 。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：num = 16\n> 输出：true\n> 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：num = 14\n> 输出：false\n> 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= num <= 231 - 1`\n>\n> Related Topics\n>\n> 数学\n>\n> 二分查找\n\n```Java\n    public boolean isPerfectSquare(int num) {\n        if(num==1)return true;\n        int l=1,r=num;\n        while(l<r){\n            int mid=l+((r-l+1)>>1);\n            if(num/mid>=mid){\n                l=mid;\n            }else{\n                r=mid-1;\n            }\n        }\n        return r*r==num;\n    }\n}\n```\n\n- 时间复杂度：O(log(n))\n\n- 空间复杂度：O(1)\n\n# <span id=\"head6\">🟢[27]移除元素 </span>\n\n>给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n>不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n>\n>\n>\n>**说明:**\n>\n>为什么返回数值是整数，但输出的答案是数组呢?\n>\n>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n>\n>你可以想象内部操作如下:\n>\n>```\n>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\n>int len = removeElement(nums, val);\n>\n>// 在函数里修改输入数组对于调用者是可见的。\n>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n>for (int i = 0; i < len; i++) {\n>print(nums[i]);\n>}\n>```\n>\n>\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [3,2,2,3], val = 3\n>输出：2, nums = [2,2]\n>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [0,1,2,2,3,0,4,2], val = 2\n>输出：5, nums = [0,1,4,0,3]\n>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n>```\n>\n>\n>\n>**提示：**\n>\n>- `0 <= nums.length <= 100`\n>- `0 <= nums[i] <= 50`\n>- `0 <= val <= 100`\n>\n>Related Topics\n>\n>数组\n>\n>双指针\n\n```Java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int len=nums.length;\n        int pre=0,last=len-1;\n        while(last>=0&&nums[last]==val){//寻找从后往前数的第一个可以替换的位置\n            last--;\n        }\n        while(pre<last){\n            if(nums[pre]==val){\n                int temp=nums[pre];\n                nums[pre]=nums[last];\n                nums[last]=temp;\n                while(last>=pre&&nums[last]==val){//再次寻找从后往前数的第一个可以替换的位置\n                    last--;\n                }\n            }\n            pre++;\n        }\n        return last+1;\n    }\n}\n```\n\n- 时间复杂度：O(log(n))\n\n- 空间复杂度：O(1)\n\n# <span id=\"head7\">🟢[26]删除排序数组中的重复项</span>\n\n> 给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。\n>\n> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：\n>\n> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。\n> - 返回 `k` 。\n>\n> **判题标准:**\n>\n> 系统会用下面的代码来测试你的题解:\n>\n> ```\n> int[] nums = [...]; // 输入数组\n> int[] expectedNums = [...]; // 长度正确的期望答案\n> \n> int k = removeDuplicates(nums); // 调用\n> \n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n> ```\n>\n> 如果所有断言都通过，那么您的题解将被 **通过**。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2,_]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= nums.length <= 3 * 104`\n> - `-104 <= nums[i] <= 104`\n> - `nums` 已按 **升序** 排列\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```Java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len=nums.length;\n        if(len==1)return 1;\n        int a=0,b=a+1;\n\n        while(b<len&&nums[b]==nums[a]){//b指向第一个和a指向的元素不同的元素\n            b++;\n        }\n\n        while(a+1<len&&b<len){\n            nums[a+1]=nums[b];\n            a++;\n            while(b<len&&nums[b]==nums[a]){//b指向下一个和a指向的元素不同的元素\n                b++;\n            }\n        }\n        return a+1;\n    }\n}\n```\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(1)\n\n# <span id=\"head8\"> 🟢[283]移动零</span>\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n>\n> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n>\n> \n>\n> **示例 1:**\n>\n> ```\n> 输入: nums = [0,1,0,3,12]\n> 输出: [1,3,12,0,0]\n> ```\n>\n> **示例 2:**\n>\n> ```\n> 输入: nums = [0]\n> 输出: [0]\n> ```\n>\n> \n>\n> **提示**:\n>\n> - `1 <= nums.length <= 104`\n> - `-231 <= nums[i] <= 231 - 1`\n>\n> \n>\n> **进阶：**你能尽量减少完成的操作次数吗？\n>\n> Related Topics\n>\n> 数组\n>\n> 双指针\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int len= nums.length;\n        int a=0;\n        while(a<len&&nums[a]!=0){//a指向第一个零元素\n            a++;\n        }\n        int b=a+1;\n        while(b<len&&nums[b]==0){//b指向第一个非零元素\n            b++;\n        }\n        while(a<len&b<len){\n            int temp=nums[a];\n            nums[a]=nums[b];\n            nums[b]=temp;\n            while(a<len&&nums[a]!=0){//a指向下一个零元素\n                a++;\n            }\n            b=a+1;\n            while(b<len&&nums[b]==0){//b指向下一个非零元素\n                b++;\n            }\n        }\n    }\n}\n```\n\n\n\n# <span id=\"head9\"> 🟢[844]比较含退格的字符串</span>\n\n> 给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。\n>\n> **注意：**如果对空文本输入退格字符，文本继续为空。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ab#c\", t = \"ad#c\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"ac\"。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"ab##\", t = \"c#d#\"\n> 输出：true\n> 解释：s 和 t 都会变成 \"\"。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：s = \"a#c\", t = \"b\"\n> 输出：false\n> 解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= s.length, t.length <= 200`\n> - `s` 和 `t` 只含有小写字母以及字符 `'#'`\n>\n> \n>\n> **进阶：**\n>\n> - 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？\n>\n> Related Topics\n>\n> 栈\n>\n> 双指针\n>\n> 字符串\n>\n> 模拟\n\n这道题首先想到了用栈,但是既然在训练双指针,还是用双指针做一遍吧.\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String s, String t) {\n        int len_s=s.length(),len_t=t.length();\n        Stack<Character> S=new Stack<Character>();//这里注意尖括号里面是Character,不是char\n        Stack<Character> T=new Stack<Character>();\n\n        int index_s=0;\n        while(index_s<len_s){\n            if(s.charAt(index_s)!='#'){\n                S.push(s.charAt(index_s));\n            }else if(!S.empty()){\n                S.pop();\n            }\n            index_s++;\n        }\n\n        int index_t=0;\n        while(index_t<len_t){\n            if(t.charAt(index_t)!='#'){\n                T.push(t.charAt(index_t));\n            }else if(!T.empty()){\n                T.pop();\n            }\n            index_t++;\n        }\n        return S.equals(T);\n    }\n}\n```\n\n\n\n# <span id=\"head10\">🟢[977]有序数组的平方 </span>\n\n>给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n>\n>**示例 1：**\n>\n>```\n>输入：nums = [-4,-1,0,3,10]\n>输出：[0,1,9,16,100]\n>解释：平方后，数组变为 [16,1,0,9,100]\n>排序后，数组变为 [0,1,9,16,100]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：nums = [-7,-3,2,3,11]\n>输出：[4,9,9,49,121]\n>```\n>\n>**提示：**\n>\n>- `1 <= nums.length <= 104`\n>- `-104 <= nums[i] <= 104`\n>- `nums` 已按 **非递减顺序** 排序\n>\n>**进阶：**\n>\n>- 请你设计时间复杂度为 `O(n)` 的算法解决本问题\n>\n>Related Topics\n>\n>数组\n>\n>双指针\n>\n>排序\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n\n        int len=nums.length;\n        int[]ans=new int[len];//创建定长的新数组\n        int index=len-1;\n        int l=0,r=len-1;\n        while(index>=0){\n            if(nums[l]*nums[l]>=nums[r]*nums[r]){\n                ans[index]=nums[l]*nums[l];\n                l++;\n            }else{\n                ans[index]=nums[r]*nums[r];\n                r--;\n            }\n            index--;\n        }\n        return ans;\n    }\n}\n```\n\n\n\n# <span id=\"head11\">🟡[209]长度最小的子数组 </span>\n\n>给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**\n>\n>找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n>\n>**示例 1：**\n>\n>```\n>输入：target = 7, nums = [2,3,1,2,4,3]\n>输出：2\n>解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：target = 4, nums = [1,4,4]\n>输出：1\n>```\n>\n>**示例 3：**\n>\n>```\n>输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n>输出：0\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= target <= 109`\n>- `1 <= nums.length <= 105`\n>- `1 <= nums[i] <= 105`\n>\n>\n>\n>**进阶：**\n>\n>- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。\n>\n>Related Topics\n>\n>数组\n>\n>二分查找\n>\n>前缀和\n>\n>滑动窗口\n\n暴力解法,也许可以骗一点分.🙃\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int len=nums.length;\n        int ans=100001,sum=0;\n        for(int i=0;i<len;i++){\n            int sum_=0;\n            for(int j=i;j<len&&sum_<target;j++){\n                sum_+=nums[j];\n                if(sum_>=target&&(j-i+1)<=ans){\n                    ans=j-i+1;\n                    sum=sum_;\n                }\n            }\n        }\n        if(ans!=100001){\n            return ans;\n        }else{\n            return 0;\n        }\n    }\n}\n```\n\n第一次使用滑动窗口\n\n```java\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int len=nums.length;\n        int i=0;\n        int sum=0;\n        int ans= Integer.MAX_VALUE;\n        for(int j=0;j<len;j++){\n            sum+=nums[j];\n            while(sum>=target){\n                ans=Math.min(ans,j-i+1);\n                sum-=nums[i];\n                i++;\n            }\n        }\n        return ans==Integer.MAX_VALUE?0:ans;\n    }\n}\n```\n\n\n\n# <span id=\"head12\"> 🟡[904]水果成篮</span>\n\n> 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。\n>\n> 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n>\n> - 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。\n> - 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n> - 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n>\n> 给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：fruits = [1,2,1]\n> 输出：3\n> 解释：可以采摘全部 3 棵树。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：fruits = [0,1,2,2]\n> 输出：3\n> 解释：可以采摘 [1,2,2] 这三棵树。\n> 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n> ```\n>\n> **示例 3：**\n>\n> ```\n> 输入：fruits = [1,2,3,2,2]\n> 输出：4\n> 解释：可以采摘 [2,3,2,2] 这四棵树。\n> 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n> ```\n>\n> **示例 4：**\n>\n> ```\n> 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n> 输出：5\n> 解释：可以采摘 [1,2,1,1,2] 这五棵树。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `1 <= fruits.length <= 105`\n> - `0 <= fruits[i] < fruits.length`\n>\n> Related Topics\n>\n> 数组\n>\n> 哈希表\n>\n> 滑动窗口\n\n```java\nclass Solution {\n    public int totalFruit(int[] fruits) {\n        int len=fruits.length;\n        if(len<=2){\n            return len;\n        }\n        int index=0,cnt=0,max=0;\n        int i=0,j=i+1;\n        while(j<len&&fruits[j]==fruits[i]){\n            j++;\n        }\n        while(index<len){\n            if(fruits[index]==fruits[i]||fruits[index]==fruits[j]){\n                cnt++;\n            }else{\n                i=j;\n                j=i+1;\n                while(j<len&&fruits[j]==fruits[i]){\n                    j++;\n                }\n                cnt=1;\n                index=i;\n            }\n            max=Math.max(max,cnt);\n            index++;\n        }\n        return max;\n    }\n}\n```\n\n\n\n# <span id=\"head13\"> 🔴[76]最小覆盖子串</span>\n\n> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n>\n> \n>\n> **注意：**\n>\n> - 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。\n> - 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。\n>\n> \n>\n> **示例 1：**\n>\n> ```\n> 输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n> 输出：\"BANC\"\n> 解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n> ```\n>\n> **示例 2：**\n>\n> ```\n> 输入：s = \"a\", t = \"a\"\n> 输出：\"a\"\n> 解释：整个字符串 s 是最小覆盖子串。\n> ```\n>\n> **示例 3:**\n>\n> ```\n> 输入: s = \"a\", t = \"aa\"\n> 输出: \"\"\n> 解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n> 因此没有符合条件的子字符串，返回空字符串。\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == s.length`\n> - `n == t.length`\n> - `1 <= m, n <= 105`\n> - `s` 和 `t` 由英文字母组成\n>\n> \n>\n> **进阶：**你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？\n>\n> Related Topics\n>\n> 哈希表\n>\n> 字符串\n>\n> 滑动窗口\n\n# <span id=\"head14\">🟡[59]螺旋矩阵II </span>\n\n>给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。\n>\n>\n>\n>**示例 1：**\n>\n>![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n>\n>```\n>输入：n = 3\n>输出：[[1,2,3],[8,9,4],[7,6,5]]\n>```\n>\n>**示例 2：**\n>\n>```\n>输入：n = 1\n>输出：[[1]]\n>```\n>\n>\n>\n>**提示：**\n>\n>- `1 <= n <= 20`\n>\n>Related Topics\n>\n>数组\n>\n>矩阵\n>\n>模拟\n\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int [][]matrix=new int[n][n];\n        int cnt=1;\n        int i=0,j=-1;\n        while(cnt<=n){\n            matrix[i][++j]=cnt++;//👉\n        }\n        int len=n-1;\n        while(cnt<=n*n){\n            for (int k = 1; k <= len; k++) {\n                matrix[++i][j]=cnt++;//👇\n            }\n            for (int k = 1; k <= len; k++) {\n                matrix[i][--j]=cnt++;//👈\n            }\n            len--;\n            if(len>0){\n                for (int k = 1; k <= len; k++) {\n                    matrix[--i][j]=cnt++;//👆\n                }\n                for (int k = 1; k <= len; k++) {\n                    matrix[i][++j]=cnt++;//👉\n                }\n                len--;\n            }\n        }\n        return matrix;\n    }\n}\n```\n\n\n\n# <span id=\"head15\"> 🟡[54]螺旋矩阵</span>\n\n> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n>\n> \n>\n> **示例 1：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[1,2,3,6,9,8,7,4,5]\n> ```\n>\n> **示例 2：**\n>\n> ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n>\n> ```\n> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n> ```\n>\n> \n>\n> **提示：**\n>\n> - `m == matrix.length`\n> - `n == matrix[i].length`\n> - `1 <= m, n <= 10`\n> - `-100 <= matrix[i][j] <= 100`\n>\n> Related Topics\n>\n> 数组\n>\n> 矩阵\n>\n> 模拟\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int n=matrix.length;\n        int m=matrix[0].length;\n        List<Integer> res=new ArrayList<>();\n        int i=0,j=-1;\n        while(j<m-1){\n            res.add(matrix[i][++j]);   //👉\n        }\n        while(n*m>0){\n\n            n--;\n            for (int k = 0; k <n; k++) {\n                res.add(matrix[++i][j]);//👇\n            }\n\n            m--;\n            if(n*m>0){\n                for (int k = 0; k < m; k++) {\n                    res.add(matrix[i][--j]);//👈\n                }\n            }\n\n            n--;\n            if(n*m>0){\n                for (int k = 0; k < n; k++) {\n                    res.add(matrix[--i][j]);//👆\n                }\n            }\n\n            m--;\n            if(n*m>0){\n                for (int k = 0; k < m; k++) {\n                    res.add(matrix[i][++j]);//👉\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n","categories":["algorithm learning"]}]