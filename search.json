[{"title":"Array 3:Squares of a Sorted Array","url":"/2023/05/14/5-14-array-3-squares-of-a-sorted-array/","content":"# <span id=\"head1\">[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)</span>\n\n![977](5-14-array-3-squares-of-a-sorted-array/img.png)\n\n## <span id=\"head2\"> NOTE</span>\n\n原本自己读完题想着要先挨个平方完，然后快排（没错本人就是这么垃圾:sob:）这样的话，是复杂度是O(n+nlogn)，绝对超过了O(n)。之后看到了提示说用双指针，就恍然大悟：①遍历数组找到正负分界点②从这个点向两端依次确定\n最小值，直到有一侧达到尽头③处理剩下的数组。写完之后，发现卡哥的思路：从数组两端向中间聚拢，以此确定最大值，这样省了找分界点和处理剩下元素的时间，respect！！\n\n## <span id=\"head3\">c++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> ans(nums.size());\n        int FLAG=1;\n        int r=0;\n        while(nums[r]<0){\n            r++;\n            if(r>=nums.size())break;\n        }\n        int l=r-1;\n        if(l<0||r>=nums.size())FLAG=0;\n        int idx=0;\n        while(FLAG&&idx<nums.size()){\n            if(nums[l]*(-1)<nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l--;\n                if(l<0)FLAG=0;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r++;\n                if(r>=nums.size())FLAG=0;\n            }\n            idx++;\n        }\n\n        if(FLAG==0){\n            if(l<0){//剩下右边\n                while(idx<nums.size()&&r<nums.size()){\n                    ans[idx]=nums[r]*nums[r];\n                    idx++;\n                    r++;\n                }\n            }else{\n                 while(idx<nums.size()&&l>=0){\n                    ans[idx]=nums[l]*nums[l];\n                    idx++;\n                    l--;\n                }\n            }\n        }\n\n        return ans;\n\n    }\n};\n\n```\n## <span id=\"head4\">java solution</span>\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        \n        int len=nums.length;\n        int[]ans=new int[len];\n        int FLAG=1;\n\n        int r=0;\n        while(nums[r]<0){\n            r++;\n            if(r>=len){\n                FLAG=0;\n                break;\n            }\n        }\n\n        int l=r-1;\n        if(l<0) FLAG=0;\n\n        int idx=0;\n        while(FLAG==1&&idx<len){\n\n            if(nums[l]*(-1)<nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l--;\n                if(l<0)FLAG=0;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r++;\n                if(r>=len)FLAG=0;\n            }\n\n            idx++;\n        }\n\n        if(FLAG==0){\n            if(l<0){//只剩右边\n\n                while(idx<len&&r<len){\n                    ans[idx]=nums[r]*nums[r];\n                    idx++;\n                    r++;\n                }\n                \n            }else{\n                while(idx<len&&l>=0){\n                    ans[idx]=nums[l]*nums[l];\n                    idx++;\n                    l--;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## <span id=\"head5\">improved solution</span>\n\n显然代码短了很多\n\n```c++\nclass Solution{\n\n public:\n\n    vector<int> sortedSquares(vector<int>& nums){\n        int len = nums.size();\n        vector<int>ans(len);\n\n        int l=0;\n        int r=len-1;\n        int idx=len-1;\n\n        while(idx>=0){\n            if(nums[l]*nums[l]>nums[r]*nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l++;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r--;\n            }\n            idx--;\n        }\n\n        return ans;\n    }\n\n};\n\n```","tags":["blog"],"categories":["algorithm"]},{"title":"Array 2:Remove Element","url":"/2023/05/11/5-11-array-2-remove-element/","content":"\n\n\n# <span id=\"head1\">[27. 移除元素](https://leetcode.cn/problems/remove-element/)</span>\n\n![27](5-11-array-2-remove-element/1.png)\n\n## <span id=\"head2\">C++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n\n       int cur_index =0;\n       int length=nums.size();\n       int last_index=length-1;\n\n       if(length==1&&nums[0]==val)return 0;\n\n       while(cur_index<length){\n           if(nums[cur_index]==val){\n               while(nums[last_index]==val){\n                   length--;\n                   if(length==0)return 0;\n                    last_index=length-1;\n                    \n               }\n               if(cur_index<last_index){\n                    int t=nums[last_index];\n                    nums[last_index]=nums[cur_index];\n                    nums[cur_index]=t;\n               }\n               \n           }\n           cur_index++;\n       }\n         \n\t\treturn length;\n    }\n};\n```\n\n## <span id=\"head3\">Java solution</span>\n\n```java\n    class Solution {\n    public int removeElement(int[] nums, int val) {\n      \n      int cur=0;\n      int length=nums.length;\n      int last=length-1;\n\n      if(length==0)return 0;\n\n      while(cur<length){\n\n          if(nums[cur]==val){\n\n              while(nums[last]==val){\n                    length--;\n                    if(length==0)return 0;\n                    last=length-1;\n              }\n              if(cur<last){\n                  int t=nums[cur];\n                  nums[cur]=nums[last];\n                  nums[last]=t;\n              }\n          }\n          cur++;\n      }\n\n        return length;\n    }\n\n}\n```\n\n#  <span id=\"head1\">[26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)</span>\n\n![26](5-11-array-2-remove-element/2.png)\n\n## <span id=\"head5\">C++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int cur=0;\n        int next=cur+1;\n\n        if(nums.size()==1)return 1;\n\n        while(cur<=nums.size()-1){\n\n            while(next<nums.size()&&nums[next]==nums[cur])next++;\n            cur++;\n            if(cur>=nums.size()||next>=nums.size())break;\n\n            nums[cur]=nums[next];\n            \n            \n        }\n        return cur;\n    }\n    \n};\n```\n\n## <span id=\"head6\">Java solution</span>\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int cur=0;\n        int next=cur+1;\n\n        if(nums.length==1)return 1;\n\n        while(cur<=nums.length-1){\n           \n            while(next<nums.length&&nums[next]==nums[cur])next++;\n            cur++;\n            if(cur==nums.length||next==nums.length)break;\n            nums[cur]=nums[next];\n\n        }\n\n        return cur;\n    }\n}\n```","tags":["blog"],"categories":["algorithm"]},{"title":"Array 1:Binary Search","url":"/2023/05/10/5-10-array-1-binary-search/","content":"\n# <span id=\"head1\"> __[Ⅰ 704 二分查找](https://leetcode.cn/problems/binary-search/)__ </span>\n\n\n![704](5-10-array-1-binary-search/1.png)\n\n## <span id=\"head2\"> NOTE</span>\n\n\n### <span id=\"head3\">1. 每次写二分最容易纠结的part就是下面C++代码里面的A,B,C,D行</span>\n- A 处是用nums.size()-1还是nums.size()?\n- B 处是 <= 还是 < ?\n- C 处是 mid 还是 mid - 1 ?\n- D 处是 mid 还是 mid + 1 ?\n\n实际上这些不同的本质实际上是对于数组区间的划分法不同：\n\n|     | 左闭右闭区间                   | 左闭右开区间                 |\n|-----|--------------------------|------------------------|\n| A   | ```high=nums.size()-1``` | ```high=nums.size()``` |\n| B   | ``` while(low<=high)```  | ``` while(low<high)``` |\n| C   | ``` high=mid-1;```       | ``` high=mid;```       |\n| D   | ```low=mid+1;```         | ```low=mid+1;```       |\n\n### <span id=\"head4\">2. 二分法取中间值防溢出</span>\n\n```c++\n mid = (low+high) / 2\n```\nE 处的写法在两大数相加的时候容易发生溢出，可以改成下面的写法：\n```c++\n mid = low + (( high - low ) / 2)\n```\n\n## <span id=\"head5\">C++ solution</span>\n```c++\nclass Solution {\npublic \n    int search(vector<int>& nums, int target) {\n\n/*A*/   int low=0,high=nums.size()-1;\n\n/*B*/   while(low<=high){\n\n/*E*/        int mid=(low+high)/2;\n\n            if(target==nums[mid]){\n                return mid;\n            }else if(target<nums[mid]){\n/*C*/           high=mid-1;\n            }else{\n/*D*/           low=mid+1;\n            }\n\n        }\n\n        return -1;\n    }\n};\n```\n## <span id=\"head6\">Java solution</span>\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n\n        int low=0,high=nums.length-1;\n\n        while(low<=high){\n\n            int mid=(low+high)/2;\n\n            if(nums[mid]==target){\n                return mid;\n            }else if(nums[mid]>=target){\n                high=mid-1;\n            }else{\n                low=mid+1;\n            }\n\n        }\n\n        return -1;\n\n    }\n}\n```\n\n\n# <span id=\"head7\">__[Ⅱ  35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)__</span>\n\n![35](5-10-array-1-binary-search/2.png)\n\n## <span id=\"head8\">C++ solution</span>\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int low =0,high=nums.size()-1,mid,ans=nums.size();\n\n        while(low<=high){\n\n            mid =(low+high)>>1;\n\t\t\t\n            if(target<=nums[mid]){//在左边 \n            \tans=mid;\n                high=mid-1;\n            }else{\n                low=mid+1;\n            }\n        }\n        return ans;\n\n    }\n};\n```\n## <span id=\"head9\">Java solution</span>\n```java\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n\n        int low = 0, high = nums.length-1, ans = nums.length;\n\n        while(low<=high){\n\n            int mid = ( low + high ) >> 1;\n\n            if(target <= nums[mid]){// 在左边\n\n                ans = mid;\n\n                high = mid-1;\n\n            } else{\n\n                low = mid +1;\n\n            }\n        }\n         return ans;   \n    }\n}\n\n```\n\n# <span id=\"head10\">[ __Ⅲ 34. 在排序数组中查找元素的第一个和最后一个位置__](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)</span>\n\n![34](5-10-array-1-binary-search/3.png)\n\n## <span id=\"head11\"> NOTE</span>\n\n### <span id=\"head12\">1. 使用二分法在有序数组中查找某个数的左边界，即某个数第一次出现的位置</span>\n\n\n\n![image-20230610130542299](5-10-array-1-binary-search/image-20230610130542299.png)\n\n\n\n### <span id=\"head13\">2. 使用二分法在有序数组中查找某个数的右边界，即某个数最后一次出现的位置</span>\n\n与查找左边界不同的一个关键点有计算mid的时候需要l+r+1！\n否则会陷入死循环\n\n\n![image-20230610130632156](5-10-array-1-binary-search/image-20230610130632156.png)\n\n\n## <span id=\"head14\">C++ solution</span>\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        \n        int left = binarySearch(nums,target,true);\n        int right =  binarySearch(nums,target,false)-1;\n        \n        if(left <= right && right < nums.size() && nums[left] == target && nums[right] == target){\n        \t\n        \treturn vector<int>{left,right};\n\t\t}else{\n\t\t\treturn vector<int>{-1,-1};\n\t\t}\n        \n    }\n    \n    int binarySearch(vector<int>nums,int target,bool isLeft){\n    \tint low =0,high=nums.size()-1,mid,ans=nums.size();\n    \t\n    \twhile(low<=high){\n    \t\t\n    \t\tmid=(low+high)>>1;\n    \t\t\n    \t\tif(target<nums[mid]||isLeft&&target<=nums[mid]){\n    \t\t\tans = mid;\n    \t\t\thigh = mid - 1;\n\t\t\t\t}else{\t\t\t\t\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n    \treturn ans;\n\t}\n    \n};\n\n```\n\n## <span id=\"head15\">Java solution</span>\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n      int [] arr={-1,-1};\n\t\t\tint left = binarySearch(nums, target, true);\n\t\t\tint right = binarySearch(nums, target, false)-1;\n\n\t\t\tif(left<=right && right<nums.length && nums[left] == target && nums[right] == target){\n\t\t\t\tarr[0]=left;\n\t\t\t\tarr[1]=right;\n\t\t\t} \n\t\t\treturn arr;\n\n    }\n\t\tpublic int binarySearch(int[] nums, int target, boolean isLeft){\n\t\t\tint low = 0, high = nums.length-1, mid, ans = nums.length;\n\t\t\twhile(low<=high){\n\t\t\t\tmid=(low+high)>>1;\n\t\t\t\tif(target < nums[mid]|| isLeft && target <= nums[mid]){\n\t\t\t\t\tans = mid;\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}else{\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n}\n```","tags":["blog"],"categories":["algorithm"]}]