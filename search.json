[{"title":"Curve Integral & Surface Integral","url":"/2023/06/14/6-14-curve-integral-and-surface-integral/","content":"\n# 对弧长曲线积分\n\n## 对弧长的曲线积分的概念与性质\n\n函数$f(x,y)$在曲线$L$上对弧长的曲线积分（第一曲线积分），记作\n\n$$\n\\int_Lf(x,y)\\text{d}s  或  \\int_{\\mathop{\\frown}\\limits_{AB}}f(x,y)\\text{d}s\n$$\n即\n$$\n\\int_Lf(x,y)\\text{d}s=\\lim_{ \\lambda\\to 0}\\sum_{i=1}^nf(\\xi_i, \\eta_i) \\bigtriangleup s_i\n$$\n其中$f(x,y)$叫做被积函数，曲线$L$叫做积分路径，$\\text d s$叫做弧长元素（弧微分）。\n\n对弧长的曲线积分具有的性质：\n\n(1) 线性性质，设$\\alpha$和$\\beta$为常数，则\n$$\n\\int_L[\\alpha f(x,y)\\pm\\beta g(x,y)]\\text{d}s=\\alpha\\int_Lf(x,y)\\text{d}s\\pm\\beta\\int_Lg(x,y)\\text{d}s\n$$\n(2)对段弧具有可加性：若$L$是由$L_1$和$L_2$组成的(记作$L=L_1+L_2$)，则\n$$\n\\int_Lf(x,y)\\text{d}s=\\int_{L_1}f(x,y)\\text{d}s+\\int_{L_2}f(x,y)\\text{d}s\n$$\n​\t此性质可以推广到$L$是由$L_1$,$L_2$,…,$L_k$组成的。\n\n以上概念可以推广到空间曲线$L$上\n$$\n\\int_Lf(x,y,z)\\text{d}s=\\lim_{ \\lambda\\to 0}\\sum_{i=1}^nf(\\xi_i, \\eta_i,\\zeta_i) \\bigtriangleup s_i\n$$\n其中$f(x,y,z)$是定义在空间曲线$L$上的函数,$\\text d s$表示空间曲线的弧长元素。\n\n## 对弧长的曲线积分的计算与应用\n\n设平面曲线$L$的参数方程为\n$$\n\\begin{cases}\nx=x(t) \\\\\ny=y(t)\n\\end{cases}\n,(\\alpha\\le t \\le\\beta)\n$$\n其中$x(t)$,$y(t)$在$[\\alpha,\\beta]$上具有一阶连续导数,且$x'^2(t)+y'^2(t)\\ne0$,若$f(x,y)$在$L$上连续,则有\n$$\n\\int_Lf(x,y)\\text{d}s=\\int_\\alpha^\\beta f(x(t),y(t))\\sqrt{x'^2(t)+y'^2(t)}\\text dt\n$$\n若曲线$L$由方程\n$$\ny=y(x) (a\\le x\\le b)\n$$\n给出,那么可以把这种情况看作是\n$$\n\\begin{cases}\nx=x \\\\\ny=y(x)\n\\end{cases},(a\\le x \\le b)\n$$\n此时\n$$\n\\int_Lf(x,y)\\text{d}s=\\int_a^b f(x,y(x))\\sqrt{1+y'^2(x)}\\text dx\n$$\n类似的,若曲线$L$由方程\n$$\nx=x(y) (c\\le y\\le d)\n$$\n有\n$$\n\\int_Lf(x,y)\\text{d}s=\\int_c^d f(x(y),y)\\sqrt{x'^2(y)+1}\\text dy\n$$\n当曲线$L$由极坐标方程\n$$\n\\rho=\\rho(\\varphi) (\\alpha\\le\\varphi\\le\\beta)\n$$\n则\n$$\n\\int_Lf(x,y)\\text{d}s=\\int_\\alpha^\\beta f(\\rho cos\\varphi,\\rho sin\\varphi)\\sqrt{\\rho^2+\\rho'^2(\\varphi)}\\text d\\varphi\n$$\n设空间曲线$L$的方程为\n$$\n\\begin{cases}\nx=x(t) \\\\\ny=y(t) \\\\\nz=z(t)\n\\end{cases},(\\alpha\\le t \\le \\beta)\n$$\n则有\n$$\n\\int_Lf(x,y,z)\\text{d}s=\\int_\\alpha^\\beta f(x(t),y(t),z(t))\\sqrt{x'^2(t)+y'^2(t)+z'^2(t)}\\text dt\n$$\n\n如有光滑平面曲线$L$,其线密度为$\\mu(x,y)$,应用积分微元法,不难建立下面的结果,曲线的质心坐标$\\overline x,\\overline y$为\n$$\n\\overline x=\\frac{\\int_L x\\mu \\text d s}{\\int_L \\mu \\text d s},\\overline y=\\frac{\\int_L y\\mu \\text d s}{\\int_L \\mu \\text d s}\n$$\n曲线$L$对$x$轴,y轴,原点的转动惯量分别为\n$$\nI_x=\\int_L y^2\\mu\\text ds,I_y=\\int_L x^2\\mu\\text ds,I_O=\\int_L x^2+y^2\\mu\\text ds\n$$\n\n# 对坐标的曲线积分\n\n## 对坐标的曲面积分的概念\n\n## 对坐标的曲面积分的性质\n\n## 对坐标的曲面积分的计算法\n\n## 两类曲线积分间的关系\n\n\n\n# 格林公式及其应用\n\n# 对面积的曲面积分\n\n# 对坐标的曲面积分\n\n# 高斯公式与散度\n\n# 斯托克斯公式与旋度\n\n","tags":["blog"],"categories":["math"]},{"title":"Movie List","url":"/2023/06/13/6-13-movie-list/","content":"\n# 极简主义\n\n- [ ] 我的家里空无一物\n- [ ] 恩珠的房间\n- [ ] 无节制消费的元凶\n- [ ] 钱断情始\n- [ ] 100样东西\n- [ ] 怦然心动的人生整理魔法\n- [ ] 我的物品\n- [ ] 麻理惠的整理秘诀\n- [ ] 极简主义：记录生命中的重要事物\n\n# 性格\n\n- [ ] 东京贵族女子\n\n# 理财\n\n- [ ] 华尔街基因\n- [ ] 财富密码\n- [ ] 富可敌国\n- [ ] 货币共和国\n","tags":["hobby","private"]},{"title":"Book List","url":"/2023/06/09/6-9-book-list/","content":"\n\n\n# 小说\n\n- [ ] 三体\n- [ ] 白鹿原\n- [ ] 使女的故事\n- [ ] 美丽新世界\n- [ ] 1984\n- [ ] 独裁者手册\n- [ ] 第二性\n\n\n\n# 传记\n\n- [ ] 巴菲特传\n- [ ] 稻盛和夫自传\n- [ ] 钱钟书传\n- [ ] 成为波伏娃\n- [ ] 苏格拉底传\n\n# 逻辑类\n\n- [ ] 我为什么不结婚\n- [ ] 厌女\n- [ ] 君主论\n- [ ] 简单逻辑学\n- [ ] 逻辑思考力\n- [ ] 你以为你以为的就是你以为的吗\n- [ ] 逻辑思维，只要五步\n- [ ] 未来在等待的人才\n- [ ] 金字塔原理\n- [ ] 批判性思维工具\n- [ ] 游戏化思维\n- [ ] 全新思维\n- [ ] 系统之美\n- [ ] 一本小小的蓝色逻辑书\n- [ ] 简单的逻辑学\n- [ ] 论证是一门学问：如何让你的观点有说服力\n- [ ] 论证是一门学问：如何有理有据地说服他人\n- [ ] 身边的逻辑学\n- [ ] 好好讲道理：反击谬误的逻辑学训练\n- [ ] 思考的技术\n- [ ] 学会提问\n- [ ] 超越感觉：批判性思考指南\n- [ ] 思辨与立场：生活中无处不在的批判性思维工具\n- [ ] 批判性思维：带你走出思维的误区\n- [ ] 批判性思维：思维、写作、沟通、应变、解决问题的根本技巧\n- [ ] 批判性思维：全球最受欢迎的思维训练读本\n- [ ] 清醒思考的艺术：你最好让别人去犯的52种思维错误\n- [ ] 清醒思考的艺术：你最好让别人去犯的52种思维错误\n- [ ] 生活中的逻辑学\n- [ ] 隐性逻辑：教你快速切换思考方式\n- [ ] 逻辑学导论\n- [ ] 图解式学习法\n- [ ] 会图解思考的人最厉害\n- [ ] 决策与判断\n- [ ] 水平思考法\n- [ ] 深度思维\n- [ ] \n\n# 医学健康类\n\n- [ ] 护照\n- [ ] 施瓦辛格健身全书\n- [ ] 皮肤的秘密\n\n# 人类/心理/社会类\n\n- [ ] 心理学与生活\n- [ ] 跨越边界的社区\n- [ ] 乌合之众\n- [ ] 人性心理学\n- [ ] 乡土中国\n\n# 法律类\n\n- [ ] 刑法学讲义\n- [ ] 洞学奇案\n\n# 财经类\n\n- [ ] 经济学原理\n- [ ] 货币金融学\n- [ ] 聪明的投资者\n- [ ] 穷查理宝典\n- [ ] 穷爸爸富爸爸\n- [ ] 股票作手回忆录\n- [ ] 理性投资\n- [ ] a股投资实战心法\n\n# 计算机发展史\n\n- [ ] 浪潮之巅\n\n# 历史类\n\n- [ ] 明朝那些事\n\n- [ ] 中国通史\n\n- [ ] 全球通史\n\n- [ ] 极简宇宙史\n\n- [ ] 国史大纲\n\n- [ ] 中国人史纲\n\n- [ ] 中国历代政治得失\n\n- [ ] 西周史\n\n- [ ] 先秦史\n\n- [ ] 商文明\n\n- [ ] 夏商西周的社会变迁\n\n- [ ] 中国上古史研究讲义\n\n- [ ] 春秋史\n\n- [ ] 战国史\n\n- [ ] 波峰与波谷\n\n- [ ] 魏晋南北朝史讲演录\n\n- [ ] 两晋南北朝史\n\n- [ ] 北魏平城时代\n\n- [ ] 三国志\n\n- [ ] 隋唐五代史\n\n- [ ] 绚烂的世界帝国：隋唐时代\n\n- [ ] 细说宋朝\n\n- [ ] 东京梦华录\n\n- [ ] 经略幽燕-宋辽军事灾难的战略分析\n\n- [ ] 草原帝国\n\n- [ ] 明朝那些事儿\n\n- [ ] 万历十五年\n\n- [ ] 天朝的崩溃：鸦片战争再研究\n\n- [ ] 叫魂：1768年中国妖术大恐慌\n\n- [ ] 近代中国社会的新陈代谢\n\n- [ ] 中国近代史\n\n- [ ] 开放中的变迁\n\n  \n\n# 哲学\n\n- [ ] 大问题 简明哲学导论\n- [ ] 理想国\n- [ ] 沉思录\n- [ ] 哲学的历程\n- [ ] 认识你自己\n- [ ] 纯粹理性批判\n- [ ] 存在与虚无\n- [ ] 逻辑与哲学\n- [ ] 你的第一本哲学书\n\n# 艺术\n\n- [ ] 艺术与生活\n\n# 设计\n\n- [ ] 给大家看的设计书\n\n# 摄影\n\n- [ ] 美国纽约摄影学院摄影教材\n\n# 电影\n\n- [ ] 认识电影\n\n# 传播学\n\n- [ ] 舆论\n\n# 考古\n\n- [ ] 考古学与史前文明\n\n# 生物学\n\n- [ ] 所罗门王的指环\n- [ ] 改变你的作息，改变你的生活\n\n# 死亡\n\n- [ ] 安乐死现场\n\n# 俄罗斯文学\n\n- [ ] 白夜\n- [ ] 罪与罚\n- [ ] 白痴\n- [ ] 卡拉马佐夫兄弟\n- [ ] 少年\n- [ ] 群魔\n- [ ] 地下室手记\n\n# 人生意义\n\n- [ ] 编周记\n\n# 两性婚姻\n\n- [ ] 爱的艺术\n\n# 情绪管理\n\n- [ ] 伯恩斯新情绪疗法\n\n# 自然\n\n- [ ] 看不见的自然\n\n# 宗教\n\n- [ ] 佛教的见地和修道\n\n","tags":["hobby","private"]},{"title":"New Hexo Theme","url":"/2023/05/19/5-19-博客主题构想/","content":"\n- <span id=\"head1\"> HOME</span>\n\n![img.png](5-19-博客主题构想/img.png)\n\n- 可以到达六个模块\n- 左上角可以转换四种语言\n- 右上角到达GitHub page\n\n# <span id=\"head2\"> BLOG</span>\n\n![img_1.png](5-19-博客主题构想/img_1.png)\n\n- 左部：按照类别和目录归纳，左上角是BLOG首页\n- 中部：博客内容，左上角是类别，右上角是修改时间，底部是评论区\n- 右部：文章toc，右上角是HOME页链接\n\n# <span id=\"head3\"> RESUME</span>\n\n![img_2.png](5-19-博客主题构想/img_2.png)\n\n- 左部：左上角是RESUME首页，左下角转换四种语言\n- 中部：简历\n- 右部：简历toc，右上角是HOME页链接\n\n# <span id=\"head4\"> HOBBY</span>\n\n![img_3.png](5-19-博客主题构想/img_3.png)\n\n- 左部：按照类别和目录归纳，左上角是HOBBY首页\n- 中部：内容，左上角是类别，右上角是时间戳\n- 右部：内容toc，右上角是HOME页链接\n\n# <span id=\"head5\"> DIARY</span>\n\n![img_4.png](5-19-博客主题构想/img_4.png)\n\n- 左部：日期+题目，左上角是DIARY首页\n- 中部：内容，左上角是今日心情、新日天气，右上角是时间戳\n- 右部：本月心情记录，本月天气记录，右上角是HOME页链接\n\n# <span id=\"head6\"> REVIEW</span>\n![img_5.png](5-19-博客主题构想/img_5.png)\n\n\n- 左部：年、月、日归纳，点击年有年复盘，点击月有月复盘，点击日是日复盘，左上角是REVIEW首页\n- 中部：\n  - 日复盘：按日复盘，左上角是第几周周几，右上角是时间戳\n  - 月复盘：按月复盘，左上角是几月，右上角是时间戳\n  - 年复盘：按年复盘，左上角是几年，右上角是时间戳\n- 右部：在日历上，按照周次和周几复盘，点击第几周是周复盘，右上角是HOME页链接\n\n# <span id=\"head7\"> PREVIEW</span>\n\n![img_6](5-19-博客主题构想/img_6.png)\n\n- 左部：按照规划类型归纳，左上角是PREVIEW首页\n- 中部：左上角是第几周周几，右上角是时间戳，下面是内容\n- 右部：内容toc，右上角是HOME页链接\n\n","tags":["hobby","private"],"categories":["thoughts"]},{"title":"Array 3:Squares of a Sorted Array","url":"/2023/05/14/5-14-array-3-squares-of-a-sorted-array/","content":"# <span id=\"head1\">[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)</span>\n\n![977](5-14-array-3-squares-of-a-sorted-array/img.png)\n\n## <span id=\"head2\"> NOTE</span>\n\n原本自己读完题想着要先挨个平方完，然后快排（没错本人就是这么垃圾:sob:）这样的话，是复杂度是O(n+nlogn)，\n绝对超过了O(n)。之后看到了提示说用双指针，就恍然大悟：①遍历数组找到正负分界点②从这个点向两端依次确定\n最小值，直到有一侧达到尽头③处理剩下的数组。写完之后，发现卡哥的思路：从数组两端向中间聚拢，以此确定最大值，\n这样省了找分界点和处理剩下元素的时间，respect！！\n\n## <span id=\"head3\">c++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> ans(nums.size());\n        int FLAG=1;\n        int r=0;\n        while(nums[r]<0){\n            r++;\n            if(r>=nums.size())break;\n        }\n        int l=r-1;\n        if(l<0||r>=nums.size())FLAG=0;\n        int idx=0;\n        while(FLAG&&idx<nums.size()){\n            if(nums[l]*(-1)<nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l--;\n                if(l<0)FLAG=0;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r++;\n                if(r>=nums.size())FLAG=0;\n            }\n            idx++;\n        }\n\n        if(FLAG==0){\n            if(l<0){//剩下右边\n                while(idx<nums.size()&&r<nums.size()){\n                    ans[idx]=nums[r]*nums[r];\n                    idx++;\n                    r++;\n                }\n            }else{\n                 while(idx<nums.size()&&l>=0){\n                    ans[idx]=nums[l]*nums[l];\n                    idx++;\n                    l--;\n                }\n            }\n        }\n\n        return ans;\n\n    }\n};\n\n```\n## <span id=\"head4\">java solution</span>\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        \n        int len=nums.length;\n        int[]ans=new int[len];\n        int FLAG=1;\n\n        int r=0;\n        while(nums[r]<0){\n            r++;\n            if(r>=len){\n                FLAG=0;\n                break;\n            }\n        }\n\n        int l=r-1;\n        if(l<0) FLAG=0;\n\n        int idx=0;\n        while(FLAG==1&&idx<len){\n\n            if(nums[l]*(-1)<nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l--;\n                if(l<0)FLAG=0;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r++;\n                if(r>=len)FLAG=0;\n            }\n\n            idx++;\n        }\n\n        if(FLAG==0){\n            if(l<0){//只剩右边\n\n                while(idx<len&&r<len){\n                    ans[idx]=nums[r]*nums[r];\n                    idx++;\n                    r++;\n                }\n                \n            }else{\n                while(idx<len&&l>=0){\n                    ans[idx]=nums[l]*nums[l];\n                    idx++;\n                    l--;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## <span id=\"head5\">improved solution</span>\n\n显然代码短了很多\n\n```c++\nclass Solution{\n\n public:\n\n    vector<int> sortedSquares(vector<int>& nums){\n        int len = nums.size();\n        vector<int>ans(len);\n\n        int l=0;\n        int r=len-1;\n        int idx=len-1;\n\n        while(idx>=0){\n            if(nums[l]*nums[l]>nums[r]*nums[r]){\n                ans[idx]=nums[l]*nums[l];\n                l++;\n            }else{\n                ans[idx]=nums[r]*nums[r];\n                r--;\n            }\n            idx--;\n        }\n\n        return ans;\n    }\n\n};\n\n```","tags":["blog"],"categories":["algorithm"]},{"title":"Array 2:Remove Element","url":"/2023/05/11/5-11-array-2-remove-element/","content":"\n\n\n# <span id=\"head1\">[27. 移除元素](https://leetcode.cn/problems/remove-element/)</span>\n\n![27](5-11-array-2-remove-element/1.png)\n\n## <span id=\"head2\">C++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n\n       int cur_index =0;\n       int length=nums.size();\n       int last_index=length-1;\n\n       if(length==1&&nums[0]==val)return 0;\n\n       while(cur_index<length){\n           if(nums[cur_index]==val){\n               while(nums[last_index]==val){\n                   length--;\n                   if(length==0)return 0;\n                    last_index=length-1;\n                    \n               }\n               if(cur_index<last_index){\n                    int t=nums[last_index];\n                    nums[last_index]=nums[cur_index];\n                    nums[cur_index]=t;\n               }\n               \n           }\n           cur_index++;\n       }\n         \n\t\treturn length;\n    }\n};\n```\n\n## <span id=\"head3\">Java solution</span>\n\n```java\n    class Solution {\n    public int removeElement(int[] nums, int val) {\n      \n      int cur=0;\n      int length=nums.length;\n      int last=length-1;\n\n      if(length==0)return 0;\n\n      while(cur<length){\n\n          if(nums[cur]==val){\n\n              while(nums[last]==val){\n                    length--;\n                    if(length==0)return 0;\n                    last=length-1;\n              }\n              if(cur<last){\n                  int t=nums[cur];\n                  nums[cur]=nums[last];\n                  nums[last]=t;\n              }\n          }\n          cur++;\n      }\n\n        return length;\n    }\n\n}\n```\n\n#  <span id=\"head1\">[26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)</span>\n\n![26](5-11-array-2-remove-element/2.png)\n\n## <span id=\"head5\">C++ solution</span>\n\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int cur=0;\n        int next=cur+1;\n\n        if(nums.size()==1)return 1;\n\n        while(cur<=nums.size()-1){\n\n            while(next<nums.size()&&nums[next]==nums[cur])next++;\n            cur++;\n            if(cur>=nums.size()||next>=nums.size())break;\n\n            nums[cur]=nums[next];\n            \n            \n        }\n        return cur;\n    }\n    \n};\n```\n\n## <span id=\"head6\">Java solution</span>\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int cur=0;\n        int next=cur+1;\n\n        if(nums.length==1)return 1;\n\n        while(cur<=nums.length-1){\n           \n            while(next<nums.length&&nums[next]==nums[cur])next++;\n            cur++;\n            if(cur==nums.length||next==nums.length)break;\n            nums[cur]=nums[next];\n\n        }\n\n        return cur;\n    }\n}\n```","tags":["blog"],"categories":["algorithm"]}]